/*! For license information please see theme.js.LICENSE.txt */
(function () { var __webpack_modules__ = { 6041: function (t, e) { !function (t) { "use strict"; class e { constructor(t) { this.controller_ = t } get element() { return this.controller_.view.element } get disabled() { return this.controller_.viewProps.get("disabled") } set disabled(t) { this.controller_.viewProps.set("disabled", t) } get hidden() { return this.controller_.viewProps.get("hidden") } set hidden(t) { this.controller_.viewProps.set("hidden", t) } dispose() { this.controller_.viewProps.set("disposed", !0) } } class n { constructor(t) { this.target = t } } class i extends n { constructor(t, e, n, i) { super(t), this.value = e, this.presetKey = n, this.last = null == i || i } } function r(t) { return t } function s(t) { return null == t } const o = { alreadydisposed: () => "View has been already disposed", invalidparams: t => `Invalid parameters for '${t.name}'`, nomatchingcontroller: t => `No matching controller for '${t.key}'`, nomatchingview: t => `No matching view for '${JSON.stringify(t.params)}'`, notbindable: () => "Value is not bindable", propertynotfound: t => `Property '${t.name}' not found`, shouldneverhappen: () => "This error should never happen" }; class a { constructor(t) { var e; this.message = null !== (e = o[t.type](r(t.context))) && void 0 !== e ? e : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = t.type } static alreadyDisposed() { return new a({ type: "alreadydisposed" }) } static notBindable() { return new a({ type: "notbindable" }) } static propertyNotFound(t) { return new a({ type: "propertynotfound", context: { name: t } }) } static shouldNeverHappen() { return new a({ type: "shouldneverhappen" }) } } class l { constructor() { this.observers_ = {} } on(t, e) { let n = this.observers_[t]; return n || (n = this.observers_[t] = []), n.push({ handler: e }), this } off(t, e) { const n = this.observers_[t]; return n && (this.observers_[t] = n.filter((t => t.handler !== e))), this } emit(t, e) { const n = this.observers_[t]; n && n.forEach((t => { t.handler(e) })) } } const h = "tp"; function c(t) { return (e, n) => [h, "-", t, "v", e ? `_${e}` : "", n ? `-${n}` : ""].join("") } function u(t, e) { return n => e(t(n)) } function d(t) { return t.rawValue } function p(t, e) { t.emitter.on("change", u(d, e)), e(t.rawValue) } function f(t, e, n) { p(t.value(e), n) } function m(t, e, n) { n ? t.classList.add(e) : t.classList.remove(e) } function g(t, e) { return n => { m(t, e, n) } } function v(t, e) { p(t, (t => { e.textContent = null != t ? t : "" })) } const A = c("btn"); class b { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(A()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("button"); n.classList.add(A("b")), e.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n; const i = t.createElement("div"); i.classList.add(A("t")), v(e.props.value("title"), i), this.buttonElement.appendChild(i) } } class y { constructor(t, e) { this.emitter = new l, this.onClick_ = this.onClick_.bind(this), this.props = e.props, this.viewProps = e.viewProps, this.view = new b(t, { props: this.props, viewProps: this.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_) } onClick_() { this.emitter.emit("click", { sender: this }) } } class x { constructor(t, e) { var n; this.constraint_ = null == e ? void 0 : e.constraint, this.equals_ = null !== (n = null == e ? void 0 : e.equals) && void 0 !== n ? n : (t, e) => t === e, this.emitter = new l, this.rawValue_ = t } get constraint() { return this.constraint_ } get rawValue() { return this.rawValue_ } set rawValue(t) { this.setRawValue(t, { forceEmit: !1, last: !0 }) } setRawValue(t, e) { const n = null != e ? e : { forceEmit: !1, last: !0 }, i = this.constraint_ ? this.constraint_.constrain(t) : t, r = this.rawValue_; (!this.equals_(r, i) || n.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.rawValue_ = i, this.emitter.emit("change", { options: n, previousRawValue: r, rawValue: i, sender: this })) } } class _ { constructor(t) { this.emitter = new l, this.value_ = t } get rawValue() { return this.value_ } set rawValue(t) { this.setRawValue(t, { forceEmit: !1, last: !0 }) } setRawValue(t, e) { const n = null != e ? e : { forceEmit: !1, last: !0 }, i = this.value_; (i !== t || n.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.value_ = t, this.emitter.emit("change", { options: n, previousRawValue: i, rawValue: this.value_, sender: this })) } } function w(t, e) { const n = null == e ? void 0 : e.constraint, i = null == e ? void 0 : e.equals; return n || i ? new x(t, e) : new _(t) } class E { constructor(t) { this.emitter = new l, this.valMap_ = t; for (const t in this.valMap_) this.valMap_[t].emitter.on("change", (() => { this.emitter.emit("change", { key: t, sender: this }) })) } static createCore(t) { return Object.keys(t).reduce(((e, n) => Object.assign(e, { [n]: w(t[n]) })), {}) } static fromObject(t) { const e = this.createCore(t); return new E(e) } get(t) { return this.valMap_[t].rawValue } set(t, e) { this.valMap_[t].rawValue = e } value(t) { return this.valMap_[t] } } function C(t, e) { return r(Object.keys(e).reduce(((n, i) => { if (void 0 === n) return; const r = (0, e[i])(t[i]); return r.succeeded ? Object.assign(Object.assign({}, n), { [i]: r.value }) : void 0 }), {})) } function S(t, e) { return t.reduce(((t, n) => { if (void 0 === t) return; const i = e(n); return i.succeeded && void 0 !== i.value ? [...t, i.value] : void 0 }), []) } function M(t) { return null !== t && "object" == typeof t } function P(t) { return e => n => { if (!e && void 0 === n) return { succeeded: !1, value: void 0 }; if (e && void 0 === n) return { succeeded: !0, value: void 0 }; const i = t(n); return void 0 !== i ? { succeeded: !0, value: i } : { succeeded: !1, value: void 0 } } } function I(t) { return { custom: e => P(e)(t), boolean: P((t => "boolean" == typeof t ? t : void 0))(t), number: P((t => "number" == typeof t ? t : void 0))(t), string: P((t => "string" == typeof t ? t : void 0))(t), function: P((t => "function" == typeof t ? t : void 0))(t), constant: e => P((t => t === e ? e : void 0))(t), raw: P((t => t))(t), object: e => P((t => { if (M(t)) return C(t, e) }))(t), array: e => P((t => { if (Array.isArray(t)) return S(t, e) }))(t) } } const T = { optional: I(!0), required: I(!1) }; function D(t, e) { const n = T.required.object(e)(t); return n.succeeded ? n.value : void 0 } function B(t) { console.warn([`Missing '${t.key}' of ${t.target} in ${t.place}.`, "Please rebuild plugins with the latest core package."].join(" ")) } function L(t) { return t && t.parentElement && t.parentElement.removeChild(t), null } class F { constructor(t) { this.value_ = t } static create(t) { return [new F(t), (e, n) => { t.setRawValue(e, n) }] } get emitter() { return this.value_.emitter } get rawValue() { return this.value_.rawValue } } const k = c(""); function R(t, e) { return g(t, k(void 0, e)) } class O extends E { constructor(t) { var e; super(t), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = F.create(w(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), null === (e = this.get("parent")) || void 0 === e || e.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_) } static create(t) { var e, n, i; const r = null != t ? t : {}; return new O(E.createCore({ disabled: null !== (e = r.disabled) && void 0 !== e && e, disposed: !1, hidden: null !== (n = r.hidden) && void 0 !== n && n, parent: null !== (i = r.parent) && void 0 !== i ? i : null })) } get globalDisabled() { return this.globalDisabled_ } bindClassModifiers(t) { p(this.globalDisabled_, R(t, "disabled")), f(this, "hidden", R(t, "hidden")) } bindDisabled(t) { p(this.globalDisabled_, (e => { t.disabled = e })) } bindTabIndex(t) { p(this.globalDisabled_, (e => { t.tabIndex = e ? -1 : 0 })) } handleDispose(t) { this.value("disposed").emitter.on("change", (e => { e && t() })) } getGlobalDisabled_() { const t = this.get("parent"); return !!t && t.globalDisabled.rawValue || this.get("disabled") } updateGlobalDisabled_() { this.setGlobalDisabled_(this.getGlobalDisabled_()) } onDisabledChange_() { this.updateGlobalDisabled_() } onParentGlobalDisabledChange_() { this.updateGlobalDisabled_() } onParentChange_(t) { var e; const n = t.previousRawValue; null == n || n.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), null === (e = this.get("parent")) || void 0 === e || e.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_() } } function N() { return ["veryfirst", "first", "last", "verylast"] } const U = c(""), z = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" }; class V { constructor(t) { this.parent_ = null, this.blade = t.blade, this.view = t.view, this.viewProps = t.viewProps; const e = this.view.element; this.blade.value("positions").emitter.on("change", (() => { N().forEach((t => { e.classList.remove(U(void 0, z[t])) })), this.blade.get("positions").forEach((t => { e.classList.add(U(void 0, z[t])) })) })), this.viewProps.handleDispose((() => { L(e) })) } get parent() { return this.parent_ } set parent(t) { this.parent_ = t, "parent" in this.viewProps.valMap_ ? this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null) : B({ key: "parent", target: O.name, place: "BladeController.parent" }) } } const Q = "http://www.w3.org/2000/svg"; function G(t) { t.offsetHeight } function H(t, e) { const n = t.style.transition; t.style.transition = "none", e(), t.style.transition = n } function j(t) { return void 0 !== t.ontouchstart } function W(t) { for (; t.childNodes.length > 0;)t.removeChild(t.childNodes[0]) } function q(t) { return t.relatedTarget ? r(t.relatedTarget) : "explicitOriginalTarget" in t ? t.explicitOriginalTarget : null } const Y = c("lbl"); function X(t, e) { const n = t.createDocumentFragment(); return e.split("\n").map((e => t.createTextNode(e))).forEach(((e, i) => { i > 0 && n.appendChild(t.createElement("br")), n.appendChild(e) })), n } class K { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(Y()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(Y("l")), f(e.props, "label", (e => { s(e) ? this.element.classList.add(Y(void 0, "nol")) : (this.element.classList.remove(Y(void 0, "nol")), W(n), n.appendChild(X(t, e))) })), this.element.appendChild(n), this.labelElement = n; const i = t.createElement("div"); i.classList.add(Y("v")), this.element.appendChild(i), this.valueElement = i } } class J extends V { constructor(t, e) { const n = e.valueController.viewProps; super(Object.assign(Object.assign({}, e), { view: new K(t, { props: e.props, viewProps: n }), viewProps: n })), this.props = e.props, this.valueController = e.valueController, this.view.valueElement.appendChild(this.valueController.view.element) } } class Z extends V { constructor(t) { super(t), this.value = t.value } } class $ extends E { constructor(t) { super(t) } static create(t) { const e = { completed: !0, expanded: t, expandedHeight: null, shouldFixHeight: !1, temporaryExpanded: null }, n = E.createCore(e); return new $(n) } get styleExpanded() { var t; return null !== (t = this.get("temporaryExpanded")) && void 0 !== t ? t : this.get("expanded") } get styleHeight() { if (!this.styleExpanded) return "0"; const t = this.get("expandedHeight"); return this.get("shouldFixHeight") && !s(t) ? `${t}px` : "auto" } bindExpandedClass(t, e) { const n = () => { this.styleExpanded ? t.classList.add(e) : t.classList.remove(e) }; f(this, "expanded", n), f(this, "temporaryExpanded", n) } cleanUpTransition() { this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0) } } function tt(t) { return $.create(t) } function et(t, e) { let n = 0; return H(e, (() => { t.set("expandedHeight", null), t.set("temporaryExpanded", !0), G(e), n = e.clientHeight, t.set("temporaryExpanded", null), G(e) })), n } function nt(t, e) { e.style.height = t.styleHeight } function it(t, e) { t.value("expanded").emitter.on("beforechange", (() => { t.set("completed", !1), s(t.get("expandedHeight")) && t.set("expandedHeight", et(t, e)), t.set("shouldFixHeight", !0), G(e) })), t.emitter.on("change", (() => { nt(t, e) })), nt(t, e), e.addEventListener("transitionend", (e => { "height" === e.propertyName && t.cleanUpTransition() })) } class rt { constructor(t, e) { const n = c(e.viewName); this.element = t.createElement("div"), this.element.classList.add(n()), e.viewProps.bindClassModifiers(this.element) } } class st extends Z { constructor(t, e) { const n = e.valueController.viewProps; super(Object.assign(Object.assign({}, e), { value: e.valueController.value, view: new K(t, { props: e.props, viewProps: n }), viewProps: n })), this.props = e.props, this.valueController = e.valueController, this.view.valueElement.appendChild(this.valueController.view.element) } } class ot { constructor() { this.disabled = !1, this.emitter = new l } dispose() { } tick() { this.disabled || this.emitter.emit("tick", { sender: this }) } } class at { constructor(t, e) { this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = t, this.emitter = new l, this.interval_ = e, this.setTimer_() } get disabled() { return this.disabled_ } set disabled(t) { this.disabled_ = t, this.disabled_ ? this.clearTimer_() : this.setTimer_() } dispose() { this.clearTimer_() } clearTimer_() { if (null === this.timerId_) return; const t = this.doc_.defaultView; t && t.clearInterval(this.timerId_), this.timerId_ = null } setTimer_() { if (this.clearTimer_(), this.interval_ <= 0) return; const t = this.doc_.defaultView; t && (this.timerId_ = t.setInterval(this.onTick_, this.interval_)) } onTick_() { this.disabled_ || this.emitter.emit("tick", { sender: this }) } } class lt { constructor(t) { this.constraints = t } constrain(t) { return this.constraints.reduce(((t, e) => e.constrain(t)), t) } } function ht(t, e) { if (t instanceof e) return t; if (t instanceof lt) { const n = t.constraints.reduce(((t, n) => t || (n instanceof e ? n : null)), null); if (n) return n } return null } class ct { constructor(t) { this.values = E.fromObject({ max: t.max, min: t.min }) } constrain(t) { const e = this.values.get("max"), n = this.values.get("min"); return Math.min(Math.max(t, n), e) } } class ut { constructor(t) { this.values = E.fromObject({ max: t.max, min: t.min }) } get maxValue() { return this.values.get("max") } get minValue() { return this.values.get("min") } constrain(t) { const e = this.values.get("max"), n = this.values.get("min"); let i = t; return s(n) || (i = Math.max(i, n)), s(e) || (i = Math.min(i, e)), i } } class dt { constructor(t, e = 0) { this.step = t, this.origin = e } constrain(t) { const e = this.origin % this.step; return e + Math.round((t - e) / this.step) * this.step } } const pt = c("pop"); class ft { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(pt()), e.viewProps.bindClassModifiers(this.element), p(e.shows, g(this.element, pt(void 0, "v"))) } } class mt { constructor(t, e) { this.shows = w(!1), this.viewProps = e.viewProps, this.view = new ft(t, { shows: this.shows, viewProps: this.viewProps }) } } const gt = c("txt"); class vt { constructor(t, e) { this.onChange_ = this.onChange_.bind(this), this.element = t.createElement("div"), this.element.classList.add(gt()), e.viewProps.bindClassModifiers(this.element), this.props_ = e.props, this.props_.emitter.on("change", this.onChange_); const n = t.createElement("input"); n.classList.add(gt("i")), n.type = "text", e.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, e.value.emitter.on("change", this.onChange_), this.value_ = e.value, this.refresh() } refresh() { const t = this.props_.get("formatter"); this.inputElement.value = t(this.value_.rawValue) } onChange_() { this.refresh() } } class At { constructor(t, e) { this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = e.parser, this.props = e.props, this.value = e.value, this.viewProps = e.viewProps, this.view = new vt(t, { props: e.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_) } onInputChange_(t) { const e = r(t.currentTarget).value, n = this.parser_(e); s(n) || (this.value.rawValue = n), this.view.refresh() } } function bt(t) { return "false" !== t && !!t } class yt { constructor(t) { this.text = t } evaluate() { return Number(this.text) } toString() { return this.text } } const xt = { "**": (t, e) => Math.pow(t, e), "*": (t, e) => t * e, "/": (t, e) => t / e, "%": (t, e) => t % e, "+": (t, e) => t + e, "-": (t, e) => t - e, "<<": (t, e) => t << e, ">>": (t, e) => t >> e, ">>>": (t, e) => t >>> e, "&": (t, e) => t & e, "^": (t, e) => t ^ e, "|": (t, e) => t | e }; class _t { constructor(t, e, n) { this.left = e, this.operator = t, this.right = n } evaluate() { const t = xt[this.operator]; if (!t) throw new Error(`unexpected binary operator: '${this.operator}`); return t(this.left.evaluate(), this.right.evaluate()) } toString() { return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ") } } const wt = { "+": t => t, "-": t => -t, "~": t => ~t }; class Et { constructor(t, e) { this.operator = t, this.expression = e } evaluate() { const t = wt[this.operator]; if (!t) throw new Error(`unexpected unary operator: '${this.operator}`); return t(this.expression.evaluate()) } toString() { return ["u(", this.operator, this.expression.toString(), ")"].join(" ") } } function Ct(t) { return (e, n) => { for (let i = 0; i < t.length; i++) { const r = t[i](e, n); if ("" !== r) return r } return "" } } function St(t, e) { var n; const i = t.substr(e).match(/^\s+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function Mt(t, e) { const n = t.substr(e, 1); return n.match(/^[1-9]$/) ? n : "" } function Pt(t, e) { var n; const i = t.substr(e).match(/^[0-9]+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function It(t, e) { const n = Pt(t, e); if ("" !== n) return n; const i = t.substr(e, 1); if ("-" !== i && "+" !== i) return ""; const r = Pt(t, e += 1); return "" === r ? "" : i + r } function Tt(t, e) { const n = t.substr(e, 1); if (e += 1, "e" !== n.toLowerCase()) return ""; const i = It(t, e); return "" === i ? "" : n + i } function Dt(t, e) { const n = t.substr(e, 1); if ("0" === n) return n; const i = Mt(t, e); return e += i.length, "" === i ? "" : i + Pt(t, e) } function Bt(t, e) { const n = Dt(t, e); if (e += n.length, "" === n) return ""; const i = t.substr(e, 1); if (e += i.length, "." !== i) return ""; const r = Pt(t, e); return n + i + r + Tt(t, e += r.length) } function Lt(t, e) { const n = t.substr(e, 1); if (e += n.length, "." !== n) return ""; const i = Pt(t, e); return e += i.length, "" === i ? "" : n + i + Tt(t, e) } function Ft(t, e) { const n = Dt(t, e); return e += n.length, "" === n ? "" : n + Tt(t, e) } const kt = Ct([Bt, Lt, Ft]); function Rt(t, e) { var n; const i = t.substr(e).match(/^[01]+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function Ot(t, e) { const n = t.substr(e, 2); if (e += n.length, "0b" !== n.toLowerCase()) return ""; const i = Rt(t, e); return "" === i ? "" : n + i } function Nt(t, e) { var n; const i = t.substr(e).match(/^[0-7]+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function Ut(t, e) { const n = t.substr(e, 2); if (e += n.length, "0o" !== n.toLowerCase()) return ""; const i = Nt(t, e); return "" === i ? "" : n + i } function zt(t, e) { var n; const i = t.substr(e).match(/^[0-9a-f]+/i); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function Vt(t, e) { const n = t.substr(e, 2); if (e += n.length, "0x" !== n.toLowerCase()) return ""; const i = zt(t, e); return "" === i ? "" : n + i } const Qt = Ct([Ot, Ut, Vt]), Gt = Ct([Qt, kt]); function Ht(t, e) { const n = Gt(t, e); return e += n.length, "" === n ? null : { evaluable: new yt(n), cursor: e } } function jt(t, e) { const n = t.substr(e, 1); if (e += n.length, "(" !== n) return null; const i = Jt(t, e); if (!i) return null; e = i.cursor, e += St(t, e).length; const r = t.substr(e, 1); return e += r.length, ")" !== r ? null : { evaluable: i.evaluable, cursor: e } } function Wt(t, e) { var n; return null !== (n = Ht(t, e)) && void 0 !== n ? n : jt(t, e) } function qt(t, e) { const n = Wt(t, e); if (n) return n; const i = t.substr(e, 1); if (e += i.length, "+" !== i && "-" !== i && "~" !== i) return null; const r = qt(t, e); return r ? { cursor: e = r.cursor, evaluable: new Et(i, r.evaluable) } : null } function Yt(t, e, n) { n += St(e, n).length; const i = t.filter((t => e.startsWith(t, n)))[0]; return i ? (n += i.length, { cursor: n += St(e, n).length, operator: i }) : null } function Xt(t, e) { return (n, i) => { const r = t(n, i); if (!r) return null; i = r.cursor; let s = r.evaluable; for (; ;) { const r = Yt(e, n, i); if (!r) break; i = r.cursor; const o = t(n, i); if (!o) return null; i = o.cursor, s = new _t(r.operator, s, o.evaluable) } return s ? { cursor: i, evaluable: s } : null } } const Kt = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce(((t, e) => Xt(t, e)), qt); function Jt(t, e) { return e += St(t, e).length, Kt(t, e) } function Zt(t) { const e = Jt(t, 0); return e ? e.cursor + St(t, e.cursor).length !== t.length ? null : e.evaluable : null } function $t(t) { var e; const n = Zt(t); return null !== (e = null == n ? void 0 : n.evaluate()) && void 0 !== e ? e : null } function te(t) { if ("number" == typeof t) return t; if ("string" == typeof t) { const e = $t(t); if (!s(e)) return e } return 0 } function ee(t) { return e => e.toFixed(Math.max(Math.min(t, 20), 0)) } function ne(t) { return String(t) } function ie(t, e) { for (; t.length < e;)t.push(void 0) } function re(t) { const e = []; return ie(e, t), w(e) } function se(t) { const e = t.indexOf(void 0); return r(e < 0 ? t : t.slice(0, e)) } function oe(t, e) { const n = [...se(t), e]; return n.length > t.length ? n.splice(0, n.length - t.length) : ie(n, t.length), n } function ae({ primary: t, secondary: e, forward: n, backward: i }) { let r = !1; function s(t) { r || (r = !0, t(), r = !1) } t.emitter.on("change", (i => { s((() => { e.setRawValue(n(t, e), i.options) })) })), e.emitter.on("change", (r => { s((() => { t.setRawValue(i(t, e), r.options) })), s((() => { e.setRawValue(n(t, e), r.options) })) })), s((() => { e.setRawValue(n(t, e), { forceEmit: !1, last: !0 }) })) } function le(t, e) { const n = t * (e.altKey ? .1 : 1) * (e.shiftKey ? 10 : 1); return e.upKey ? +n : e.downKey ? -n : 0 } function he(t) { return { altKey: t.altKey, downKey: "ArrowDown" === t.key, shiftKey: t.shiftKey, upKey: "ArrowUp" === t.key } } function ce(t) { return { altKey: t.altKey, downKey: "ArrowLeft" === t.key, shiftKey: t.shiftKey, upKey: "ArrowRight" === t.key } } function ue(t) { return "ArrowUp" === t || "ArrowDown" === t } function de(t) { return ue(t) || "ArrowLeft" === t || "ArrowRight" === t } function pe(t, e) { var n, i; const r = e.ownerDocument.defaultView, s = e.getBoundingClientRect(); return { x: t.pageX - ((null !== (n = r && r.scrollX) && void 0 !== n ? n : 0) + s.left), y: t.pageY - ((null !== (i = r && r.scrollY) && void 0 !== i ? i : 0) + s.top) } } ee(0); class fe { constructor(t) { this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = t, this.emitter = new l, t.addEventListener("touchstart", this.onTouchStart_, { passive: !1 }), t.addEventListener("touchmove", this.onTouchMove_, { passive: !0 }), t.addEventListener("touchend", this.onTouchEnd_), t.addEventListener("mousedown", this.onMouseDown_) } computePosition_(t) { const e = this.elem_.getBoundingClientRect(); return { bounds: { width: e.width, height: e.height }, point: t ? { x: t.x, y: t.y } : null } } onMouseDown_(t) { var e; t.preventDefault(), null === (e = t.currentTarget) || void 0 === e || e.focus(); const n = this.elem_.ownerDocument; n.addEventListener("mousemove", this.onDocumentMouseMove_), n.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", { altKey: t.altKey, data: this.computePosition_(pe(t, this.elem_)), sender: this, shiftKey: t.shiftKey }) } onDocumentMouseMove_(t) { this.emitter.emit("move", { altKey: t.altKey, data: this.computePosition_(pe(t, this.elem_)), sender: this, shiftKey: t.shiftKey }) } onDocumentMouseUp_(t) { const e = this.elem_.ownerDocument; e.removeEventListener("mousemove", this.onDocumentMouseMove_), e.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", { altKey: t.altKey, data: this.computePosition_(pe(t, this.elem_)), sender: this, shiftKey: t.shiftKey }) } onTouchStart_(t) { t.preventDefault(); const e = t.targetTouches.item(0), n = this.elem_.getBoundingClientRect(); this.emitter.emit("down", { altKey: t.altKey, data: this.computePosition_(e ? { x: e.clientX - n.left, y: e.clientY - n.top } : void 0), sender: this, shiftKey: t.shiftKey }), this.lastTouch_ = e } onTouchMove_(t) { const e = t.targetTouches.item(0), n = this.elem_.getBoundingClientRect(); this.emitter.emit("move", { altKey: t.altKey, data: this.computePosition_(e ? { x: e.clientX - n.left, y: e.clientY - n.top } : void 0), sender: this, shiftKey: t.shiftKey }), this.lastTouch_ = e } onTouchEnd_(t) { var e; const n = null !== (e = t.targetTouches.item(0)) && void 0 !== e ? e : this.lastTouch_, i = this.elem_.getBoundingClientRect(); this.emitter.emit("up", { altKey: t.altKey, data: this.computePosition_(n ? { x: n.clientX - i.left, y: n.clientY - i.top } : void 0), sender: this, shiftKey: t.shiftKey }) } } function me(t, e, n, i, r) { return i + (t - e) / (n - e) * (r - i) } function ge(t) { return String(t.toFixed(10)).split(".")[1].replace(/0+$/, "").length } function ve(t, e, n) { return Math.min(Math.max(t, e), n) } const Ae = c("txt"); class be { constructor(t, e) { this.onChange_ = this.onChange_.bind(this), this.props_ = e.props, this.props_.emitter.on("change", this.onChange_), this.element = t.createElement("div"), this.element.classList.add(Ae(), Ae(void 0, "num")), e.arrayPosition && this.element.classList.add(Ae(void 0, e.arrayPosition)), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("input"); n.classList.add(Ae("i")), n.type = "text", e.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = e.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Ae()), this.inputElement.classList.add(Ae("i")); const i = t.createElement("div"); i.classList.add(Ae("k")), this.element.appendChild(i), this.knobElement = i; const r = t.createElementNS(Q, "svg"); r.classList.add(Ae("g")), this.knobElement.appendChild(r); const s = t.createElementNS(Q, "path"); s.classList.add(Ae("gb")), r.appendChild(s), this.guideBodyElem_ = s; const o = t.createElementNS(Q, "path"); o.classList.add(Ae("gh")), r.appendChild(o), this.guideHeadElem_ = o; const a = t.createElement("div"); a.classList.add(c("tt")()), this.knobElement.appendChild(a), this.tooltipElem_ = a, e.value.emitter.on("change", this.onChange_), this.value = e.value, this.refresh() } onDraggingChange_(t) { if (null === t.rawValue) return void this.element.classList.remove(Ae(void 0, "drg")); this.element.classList.add(Ae(void 0, "drg")); const e = t.rawValue / this.props_.get("draggingScale"), n = e + (e > 0 ? -1 : e < 0 ? 1 : 0), i = ve(-n, -4, 4); this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n + i},0 L${n},4 L${n + i},8`, `M ${e},-1 L${e},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${e},4`); const r = this.props_.get("formatter"); this.tooltipElem_.textContent = r(this.value.rawValue), this.tooltipElem_.style.left = `${e}px` } refresh() { const t = this.props_.get("formatter"); this.inputElement.value = t(this.value.rawValue) } onChange_() { this.refresh() } } class ye { constructor(t, e) { var n; this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = e.baseStep, this.parser_ = e.parser, this.props = e.props, this.sliderProps_ = null !== (n = e.sliderProps) && void 0 !== n ? n : null, this.value = e.value, this.viewProps = e.viewProps, this.dragging_ = w(null), this.view = new be(t, { arrayPosition: e.arrayPosition, dragging: this.dragging_, props: this.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_); const i = new fe(this.view.knobElement); i.emitter.on("down", this.onPointerDown_), i.emitter.on("move", this.onPointerMove_), i.emitter.on("up", this.onPointerUp_) } constrainValue_(t) { var e, n; const i = null === (e = this.sliderProps_) || void 0 === e ? void 0 : e.get("minValue"), r = null === (n = this.sliderProps_) || void 0 === n ? void 0 : n.get("maxValue"); let s = t; return void 0 !== i && (s = Math.max(s, i)), void 0 !== r && (s = Math.min(s, r)), s } onInputChange_(t) { const e = r(t.currentTarget).value, n = this.parser_(e); s(n) || (this.value.rawValue = this.constrainValue_(n)), this.view.refresh() } onInputKeyDown_(t) { const e = le(this.baseStep_, he(t)); 0 !== e && this.value.setRawValue(this.constrainValue_(this.value.rawValue + e), { forceEmit: !1, last: !1 }) } onInputKeyUp_(t) { 0 !== le(this.baseStep_, he(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } onPointerDown_() { this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0 } computeDraggingValue_(t) { if (!t.point) return null; const e = t.point.x - t.bounds.width / 2; return this.constrainValue_(this.originRawValue_ + e * this.props.get("draggingScale")) } onPointerMove_(t) { const e = this.computeDraggingValue_(t.data); null !== e && (this.value.setRawValue(e, { forceEmit: !1, last: !1 }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_) } onPointerUp_(t) { const e = this.computeDraggingValue_(t.data); null !== e && (this.value.setRawValue(e, { forceEmit: !0, last: !0 }), this.dragging_.rawValue = null) } } function xe(t, e) { t.write(e) } function _e(t) { const e = t ? ht(t, dt) : null; return e ? e.step : null } function we(t, e) { const n = t && ht(t, dt); return n ? ge(n.step) : Math.max(ge(e), 2) } function Ee(t) { const e = _e(t); return null != e ? e : 1 } function Ce(t, e) { var n; const i = t && ht(t, dt), r = Math.abs(null !== (n = null == i ? void 0 : i.step) && void 0 !== n ? n : e); return 0 === r ? .1 : Math.pow(10, Math.floor(Math.log10(r)) - 1) } function Se(t) { return [t[0], t[1], t[2]] } function Me(t, e) { const n = ee("float" === e ? 2 : 0); return `rgb(${Se(t.getComponents("rgb", e)).map((t => n(t))).join(", ")})` } function Pe(t) { return e => Me(e, t) } function Ie(t, e) { const n = ee(2), i = ee("float" === e ? 2 : 0); return `rgba(${t.getComponents("rgb", e).map(((t, e) => (3 === e ? n : i)(t))).join(", ")})` } function Te(t) { return e => Ie(e, t) } function De(t, e) { const n = ee("float" === e ? 2 : 0), i = ["r", "g", "b"]; return `{${Se(t.getComponents("rgb", e)).map(((t, e) => `${i[e]}: ${n(t)}`)).join(", ")}}` } function Be(t) { return e => De(e, t) } function Le(t, e) { const n = ee(2), i = ee("float" === e ? 2 : 0), r = ["r", "g", "b", "a"]; return `{${t.getComponents("rgb", e).map(((t, e) => { const s = 3 === e ? n : i; return `${r[e]}: ${s(t)}` })).join(", ")}}` } function Fe(t) { return e => Le(e, t) } ["int", "float"].reduce(((t, e) => [...t, { format: { alpha: !1, mode: "rgb", notation: "func", type: e }, stringifier: Pe(e) }, { format: { alpha: !0, mode: "rgb", notation: "func", type: e }, stringifier: Te(e) }, { format: { alpha: !1, mode: "rgb", notation: "object", type: e }, stringifier: Be(e) }, { format: { alpha: !0, mode: "rgb", notation: "object", type: e }, stringifier: Fe(e) }]), []); class ke { constructor(t) { this.components = t.components, this.asm_ = t.assembly } constrain(t) { const e = this.asm_.toComponents(t).map(((t, e) => { var n, i; return null !== (i = null === (n = this.components[e]) || void 0 === n ? void 0 : n.constrain(t)) && void 0 !== i ? i : t })); return this.asm_.fromComponents(e) } } const Re = c("pndtxt"); class Oe { constructor(t, e) { this.textViews = e.textViews, this.element = t.createElement("div"), this.element.classList.add(Re()), this.textViews.forEach((e => { const n = t.createElement("div"); n.classList.add(Re("a")), n.appendChild(e.element), this.element.appendChild(n) })) } } function Ne(t, e, n) { return new ye(t, { arrayPosition: 0 === n ? "fst" : n === e.axes.length - 1 ? "lst" : "mid", baseStep: e.axes[n].baseStep, parser: e.parser, props: e.axes[n].textProps, value: w(0, { constraint: e.axes[n].constraint }), viewProps: e.viewProps }) } class Ue { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.acs_ = e.axes.map(((n, i) => Ne(t, e, i))), this.acs_.forEach(((t, n) => { ae({ primary: this.value, secondary: t.value, forward: t => e.assembly.toComponents(t.rawValue)[n], backward: (t, i) => { const r = e.assembly.toComponents(t.rawValue); return r[n] = i.rawValue, e.assembly.fromComponents(r) } }) })), this.view = new Oe(t, { textViews: this.acs_.map((t => t.view)) }) } } function ze(t, e) { return "step" in t && !s(t.step) ? new dt(t.step, e) : null } function Ve(t) { return s(t.max) || s(t.min) ? s(t.max) && s(t.min) ? null : new ut({ max: t.max, min: t.min }) : new ct({ max: t.max, min: t.min }) } const Qe = { monitor: { defaultInterval: 200, defaultLineCount: 3 } }, Ge = c("grl"); class He { constructor(t, e) { this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = t.createElement("div"), this.element.classList.add(Ge()), e.viewProps.bindClassModifiers(this.element), this.formatter_ = e.formatter, this.props_ = e.props, this.cursor_ = e.cursor, this.cursor_.emitter.on("change", this.onCursorChange_); const n = t.createElementNS(Q, "svg"); n.classList.add(Ge("g")), n.style.height = `calc(var(--bld-us) * ${e.lineCount})`, this.element.appendChild(n), this.svgElem_ = n; const i = t.createElementNS(Q, "polyline"); this.svgElem_.appendChild(i), this.lineElem_ = i; const r = t.createElement("div"); r.classList.add(Ge("t"), c("tt")()), this.element.appendChild(r), this.tooltipElem_ = r, e.value.emitter.on("change", this.onValueUpdate_), this.value = e.value, this.update_() } get graphElement() { return this.svgElem_ } update_() { const t = this.svgElem_.getBoundingClientRect(), e = this.value.rawValue.length - 1, n = this.props_.get("minValue"), i = this.props_.get("maxValue"), r = []; this.value.rawValue.forEach(((s, o) => { if (void 0 === s) return; const a = me(o, 0, e, 0, t.width), l = me(s, n, i, t.height, 0); r.push([a, l].join(",")) })), this.lineElem_.setAttributeNS(null, "points", r.join(" ")); const s = this.tooltipElem_, o = this.value.rawValue[this.cursor_.rawValue]; if (void 0 === o) return void s.classList.remove(Ge("t", "a")); const a = me(this.cursor_.rawValue, 0, e, 0, t.width), l = me(o, n, i, t.height, 0); s.style.left = `${a}px`, s.style.top = `${l}px`, s.textContent = `${this.formatter_(o)}`, s.classList.contains(Ge("t", "a")) || (s.classList.add(Ge("t", "a"), Ge("t", "in")), G(s), s.classList.remove(Ge("t", "in"))) } onValueUpdate_() { this.update_() } onCursorChange_() { this.update_() } } class je { constructor(t, e) { if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = e.props, this.value = e.value, this.viewProps = e.viewProps, this.cursor_ = w(-1), this.view = new He(t, { cursor: this.cursor_, formatter: e.formatter, lineCount: e.lineCount, props: this.props_, value: this.value, viewProps: this.viewProps }), j(t)) { const t = new fe(this.view.element); t.emitter.on("down", this.onGraphPointerDown_), t.emitter.on("move", this.onGraphPointerMove_), t.emitter.on("up", this.onGraphPointerUp_) } else this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_) } onGraphMouseLeave_() { this.cursor_.rawValue = -1 } onGraphMouseMove_(t) { const e = this.view.element.getBoundingClientRect(); this.cursor_.rawValue = Math.floor(me(t.offsetX, 0, e.width, 0, this.value.rawValue.length)) } onGraphPointerDown_(t) { this.onGraphPointerMove_(t) } onGraphPointerMove_(t) { t.data.point ? this.cursor_.rawValue = Math.floor(me(t.data.point.x, 0, t.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.rawValue = -1 } onGraphPointerUp_() { this.cursor_.rawValue = -1 } } class We { constructor(t) { this.controller_ = t } get disabled() { return this.controller_.viewProps.get("disabled") } set disabled(t) { this.controller_.viewProps.set("disabled", t) } get title() { var t; return null !== (t = this.controller_.props.get("title")) && void 0 !== t ? t : "" } set title(t) { this.controller_.props.set("title", t) } on(t, e) { const i = e.bind(this); return this.controller_.emitter.on(t, (() => { i(new n(this)) })), this } } class qe extends n { constructor(t, e, n) { super(t), this.cell = e, this.index = n } } class Ye extends e { constructor(t) { super(t), this.cellToApiMap_ = new Map, this.emitter_ = new l; const e = this.controller_.valueController; e.cellControllers.forEach(((t, n) => { const i = new We(t); this.cellToApiMap_.set(t, i), t.emitter.on("click", (() => { const t = n % e.size[0], r = Math.floor(n / e.size[0]); this.emitter_.emit("click", { event: new qe(this, i, [t, r]) }) })) })) } cell(t, e) { const n = this.controller_.valueController, i = n.cellControllers[e * n.size[0] + t]; return this.cellToApiMap_.get(i) } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } } class Xe { constructor(t, e) { this.size = e.size; const [n, i] = this.size, r = []; for (let s = 0; s < i; s++)for (let i = 0; i < n; i++) { const n = new y(t, { props: E.fromObject(Object.assign({}, e.cellConfig(i, s))), viewProps: O.create() }); r.push(n) } this.cellCs_ = r, this.viewProps = O.create(), this.viewProps.handleDispose((() => { this.cellCs_.forEach((t => { t.viewProps.set("disposed", !0) })) })), this.view = new rt(t, { viewProps: this.viewProps, viewName: "btngrid" }), this.view.element.style.gridTemplateColumns = `repeat(${n}, 1fr)`, this.cellCs_.forEach((t => { this.view.element.appendChild(t.view.element) })) } get cellControllers() { return this.cellCs_ } } const Ke = { id: "buttongrid", type: "blade", css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}', accept(t) { const e = T, n = D(t, { cells: e.required.function, size: e.required.array(e.required.number), view: e.required.constant("buttongrid"), label: e.optional.string }); return n ? { params: n } : null }, controller(t) { return new J(t.document, { blade: t.blade, props: E.fromObject({ label: t.params.label }), valueController: new Xe(t.document, { cellConfig: t.params.cells, size: t.params.size }) }) }, api(t) { return t.controller instanceof J && t.controller.valueController instanceof Xe ? new Ye(t.controller) : null } }; class Je extends e { get label() { return this.controller_.props.get("label") } set label(t) { this.controller_.props.set("label", t) } get value() { return this.controller_.valueController.value.rawValue } set value(t) { this.controller_.valueController.value.rawValue = t } on(t, e) { const n = e.bind(this); return this.controller_.valueController.value.emitter.on(t, (t => { n(new i(this, t.rawValue, void 0, t.options.last)) })), this } } function Ze(t, e, n) { return t * (1 - n) + e * n } const $e = 20, tn = .001, en = 100; function nn(t, e) { let n = .25, i = .5, r = -1; for (let s = 0; s < $e; s++) { const [s, o] = t.curve(i); if (i += n * (s < e ? 1 : -1), r = o, n *= .5, Math.abs(e - s) < tn) break } return r } class rn { constructor(t = 0, e = 0, n = 1, i = 1) { this.cache_ = [], this.comps_ = [t, e, n, i] } get x1() { return this.comps_[0] } get y1() { return this.comps_[1] } get x2() { return this.comps_[2] } get y2() { return this.comps_[3] } static isObject(t) { return !s(t) && !!Array.isArray(t) && "number" == typeof t[0] && "number" == typeof t[1] && "number" == typeof t[2] && "number" == typeof t[3] } static equals(t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 } curve(t) { const e = Ze(0, this.x1, t), n = Ze(0, this.y1, t), i = Ze(this.x1, this.x2, t), r = Ze(this.y1, this.y2, t), s = Ze(this.x2, 1, t), o = Ze(this.y2, 1, t), a = Ze(e, i, t), l = Ze(n, r, t), h = Ze(i, s, t), c = Ze(r, o, t); return [Ze(a, h, t), Ze(l, c, t)] } y(t) { if (0 === this.cache_.length) { const t = []; for (let e = 0; e < en; e++)t.push(nn(this, me(e, 0, en - 1, 0, 1))); this.cache_ = t } return this.cache_[Math.round(me(ve(t, 0, 1), 0, 1, 0, en - 1))] } toObject() { return [this.comps_[0], this.comps_[1], this.comps_[2], this.comps_[3]] } } const sn = { toComponents: t => t.toObject(), fromComponents: t => new rn(...t) }; function on(t) { const e = ee(2); return `cubic-bezier(${t.toObject().map((t => e(t))).join(", ")})` } const an = [0, .5, .5, 1]; function ln(t) { const e = t.match(/^cubic-bezier\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)$/); if (!e) return new rn(...an); const n = [e[1], e[2], e[3], e[4]].reduce(((t, e) => { if (!t) return null; const n = Number(e); return isNaN(n) ? null : [...t, n] }), []); return new rn(...null != n ? n : an) } const hn = c("cbz"); class cn { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(hn()), e.viewProps.bindClassModifiers(this.element), e.foldable.bindExpandedClass(this.element, hn(void 0, "expanded")), f(e.foldable, "completed", g(this.element, hn(void 0, "cpl"))); const n = t.createElement("div"); n.classList.add(hn("h")), this.element.appendChild(n); const i = t.createElement("button"); i.classList.add(hn("b")), e.viewProps.bindDisabled(i); const r = t.createElementNS(Q, "svg"); r.innerHTML = '<path d="M2 13C8 13 8 3 14 3"/>', i.appendChild(r), n.appendChild(i), this.buttonElement = i; const s = t.createElement("div"); if (s.classList.add(hn("t")), n.appendChild(s), this.textElement = s, "inline" === e.pickerLayout) { const e = t.createElement("div"); e.classList.add(hn("p")), this.element.appendChild(e), this.pickerElement = e } else this.pickerElement = null } } const un = c("cbzp"); class dn { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(un()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(un("g")), this.element.appendChild(n), this.graphElement = n; const i = t.createElement("div"); i.classList.add(un("t")), this.element.appendChild(i), this.textElement = i } } function pn(t, e) { const n = new MutationObserver((t => { for (const i of t) "childList" === i.type && i.addedNodes.forEach((t => { t.contains(t) && (e(), n.disconnect()) })) })), i = t.ownerDocument; n.observe(i.body, { attributes: !0, childList: !0, subtree: !0 }) } const fn = c("cbzg"); function mn(t, e) { return n => e(t(n)) } class gn { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(fn()), e.viewProps.bindClassModifiers(this.element), e.viewProps.bindTabIndex(this.element); const n = t.createElement("div"); n.classList.add(fn("p")), this.element.appendChild(n), this.previewElement = n; const i = t.createElementNS(Q, "svg"); i.classList.add(fn("g")), this.element.appendChild(i), this.svgElem_ = i; const r = t.createElementNS(Q, "path"); r.classList.add(fn("u")), this.svgElem_.appendChild(r), this.guideElem_ = r; const s = t.createElementNS(Q, "polyline"); s.classList.add(fn("l")), this.svgElem_.appendChild(s), this.lineElem_ = s, this.handleElems_ = [t.createElement("div"), t.createElement("div")], this.handleElems_.forEach((t => { t.classList.add(fn("h")), this.element.appendChild(t) })), this.vectorElems_ = [t.createElementNS(Q, "line"), t.createElementNS(Q, "line")], this.vectorElems_.forEach((t => { t.classList.add(fn("v")), this.svgElem_.appendChild(t) })), this.value_ = e.value, this.value_.emitter.on("change", this.onValueChange_.bind(this)), this.sel_ = e.selection, this.handleElems_.forEach(((t, e) => { p(this.sel_, mn((t => t === e), g(t, fn("h", "sel")))) })), pn(this.element, (() => { this.refresh() })) } getVertMargin_(t) { return .25 * t } valueToPosition(t, e) { const n = this.element.getBoundingClientRect(), i = n.width, r = n.height, s = this.getVertMargin_(r); return { x: me(t, 0, 1, 0, i), y: me(e, 0, 1, r - s, s) } } positionToValue(t, e) { const n = this.element.getBoundingClientRect(), i = n.width, r = n.height, s = this.getVertMargin_(r); return { x: ve(me(t, 0, i, 0, 1), 0, 1), y: me(e, r - s, s, 0, 1) } } refresh() { this.guideElem_.setAttributeNS(null, "d", [0, 1].map((t => { const e = this.valueToPosition(0, t), n = this.valueToPosition(1, t); return [`M ${e.x},${e.y}`, `L ${n.x},${n.y}`].join(" ") })).join(" ")); const t = this.value_.rawValue, e = []; let n = 0; for (; ;) { const i = this.valueToPosition(...t.curve(n)); if (e.push([i.x, i.y].join(",")), n >= 1) break; n = Math.min(n + .05, 1) } this.lineElem_.setAttributeNS(null, "points", e.join(" ")); const i = t.toObject();[0, 1].forEach((t => { const e = this.valueToPosition(t, t), n = this.valueToPosition(i[2 * t], i[2 * t + 1]), r = this.vectorElems_[t]; r.setAttributeNS(null, "x1", String(e.x)), r.setAttributeNS(null, "y1", String(e.y)), r.setAttributeNS(null, "x2", String(n.x)), r.setAttributeNS(null, "y2", String(n.y)); const s = this.handleElems_[t]; s.style.left = `${n.x}px`, s.style.top = `${n.y}px` })) } onValueChange_() { this.refresh() } } const vn = 24, An = 400, bn = 1e3, yn = c("cbzprv"); class xn { constructor(t, e) { this.stopped_ = !0, this.startTime_ = -1, this.onDispose_ = this.onDispose_.bind(this), this.onTimer_ = this.onTimer_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.element = t.createElement("div"), this.element.classList.add(yn()), e.viewProps.bindClassModifiers(this.element); const n = t.createElementNS(Q, "svg"); n.classList.add(yn("g")), this.element.appendChild(n), this.svgElem_ = n; const i = t.createElementNS(Q, "path"); i.classList.add(yn("t")), this.svgElem_.appendChild(i), this.ticksElem_ = i; const r = t.createElement("div"); r.classList.add(yn("m")), this.element.appendChild(r), this.markerElem_ = r, this.value_ = e.value, this.value_.emitter.on("change", this.onValueChange_), e.viewProps.handleDispose(this.onDispose_), pn(this.element, (() => { this.refresh() })) } play() { this.stop(), this.updateMarker_(0), this.markerElem_.classList.add(yn("m", "a")), this.startTime_ = (new Date).getTime() + An, this.stopped_ = !1, requestAnimationFrame(this.onTimer_) } stop() { this.stopped_ = !0, this.markerElem_.classList.remove(yn("m", "a")) } onDispose_() { this.stop() } updateMarker_(t) { const e = this.value_.rawValue.y(ve(t, 0, 1)); this.markerElem_.style.left = 100 * e + "%" } refresh() { const t = this.svgElem_.getBoundingClientRect(), e = t.width, n = t.height, i = [], r = this.value_.rawValue; for (let t = 0; t < vn; t++) { const s = me(t, 0, vn - 1, 0, 1), o = me(r.y(s), 0, 1, 0, e); i.push(`M ${o},0 v${n}`) } this.ticksElem_.setAttributeNS(null, "d", i.join(" ")) } onTimer_() { if (null === this.startTime_) return; const t = (new Date).getTime() - this.startTime_, e = t / bn; this.updateMarker_(e), t > bn + An && this.stop(), this.stopped_ || requestAnimationFrame(this.onTimer_) } onValueChange_() { this.refresh(), this.play() } } function _n(t, e, n, i) { const r = n - t, s = i - e; return Math.sqrt(r * r + s * s) } function wn(t, e, n, i) { const r = _n(t, e, n, i), s = Math.atan2(i - e, n - t), o = Math.round(s / (Math.PI / 4)) * Math.PI / 4; return { x: t + Math.cos(o) * r, y: e + Math.sin(o) * r } } class En { constructor(t, e) { this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = e.baseStep, this.value = e.value, this.sel_ = w(0), this.viewProps = e.viewProps, this.view = new gn(t, { selection: this.sel_, value: this.value, viewProps: this.viewProps }), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_), this.prevView_ = new xn(t, { value: this.value, viewProps: this.viewProps }), this.prevView_.element.addEventListener("mousedown", (t => { t.stopImmediatePropagation(), t.preventDefault(), this.prevView_.play() })), this.view.previewElement.appendChild(this.prevView_.element); const n = new fe(this.view.element); n.emitter.on("down", this.onPointerDown_), n.emitter.on("move", this.onPointerMove_), n.emitter.on("up", this.onPointerUp_) } refresh() { this.view.refresh(), this.prevView_.refresh(), this.prevView_.play() } updateValue_(t, e, n) { const i = this.sel_.rawValue, r = this.value.rawValue.toObject(), s = this.view.positionToValue(t.x, t.y), o = e ? wn(i, i, s.x, s.y) : s; r[2 * i] = o.x, r[2 * i + 1] = o.y, this.value.setRawValue(new rn(...r), n) } onPointerDown_(t) { const e = t.data; if (!e.point) return; const n = this.value.rawValue, i = this.view.valueToPosition(n.x1, n.y1), r = _n(e.point.x, e.point.y, i.x, i.y), s = this.view.valueToPosition(n.x2, n.y2), o = _n(e.point.x, e.point.y, s.x, s.y); this.sel_.rawValue = r <= o ? 0 : 1, this.updateValue_(e.point, t.shiftKey, { forceEmit: !1, last: !1 }) } onPointerMove_(t) { const e = t.data; e.point && this.updateValue_(e.point, t.shiftKey, { forceEmit: !1, last: !1 }) } onPointerUp_(t) { const e = t.data; e.point && this.updateValue_(e.point, t.shiftKey, { forceEmit: !0, last: !0 }) } onKeyDown_(t) { de(t.key) && t.preventDefault(); const e = this.sel_.rawValue, n = this.value.rawValue.toObject(); n[2 * e] += le(this.baseStep_, ce(t)), n[2 * e + 1] += le(this.baseStep_, he(t)), this.value.setRawValue(new rn(...n), { forceEmit: !1, last: !1 }) } onKeyUp_(t) { de(t.key) && t.preventDefault(); const e = le(this.baseStep_, ce(t)), n = le(this.baseStep_, he(t)); 0 === e && 0 === n || this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } } class Cn { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.view = new dn(t, { viewProps: this.viewProps }), this.gc_ = new En(t, { baseStep: e.axis.baseStep, value: this.value, viewProps: this.viewProps }), this.view.graphElement.appendChild(this.gc_.view.element); const n = Object.assign(Object.assign({}, e.axis), { constraint: new ut({ max: 1, min: 0 }) }), i = Object.assign(Object.assign({}, e.axis), { constraint: void 0 }); this.tc_ = new Ue(t, { assembly: sn, axes: [n, i, n, i], parser: $t, value: this.value, viewProps: this.viewProps }), this.view.textElement.appendChild(this.tc_.view.element) } get allFocusableElements() { return [this.gc_.view.element, ...this.tc_.view.textViews.map((t => t.inputElement))] } refresh() { this.gc_.refresh() } } class Sn { constructor(t, e) { this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.foldable_ = tt(e.expanded), this.view = new cn(t, { foldable: this.foldable_, pickerLayout: e.pickerLayout, viewProps: this.viewProps }), this.view.buttonElement.addEventListener("blur", this.onButtonBlur_), this.view.buttonElement.addEventListener("click", this.onButtonClick_), this.tc_ = new At(t, { parser: ln, props: E.fromObject({ formatter: on }), value: this.value, viewProps: this.viewProps }), this.view.textElement.appendChild(this.tc_.view.element), this.popC_ = "popup" === e.pickerLayout ? new mt(t, { viewProps: this.viewProps }) : null; const n = new Cn(t, { axis: e.axis, value: this.value, viewProps: this.viewProps }); n.allFocusableElements.forEach((t => { t.addEventListener("blur", this.onPopupChildBlur_), t.addEventListener("keydown", this.onPopupChildKeydown_) })), this.pickerC_ = n, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), p(this.popC_.shows, (t => { t && n.refresh() })), ae({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: t => t.rawValue, backward: (t, e) => e.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), it(this.foldable_, this.view.pickerElement)) } onButtonBlur_(t) { if (!this.popC_) return; const e = r(t.relatedTarget); e && this.popC_.view.element.contains(e) || (this.popC_.shows.rawValue = !1) } onButtonClick_() { this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.allFocusableElements[0].focus() } onPopupChildBlur_(t) { if (!this.popC_) return; const e = this.popC_.view.element, n = q(t); n && e.contains(n) || n && n === this.view.buttonElement && !j(e.ownerDocument) || (this.popC_.shows.rawValue = !1) } onPopupChildKeydown_(t) { this.popC_ && "Escape" === t.key && (this.popC_.shows.rawValue = !1) } } function Mn() { return new ke({ assembly: sn, components: [0, 1, 2, 3].map((t => t % 2 == 0 ? new ut({ min: 0, max: 1 }) : void 0)) }) } const Pn = { id: "cubic-bezier", type: "blade", css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}', accept(t) { const e = T, n = D(t, { value: e.required.array(e.required.number), view: e.required.constant("cubicbezier"), expanded: e.optional.boolean, label: e.optional.string, picker: e.optional.custom((t => "inline" === t || "popup" === t ? t : void 0)) }); return n ? { params: n } : null }, controller(t) { var e, n; const i = w(new rn(...t.params.value), { constraint: Mn(), equals: rn.equals }), r = new Sn(t.document, { axis: { baseStep: .1, textProps: E.fromObject({ draggingScale: .01, formatter: ee(2) }) }, expanded: null !== (e = t.params.expanded) && void 0 !== e && e, pickerLayout: null !== (n = t.params.picker) && void 0 !== n ? n : "popup", value: i, viewProps: t.viewProps }); return new st(t.document, { blade: t.blade, props: E.fromObject({ label: t.params.label }), valueController: r }) }, api(t) { return t.controller instanceof st && t.controller.valueController instanceof Sn ? new Je(t.controller) : null } }; class In extends e { begin() { this.controller_.valueController.begin() } end() { this.controller_.valueController.end() } } const Tn = 20; class Dn { constructor() { this.start_ = null, this.duration_ = 0, this.fps_ = null, this.frameCount_ = 0, this.timestamps_ = [] } get duration() { return this.duration_ } get fps() { return this.fps_ } begin(t) { this.start_ = t.getTime() } calculateFps_(t) { if (0 === this.timestamps_.length) return null; const e = this.timestamps_[0]; return 1e3 * (this.frameCount_ - e.frameCount) / (t - e.time) } compactTimestamps_() { if (this.timestamps_.length <= Tn) return; const t = this.timestamps_.length - Tn; this.timestamps_.splice(0, t); const e = this.timestamps_[0].frameCount; this.timestamps_.forEach((t => { t.frameCount -= e })), this.frameCount_ -= e } end(t) { if (null === this.start_) return; const e = t.getTime(); this.duration_ = e - this.start_, this.start_ = null, this.fps_ = this.calculateFps_(e), this.timestamps_.push({ frameCount: this.frameCount_, time: e }), ++this.frameCount_, this.compactTimestamps_() } } const Bn = c("fps"); class Ln { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(Bn()), e.viewProps.bindClassModifiers(this.element), this.graphElement = t.createElement("div"), this.graphElement.classList.add(Bn("g")), this.element.appendChild(this.graphElement); const n = t.createElement("div"); n.classList.add(Bn("l")), this.element.appendChild(n); const i = t.createElement("span"); i.classList.add(Bn("v")), i.textContent = "--", n.appendChild(i), this.valueElement = i; const r = t.createElement("span"); r.classList.add(Bn("u")), r.textContent = "FPS", n.appendChild(r) } } class Fn { constructor(t, e) { this.stopwatch_ = new Dn, this.onTick_ = this.onTick_.bind(this), this.ticker_ = e.ticker, this.ticker_.emitter.on("tick", this.onTick_), this.value_ = e.value, this.viewProps = e.viewProps, this.view = new Ln(t, { viewProps: this.viewProps }), this.graphC_ = new je(t, { formatter: ee(0), lineCount: e.lineCount, props: E.fromObject({ maxValue: e.maxValue, minValue: e.minValue }), value: this.value_, viewProps: this.viewProps }), this.view.graphElement.appendChild(this.graphC_.view.element), this.viewProps.handleDispose((() => { this.graphC_.viewProps.set("disposed", !0), this.ticker_.dispose() })) } begin() { this.stopwatch_.begin(new Date) } end() { this.stopwatch_.end(new Date) } onTick_() { const t = this.stopwatch_.fps; if (null !== t) { const e = this.value_.rawValue; this.value_.rawValue = oe(e, t), this.view.valueElement.textContent = t.toFixed(0) } } } function kn(t, e) { return 0 === e ? new ot : new at(t, null != e ? e : Qe.monitor.defaultInterval) } const Rn = { id: "fpsgraph", type: "blade", accept(t) { const e = T, n = D(t, { view: e.required.constant("fpsgraph"), interval: e.optional.number, label: e.optional.string, lineCount: e.optional.number, max: e.optional.number, min: e.optional.number }); return n ? { params: n } : null }, controller(t) { var e, n, i, r; const s = null !== (e = t.params.interval) && void 0 !== e ? e : 500; return new J(t.document, { blade: t.blade, props: E.fromObject({ label: t.params.label }), valueController: new Fn(t.document, { lineCount: null !== (n = t.params.lineCount) && void 0 !== n ? n : 2, maxValue: null !== (i = t.params.max) && void 0 !== i ? i : 90, minValue: null !== (r = t.params.min) && void 0 !== r ? r : 0, ticker: kn(t.document, s), value: re(80), viewProps: t.viewProps }) }) }, api(t) { return t.controller instanceof J && t.controller.valueController instanceof Fn ? new In(t.controller) : null } }; class On { constructor(t, e) { this.min = t, this.max = e } static isObject(t) { if ("object" != typeof t || null === t) return !1; const e = t.min, n = t.max; return "number" == typeof e && "number" == typeof n } static equals(t, e) { return t.min === e.min && t.max === e.max } get length() { return this.max - this.min } toObject() { return { min: this.min, max: this.max } } } const Nn = { fromComponents: t => new On(t[0], t[1]), toComponents: t => [t.min, t.max] }; class Un { constructor(t) { this.edge = t } constrain(t) { var e, n, i, r, s, o, a, l; if (t.min <= t.max) return new On(null !== (n = null === (e = this.edge) || void 0 === e ? void 0 : e.constrain(t.min)) && void 0 !== n ? n : t.min, null !== (r = null === (i = this.edge) || void 0 === i ? void 0 : i.constrain(t.max)) && void 0 !== r ? r : t.max); const h = (t.min + t.max) / 2; return new On(null !== (o = null === (s = this.edge) || void 0 === s ? void 0 : s.constrain(h)) && void 0 !== o ? o : h, null !== (l = null === (a = this.edge) || void 0 === a ? void 0 : a.constrain(h)) && void 0 !== l ? l : h) } } const zn = c("rsltxt"); class Vn { constructor(t, e) { this.sliderView_ = e.sliderView, this.textView_ = e.textView, this.element = t.createElement("div"), this.element.classList.add(zn()); const n = t.createElement("div"); n.classList.add(zn("s")), n.appendChild(this.sliderView_.element), this.element.appendChild(n); const i = t.createElement("div"); i.classList.add(zn("t")), i.appendChild(this.textView_.element), this.element.appendChild(i) } } const Qn = c("rsl"); class Gn { constructor(t, e) { this.onSliderPropsChange_ = this.onSliderPropsChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.sliderProps_ = e.sliderProps, this.sliderProps_.emitter.on("change", this.onSliderPropsChange_), this.element = t.createElement("div"), this.element.classList.add(Qn()), e.viewProps.bindClassModifiers(this.element), this.value_ = e.value, this.value_.emitter.on("change", this.onValueChange_); const n = t.createElement("div"); n.classList.add(Qn("t")), this.element.appendChild(n), this.trackElement = n; const i = t.createElement("div"); i.classList.add(Qn("b")), n.appendChild(i), this.barElement = i; const r = ["min", "max"].map((e => { const i = t.createElement("div"); return i.classList.add(Qn("k"), Qn("k", e)), n.appendChild(i), i })); this.knobElements = [r[0], r[1]], this.update_() } valueToX_(t) { return 100 * ve(me(t, this.sliderProps_.get("minValue"), this.sliderProps_.get("maxValue"), 0, 1), 0, 1) } update_() { const t = this.value_.rawValue; 0 === t.length ? this.element.classList.add(Qn(void 0, "zero")) : this.element.classList.remove(Qn(void 0, "zero")); const e = [this.valueToX_(t.min), this.valueToX_(t.max)]; this.barElement.style.left = `${e[0]}%`, this.barElement.style.right = 100 - e[1] + "%", this.knobElements.forEach(((t, n) => { t.style.left = `${e[n]}%` })) } onSliderPropsChange_() { this.update_() } onValueChange_() { this.update_() } } class Hn { constructor(t, e) { this.grabbing_ = null, this.grabOffset_ = 0, this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.sliderProps = e.sliderProps, this.viewProps = e.viewProps, this.value = e.value, this.view = new Gn(t, { sliderProps: this.sliderProps, value: this.value, viewProps: e.viewProps }); const n = new fe(this.view.trackElement); n.emitter.on("down", this.onPointerDown_), n.emitter.on("move", this.onPointerMove_), n.emitter.on("up", this.onPointerUp_) } ofs_() { return "min" === this.grabbing_ ? this.view.knobElements[0].getBoundingClientRect().width / 2 : "max" === this.grabbing_ ? -this.view.knobElements[1].getBoundingClientRect().width / 2 : 0 } valueFromData_(t) { return t.point ? me((t.point.x + this.ofs_()) / t.bounds.width, 0, 1, this.sliderProps.get("minValue"), this.sliderProps.get("maxValue")) : null } onPointerDown_(t) { if (!t.data.point) return; const e = t.data.point.x / t.data.bounds.width, n = this.value.rawValue, i = this.sliderProps.get("minValue"), r = this.sliderProps.get("maxValue"), s = me(n.min, i, r, 0, 1), o = me(n.max, i, r, 0, 1); Math.abs(o - e) <= .025 ? this.grabbing_ = "max" : Math.abs(s - e) <= .025 ? this.grabbing_ = "min" : e >= s && e <= o ? (this.grabbing_ = "length", this.grabOffset_ = me(e - s, 0, 1, 0, r - i)) : e < s ? (this.grabbing_ = "min", this.onPointerMove_(t)) : e > o && (this.grabbing_ = "max", this.onPointerMove_(t)) } applyPointToValue_(t, e) { const n = this.valueFromData_(t); if (null === n) return; const i = this.sliderProps.get("minValue"), r = this.sliderProps.get("maxValue"); if ("min" === this.grabbing_) this.value.setRawValue(new On(n, this.value.rawValue.max), e); else if ("max" === this.grabbing_) this.value.setRawValue(new On(this.value.rawValue.min, n), e); else if ("length" === this.grabbing_) { const t = this.value.rawValue.length; let s = n - this.grabOffset_, o = s + t; s < i ? (s = i, o = i + t) : o > r && (s = r - t, o = r), this.value.setRawValue(new On(s, o), e) } } onPointerMove_(t) { this.applyPointToValue_(t.data, { forceEmit: !1, last: !1 }) } onPointerUp_(t) { this.applyPointToValue_(t.data, { forceEmit: !0, last: !0 }), this.grabbing_ = null } } class jn { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.sc_ = new Hn(t, e); const n = { baseStep: e.baseStep, constraint: e.constraint, textProps: E.fromObject({ draggingScale: e.draggingScale, formatter: e.formatter }) }; this.tc_ = new Ue(t, { assembly: Nn, axes: [n, n], parser: e.parser, value: this.value, viewProps: e.viewProps }), this.view = new Vn(t, { sliderView: this.sc_.view, textView: this.tc_.view }) } get textController() { return this.tc_ } } function Wn(t) { return On.isObject(t) ? new On(t.min, t.max) : new On(0, 0) } function qn(t, e) { t.writeProperty("max", e.max), t.writeProperty("min", e.min) } function Yn(t) { const e = [], n = Ve(t); n && e.push(n); const i = ze(t); return i && e.push(i), new Un(new lt(e)) } const Xn = { id: "input-interval", type: "input", css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}', accept: (t, e) => { if (!On.isObject(t)) return null; const n = T, i = D(e, { format: n.optional.function, max: n.optional.number, min: n.optional.number, step: n.optional.number }); return i ? { initialValue: new On(t.min, t.max), params: i } : null }, binding: { reader: t => Wn, constraint: t => Yn(t.params), equals: On.equals, writer: t => qn }, controller(t) { var e; const n = t.value, i = t.constraint; if (!(i instanceof Un)) throw a.shouldNeverHappen(); const r = (n.rawValue.min + n.rawValue.max) / 2, s = null !== (e = t.params.format) && void 0 !== e ? e : ee(we(i.edge, r)), o = i.edge && ht(i.edge, ct); if (o) return new jn(t.document, { baseStep: Ee(i.edge), constraint: i.edge, draggingScale: Ce(i.edge, r), formatter: s, parser: $t, sliderProps: new E({ maxValue: o.values.value("max"), minValue: o.values.value("min") }), value: n, viewProps: t.viewProps }); const l = { baseStep: Ee(i.edge), constraint: i.edge, textProps: E.fromObject({ draggingScale: r, formatter: s }) }; return new Ue(t.document, { assembly: Nn, axes: [l, l], parser: $t, value: n, viewProps: t.viewProps }) } }; class Kn { constructor(t) { this.controller_ = t } get disabled() { return this.controller_.viewProps.get("disabled") } set disabled(t) { this.controller_.viewProps.set("disabled", t) } get title() { var t; return null !== (t = this.controller_.props.get("title")) && void 0 !== t ? t : "" } set title(t) { this.controller_.props.set("title", t) } } class Jn extends i { constructor(t, e, n, i, r) { super(t, i, r), this.cell = e, this.index = n } } class Zn extends e { constructor(t) { super(t), this.cellToApiMap_ = new Map, this.controller_.valueController.cellControllers.forEach((t => { const e = new Kn(t); this.cellToApiMap_.set(t, e) })) } get value() { return this.controller_.value } cell(t, e) { const n = this.controller_.valueController, i = n.cellControllers[e * n.size[0] + t]; return this.cellToApiMap_.get(i) } on(t, e) { const n = e.bind(this); this.controller_.value.emitter.on(t, (t => { const e = this.controller_.valueController, i = e.findCellByValue(t.rawValue); if (!i) return; const r = this.cellToApiMap_.get(i); if (!r) return; const s = e.cellControllers.indexOf(i); n(new Jn(this, r, [s % e.size[0], Math.floor(s / e.size[0])], t.rawValue, void 0)) })) } } const $n = c("rad"); class ti { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add($n()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("label"); n.classList.add($n("l")), this.element.appendChild(n); const i = t.createElement("input"); i.classList.add($n("i")), i.name = e.name, i.type = "radio", e.viewProps.bindDisabled(i), n.appendChild(i), this.inputElement = i; const r = t.createElement("div"); r.classList.add($n("b")), n.appendChild(r); const s = t.createElement("div"); s.classList.add($n("t")), r.appendChild(s), f(e.props, "title", (t => { s.textContent = t })) } } class ei { constructor(t, e) { this.props = e.props, this.viewProps = e.viewProps, this.view = new ti(t, { name: e.name, props: this.props, viewProps: this.viewProps }) } } class ni { constructor(t, e) { this.cellCs_ = [], this.cellValues_ = [], this.onCellInputChange_ = this.onCellInputChange_.bind(this), this.size = e.size; const [n, i] = this.size; for (let r = 0; r < i; r++)for (let i = 0; i < n; i++) { const n = new ei(t, { name: e.groupName, props: E.fromObject(Object.assign({}, e.cellConfig(i, r))), viewProps: O.create() }); this.cellCs_.push(n), this.cellValues_.push(e.cellConfig(i, r).value) } this.value = e.value, p(this.value, (t => { const e = this.findCellByValue(t); e && (e.view.inputElement.checked = !0) })), this.viewProps = O.create(), this.view = new rt(t, { viewProps: this.viewProps, viewName: "radgrid" }), this.view.element.style.gridTemplateColumns = `repeat(${n}, 1fr)`, this.cellCs_.forEach((t => { t.view.inputElement.addEventListener("change", this.onCellInputChange_), this.view.element.appendChild(t.view.element) })) } get cellControllers() { return this.cellCs_ } findCellByValue(t) { const e = this.cellValues_.findIndex((e => e === t)); return e < 0 ? null : this.cellCs_[e] } onCellInputChange_(t) { const e = t.currentTarget, n = this.cellCs_.findIndex((t => t.view.inputElement === e)); n < 0 || (this.value.rawValue = this.cellValues_[n]) } } const ii = { id: "radiogrid", type: "blade", accept(t) { const e = T, n = D(t, { cells: e.required.function, groupName: e.required.string, size: e.required.array(e.required.number), value: e.required.raw, view: e.required.constant("radiogrid"), label: e.optional.string }); return n ? { params: n } : null }, controller(t) { return new st(t.document, { blade: t.blade, props: E.fromObject({ label: t.params.label }), valueController: new ni(t.document, { groupName: t.params.groupName, cellConfig: t.params.cells, size: t.params.size, value: w(t.params.value) }) }) }, api(t) { return t.controller instanceof st && t.controller.valueController instanceof ni ? new Zn(t.controller) : null } }; function ri(t) { return { id: "input-radiogrid", type: "input", accept(e, n) { if (!t.isType(e)) return null; const i = T, r = D(n, { cells: i.required.function, groupName: i.required.string, size: i.required.array(i.required.number), view: i.required.constant("radiogrid") }); return r ? { initialValue: e, params: r } : null }, binding: t.binding, controller: t => new ni(t.document, { cellConfig: t.params.cells, groupName: t.params.groupName, size: t.params.size, value: t.value }) } } const si = ri({ isType: t => "number" == typeof t, binding: { reader: t => te, writer: t => xe } }), oi = ri({ isType: t => "string" == typeof t, binding: { reader: t => ne, writer: t => xe } }), ai = ri({ isType: t => "boolean" == typeof t, binding: { reader: t => bt, writer: t => xe } }), li = [Ke, Pn, Rn, Xn, ii, ai, si, oi]; t.ButtonCellApi = We, t.ButtonGridApi = Ye, t.ButtonGridController = Xe, t.CubicBezier = rn, t.CubicBezierApi = Je, t.CubicBezierAssembly = sn, t.CubicBezierController = Sn, t.CubicBezierGraphController = En, t.CubicBezierGraphView = gn, t.CubicBezierPickerController = Cn, t.CubicBezierPickerView = dn, t.CubicBezierPreviewView = xn, t.CubicBezierView = cn, t.FpsGraphBladeApi = In, t.FpsGraphController = Fn, t.FpsView = Ln, t.Fpswatch = Dn, t.Interval = On, t.IntervalAssembly = Nn, t.IntervalConstraint = Un, t.RadioCellApi = Kn, t.RadioController = ei, t.RadioGridApi = Zn, t.RadioGridController = ni, t.RadioView = ti, t.RangeSliderController = Hn, t.RangeSliderTextController = jn, t.RangeSliderTextView = Vn, t.RangeSliderView = Gn, t.TpRadioGridChangeEvent = Jn, t.plugins = li, Object.defineProperty(t, "__esModule", { value: !0 }) }(e) }, 6077: function (t, e, n) { "use strict"; var i = {}; n.r(i), n.d(i, { plugin: function () { return tx } }); n(3948), n(1637); const r = "148", s = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, o = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, a = 0, l = 1, h = 2, c = 1, u = 2, d = 3, p = 0, f = 1, m = 2, g = 3, v = 0, A = 1, b = 2, y = 3, x = 4, _ = 5, w = 100, E = 101, C = 102, S = 103, M = 104, P = 200, I = 201, T = 202, D = 203, B = 204, L = 205, F = 206, k = 207, R = 208, O = 209, N = 210, U = 0, z = 1, V = 2, Q = 3, G = 4, H = 5, j = 6, W = 7, q = 0, Y = 1, X = 2, K = 0, J = 1, Z = 2, $ = 3, tt = 4, et = 5, nt = 301, it = 302, rt = 303, st = 304, ot = 306, at = 1e3, lt = 1001, ht = 1002, ct = 1003, ut = 1004, dt = 1005, pt = 1006, ft = 1007, mt = 1008, gt = 1009, vt = 1010, At = 1011, bt = 1012, yt = 1013, xt = 1014, _t = 1015, wt = 1016, Et = 1017, Ct = 1018, St = 1020, Mt = 1021, Pt = 1022, It = 1023, Tt = 1024, Dt = 1025, Bt = 1026, Lt = 1027, Ft = 1028, kt = 1029, Rt = 1030, Ot = 1031, Nt = 1033, Ut = 33776, zt = 33777, Vt = 33778, Qt = 33779, Gt = 35840, Ht = 35841, jt = 35842, Wt = 35843, qt = 36196, Yt = 37492, Xt = 37496, Kt = 37808, Jt = 37809, Zt = 37810, $t = 37811, te = 37812, ee = 37813, ne = 37814, ie = 37815, re = 37816, se = 37817, oe = 37818, ae = 37819, le = 37820, he = 37821, ce = 36492, ue = 2300, de = 2301, pe = 2302, fe = 2400, me = 2401, ge = 2402, ve = 2, Ae = 3e3, be = 3001, ye = 3201, xe = 0, _e = 1, we = "srgb", Ee = "srgb-linear", Ce = 7680, Se = 35044, Me = "300 es", Pe = 1035; class Ie { addEventListener(t, e) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e) } hasEventListener(t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) } removeEventListener(t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); -1 !== t && n.splice(t, 1) } } dispatchEvent(t) { if (void 0 === this._listeners) return; const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; const n = e.slice(0); for (let e = 0, i = n.length; e < i; e++)n[e].call(this, t); t.target = null } } } const Te = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let De = 1234567; const Be = Math.PI / 180, Le = 180 / Math.PI; function Fe() { const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (Te[255 & t] + Te[t >> 8 & 255] + Te[t >> 16 & 255] + Te[t >> 24 & 255] + "-" + Te[255 & e] + Te[e >> 8 & 255] + "-" + Te[e >> 16 & 15 | 64] + Te[e >> 24 & 255] + "-" + Te[63 & n | 128] + Te[n >> 8 & 255] + "-" + Te[n >> 16 & 255] + Te[n >> 24 & 255] + Te[255 & i] + Te[i >> 8 & 255] + Te[i >> 16 & 255] + Te[i >> 24 & 255]).toLowerCase() } function ke(t, e, n) { return Math.max(e, Math.min(n, t)) } function Re(t, e) { return (t % e + e) % e } function Oe(t, e, n) { return (1 - n) * t + n * e } function Ne(t) { return 0 == (t & t - 1) && 0 !== t } function Ue(t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) } function ze(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) } function Ve(t, e) { switch (e.constructor) { case Float32Array: return t; case Uint16Array: return t / 65535; case Uint8Array: return t / 255; case Int16Array: return Math.max(t / 32767, -1); case Int8Array: return Math.max(t / 127, -1); default: throw new Error("Invalid component type.") } } function Qe(t, e) { switch (e.constructor) { case Float32Array: return t; case Uint16Array: return Math.round(65535 * t); case Uint8Array: return Math.round(255 * t); case Int16Array: return Math.round(32767 * t); case Int8Array: return Math.round(127 * t); default: throw new Error("Invalid component type.") } } var Ge = Object.freeze({ __proto__: null, DEG2RAD: Be, RAD2DEG: Le, generateUUID: Fe, clamp: ke, euclideanModulo: Re, mapLinear: function (t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) }, inverseLerp: function (t, e, n) { return t !== e ? (n - t) / (e - t) : 0 }, lerp: Oe, damp: function (t, e, n, i) { return Oe(t, e, 1 - Math.exp(-n * i)) }, pingpong: function (t, e = 1) { return e - Math.abs(Re(t, 2 * e) - e) }, smoothstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, seededRandom: function (t) { void 0 !== t && (De = t); let e = De += 1831565813; return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296 }, degToRad: function (t) { return t * Be }, radToDeg: function (t) { return t * Le }, isPowerOfTwo: Ne, ceilPowerOfTwo: Ue, floorPowerOfTwo: ze, setQuaternionFromProperEuler: function (t, e, n, i, r) { const s = Math.cos, o = Math.sin, a = s(n / 2), l = o(n / 2), h = s((e + i) / 2), c = o((e + i) / 2), u = s((e - i) / 2), d = o((e - i) / 2), p = s((i - e) / 2), f = o((i - e) / 2); switch (r) { case "XYX": t.set(a * c, l * u, l * d, a * h); break; case "YZY": t.set(l * d, a * c, l * u, a * h); break; case "ZXZ": t.set(l * u, l * d, a * c, a * h); break; case "XZX": t.set(a * c, l * f, l * p, a * h); break; case "YXY": t.set(l * p, a * c, l * f, a * h); break; case "ZYZ": t.set(l * f, l * p, a * c, a * h); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } }, normalize: Qe, denormalize: Ve }); class He { constructor(t = 0, e = 0) { He.prototype.isVector2 = !0, this.x = t, this.y = e } get width() { return this.x } set width(t) { this.x = t } get height() { return this.y } set height(t) { this.y = t } set(t, e) { return this.x = t, this.y = e, this } setScalar(t) { return this.x = t, this.y = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y) } copy(t) { return this.x = t.x, this.y = t.y, this } add(t) { return this.x += t.x, this.y += t.y, this } addScalar(t) { return this.x += t, this.y += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this } sub(t) { return this.x -= t.x, this.y -= t.y, this } subScalar(t) { return this.x -= t, this.y -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this } divide(t) { return this.x /= t.x, this.y /= t.y, this } divideScalar(t) { return this.multiplyScalar(1 / t) } applyMatrix3(t) { const e = this.x, n = this.y, i = t.elements; return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(t) { return this.x * t.x + this.y * t.y } cross(t) { return this.x * t.y - this.y * t.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y; return e * e + n * n } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this } equals(t) { return t.x === this.x && t.y === this.y } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t } fromBufferAttribute(t, e) { return this.x = t.getX(e), this.y = t.getY(e), this } rotateAround(t, e) { const n = Math.cos(e), i = Math.sin(e), r = this.x - t.x, s = this.y - t.y; return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class je { constructor() { je.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1] } set(t, e, n, i, r, s, o, a, l) { const h = this.elements; return h[0] = t, h[1] = i, h[2] = o, h[3] = e, h[4] = r, h[5] = a, h[6] = n, h[7] = s, h[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this } extractBasis(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply(t) { return this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, i = e.elements, r = this.elements, s = n[0], o = n[3], a = n[6], l = n[1], h = n[4], c = n[7], u = n[2], d = n[5], p = n[8], f = i[0], m = i[3], g = i[6], v = i[1], A = i[4], b = i[7], y = i[2], x = i[5], _ = i[8]; return r[0] = s * f + o * v + a * y, r[3] = s * m + o * A + a * x, r[6] = s * g + o * b + a * _, r[1] = l * f + h * v + c * y, r[4] = l * m + h * A + c * x, r[7] = l * g + h * b + c * _, r[2] = u * f + d * v + p * y, r[5] = u * m + d * A + p * x, r[8] = u * g + d * b + p * _, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], s = t[4], o = t[5], a = t[6], l = t[7], h = t[8]; return e * s * h - e * o * l - n * r * h + n * o * a + i * r * l - i * s * a } invert() { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], s = t[4], o = t[5], a = t[6], l = t[7], h = t[8], c = h * s - o * l, u = o * a - h * r, d = l * r - s * a, p = e * c + n * u + i * d; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const f = 1 / p; return t[0] = c * f, t[1] = (i * l - h * n) * f, t[2] = (o * n - i * s) * f, t[3] = u * f, t[4] = (h * e - i * a) * f, t[5] = (i * r - o * e) * f, t[6] = d * f, t[7] = (n * a - l * e) * f, t[8] = (s * e - n * r) * f, this } transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this } getNormalMatrix(t) { return this.setFromMatrix4(t).invert().transpose() } transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this } setUvTransform(t, e, n, i, r, s, o) { const a = Math.cos(r), l = Math.sin(r); return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1), this } scale(t, e) { return this.premultiply(We.makeScale(t, e)), this } rotate(t) { return this.premultiply(We.makeRotation(-t)), this } translate(t, e) { return this.premultiply(We.makeTranslation(t, e)), this } makeTranslation(t, e) { return this.set(1, 0, t, 0, 1, e, 0, 0, 1), this } makeRotation(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this } makeScale(t, e) { return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this } equals(t) { const e = this.elements, n = t.elements; for (let t = 0; t < 9; t++)if (e[t] !== n[t]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } clone() { return (new this.constructor).fromArray(this.elements) } } const We = new je; function qe(t) { for (let e = t.length - 1; e >= 0; --e)if (t[e] >= 65535) return !0; return !1 } Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array; function Ye(t) { return document.createElementNS("http://www.w3.org/1999/xhtml", t) } function Xe(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function Ke(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } const Je = { [we]: { [Ee]: Xe }, [Ee]: { [we]: Ke } }, Ze = { legacyMode: !0, get workingColorSpace() { return Ee }, set workingColorSpace(t) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (t, e, n) { if (this.legacyMode || e === n || !e || !n) return t; if (Je[e] && void 0 !== Je[e][n]) { const i = Je[e][n]; return t.r = i(t.r), t.g = i(t.g), t.b = i(t.b), t } throw new Error("Unsupported color space conversion.") }, fromWorkingColorSpace: function (t, e) { return this.convert(t, this.workingColorSpace, e) }, toWorkingColorSpace: function (t, e) { return this.convert(t, e, this.workingColorSpace) } }, $e = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 15631086, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, tn = { r: 0, g: 0, b: 0 }, en = { h: 0, s: 0, l: 0 }, nn = { h: 0, s: 0, l: 0 }; function rn(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } function sn(t, e) { return e.r = t.r, e.g = t.g, e.b = t.b, e } class on { constructor(t, e, n) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this } setScalar(t) { return this.r = t, this.g = t, this.b = t, this } setHex(t, e = we) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, Ze.toWorkingColorSpace(this, e), this } setRGB(t, e, n, i = Ze.workingColorSpace) { return this.r = t, this.g = e, this.b = n, Ze.toWorkingColorSpace(this, i), this } setHSL(t, e, n, i = Ze.workingColorSpace) { if (t = Re(t, 1), e = ke(e, 0, 1), n = ke(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else { const i = n <= .5 ? n * (1 + e) : n + e - n * e, r = 2 * n - i; this.r = rn(r, i, t + 1 / 3), this.g = rn(r, i, t), this.b = rn(r, i, t - 1 / 3) } return Ze.toWorkingColorSpace(this, i), this } setStyle(t, e = we) { function n(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let i; if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) { let t; const r = i[1], s = i[2]; switch (r) { case "rgb": case "rgba": if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, Ze.toWorkingColorSpace(this, e), n(t[4]), this; if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, Ze.toWorkingColorSpace(this, e), n(t[4]), this; break; case "hsl": case "hsla": if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) { const i = parseFloat(t[1]) / 360, r = parseFloat(t[2]) / 100, s = parseFloat(t[3]) / 100; return n(t[4]), this.setHSL(i, r, s, e) } } } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) { const t = i[1], n = t.length; if (3 === n) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, Ze.toWorkingColorSpace(this, e), this; if (6 === n) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, Ze.toWorkingColorSpace(this, e), this } return t && t.length > 0 ? this.setColorName(t, e) : this } setColorName(t, e = we) { const n = $e[t.toLowerCase()]; return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this } copySRGBToLinear(t) { return this.r = Xe(t.r), this.g = Xe(t.g), this.b = Xe(t.b), this } copyLinearToSRGB(t) { return this.r = Ke(t.r), this.g = Ke(t.g), this.b = Ke(t.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(t = we) { return Ze.fromWorkingColorSpace(sn(this, tn), t), ke(255 * tn.r, 0, 255) << 16 ^ ke(255 * tn.g, 0, 255) << 8 ^ ke(255 * tn.b, 0, 255) << 0 } getHexString(t = we) { return ("000000" + this.getHex(t).toString(16)).slice(-6) } getHSL(t, e = Ze.workingColorSpace) { Ze.fromWorkingColorSpace(sn(this, tn), e); const n = tn.r, i = tn.g, r = tn.b, s = Math.max(n, i, r), o = Math.min(n, i, r); let a, l; const h = (o + s) / 2; if (o === s) a = 0, l = 0; else { const t = s - o; switch (l = h <= .5 ? t / (s + o) : t / (2 - s - o), s) { case n: a = (i - r) / t + (i < r ? 6 : 0); break; case i: a = (r - n) / t + 2; break; case r: a = (n - i) / t + 4 }a /= 6 } return t.h = a, t.s = l, t.l = h, t } getRGB(t, e = Ze.workingColorSpace) { return Ze.fromWorkingColorSpace(sn(this, tn), e), t.r = tn.r, t.g = tn.g, t.b = tn.b, t } getStyle(t = we) { return Ze.fromWorkingColorSpace(sn(this, tn), t), t !== we ? `color(${t} ${tn.r} ${tn.g} ${tn.b})` : `rgb(${255 * tn.r | 0},${255 * tn.g | 0},${255 * tn.b | 0})` } offsetHSL(t, e, n) { return this.getHSL(en), en.h += t, en.s += e, en.l += n, this.setHSL(en.h, en.s, en.l), this } add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this } addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this } addScalar(t) { return this.r += t, this.g += t, this.b += t, this } sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this } multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this } multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this } lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this } lerpColors(t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this } lerpHSL(t, e) { this.getHSL(en), t.getHSL(nn); const n = Oe(en.h, nn.h, e), i = Oe(en.s, nn.s, e), r = Oe(en.l, nn.l, e); return this.setHSL(n, i, r), this } equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b } fromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t } fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } let an; on.NAMES = $e; class ln { static getDataURL(t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === an && (an = Ye("canvas")), an.width = t.width, an.height = t.height; const n = an.getContext("2d"); t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = an } return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png") } static sRGBToLinear(t) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const e = Ye("canvas"); e.width = t.width, e.height = t.height; const n = e.getContext("2d"); n.drawImage(t, 0, 0, t.width, t.height); const i = n.getImageData(0, 0, t.width, t.height), r = i.data; for (let t = 0; t < r.length; t++)r[t] = 255 * Xe(r[t] / 255); return n.putImageData(i, 0, 0), e } if (t.data) { const e = t.data.slice(0); for (let t = 0; t < e.length; t++)e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Xe(e[t] / 255)) : e[t] = Xe(e[t]); return { data: e, width: t.width, height: t.height } } return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t } } class hn { constructor(t = null) { this.isSource = !0, this.uuid = Fe(), this.data = t, this.version = 0 } set needsUpdate(t) { !0 === t && this.version++ } toJSON(t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid]; const n = { uuid: this.uuid, url: "" }, i = this.data; if (null !== i) { let t; if (Array.isArray(i)) { t = []; for (let e = 0, n = i.length; e < n; e++)i[e].isDataTexture ? t.push(cn(i[e].image)) : t.push(cn(i[e])) } else t = cn(i); n.url = t } return e || (t.images[this.uuid] = n), n } } function cn(t) { return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ln.getDataURL(t) : t.data ? { data: Array.from(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let un = 0; class dn extends Ie { constructor(t = dn.DEFAULT_IMAGE, e = dn.DEFAULT_MAPPING, n = lt, i = lt, r = pt, s = mt, o = It, a = gt, l = dn.DEFAULT_ANISOTROPY, h = Ae) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: un++ }), this.uuid = Fe(), this.name = "", this.source = new hn(t), this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new He(0, 0), this.repeat = new He(1, 1), this.center = new He(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new je, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(t) { this.source.data = t } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this } toJSON(t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(t).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case at: t.x = t.x - Math.floor(t.x); break; case lt: t.x = t.x < 0 ? 0 : 1; break; case ht: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case at: t.y = t.y - Math.floor(t.y); break; case lt: t.y = t.y < 0 ? 0 : 1; break; case ht: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } set needsUpdate(t) { !0 === t && (this.version++, this.source.needsUpdate = !0) } } dn.DEFAULT_IMAGE = null, dn.DEFAULT_MAPPING = 300, dn.DEFAULT_ANISOTROPY = 1; class pn { constructor(t = 0, e = 0, n = 0, i = 1) { pn.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i } get width() { return this.z } set width(t) { this.z = t } get height() { return this.w } set height(t) { this.w = t } set(t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setW(t) { return this.w = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this } add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this } addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this } sub(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this } applyMatrix4(t) { const e = this.x, n = this.y, i = this.z, r = this.w, s = t.elements; return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this } divideScalar(t) { return this.multiplyScalar(1 / t) } setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this } setAxisAngleFromRotationMatrix(t) { let e, n, i, r; const s = .01, o = .1, a = t.elements, l = a[0], h = a[4], c = a[8], u = a[1], d = a[5], p = a[9], f = a[2], m = a[6], g = a[10]; if (Math.abs(h - u) < s && Math.abs(c - f) < s && Math.abs(p - m) < s) { if (Math.abs(h + u) < o && Math.abs(c + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this; e = Math.PI; const t = (l + 1) / 2, a = (d + 1) / 2, v = (g + 1) / 2, A = (h + u) / 4, b = (c + f) / 4, y = (p + m) / 4; return t > a && t > v ? t < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = A / n, r = b / n) : a > v ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = A / i, r = y / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = b / r, i = y / r), this.set(n, i, r, e), this } let v = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (u - h) * (u - h)); return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (c - f) / v, this.z = (u - h) / v, this.w = Math.acos((l + d + g - 1) / 2), this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t } fromBufferAttribute(t, e) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class fn extends Ie { constructor(t = 1, e = 1, n = {}) { super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new pn(0, 0, t, e), this.scissorTest = !1, this.viewport = new pn(0, 0, t, e); const i = { width: t, height: e, depth: 1 }; this.texture = new dn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : pt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0 } setSize(t, e, n = 1) { this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) } clone() { return (new this.constructor).copy(this) } copy(t) { this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0; const e = Object.assign({}, t.texture.image); return this.texture.source = new hn(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class mn extends dn { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = ct, this.minFilter = ct, this.wrapR = lt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class gn extends dn { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = ct, this.minFilter = ct, this.wrapR = lt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class vn { constructor(t = 0, e = 0, n = 0, i = 1) { this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i } static slerpFlat(t, e, n, i, r, s, o) { let a = n[i + 0], l = n[i + 1], h = n[i + 2], c = n[i + 3]; const u = r[s + 0], d = r[s + 1], p = r[s + 2], f = r[s + 3]; if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = h, void (t[e + 3] = c); if (1 === o) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void (t[e + 3] = f); if (c !== f || a !== u || l !== d || h !== p) { let t = 1 - o; const e = a * u + l * d + h * p + c * f, n = e >= 0 ? 1 : -1, i = 1 - e * e; if (i > Number.EPSILON) { const r = Math.sqrt(i), s = Math.atan2(r, e * n); t = Math.sin(t * s) / r, o = Math.sin(o * s) / r } const r = o * n; if (a = a * t + u * r, l = l * t + d * r, h = h * t + p * r, c = c * t + f * r, t === 1 - o) { const t = 1 / Math.sqrt(a * a + l * l + h * h + c * c); a *= t, l *= t, h *= t, c *= t } } t[e] = a, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c } static multiplyQuaternionsFlat(t, e, n, i, r, s) { const o = n[i], a = n[i + 1], l = n[i + 2], h = n[i + 3], c = r[s], u = r[s + 1], d = r[s + 2], p = r[s + 3]; return t[e] = o * p + h * c + a * d - l * u, t[e + 1] = a * p + h * u + l * c - o * d, t[e + 2] = l * p + h * d + o * u - a * c, t[e + 3] = h * p - o * c - a * u - l * d, t } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get w() { return this._w } set w(t) { this._w = t, this._onChangeCallback() } set(t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this } setFromEuler(t, e) { const n = t._x, i = t._y, r = t._z, s = t._order, o = Math.cos, a = Math.sin, l = o(n / 2), h = o(i / 2), c = o(r / 2), u = a(n / 2), d = a(i / 2), p = a(r / 2); switch (s) { case "XYZ": this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p; break; case "YXZ": this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p; break; case "ZXY": this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p; break; case "ZYX": this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p; break; case "YZX": this._x = u * h * c + l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c - u * d * p; break; case "XZY": this._x = u * h * c - l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c + u * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return !1 !== e && this._onChangeCallback(), this } setFromAxisAngle(t, e) { const n = e / 2, i = Math.sin(n); return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(t) { const e = t.elements, n = e[0], i = e[4], r = e[8], s = e[1], o = e[5], a = e[9], l = e[2], h = e[6], c = e[10], u = n + o + c; if (u > 0) { const t = .5 / Math.sqrt(u + 1); this._w = .25 / t, this._x = (h - a) * t, this._y = (r - l) * t, this._z = (s - i) * t } else if (n > o && n > c) { const t = 2 * Math.sqrt(1 + n - o - c); this._w = (h - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t } else if (o > c) { const t = 2 * Math.sqrt(1 + o - n - c); this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + h) / t } else { const t = 2 * Math.sqrt(1 + c - n - o); this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + h) / t, this._z = .25 * t } return this._onChangeCallback(), this } setFromUnitVectors(t, e) { let n = t.dot(e) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() } angleTo(t) { return 2 * Math.acos(Math.abs(ke(this.dot(t), -1, 1))) } rotateTowards(t, e) { const n = this.angleTo(t); if (0 === n) return this; const i = Math.min(1, e / n); return this.slerp(t, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this } multiply(t) { return this.multiplyQuaternions(this, t) } premultiply(t) { return this.multiplyQuaternions(t, this) } multiplyQuaternions(t, e) { const n = t._x, i = t._y, r = t._z, s = t._w, o = e._x, a = e._y, l = e._z, h = e._w; return this._x = n * h + s * o + i * l - r * a, this._y = i * h + s * a + r * o - n * l, this._z = r * h + s * l + n * a - i * o, this._w = s * h - n * o - i * a - r * l, this._onChangeCallback(), this } slerp(t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); const n = this._x, i = this._y, r = this._z, s = this._w; let o = s * t._w + n * t._x + i * t._y + r * t._z; if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this; const a = 1 - o * o; if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this } const l = Math.sqrt(a), h = Math.atan2(l, o), c = Math.sin((1 - e) * h) / l, u = Math.sin(e * h) / l; return this._w = s * c + this._w * u, this._x = n * c + this._x * u, this._y = i * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this } slerpQuaternions(t, e, n) { return this.copy(t).slerp(e, n) } random() { const t = Math.random(), e = Math.sqrt(1 - t), n = Math.sqrt(t), i = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random(); return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i)) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w } fromArray(t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t } fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class An { constructor(t = 0, e = 0, n = 0) { An.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n } set(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this } add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this } addScalar(t) { return this.x += t, this.y += t, this.z += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this } sub(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this } multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this } applyEuler(t) { return this.applyQuaternion(yn.setFromEuler(t)) } applyAxisAngle(t, e) { return this.applyQuaternion(yn.setFromAxisAngle(t, e)) } applyMatrix3(t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this } applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() } applyMatrix4(t) { const e = this.x, n = this.y, i = this.z, r = t.elements, s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this } applyQuaternion(t) { const e = this.x, n = this.y, i = this.z, r = t.x, s = t.y, o = t.z, a = t.w, l = a * e + s * i - o * n, h = a * n + o * e - r * i, c = a * i + r * n - s * e, u = -r * e - s * n - o * i; return this.x = l * a + u * -r + h * -o - c * -s, this.y = h * a + u * -s + c * -r - l * -o, this.z = c * a + u * -o + l * -s - h * -r, this } project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) } unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) } transformDirection(t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize() } divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this } divideScalar(t) { return this.multiplyScalar(1 / t) } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this } cross(t) { return this.crossVectors(this, t) } crossVectors(t, e) { const n = t.x, i = t.y, r = t.z, s = e.x, o = e.y, a = e.z; return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this } projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) } projectOnPlane(t) { return bn.copy(this).projectOnVector(t), this.sub(bn) } reflect(t) { return this.sub(bn.copy(t).multiplyScalar(2 * this.dot(t))) } angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(ke(n, -1, 1)) } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z; return e * e + n * n + i * i } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) } setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) } setFromSphericalCoords(t, e, n) { const i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this } setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) } setFromCylindricalCoords(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this } setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale(t) { const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = i, this } setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) } setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) } setFromEuler(t) { return this.x = t._x, this.y = t._y, this.z = t._z, this } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t } fromBufferAttribute(t, e) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const t = 2 * (Math.random() - .5), e = Math.random() * Math.PI * 2, n = Math.sqrt(1 - t ** 2); return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const bn = new An, yn = new vn; class xn { constructor(t = new An(1 / 0, 1 / 0, 1 / 0), e = new An(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = t, this.max = e } set(t, e) { return this.min.copy(t), this.max.copy(e), this } setFromArray(t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, o = -1 / 0; for (let a = 0, l = t.length; a < l; a += 3) { const l = t[a], h = t[a + 1], c = t[a + 2]; l < e && (e = l), h < n && (n = h), c < i && (i = c), l > r && (r = l), h > s && (s = h), c > o && (o = c) } return this.min.set(e, n, i), this.max.set(r, s, o), this } setFromBufferAttribute(t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, o = -1 / 0; for (let a = 0, l = t.count; a < l; a++) { const l = t.getX(a), h = t.getY(a), c = t.getZ(a); l < e && (e = l), h < n && (n = h), c < i && (i = c), l > r && (r = l), h > s && (s = h), c > o && (o = c) } return this.min.set(e, n, i), this.max.set(r, s, o), this } setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize(t, e) { const n = wn.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } setFromObject(t, e = !1) { return this.makeEmpty(), this.expandByObject(t, e) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) } expandByPoint(t) { return this.min.min(t), this.max.max(t), this } expandByVector(t) { return this.min.sub(t), this.max.add(t), this } expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this } expandByObject(t, e = !1) { t.updateWorldMatrix(!1, !1); const n = t.geometry; if (void 0 !== n) if (e && null != n.attributes && void 0 !== n.attributes.position) { const e = n.attributes.position; for (let n = 0, i = e.count; n < i; n++)wn.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(wn) } else null === n.boundingBox && n.computeBoundingBox(), En.copy(n.boundingBox), En.applyMatrix4(t.matrixWorld), this.union(En); const i = t.children; for (let t = 0, n = i.length; t < n; t++)this.expandByObject(i[t], e); return this } containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) } containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z } getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) } intersectsSphere(t) { return this.clampPoint(t.center, wn), wn.distanceToSquared(t.center) <= t.radius * t.radius } intersectsPlane(t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant } intersectsTriangle(t) { if (this.isEmpty()) return !1; this.getCenter(Dn), Bn.subVectors(this.max, Dn), Cn.subVectors(t.a, Dn), Sn.subVectors(t.b, Dn), Mn.subVectors(t.c, Dn), Pn.subVectors(Sn, Cn), In.subVectors(Mn, Sn), Tn.subVectors(Cn, Mn); let e = [0, -Pn.z, Pn.y, 0, -In.z, In.y, 0, -Tn.z, Tn.y, Pn.z, 0, -Pn.x, In.z, 0, -In.x, Tn.z, 0, -Tn.x, -Pn.y, Pn.x, 0, -In.y, In.x, 0, -Tn.y, Tn.x, 0]; return !!kn(e, Cn, Sn, Mn, Bn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!kn(e, Cn, Sn, Mn, Bn) && (Ln.crossVectors(Pn, In), e = [Ln.x, Ln.y, Ln.z], kn(e, Cn, Sn, Mn, Bn))) } clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) } distanceToPoint(t) { return wn.copy(t).clamp(this.min, this.max).sub(t).length() } getBoundingSphere(t) { return this.getCenter(t.center), t.radius = .5 * this.getSize(wn).length(), t } intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this } union(t) { return this.min.min(t.min), this.max.max(t.max), this } applyMatrix4(t) { return this.isEmpty() || (_n[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), _n[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), _n[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), _n[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), _n[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), _n[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), _n[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), _n[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(_n)), this } translate(t) { return this.min.add(t), this.max.add(t), this } equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) } } const _n = [new An, new An, new An, new An, new An, new An, new An, new An], wn = new An, En = new xn, Cn = new An, Sn = new An, Mn = new An, Pn = new An, In = new An, Tn = new An, Dn = new An, Bn = new An, Ln = new An, Fn = new An; function kn(t, e, n, i, r) { for (let s = 0, o = t.length - 3; s <= o; s += 3) { Fn.fromArray(t, s); const o = r.x * Math.abs(Fn.x) + r.y * Math.abs(Fn.y) + r.z * Math.abs(Fn.z), a = e.dot(Fn), l = n.dot(Fn), h = i.dot(Fn); if (Math.max(-Math.max(a, l, h), Math.min(a, l, h)) > o) return !1 } return !0 } const Rn = new xn, On = new An, Nn = new An; class Un { constructor(t = new An, e = -1) { this.center = t, this.radius = e } set(t, e) { return this.center.copy(t), this.radius = e, this } setFromPoints(t, e) { const n = this.center; void 0 !== e ? n.copy(e) : Rn.setFromPoints(t).getCenter(n); let i = 0; for (let e = 0, r = t.length; e < r; e++)i = Math.max(i, n.distanceToSquared(t[e])); return this.radius = Math.sqrt(i), this } copy(t) { return this.center.copy(t.center), this.radius = t.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(t) { return t.distanceTo(this.center) - this.radius } intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e } intersectsBox(t) { return t.intersectsSphere(this) } intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius } clampPoint(t, e) { const n = this.center.distanceToSquared(t); return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e } getBoundingBox(t) { return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) } applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this } translate(t) { return this.center.add(t), this } expandByPoint(t) { if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this; On.subVectors(t, this.center); const e = On.lengthSq(); if (e > this.radius * this.radius) { const t = Math.sqrt(e), n = .5 * (t - this.radius); this.center.addScaledVector(On, n / t), this.radius += n } return this } union(t) { return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (Nn.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(On.copy(t.center).add(Nn)), this.expandByPoint(On.copy(t.center).sub(Nn))), this) } equals(t) { return t.center.equals(this.center) && t.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const zn = new An, Vn = new An, Qn = new An, Gn = new An, Hn = new An, jn = new An, Wn = new An; class qn { constructor(t = new An, e = new An(0, 0, -1)) { this.origin = t, this.direction = e } set(t, e) { return this.origin.copy(t), this.direction.copy(e), this } copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this } at(t, e) { return e.copy(this.direction).multiplyScalar(t).add(this.origin) } lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this } recast(t) { return this.origin.copy(this.at(t, zn)), this } closestPointToPoint(t, e) { e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) } distanceSqToPoint(t) { const e = zn.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (zn.copy(this.direction).multiplyScalar(e).add(this.origin), zn.distanceToSquared(t)) } distanceSqToSegment(t, e, n, i) { Vn.copy(t).add(e).multiplyScalar(.5), Qn.copy(e).sub(t).normalize(), Gn.copy(this.origin).sub(Vn); const r = .5 * t.distanceTo(e), s = -this.direction.dot(Qn), o = Gn.dot(this.direction), a = -Gn.dot(Qn), l = Gn.lengthSq(), h = Math.abs(1 - s * s); let c, u, d, p; if (h > 0) if (c = s * a - o, u = s * o - a, p = r * h, c >= 0) if (u >= -p) if (u <= p) { const t = 1 / h; c *= t, u *= t, d = c * (c + s * u + 2 * o) + u * (s * c + u + 2 * a) + l } else u = r, c = Math.max(0, -(s * u + o)), d = -c * c + u * (u + 2 * a) + l; else u = -r, c = Math.max(0, -(s * u + o)), d = -c * c + u * (u + 2 * a) + l; else u <= -p ? (c = Math.max(0, -(-s * r + o)), u = c > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -c * c + u * (u + 2 * a) + l) : u <= p ? (c = 0, u = Math.min(Math.max(-r, -a), r), d = u * (u + 2 * a) + l) : (c = Math.max(0, -(s * r + o)), u = c > 0 ? r : Math.min(Math.max(-r, -a), r), d = -c * c + u * (u + 2 * a) + l); else u = s > 0 ? -r : r, c = Math.max(0, -(s * u + o)), d = -c * c + u * (u + 2 * a) + l; return n && n.copy(this.direction).multiplyScalar(c).add(this.origin), i && i.copy(Qn).multiplyScalar(u).add(Vn), d } intersectSphere(t, e) { zn.subVectors(t.center, this.origin); const n = zn.dot(this.direction), i = zn.dot(zn) - n * n, r = t.radius * t.radius; if (i > r) return null; const s = Math.sqrt(r - i), o = n - s, a = n + s; return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e) } intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius } distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null } intersectPlane(t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) } intersectsPlane(t) { const e = t.distanceToPoint(this.origin); if (0 === e) return !0; return t.normal.dot(this.direction) * e < 0 } intersectBox(t, e) { let n, i, r, s, o, a; const l = 1 / this.direction.x, h = 1 / this.direction.y, c = 1 / this.direction.z, u = this.origin; return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), h >= 0 ? (r = (t.min.y - u.y) * h, s = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, s = (t.min.y - u.y) * h), n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r), (s < i || isNaN(i)) && (i = s), c >= 0 ? (o = (t.min.z - u.z) * c, a = (t.max.z - u.z) * c) : (o = (t.max.z - u.z) * c, a = (t.min.z - u.z) * c), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e))) } intersectsBox(t) { return null !== this.intersectBox(t, zn) } intersectTriangle(t, e, n, i, r) { Hn.subVectors(e, t), jn.subVectors(n, t), Wn.crossVectors(Hn, jn); let s, o = this.direction.dot(Wn); if (o > 0) { if (i) return null; s = 1 } else { if (!(o < 0)) return null; s = -1, o = -o } Gn.subVectors(this.origin, t); const a = s * this.direction.dot(jn.crossVectors(Gn, jn)); if (a < 0) return null; const l = s * this.direction.dot(Hn.cross(Gn)); if (l < 0) return null; if (a + l > o) return null; const h = -s * Gn.dot(Wn); return h < 0 ? null : this.at(h / o, r) } applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this } equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class Yn { constructor() { Yn.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } set(t, e, n, i, r, s, o, a, l, h, c, u, d, p, f, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new Yn).fromArray(this.elements) } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this } copyPosition(t) { const e = this.elements, n = t.elements; return e[12] = n[12], e[13] = n[13], e[14] = n[14], this } setFromMatrix3(t) { const e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this } extractBasis(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(t) { const e = this.elements, n = t.elements, i = 1 / Xn.setFromMatrixColumn(t, 0).length(), r = 1 / Xn.setFromMatrixColumn(t, 1).length(), s = 1 / Xn.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromEuler(t) { const e = this.elements, n = t.x, i = t.y, r = t.z, s = Math.cos(n), o = Math.sin(n), a = Math.cos(i), l = Math.sin(i), h = Math.cos(r), c = Math.sin(r); if ("XYZ" === t.order) { const t = s * h, n = s * c, i = o * h, r = o * c; e[0] = a * h, e[4] = -a * c, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a } else if ("YXZ" === t.order) { const t = a * h, n = a * c, i = l * h, r = l * c; e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * c, e[5] = s * h, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a } else if ("ZXY" === t.order) { const t = a * h, n = a * c, i = l * h, r = l * c; e[0] = t - r * o, e[4] = -s * c, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * h, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a } else if ("ZYX" === t.order) { const t = s * h, n = s * c, i = o * h, r = o * c; e[0] = a * h, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * c, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a } else if ("YZX" === t.order) { const t = s * a, n = s * l, i = o * a, r = o * l; e[0] = a * h, e[4] = r - t * c, e[8] = i * c + n, e[1] = c, e[5] = s * h, e[9] = -o * h, e[2] = -l * h, e[6] = n * c + i, e[10] = t - r * c } else if ("XZY" === t.order) { const t = s * a, n = s * l, i = o * a, r = o * l; e[0] = a * h, e[4] = -c, e[8] = l * h, e[1] = t * c + r, e[5] = s * h, e[9] = n * c - i, e[2] = i * c - n, e[6] = o * h, e[10] = r * c + t } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromQuaternion(t) { return this.compose(Jn, t, Zn) } lookAt(t, e, n) { const i = this.elements; return ei.subVectors(t, e), 0 === ei.lengthSq() && (ei.z = 1), ei.normalize(), $n.crossVectors(n, ei), 0 === $n.lengthSq() && (1 === Math.abs(n.z) ? ei.x += 1e-4 : ei.z += 1e-4, ei.normalize(), $n.crossVectors(n, ei)), $n.normalize(), ti.crossVectors(ei, $n), i[0] = $n.x, i[4] = ti.x, i[8] = ei.x, i[1] = $n.y, i[5] = ti.y, i[9] = ei.y, i[2] = $n.z, i[6] = ti.z, i[10] = ei.z, this } multiply(t) { return this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, i = e.elements, r = this.elements, s = n[0], o = n[4], a = n[8], l = n[12], h = n[1], c = n[5], u = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], A = n[7], b = n[11], y = n[15], x = i[0], _ = i[4], w = i[8], E = i[12], C = i[1], S = i[5], M = i[9], P = i[13], I = i[2], T = i[6], D = i[10], B = i[14], L = i[3], F = i[7], k = i[11], R = i[15]; return r[0] = s * x + o * C + a * I + l * L, r[4] = s * _ + o * S + a * T + l * F, r[8] = s * w + o * M + a * D + l * k, r[12] = s * E + o * P + a * B + l * R, r[1] = h * x + c * C + u * I + d * L, r[5] = h * _ + c * S + u * T + d * F, r[9] = h * w + c * M + u * D + d * k, r[13] = h * E + c * P + u * B + d * R, r[2] = p * x + f * C + m * I + g * L, r[6] = p * _ + f * S + m * T + g * F, r[10] = p * w + f * M + m * D + g * k, r[14] = p * E + f * P + m * B + g * R, r[3] = v * x + A * C + b * I + y * L, r[7] = v * _ + A * S + b * T + y * F, r[11] = v * w + A * M + b * D + y * k, r[15] = v * E + A * P + b * B + y * R, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[4], i = t[8], r = t[12], s = t[1], o = t[5], a = t[9], l = t[13], h = t[2], c = t[6], u = t[10], d = t[14]; return t[3] * (+r * a * c - i * l * c - r * o * u + n * l * u + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * u + r * s * u - i * s * d + i * l * h - r * a * h) + t[11] * (+e * l * c - e * o * d - r * s * c + n * s * d + r * o * h - n * l * h) + t[15] * (-i * o * h - e * a * c + e * o * u + i * s * c - n * s * u + n * a * h) } transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } setPosition(t, e, n) { const i = this.elements; return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this } invert() { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], s = t[4], o = t[5], a = t[6], l = t[7], h = t[8], c = t[9], u = t[10], d = t[11], p = t[12], f = t[13], m = t[14], g = t[15], v = c * m * l - f * u * l + f * a * d - o * m * d - c * a * g + o * u * g, A = p * u * l - h * m * l - p * a * d + s * m * d + h * a * g - s * u * g, b = h * f * l - p * c * l + p * o * d - s * f * d - h * o * g + s * c * g, y = p * c * a - h * f * a - p * o * u + s * f * u + h * o * m - s * c * m, x = e * v + n * A + i * b + r * y; if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const _ = 1 / x; return t[0] = v * _, t[1] = (f * u * r - c * m * r - f * i * d + n * m * d + c * i * g - n * u * g) * _, t[2] = (o * m * r - f * a * r + f * i * l - n * m * l - o * i * g + n * a * g) * _, t[3] = (c * a * r - o * u * r - c * i * l + n * u * l + o * i * d - n * a * d) * _, t[4] = A * _, t[5] = (h * m * r - p * u * r + p * i * d - e * m * d - h * i * g + e * u * g) * _, t[6] = (p * a * r - s * m * r - p * i * l + e * m * l + s * i * g - e * a * g) * _, t[7] = (s * u * r - h * a * r + h * i * l - e * u * l - s * i * d + e * a * d) * _, t[8] = b * _, t[9] = (p * c * r - h * f * r - p * n * d + e * f * d + h * n * g - e * c * g) * _, t[10] = (s * f * r - p * o * r + p * n * l - e * f * l - s * n * g + e * o * g) * _, t[11] = (h * o * r - s * c * r - h * n * l + e * c * l + s * n * d - e * o * d) * _, t[12] = y * _, t[13] = (h * f * i - p * c * i + p * n * u - e * f * u - h * n * m + e * c * m) * _, t[14] = (p * o * i - s * f * i - p * n * a + e * f * a + s * n * m - e * o * m) * _, t[15] = (s * c * i - h * o * i + h * n * a - e * c * a - s * n * u + e * o * u) * _, this } scale(t) { const e = this.elements, n = t.x, i = t.y, r = t.z; return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this } getMaxScaleOnAxis() { const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, n, i)) } makeTranslation(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this } makeRotationY(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this } makeRotationZ(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(t, e) { const n = Math.cos(e), i = Math.sin(e), r = 1 - n, s = t.x, o = t.y, a = t.z, l = r * s, h = r * o; return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, h * o + n, h * a - i * s, 0, l * a - i * o, h * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this } makeScale(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(t, e, n, i, r, s) { return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this } compose(t, e, n) { const i = this.elements, r = e._x, s = e._y, o = e._z, a = e._w, l = r + r, h = s + s, c = o + o, u = r * l, d = r * h, p = r * c, f = s * h, m = s * c, g = o * c, v = a * l, A = a * h, b = a * c, y = n.x, x = n.y, _ = n.z; return i[0] = (1 - (f + g)) * y, i[1] = (d + b) * y, i[2] = (p - A) * y, i[3] = 0, i[4] = (d - b) * x, i[5] = (1 - (u + g)) * x, i[6] = (m + v) * x, i[7] = 0, i[8] = (p + A) * _, i[9] = (m - v) * _, i[10] = (1 - (u + f)) * _, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this } decompose(t, e, n) { const i = this.elements; let r = Xn.set(i[0], i[1], i[2]).length(); const s = Xn.set(i[4], i[5], i[6]).length(), o = Xn.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Kn.copy(this); const a = 1 / r, l = 1 / s, h = 1 / o; return Kn.elements[0] *= a, Kn.elements[1] *= a, Kn.elements[2] *= a, Kn.elements[4] *= l, Kn.elements[5] *= l, Kn.elements[6] *= l, Kn.elements[8] *= h, Kn.elements[9] *= h, Kn.elements[10] *= h, e.setFromRotationMatrix(Kn), n.x = r, n.y = s, n.z = o, this } makePerspective(t, e, n, i, r, s) { const o = this.elements, a = 2 * r / (e - t), l = 2 * r / (n - i), h = (e + t) / (e - t), c = (n + i) / (n - i), u = -(s + r) / (s - r), d = -2 * s * r / (s - r); return o[0] = a, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = l, o[9] = c, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(t, e, n, i, r, s) { const o = this.elements, a = 1 / (e - t), l = 1 / (n - i), h = 1 / (s - r), c = (e + t) * a, u = (n + i) * l, d = (s + r) * h; return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -c, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(t) { const e = this.elements, n = t.elements; for (let t = 0; t < 16; t++)if (e[t] !== n[t]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } } const Xn = new An, Kn = new Yn, Jn = new An(0, 0, 0), Zn = new An(1, 1, 1), $n = new An, ti = new An, ei = new An, ni = new Yn, ii = new vn; class ri { constructor(t = 0, e = 0, n = 0, i = ri.DefaultOrder) { this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get order() { return this._order } set order(t) { this._order = t, this._onChangeCallback() } set(t, e, n, i = this._order) { return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this } setFromRotationMatrix(t, e = this._order, n = !0) { const i = t.elements, r = i[0], s = i[4], o = i[8], a = i[1], l = i[5], h = i[9], c = i[2], u = i[6], d = i[10]; switch (e) { case "XYZ": this._y = Math.asin(ke(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-ke(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-c, r), this._z = 0); break; case "ZXY": this._x = Math.asin(ke(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r)); break; case "ZYX": this._y = Math.asin(-ke(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(ke(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(o, d)); break; case "XZY": this._z = Math.asin(-ke(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, !0 === n && this._onChangeCallback(), this } setFromQuaternion(t, e, n) { return ni.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ni, e, n) } setFromVector3(t, e = this._order) { return this.set(t.x, t.y, t.z, e) } reorder(t) { return ii.setFromEuler(this), this.setFromQuaternion(ii, t) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order } fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } toVector3() { console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead") } } ri.DefaultOrder = "XYZ", ri.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class si { constructor() { this.mask = 1 } set(t) { this.mask = (1 << t | 0) >>> 0 } enable(t) { this.mask |= 1 << t | 0 } enableAll() { this.mask = -1 } toggle(t) { this.mask ^= 1 << t | 0 } disable(t) { this.mask &= ~(1 << t | 0) } disableAll() { this.mask = 0 } test(t) { return 0 != (this.mask & t.mask) } isEnabled(t) { return 0 != (this.mask & (1 << t | 0)) } } let oi = 0; const ai = new An, li = new vn, hi = new Yn, ci = new An, ui = new An, di = new An, pi = new vn, fi = new An(1, 0, 0), mi = new An(0, 1, 0), gi = new An(0, 0, 1), vi = { type: "added" }, Ai = { type: "removed" }; class bi extends Ie { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: oi++ }), this.uuid = Fe(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = bi.DefaultUp.clone(); const t = new An, e = new ri, n = new vn, i = new An(1, 1, 1); e._onChange((function () { n.setFromEuler(e, !1) })), n._onChange((function () { e.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Yn }, normalMatrix: { value: new je } }), this.matrix = new Yn, this.matrixWorld = new Yn, this.matrixAutoUpdate = bi.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = bi.DefaultMatrixWorldAutoUpdate, this.layers = new si, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(t) { return this.quaternion.premultiply(t), this } setRotationFromAxisAngle(t, e) { this.quaternion.setFromAxisAngle(t, e) } setRotationFromEuler(t) { this.quaternion.setFromEuler(t, !0) } setRotationFromMatrix(t) { this.quaternion.setFromRotationMatrix(t) } setRotationFromQuaternion(t) { this.quaternion.copy(t) } rotateOnAxis(t, e) { return li.setFromAxisAngle(t, e), this.quaternion.multiply(li), this } rotateOnWorldAxis(t, e) { return li.setFromAxisAngle(t, e), this.quaternion.premultiply(li), this } rotateX(t) { return this.rotateOnAxis(fi, t) } rotateY(t) { return this.rotateOnAxis(mi, t) } rotateZ(t) { return this.rotateOnAxis(gi, t) } translateOnAxis(t, e) { return ai.copy(t).applyQuaternion(this.quaternion), this.position.add(ai.multiplyScalar(e)), this } translateX(t) { return this.translateOnAxis(fi, t) } translateY(t) { return this.translateOnAxis(mi, t) } translateZ(t) { return this.translateOnAxis(gi, t) } localToWorld(t) { return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld) } worldToLocal(t) { return this.updateWorldMatrix(!0, !1), t.applyMatrix4(hi.copy(this.matrixWorld).invert()) } lookAt(t, e, n) { t.isVector3 ? ci.copy(t) : ci.set(t, e, n); const i = this.parent; this.updateWorldMatrix(!0, !1), ui.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? hi.lookAt(ui, ci, this.up) : hi.lookAt(ci, ui, this.up), this.quaternion.setFromRotationMatrix(hi), i && (hi.extractRotation(i.matrixWorld), li.setFromRotationMatrix(hi), this.quaternion.premultiply(li.invert())) } add(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(vi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) } remove(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Ai)), this } removeFromParent() { const t = this.parent; return null !== t && t.remove(this), this } clear() { for (let t = 0; t < this.children.length; t++) { const e = this.children[t]; e.parent = null, e.dispatchEvent(Ai) } return this.children.length = 0, this } attach(t) { return this.updateWorldMatrix(!0, !1), hi.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), hi.multiply(t.parent.matrixWorld)), t.applyMatrix4(hi), this.add(t), t.updateWorldMatrix(!1, !0), this } getObjectById(t) { return this.getObjectByProperty("id", t) } getObjectByName(t) { return this.getObjectByProperty("name", t) } getObjectByProperty(t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } } getObjectsByProperty(t, e) { let n = []; this[t] === e && n.push(this); for (let i = 0, r = this.children.length; i < r; i++) { const r = this.children[i].getObjectsByProperty(t, e); r.length > 0 && (n = n.concat(r)) } return n } getWorldPosition(t) { return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ui, t, di), t } getWorldScale(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ui, pi, t), t } getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() } raycast() { } traverse(t) { t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverse(t) } traverseVisible(t) { if (!1 === this.visible) return; t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverseVisible(t) } traverseAncestors(t) { const e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; !0 !== i.matrixWorldAutoUpdate && !0 !== t || i.updateMatrixWorld(t) } } updateWorldMatrix(t, e) { const n = this.parent; if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0) } } } toJSON(t) { const e = void 0 === t || "string" == typeof t, n = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const i = {}; function r(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) { i.geometry = r(t.geometries, this.geometry); const e = this.geometry.parameters; if (void 0 !== e && void 0 !== e.shapes) { const n = e.shapes; if (Array.isArray(n)) for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; r(t.shapes, i) } else r(t.shapes, n) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const e = []; for (let n = 0, i = this.material.length; n < i; n++)e.push(r(t.materials, this.material[n])); i.material = e } else i.material = r(t.materials, this.material); if (this.children.length > 0) { i.children = []; for (let e = 0; e < this.children.length; e++)i.children.push(this.children[e].toJSON(t).object) } if (this.animations.length > 0) { i.animations = []; for (let e = 0; e < this.animations.length; e++) { const n = this.animations[e]; i.animations.push(r(t.animations, n)) } } if (e) { const e = s(t.geometries), i = s(t.materials), r = s(t.textures), o = s(t.images), a = s(t.shapes), l = s(t.skeletons), h = s(t.animations), c = s(t.nodes); e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), h.length > 0 && (n.animations = h), c.length > 0 && (n.nodes = c) } return n.object = i, n; function s(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } } clone(t) { return (new this.constructor).copy(this, t) } copy(t, e = !0) { if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) { const n = t.children[e]; this.add(n.clone()) } return this } } bi.DefaultUp = new An(0, 1, 0), bi.DefaultMatrixAutoUpdate = !0, bi.DefaultMatrixWorldAutoUpdate = !0; const yi = new An, xi = new An, _i = new An, wi = new An, Ei = new An, Ci = new An, Si = new An, Mi = new An, Pi = new An, Ii = new An; class Ti { constructor(t = new An, e = new An, n = new An) { this.a = t, this.b = e, this.c = n } static getNormal(t, e, n, i) { i.subVectors(n, e), yi.subVectors(t, e), i.cross(yi); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) } static getBarycoord(t, e, n, i, r) { yi.subVectors(i, e), xi.subVectors(n, e), _i.subVectors(t, e); const s = yi.dot(yi), o = yi.dot(xi), a = yi.dot(_i), l = xi.dot(xi), h = xi.dot(_i), c = s * l - o * o; if (0 === c) return r.set(-2, -1, -1); const u = 1 / c, d = (l * a - o * h) * u, p = (s * h - o * a) * u; return r.set(1 - d - p, p, d) } static containsPoint(t, e, n, i) { return this.getBarycoord(t, e, n, i, wi), wi.x >= 0 && wi.y >= 0 && wi.x + wi.y <= 1 } static getUV(t, e, n, i, r, s, o, a) { return this.getBarycoord(t, e, n, i, wi), a.set(0, 0), a.addScaledVector(r, wi.x), a.addScaledVector(s, wi.y), a.addScaledVector(o, wi.z), a } static isFrontFacing(t, e, n, i) { return yi.subVectors(n, e), xi.subVectors(t, e), yi.cross(xi).dot(i) < 0 } set(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this } setFromPointsAndIndices(t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this } setFromAttributeAndIndices(t, e, n, i) { return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this } getArea() { return yi.subVectors(this.c, this.b), xi.subVectors(this.a, this.b), .5 * yi.cross(xi).length() } getMidpoint(t) { return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(t) { return Ti.getNormal(this.a, this.b, this.c, t) } getPlane(t) { return t.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(t, e) { return Ti.getBarycoord(t, this.a, this.b, this.c, e) } getUV(t, e, n, i, r) { return Ti.getUV(t, this.a, this.b, this.c, e, n, i, r) } containsPoint(t) { return Ti.containsPoint(t, this.a, this.b, this.c) } isFrontFacing(t) { return Ti.isFrontFacing(this.a, this.b, this.c, t) } intersectsBox(t) { return t.intersectsTriangle(this) } closestPointToPoint(t, e) { const n = this.a, i = this.b, r = this.c; let s, o; Ei.subVectors(i, n), Ci.subVectors(r, n), Mi.subVectors(t, n); const a = Ei.dot(Mi), l = Ci.dot(Mi); if (a <= 0 && l <= 0) return e.copy(n); Pi.subVectors(t, i); const h = Ei.dot(Pi), c = Ci.dot(Pi); if (h >= 0 && c <= h) return e.copy(i); const u = a * c - h * l; if (u <= 0 && a >= 0 && h <= 0) return s = a / (a - h), e.copy(n).addScaledVector(Ei, s); Ii.subVectors(t, r); const d = Ei.dot(Ii), p = Ci.dot(Ii); if (p >= 0 && d <= p) return e.copy(r); const f = d * l - a * p; if (f <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(Ci, o); const m = h * p - d * c; if (m <= 0 && c - h >= 0 && d - p >= 0) return Si.subVectors(r, i), o = (c - h) / (c - h + (d - p)), e.copy(i).addScaledVector(Si, o); const g = 1 / (m + f + u); return s = f * g, o = u * g, e.copy(n).addScaledVector(Ei, s).addScaledVector(Ci, o) } equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } } let Di = 0; class Bi extends Ie { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Di++ }), this.uuid = Fe(), this.name = "", this.type = "Material", this.blending = A, this.side = p, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = B, this.blendDst = L, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Q, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ce, this.stencilZFail = Ce, this.stencilZPass = Ce, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(t) { this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(t) { if (void 0 !== t) for (const e in t) { const n = t[e]; if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } const i = this[e]; void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } } toJSON(t) { const e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function i(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== A && (n.blending = this.blending), this.side !== p && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) { const e = i(t.textures), r = i(t.images); e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r) } return n } clone() { return (new this.constructor).copy(this) } copy(t) { this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const e = t.clippingPlanes; let n = null; if (null !== e) { const t = e.length; n = new Array(t); for (let i = 0; i !== t; ++i)n[i] = e[i].clone() } return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(t) { !0 === t && this.version++ } } class Li extends Bi { constructor(t) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new on(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this } } const Fi = new An, ki = new He; class Ri { constructor(t, e, n = !1) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = Se, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(t) { !0 === t && this.version++ } setUsage(t) { return this.usage = t, this } copy(t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this } copyAt(t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++)this.array[t + i] = e.array[n + i]; return this } copyArray(t) { return this.array.set(t), this } applyMatrix3(t) { if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)ki.fromBufferAttribute(this, e), ki.applyMatrix3(t), this.setXY(e, ki.x, ki.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)Fi.fromBufferAttribute(this, e), Fi.applyMatrix3(t), this.setXYZ(e, Fi.x, Fi.y, Fi.z); return this } applyMatrix4(t) { for (let e = 0, n = this.count; e < n; e++)Fi.fromBufferAttribute(this, e), Fi.applyMatrix4(t), this.setXYZ(e, Fi.x, Fi.y, Fi.z); return this } applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++)Fi.fromBufferAttribute(this, e), Fi.applyNormalMatrix(t), this.setXYZ(e, Fi.x, Fi.y, Fi.z); return this } transformDirection(t) { for (let e = 0, n = this.count; e < n; e++)Fi.fromBufferAttribute(this, e), Fi.transformDirection(t), this.setXYZ(e, Fi.x, Fi.y, Fi.z); return this } set(t, e = 0) { return this.array.set(t, e), this } getX(t) { let e = this.array[t * this.itemSize]; return this.normalized && (e = Ve(e, this.array)), e } setX(t, e) { return this.normalized && (e = Qe(e, this.array)), this.array[t * this.itemSize] = e, this } getY(t) { let e = this.array[t * this.itemSize + 1]; return this.normalized && (e = Ve(e, this.array)), e } setY(t, e) { return this.normalized && (e = Qe(e, this.array)), this.array[t * this.itemSize + 1] = e, this } getZ(t) { let e = this.array[t * this.itemSize + 2]; return this.normalized && (e = Ve(e, this.array)), e } setZ(t, e) { return this.normalized && (e = Qe(e, this.array)), this.array[t * this.itemSize + 2] = e, this } getW(t) { let e = this.array[t * this.itemSize + 3]; return this.normalized && (e = Ve(e, this.array)), e } setW(t, e) { return this.normalized && (e = Qe(e, this.array)), this.array[t * this.itemSize + 3] = e, this } setXY(t, e, n) { return t *= this.itemSize, this.normalized && (e = Qe(e, this.array), n = Qe(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this } setXYZ(t, e, n, i) { return t *= this.itemSize, this.normalized && (e = Qe(e, this.array), n = Qe(n, this.array), i = Qe(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this } setXYZW(t, e, n, i, r) { return t *= this.itemSize, this.normalized && (e = Qe(e, this.array), n = Qe(n, this.array), i = Qe(i, this.array), r = Qe(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this } onUpload(t) { return this.onUploadCallback = t, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return "" !== this.name && (t.name = this.name), this.usage !== Se && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t } copyColorsArray() { console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.") } copyVector2sArray() { console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.") } copyVector3sArray() { console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.") } copyVector4sArray() { console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.") } } class Oi extends Ri { constructor(t, e, n) { super(new Uint16Array(t), e, n) } } class Ni extends Ri { constructor(t, e, n) { super(new Uint32Array(t), e, n) } } class Ui extends Ri { constructor(t, e, n) { super(new Float32Array(t), e, n) } } let zi = 0; const Vi = new Yn, Qi = new bi, Gi = new An, Hi = new xn, ji = new xn, Wi = new An; class qi extends Ie { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: zi++ }), this.uuid = Fe(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(t) { return Array.isArray(t) ? this.index = new (qe(t) ? Ni : Oi)(t, 1) : this.index = t, this } getAttribute(t) { return this.attributes[t] } setAttribute(t, e) { return this.attributes[t] = e, this } deleteAttribute(t) { return delete this.attributes[t], this } hasAttribute(t) { return void 0 !== this.attributes[t] } addGroup(t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(t, e) { this.drawRange.start = t, this.drawRange.count = e } applyMatrix4(t) { const e = this.attributes.position; void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const e = (new je).getNormalMatrix(t); n.applyNormalMatrix(e), n.needsUpdate = !0 } const i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(t) { return Vi.makeRotationFromQuaternion(t), this.applyMatrix4(Vi), this } rotateX(t) { return Vi.makeRotationX(t), this.applyMatrix4(Vi), this } rotateY(t) { return Vi.makeRotationY(t), this.applyMatrix4(Vi), this } rotateZ(t) { return Vi.makeRotationZ(t), this.applyMatrix4(Vi), this } translate(t, e, n) { return Vi.makeTranslation(t, e, n), this.applyMatrix4(Vi), this } scale(t, e, n) { return Vi.makeScale(t, e, n), this.applyMatrix4(Vi), this } lookAt(t) { return Qi.lookAt(t), Qi.updateMatrix(), this.applyMatrix4(Qi.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Gi).negate(), this.translate(Gi.x, Gi.y, Gi.z), this } setFromPoints(t) { const e = []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new Ui(e, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new xn); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new An(-1 / 0, -1 / 0, -1 / 0), new An(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; Hi.setFromBufferAttribute(n), this.morphTargetsRelative ? (Wi.addVectors(this.boundingBox.min, Hi.min), this.boundingBox.expandByPoint(Wi), Wi.addVectors(this.boundingBox.max, Hi.max), this.boundingBox.expandByPoint(Wi)) : (this.boundingBox.expandByPoint(Hi.min), this.boundingBox.expandByPoint(Hi.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new Un); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new An, 1 / 0); if (t) { const n = this.boundingSphere.center; if (Hi.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; ji.setFromBufferAttribute(n), this.morphTargetsRelative ? (Wi.addVectors(Hi.min, ji.min), Hi.expandByPoint(Wi), Wi.addVectors(Hi.max, ji.max), Hi.expandByPoint(Wi)) : (Hi.expandByPoint(ji.min), Hi.expandByPoint(ji.max)) } Hi.getCenter(n); let i = 0; for (let e = 0, r = t.count; e < r; e++)Wi.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Wi)); if (e) for (let r = 0, s = e.length; r < s; r++) { const s = e[r], o = this.morphTargetsRelative; for (let e = 0, r = s.count; e < r; e++)Wi.fromBufferAttribute(s, e), o && (Gi.fromBufferAttribute(t, e), Wi.add(Gi)), i = Math.max(i, n.distanceToSquared(Wi)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const t = this.index, e = this.attributes; if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = t.array, i = e.position.array, r = e.normal.array, s = e.uv.array, o = i.length / 3; !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ri(new Float32Array(4 * o), 4)); const a = this.getAttribute("tangent").array, l = [], h = []; for (let t = 0; t < o; t++)l[t] = new An, h[t] = new An; const c = new An, u = new An, d = new An, p = new He, f = new He, m = new He, g = new An, v = new An; function A(t, e, n) { c.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), f.fromArray(s, 2 * e), m.fromArray(s, 2 * n), u.sub(c), d.sub(c), f.sub(p), m.sub(p); const r = 1 / (f.x * m.y - m.x * f.y); isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), h[t].add(v), h[e].add(v), h[n].add(v)) } let b = this.groups; 0 === b.length && (b = [{ start: 0, count: n.length }]); for (let t = 0, e = b.length; t < e; ++t) { const e = b[t], i = e.start; for (let t = i, r = i + e.count; t < r; t += 3)A(n[t + 0], n[t + 1], n[t + 2]) } const y = new An, x = new An, _ = new An, w = new An; function E(t) { _.fromArray(r, 3 * t), w.copy(_); const e = l[t]; y.copy(e), y.sub(_.multiplyScalar(_.dot(e))).normalize(), x.crossVectors(w, e); const n = x.dot(h[t]) < 0 ? -1 : 1; a[4 * t] = y.x, a[4 * t + 1] = y.y, a[4 * t + 2] = y.z, a[4 * t + 3] = n } for (let t = 0, e = b.length; t < e; ++t) { const e = b[t], i = e.start; for (let t = i, r = i + e.count; t < r; t += 3)E(n[t + 0]), E(n[t + 1]), E(n[t + 2]) } } computeVertexNormals() { const t = this.index, e = this.getAttribute("position"); if (void 0 !== e) { let n = this.getAttribute("normal"); if (void 0 === n) n = new Ri(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++)n.setXYZ(t, 0, 0, 0); const i = new An, r = new An, s = new An, o = new An, a = new An, l = new An, h = new An, c = new An; if (t) for (let u = 0, d = t.count; u < d; u += 3) { const d = t.getX(u + 0), p = t.getX(u + 1), f = t.getX(u + 2); i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, f), h.subVectors(s, r), c.subVectors(i, r), h.cross(c), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), o.add(h), a.add(h), l.add(h), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z) } else for (let t = 0, o = e.count; t < o; t += 3)i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), h.subVectors(s, r), c.subVectors(i, r), h.cross(c), n.setXYZ(t + 0, h.x, h.y, h.z), n.setXYZ(t + 1, h.x, h.y, h.z), n.setXYZ(t + 2, h.x, h.y, h.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge() { return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this } normalizeNormals() { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++)Wi.fromBufferAttribute(t, e), Wi.normalize(), t.setXYZ(e, Wi.x, Wi.y, Wi.z) } toNonIndexed() { function t(t, e) { const n = t.array, i = t.itemSize, r = t.normalized, s = new n.constructor(e.length * i); let o = 0, a = 0; for (let r = 0, l = e.length; r < l; r++) { o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i; for (let t = 0; t < i; t++)s[a++] = n[o++] } return new Ri(s, i, r) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const e = new qi, n = this.index.array, i = this.attributes; for (const r in i) { const s = t(i[r], n); e.setAttribute(r, s) } const r = this.morphAttributes; for (const i in r) { const s = [], o = r[i]; for (let e = 0, i = o.length; e < i; e++) { const i = t(o[e], n); s.push(i) } e.morphAttributes[i] = s } e.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let t = 0, n = s.length; t < n; t++) { const n = s[t]; e.addGroup(n.start, n.count, n.materialIndex) } return e } toJSON() { const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } t.data = { attributes: {} }; const e = this.index; null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); const n = this.attributes; for (const e in n) { const i = n[e]; t.data.attributes[e] = i.toJSON(t.data) } const i = {}; let r = !1; for (const e in this.morphAttributes) { const n = this.morphAttributes[e], s = []; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; s.push(i.toJSON(t.data)) } s.length > 0 && (i[e] = s, r = !0) } r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s))); const o = this.boundingSphere; return null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t } clone() { return (new this.constructor).copy(this) } copy(t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const e = {}; this.name = t.name; const n = t.index; null !== n && this.setIndex(n.clone(e)); const i = t.attributes; for (const t in i) { const n = i[t]; this.setAttribute(t, n.clone(e)) } const r = t.morphAttributes; for (const t in r) { const n = [], i = r[t]; for (let t = 0, r = i.length; t < r; t++)n.push(i[t].clone(e)); this.morphAttributes[t] = n } this.morphTargetsRelative = t.morphTargetsRelative; const s = t.groups; for (let t = 0, e = s.length; t < e; t++) { const e = s[t]; this.addGroup(e.start, e.count, e.materialIndex) } const o = t.boundingBox; null !== o && (this.boundingBox = o.clone()); const a = t.boundingSphere; return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const Yi = new Yn, Xi = new qn, Ki = new Un, Ji = new An, Zi = new An, $i = new An, tr = new An, er = new An, nr = new He, ir = new He, rr = new He, sr = new An, or = new An; class ar extends bi { constructor(t = new qi, e = new Li) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t, e) { return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this } updateMorphTargets() { const t = this.geometry.morphAttributes, e = Object.keys(t); if (e.length > 0) { const n = t[e[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, e = n.length; t < e; t++) { const e = n[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t } } } } getVertexPosition(t, e) { const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, s = n.morphTargetsRelative; e.fromBufferAttribute(i, t); const o = this.morphTargetInfluences; if (r && o) { er.set(0, 0, 0); for (let n = 0, i = r.length; n < i; n++) { const i = o[n], a = r[n]; 0 !== i && (tr.fromBufferAttribute(a, t), s ? er.addScaledVector(tr, i) : er.addScaledVector(tr.sub(e), i)) } e.add(er) } return this.isSkinnedMesh && this.boneTransform(t, e), e } raycast(t, e) { const n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 === i) return; if (null === n.boundingSphere && n.computeBoundingSphere(), Ki.copy(n.boundingSphere), Ki.applyMatrix4(r), !1 === t.ray.intersectsSphere(Ki)) return; if (Yi.copy(r).invert(), Xi.copy(t.ray).applyMatrix4(Yi), null !== n.boundingBox && !1 === Xi.intersectsBox(n.boundingBox)) return; let s; const o = n.index, a = n.attributes.position, l = n.attributes.uv, h = n.attributes.uv2, c = n.groups, u = n.drawRange; if (null !== o) if (Array.isArray(i)) for (let n = 0, r = c.length; n < r; n++) { const r = c[n], a = i[r.materialIndex]; for (let n = Math.max(r.start, u.start), i = Math.min(o.count, Math.min(r.start + r.count, u.start + u.count)); n < i; n += 3) { const i = o.getX(n), c = o.getX(n + 1), u = o.getX(n + 2); s = lr(this, a, t, Xi, l, h, i, c, u), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s)) } } else { for (let n = Math.max(0, u.start), r = Math.min(o.count, u.start + u.count); n < r; n += 3) { const r = o.getX(n), a = o.getX(n + 1), c = o.getX(n + 2); s = lr(this, i, t, Xi, l, h, r, a, c), s && (s.faceIndex = Math.floor(n / 3), e.push(s)) } } else if (void 0 !== a) if (Array.isArray(i)) for (let n = 0, r = c.length; n < r; n++) { const r = c[n], o = i[r.materialIndex]; for (let n = Math.max(r.start, u.start), i = Math.min(a.count, Math.min(r.start + r.count, u.start + u.count)); n < i; n += 3) { s = lr(this, o, t, Xi, l, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s)) } } else { for (let n = Math.max(0, u.start), r = Math.min(a.count, u.start + u.count); n < r; n += 3) { s = lr(this, i, t, Xi, l, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s)) } } } } function lr(t, e, n, i, r, s, o, a, l) { t.getVertexPosition(o, Ji), t.getVertexPosition(a, Zi), t.getVertexPosition(l, $i); const h = function (t, e, n, i, r, s, o, a) { let l; if (l = e.side === f ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, e.side === p, a), null === l) return null; or.copy(a), or.applyMatrix4(t.matrixWorld); const h = n.ray.origin.distanceTo(or); return h < n.near || h > n.far ? null : { distance: h, point: or.clone(), object: t } }(t, e, n, i, Ji, Zi, $i, sr); if (h) { r && (nr.fromBufferAttribute(r, o), ir.fromBufferAttribute(r, a), rr.fromBufferAttribute(r, l), h.uv = Ti.getUV(sr, Ji, Zi, $i, nr, ir, rr, new He)), s && (nr.fromBufferAttribute(s, o), ir.fromBufferAttribute(s, a), rr.fromBufferAttribute(s, l), h.uv2 = Ti.getUV(sr, Ji, Zi, $i, nr, ir, rr, new He)); const t = { a: o, b: a, c: l, normal: new An, materialIndex: 0 }; Ti.getNormal(Ji, Zi, $i, t.normal), h.face = t } return h } class hr extends qi { constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: s }; const o = this; i = Math.floor(i), r = Math.floor(r), s = Math.floor(s); const a = [], l = [], h = [], c = []; let u = 0, d = 0; function p(t, e, n, i, r, s, p, f, m, g, v) { const A = s / m, b = p / g, y = s / 2, x = p / 2, _ = f / 2, w = m + 1, E = g + 1; let C = 0, S = 0; const M = new An; for (let s = 0; s < E; s++) { const o = s * b - x; for (let a = 0; a < w; a++) { const u = a * A - y; M[t] = u * i, M[e] = o * r, M[n] = _, l.push(M.x, M.y, M.z), M[t] = 0, M[e] = 0, M[n] = f > 0 ? 1 : -1, h.push(M.x, M.y, M.z), c.push(a / m), c.push(1 - s / g), C += 1 } } for (let t = 0; t < g; t++)for (let e = 0; e < m; e++) { const n = u + e + w * t, i = u + e + w * (t + 1), r = u + (e + 1) + w * (t + 1), s = u + (e + 1) + w * t; a.push(n, i, s), a.push(i, r, s), S += 6 } o.addGroup(d, S, v), d += S, u += C } p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Ui(l, 3)), this.setAttribute("normal", new Ui(h, 3)), this.setAttribute("uv", new Ui(c, 2)) } static fromJSON(t) { return new hr(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments) } } function cr(t) { const e = {}; for (const n in t) { e[n] = {}; for (const i in t[n]) { const r = t[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r } } return e } function ur(t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = cr(t[n]); for (const t in i) e[t] = i[t] } return e } function dr(t) { return null === t.getRenderTarget() && t.outputEncoding === be ? we : Ee } const pr = { clone: cr, merge: ur }; class fr extends Bi { constructor(t) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t) } copy(t) { return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = cr(t.uniforms), this.uniformsGroups = function (t) { const e = []; for (let n = 0; n < t.length; n++)e.push(t[n].clone()); return e }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this } toJSON(t) { const e = super.toJSON(t); e.glslVersion = this.glslVersion, e.uniforms = {}; for (const n in this.uniforms) { const i = this.uniforms[n].value; i && i.isTexture ? e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid } : i && i.isColor ? e.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? e.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? e.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? e.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? e.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? e.uniforms[n] = { type: "m4", value: i.toArray() } : e.uniforms[n] = { value: i } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; const n = {}; for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0); return Object.keys(n).length > 0 && (e.extensions = n), e } } class mr extends bi { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Yn, this.projectionMatrix = new Yn, this.projectionMatrixInverse = new Yn } copy(t, e) { return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this } getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() } updateMatrixWorld(t) { super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(t, e) { super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } class gr extends mr { constructor(t = 50, e = 1, n = .1, i = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(t, e) { return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this } setFocalLength(t) { const e = .5 * this.getFilmHeight() / t; this.fov = 2 * Le * Math.atan(e), this.updateProjectionMatrix() } getFocalLength() { const t = Math.tan(.5 * Be * this.fov); return .5 * this.getFilmHeight() / t } getEffectiveFOV() { return 2 * Le * Math.atan(Math.tan(.5 * Be * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(t, e, n, i, r, s) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const t = this.near; let e = t * Math.tan(.5 * Be * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, r = -.5 * i; const s = this.view; if (null !== this.view && this.view.enabled) { const t = s.fullWidth, o = s.fullHeight; r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o } const o = this.filmOffset; 0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(t) { const e = super.toJSON(t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } } const vr = -90; class Ar extends bi { constructor(t, e, n) { super(), this.type = "CubeCamera", this.renderTarget = n; const i = new gr(vr, 1, t, e); i.layers = this.layers, i.up.set(0, 1, 0), i.lookAt(1, 0, 0), this.add(i); const r = new gr(vr, 1, t, e); r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), this.add(r); const s = new gr(vr, 1, t, e); s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(0, 1, 0), this.add(s); const o = new gr(vr, 1, t, e); o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(0, -1, 0), this.add(o); const a = new gr(vr, 1, t, e); a.layers = this.layers, a.up.set(0, 1, 0), a.lookAt(0, 0, 1), this.add(a); const l = new gr(vr, 1, t, e); l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, -1), this.add(l) } update(t, e) { null === this.parent && this.updateMatrixWorld(); const n = this.renderTarget, [i, r, s, o, a, l] = this.children, h = t.getRenderTarget(), c = t.toneMapping, u = t.xr.enabled; t.toneMapping = K, t.xr.enabled = !1; const d = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = d, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.toneMapping = c, t.xr.enabled = u, n.texture.needsPMREMUpdate = !0 } } class br extends dn { constructor(t, e, n, i, r, s, o, a, l, h) { super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : nt, n, i, r, s, o, a, l, h), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(t) { this.image = t } } class yr extends fn { constructor(t = 1, e = {}) { super(t, t, e), this.isWebGLCubeRenderTarget = !0; const n = { width: t, height: t, depth: 1 }, i = [n, n, n, n, n, n]; this.texture = new br(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : pt } fromEquirectangularTexture(t, e) { this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; const n = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t" }, i = new hr(5, 5, 5), r = new fr({ name: "CubemapFromEquirect", uniforms: cr(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: f, blending: v }); r.uniforms.tEquirect.value = e; const s = new ar(i, r), o = e.minFilter; e.minFilter === mt && (e.minFilter = pt); return new Ar(1, 10, this).update(t, s), e.minFilter = o, s.geometry.dispose(), s.material.dispose(), this } clear(t, e, n, i) { const r = t.getRenderTarget(); for (let r = 0; r < 6; r++)t.setRenderTarget(this, r), t.clear(e, n, i); t.setRenderTarget(r) } } const xr = new An, _r = new An, wr = new je; class Er { constructor(t = new An(1, 0, 0), e = 0) { this.isPlane = !0, this.normal = t, this.constant = e } set(t, e) { return this.normal.copy(t), this.constant = e, this } setComponents(t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this } setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this } setFromCoplanarPoints(t, e, n) { const i = xr.subVectors(n, e).cross(_r.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(i, t), this } copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this } normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(t) { return this.normal.dot(t) + this.constant } distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius } projectPoint(t, e) { return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) } intersectLine(t, e) { const n = t.delta(xr), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null; const r = -(t.start.dot(this.normal) + this.constant) / i; return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start) } intersectsLine(t) { const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end); return e < 0 && n > 0 || n < 0 && e > 0 } intersectsBox(t) { return t.intersectsPlane(this) } intersectsSphere(t) { return t.intersectsPlane(this) } coplanarPoint(t) { return t.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(t, e) { const n = e || wr.getNormalMatrix(t), i = this.coplanarPoint(xr).applyMatrix4(t), r = this.normal.applyMatrix3(n).normalize(); return this.constant = -i.dot(r), this } translate(t) { return this.constant -= t.dot(this.normal), this } equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant } clone() { return (new this.constructor).copy(this) } } const Cr = new Un, Sr = new An; class Mr { constructor(t = new Er, e = new Er, n = new Er, i = new Er, r = new Er, s = new Er) { this.planes = [t, e, n, i, r, s] } set(t, e, n, i, r, s) { const o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this } copy(t) { const e = this.planes; for (let n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this } setFromProjectionMatrix(t) { const e = this.planes, n = t.elements, i = n[0], r = n[1], s = n[2], o = n[3], a = n[4], l = n[5], h = n[6], c = n[7], u = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14], A = n[15]; return e[0].setComponents(o - i, c - a, f - u, A - m).normalize(), e[1].setComponents(o + i, c + a, f + u, A + m).normalize(), e[2].setComponents(o + r, c + l, f + d, A + g).normalize(), e[3].setComponents(o - r, c - l, f - d, A - g).normalize(), e[4].setComponents(o - s, c - h, f - p, A - v).normalize(), e[5].setComponents(o + s, c + h, f + p, A + v).normalize(), this } intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), Cr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Cr) } intersectsSprite(t) { return Cr.center.set(0, 0, 0), Cr.radius = .7071067811865476, Cr.applyMatrix4(t.matrixWorld), this.intersectsSphere(Cr) } intersectsSphere(t) { const e = this.planes, n = t.center, i = -t.radius; for (let t = 0; t < 6; t++) { if (e[t].distanceToPoint(n) < i) return !1 } return !0 } intersectsBox(t) { const e = this.planes; for (let n = 0; n < 6; n++) { const i = e[n]; if (Sr.x = i.normal.x > 0 ? t.max.x : t.min.x, Sr.y = i.normal.y > 0 ? t.max.y : t.min.y, Sr.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Sr) < 0) return !1 } return !0 } containsPoint(t) { const e = this.planes; for (let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function Pr() { let t = null, e = !1, n = null, i = null; function r(e, s) { n(e, s), i = t.requestAnimationFrame(r) } return { start: function () { !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0) }, stop: function () { t.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function (t) { n = t }, setContext: function (e) { t = e } } } function Ir(t, e) { const n = e.isWebGL2, i = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), i.get(t) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); const n = i.get(e); n && (t.deleteBuffer(n.buffer), i.delete(e)) }, update: function (e, r) { if (e.isGLBufferAttribute) { const t = i.get(e); return void ((!t || t.version < e.version) && i.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) } e.isInterleavedBufferAttribute && (e = e.data); const s = i.get(e); void 0 === s ? i.set(e, function (e, i) { const r = e.array, s = e.usage, o = t.createBuffer(); let a; if (t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback(), r instanceof Float32Array) a = 5126; else if (r instanceof Uint16Array) if (e.isFloat16BufferAttribute) { if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); a = 5131 } else a = 5123; else if (r instanceof Int16Array) a = 5122; else if (r instanceof Uint32Array) a = 5125; else if (r instanceof Int32Array) a = 5124; else if (r instanceof Int8Array) a = 5120; else if (r instanceof Uint8Array) a = 5121; else { if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r); a = 5121 } return { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version } }(e, r)) : s.version < e.version && (!function (e, i, r) { const s = i.array, o = i.updateRange; t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1), i.onUploadCallback() }(s.buffer, e, r), s.version = e.version) } } } class Tr extends qi { constructor(t = 1, e = 1, n = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }; const r = t / 2, s = e / 2, o = Math.floor(n), a = Math.floor(i), l = o + 1, h = a + 1, c = t / o, u = e / a, d = [], p = [], f = [], m = []; for (let t = 0; t < h; t++) { const e = t * u - s; for (let n = 0; n < l; n++) { const i = n * c - r; p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - t / a) } } for (let t = 0; t < a; t++)for (let e = 0; e < o; e++) { const n = e + l * t, i = e + l * (t + 1), r = e + 1 + l * (t + 1), s = e + 1 + l * t; d.push(n, i, s), d.push(i, r, s) } this.setIndex(d), this.setAttribute("position", new Ui(p, 3)), this.setAttribute("normal", new Ui(f, 3)), this.setAttribute("uv", new Ui(m, 2)) } static fromJSON(t) { return new Tr(t.width, t.height, t.widthSegments, t.heightSegments) } } const Dr = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}" }, Br = { common: { diffuse: { value: new on(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new je }, uv2Transform: { value: new je }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new He(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new on(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new on(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new je } }, sprite: { diffuse: { value: new on(16777215) }, opacity: { value: 1 }, center: { value: new He(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new je } } }, Lr = { basic: { uniforms: ur([Br.common, Br.specularmap, Br.envmap, Br.aomap, Br.lightmap, Br.fog]), vertexShader: Dr.meshbasic_vert, fragmentShader: Dr.meshbasic_frag }, lambert: { uniforms: ur([Br.common, Br.specularmap, Br.envmap, Br.aomap, Br.lightmap, Br.emissivemap, Br.bumpmap, Br.normalmap, Br.displacementmap, Br.fog, Br.lights, { emissive: { value: new on(0) } }]), vertexShader: Dr.meshlambert_vert, fragmentShader: Dr.meshlambert_frag }, phong: { uniforms: ur([Br.common, Br.specularmap, Br.envmap, Br.aomap, Br.lightmap, Br.emissivemap, Br.bumpmap, Br.normalmap, Br.displacementmap, Br.fog, Br.lights, { emissive: { value: new on(0) }, specular: { value: new on(1118481) }, shininess: { value: 30 } }]), vertexShader: Dr.meshphong_vert, fragmentShader: Dr.meshphong_frag }, standard: { uniforms: ur([Br.common, Br.envmap, Br.aomap, Br.lightmap, Br.emissivemap, Br.bumpmap, Br.normalmap, Br.displacementmap, Br.roughnessmap, Br.metalnessmap, Br.fog, Br.lights, { emissive: { value: new on(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Dr.meshphysical_vert, fragmentShader: Dr.meshphysical_frag }, toon: { uniforms: ur([Br.common, Br.aomap, Br.lightmap, Br.emissivemap, Br.bumpmap, Br.normalmap, Br.displacementmap, Br.gradientmap, Br.fog, Br.lights, { emissive: { value: new on(0) } }]), vertexShader: Dr.meshtoon_vert, fragmentShader: Dr.meshtoon_frag }, matcap: { uniforms: ur([Br.common, Br.bumpmap, Br.normalmap, Br.displacementmap, Br.fog, { matcap: { value: null } }]), vertexShader: Dr.meshmatcap_vert, fragmentShader: Dr.meshmatcap_frag }, points: { uniforms: ur([Br.points, Br.fog]), vertexShader: Dr.points_vert, fragmentShader: Dr.points_frag }, dashed: { uniforms: ur([Br.common, Br.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Dr.linedashed_vert, fragmentShader: Dr.linedashed_frag }, depth: { uniforms: ur([Br.common, Br.displacementmap]), vertexShader: Dr.depth_vert, fragmentShader: Dr.depth_frag }, normal: { uniforms: ur([Br.common, Br.bumpmap, Br.normalmap, Br.displacementmap, { opacity: { value: 1 } }]), vertexShader: Dr.meshnormal_vert, fragmentShader: Dr.meshnormal_frag }, sprite: { uniforms: ur([Br.sprite, Br.fog]), vertexShader: Dr.sprite_vert, fragmentShader: Dr.sprite_frag }, background: { uniforms: { uvTransform: { value: new je }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Dr.background_vert, fragmentShader: Dr.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: Dr.backgroundCube_vert, fragmentShader: Dr.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Dr.cube_vert, fragmentShader: Dr.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Dr.equirect_vert, fragmentShader: Dr.equirect_frag }, distanceRGBA: { uniforms: ur([Br.common, Br.displacementmap, { referencePosition: { value: new An }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Dr.distanceRGBA_vert, fragmentShader: Dr.distanceRGBA_frag }, shadow: { uniforms: ur([Br.lights, Br.fog, { color: { value: new on(0) }, opacity: { value: 1 } }]), vertexShader: Dr.shadow_vert, fragmentShader: Dr.shadow_frag } }; Lr.physical = { uniforms: ur([Lr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new He(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new on(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new He }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new on(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new on(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Dr.meshphysical_vert, fragmentShader: Dr.meshphysical_frag }; const Fr = { r: 0, b: 0, g: 0 }; function kr(t, e, n, i, r, s, o) { const a = new on(0); let l, h, c = !0 === s ? 0 : 1, u = null, d = 0, m = null; function g(e, n) { e.getRGB(Fr, dr(t)), i.buffers.color.setClear(Fr.r, Fr.g, Fr.b, n, o) } return { getClearColor: function () { return a }, setClearColor: function (t, e = 1) { a.set(t), c = e, g(a, c) }, getClearAlpha: function () { return c }, setClearAlpha: function (t) { c = t, g(a, c) }, render: function (i, s) { let o = !1, v = !0 === s.isScene ? s.background : null; if (v && v.isTexture) { v = (s.backgroundBlurriness > 0 ? n : e).get(v) } const A = t.xr, b = A.getSession && A.getSession(); b && "additive" === b.environmentBlendMode && (v = null), null === v ? g(a, c) : v && v.isColor && (g(v, 1), o = !0), (t.autoClear || o) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), v && (v.isCubeTexture || v.mapping === ot) ? (void 0 === h && (h = new ar(new hr(1, 1, 1), new fr({ name: "BackgroundCubeMaterial", uniforms: cr(Lr.backgroundCube.uniforms), vertexShader: Lr.backgroundCube.vertexShader, fragmentShader: Lr.backgroundCube.fragmentShader, side: f, depthTest: !1, depthWrite: !1, fog: !1 })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function (t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(h.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(h)), h.material.uniforms.envMap.value = v, h.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = s.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = s.backgroundIntensity, h.material.toneMapped = v.encoding !== be, u === v && d === v.version && m === t.toneMapping || (h.material.needsUpdate = !0, u = v, d = v.version, m = t.toneMapping), h.layers.enableAll(), i.unshift(h, h.geometry, h.material, 0, 0, null)) : v && v.isTexture && (void 0 === l && (l = new ar(new Tr(2, 2), new fr({ name: "BackgroundMaterial", uniforms: cr(Lr.background.uniforms), vertexShader: Lr.background.vertexShader, fragmentShader: Lr.background.fragmentShader, side: p, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(l)), l.material.uniforms.t2D.value = v, l.material.uniforms.backgroundIntensity.value = s.backgroundIntensity, l.material.toneMapped = v.encoding !== be, !0 === v.matrixAutoUpdate && v.updateMatrix(), l.material.uniforms.uvTransform.value.copy(v.matrix), u === v && d === v.version && m === t.toneMapping || (l.material.needsUpdate = !0, u = v, d = v.version, m = t.toneMapping), l.layers.enableAll(), i.unshift(l, l.geometry, l.material, 0, 0, null)) } } } function Rr(t, e, n, i) { const r = t.getParameter(34921), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = i.isWebGL2 || null !== s, a = {}, l = p(null); let h = l, c = !1; function u(e) { return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e) } function d(e) { return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e) } function p(t) { const e = [], n = [], i = []; for (let t = 0; t < r; t++)e[t] = 0, n[t] = 0, i[t] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {}, index: null } } function f() { const t = h.newAttributes; for (let e = 0, n = t.length; e < n; e++)t[e] = 0 } function m(t) { g(t, 0) } function g(n, r) { const s = h.newAttributes, o = h.enabledAttributes, a = h.attributeDivisors; if (s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r) { (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r } } function v() { const e = h.newAttributes, n = h.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0) } function A(e, n, r, s, o, a) { !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a) } function b() { y(), c = !0, h !== l && (h = l, u(h.object)) } function y() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (r, l, d, b, y) { let x = !1; if (o) { const e = function (e, n, r) { const o = !0 === r.wireframe; let l = a[e.id]; void 0 === l && (l = {}, a[e.id] = l); let h = l[n.id]; void 0 === h && (h = {}, l[n.id] = h); let c = h[o]; void 0 === c && (c = p(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), h[o] = c); return c }(b, d, l); h !== e && (h = e, u(h.object)), x = function (t, e, n, i) { const r = h.attributes, s = e.attributes; let o = 0; const a = n.getAttributes(); for (const e in a) { if (a[e].location >= 0) { const n = r[e]; let i = s[e]; if (void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (i = t.instanceColor)), void 0 === n) return !0; if (n.attribute !== i) return !0; if (i && n.data !== i.data) return !0; o++ } } return h.attributesNum !== o || h.index !== i }(r, b, d, y), x && function (t, e, n, i) { const r = {}, s = e.attributes; let o = 0; const a = n.getAttributes(); for (const e in a) { if (a[e].location >= 0) { let n = s[e]; void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor)); const i = {}; i.attribute = n, n && n.data && (i.data = n.data), r[e] = i, o++ } } h.attributes = r, h.attributesNum = o, h.index = i }(r, b, d, y) } else { const t = !0 === l.wireframe; h.geometry === b.id && h.program === d.id && h.wireframe === t || (h.geometry = b.id, h.program = d.id, h.wireframe = t, x = !0) } null !== y && n.update(y, 34963), (x || c) && (c = !1, function (r, s, o, a) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return; f(); const l = a.attributes, h = o.getAttributes(), c = s.defaultAttributeValues; for (const e in h) { const i = h[e]; if (i.location >= 0) { let s = l[e]; if (void 0 === s && ("instanceMatrix" === e && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (s = r.instanceColor)), void 0 !== s) { const e = s.normalized, o = s.itemSize, l = n.get(s); if (void 0 === l) continue; const h = l.buffer, c = l.type, u = l.bytesPerElement; if (s.isInterleavedBufferAttribute) { const n = s.data, l = n.stride, d = s.offset; if (n.isInstancedInterleavedBuffer) { for (let t = 0; t < i.locationSize; t++)g(i.location + t, n.meshPerAttribute); !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count) } else for (let t = 0; t < i.locationSize; t++)m(i.location + t); t.bindBuffer(34962, h); for (let t = 0; t < i.locationSize; t++)A(i.location + t, o / i.locationSize, c, e, l * u, (d + o / i.locationSize * t) * u) } else { if (s.isInstancedBufferAttribute) { for (let t = 0; t < i.locationSize; t++)g(i.location + t, s.meshPerAttribute); !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count) } else for (let t = 0; t < i.locationSize; t++)m(i.location + t); t.bindBuffer(34962, h); for (let t = 0; t < i.locationSize; t++)A(i.location + t, o / i.locationSize, c, e, o * u, o / i.locationSize * t * u) } } else if (void 0 !== c) { const n = c[e]; if (void 0 !== n) switch (n.length) { case 2: t.vertexAttrib2fv(i.location, n); break; case 3: t.vertexAttrib3fv(i.location, n); break; case 4: t.vertexAttrib4fv(i.location, n); break; default: t.vertexAttrib1fv(i.location, n) } } } } v() }(r, l, d, b), null !== y && t.bindBuffer(34963, n.get(y).buffer)) }, reset: b, resetDefaultState: y, dispose: function () { b(); for (const t in a) { const e = a[t]; for (const t in e) { const n = e[t]; for (const t in n) d(n[t].object), delete n[t]; delete e[t] } delete a[t] } }, releaseStatesOfGeometry: function (t) { if (void 0 === a[t.id]) return; const e = a[t.id]; for (const t in e) { const n = e[t]; for (const t in n) d(n[t].object), delete n[t]; delete e[t] } delete a[t.id] }, releaseStatesOfProgram: function (t) { for (const e in a) { const n = a[e]; if (void 0 === n[t.id]) continue; const i = n[t.id]; for (const t in i) d(i[t].object), delete i[t]; delete n[t.id] } }, initAttributes: f, enableAttribute: m, disableUnusedAttributes: v } } function Or(t, e, n, i) { const r = i.isWebGL2; let s; this.setMode = function (t) { s = t }, this.render = function (e, i) { t.drawArrays(s, e, i), n.update(i, s, 1) }, this.renderInstances = function (i, o, a) { if (0 === a) return; let l, h; if (r) l = t, h = "drawArraysInstanced"; else if (l = e.get("ANGLE_instanced_arrays"), h = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[h](s, i, o, a), n.update(o, s, a) } } function Nr(t, e, n) { let i; function r(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let o = void 0 !== n.precision ? n.precision : "highp"; const a = r(o); a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a); const l = s || e.has("WEBGL_draw_buffers"), h = !0 === n.logarithmicDepthBuffer, c = t.getParameter(34930), u = t.getParameter(35660), d = t.getParameter(3379), p = t.getParameter(34076), f = t.getParameter(34921), m = t.getParameter(36347), g = t.getParameter(36348), v = t.getParameter(36349), A = u > 0, b = s || e.has("OES_texture_float"); return { isWebGL2: s, drawBuffers: l, getMaxAnisotropy: function () { if (void 0 !== i) return i; if (!0 === e.has("EXT_texture_filter_anisotropic")) { const n = e.get("EXT_texture_filter_anisotropic"); i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i }, getMaxPrecision: r, precision: o, logarithmicDepthBuffer: h, maxTextures: c, maxVertexTextures: u, maxTextureSize: d, maxCubemapSize: p, maxAttributes: f, maxVertexUniforms: m, maxVaryings: g, maxFragmentUniforms: v, vertexTextures: A, floatFragmentTextures: b, floatVertexTextures: A && b, maxSamples: s ? t.getParameter(36183) : 0 } } function Ur(t) { const e = this; let n = null, i = 0, r = !1, s = !1; const o = new Er, a = new je, l = { value: null, needsUpdate: !1 }; function h() { l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 } function c(t, n, i, r) { const s = null !== t ? t.length : 0; let h = null; if (0 !== s) { if (h = l.value, !0 !== r || null === h) { const e = i + 4 * s, r = n.matrixWorldInverse; a.getNormalMatrix(r), (null === h || h.length < e) && (h = new Float32Array(e)); for (let e = 0, n = i; e !== s; ++e, n += 4)o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(h, n), h[n + 3] = o.constant } l.value = h, l.needsUpdate = !0 } return e.numPlanes = s, e.numIntersection = 0, h } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, s) { const o = 0 !== t.length || e || 0 !== i || r; return r = e, n = c(t, s, 0), i = t.length, o }, this.beginShadows = function () { s = !0, c(null) }, this.endShadows = function () { s = !1, h() }, this.setState = function (e, o, a) { const u = e.clippingPlanes, d = e.clipIntersection, p = e.clipShadows, f = t.get(e); if (!r || null === u || 0 === u.length || s && !p) s ? c(null) : h(); else { const t = s ? 0 : i, e = 4 * t; let r = f.clippingState || null; l.value = r, r = c(u, o, e, a); for (let t = 0; t !== e; ++t)r[t] = n[t]; f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t } } } function zr(t) { let e = new WeakMap; function n(t, e) { return e === rt ? t.mapping = nt : e === st && (t.mapping = it), t } function i(t) { const n = t.target; n.removeEventListener("dispose", i); const r = e.get(n); void 0 !== r && (e.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture && !1 === r.isRenderTargetTexture) { const s = r.mapping; if (s === rt || s === st) { if (e.has(r)) { return n(e.get(r).texture, r.mapping) } { const s = r.image; if (s && s.height > 0) { const o = new yr(s.height / 2); return o.fromEquirectangularTexture(t, r), e.set(r, o), r.addEventListener("dispose", i), n(o.texture, r.mapping) } return null } } } return r }, dispose: function () { e = new WeakMap } } } class Vr extends mr { constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix() } copy(t, e) { return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this } setViewOffset(t, e, n, i, r, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let r = n - t, s = n + t, o = i + e, a = i - e; if (null !== this.view && this.view.enabled) { const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom; r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height } this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(t) { const e = super.toJSON(t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } } const Qr = 4, Gr = [.125, .215, .35, .446, .526, .582], Hr = 20, jr = new Vr, Wr = new on; let qr = null; const Yr = (1 + Math.sqrt(5)) / 2, Xr = 1 / Yr, Kr = [new An(1, 1, 1), new An(-1, 1, 1), new An(1, 1, -1), new An(-1, 1, -1), new An(0, Yr, Xr), new An(0, Yr, -Xr), new An(Xr, 0, Yr), new An(-Xr, 0, Yr), new An(Yr, Xr, 0), new An(-Yr, Xr, 0)]; class Jr { constructor(t) { this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(t, e = 0, n = .1, i = 100) { qr = this._renderer.getRenderTarget(), this._setSize(256); const r = this._allocateTargets(); return r.depthBuffer = !0, this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r } fromEquirectangular(t, e = null) { return this._fromTexture(t, e) } fromCubemap(t, e = null) { return this._fromTexture(t, e) } compileCubemapShader() { null === this._cubemapMaterial && (this._cubemapMaterial = es(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { null === this._equirectMaterial && (this._equirectMaterial = ts(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose() } _setSize(t) { this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(); for (let t = 0; t < this._lodPlanes.length; t++)this._lodPlanes[t].dispose() } _cleanup(t) { this._renderer.setRenderTarget(qr), t.scissorTest = !1, $r(t, 0, 0, t.width, t.height) } _fromTexture(t, e) { t.mapping === nt || t.mapping === it ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), qr = this._renderer.getRenderTarget(); const n = e || this._allocateTargets(); return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n } _allocateTargets() { const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = { magFilter: pt, minFilter: pt, generateMipmaps: !1, type: wt, format: It, encoding: Ae, depthBuffer: !1 }, i = Zr(t, e, n); if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t) { null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Zr(t, e, n); const { _lodMax: i } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (t) { const e = [], n = [], i = []; let r = t; const s = t - Qr + 1 + Gr.length; for (let o = 0; o < s; o++) { const s = Math.pow(2, r); n.push(s); let a = 1 / s; o > t - Qr ? a = Gr[o - t + Qr - 1] : 0 === o && (a = 0), i.push(a); const l = 1 / (s - 2), h = -l, c = 1 + l, u = [h, h, c, h, c, c, h, h, c, c, h, c], d = 6, p = 6, f = 3, m = 2, g = 1, v = new Float32Array(f * p * d), A = new Float32Array(m * p * d), b = new Float32Array(g * p * d); for (let t = 0; t < d; t++) { const e = t % 3 * 2 / 3 - 1, n = t > 2 ? 0 : -1, i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0]; v.set(i, f * p * t), A.set(u, m * p * t); const r = [t, t, t, t, t, t]; b.set(r, g * p * t) } const y = new qi; y.setAttribute("position", new Ri(v, f)), y.setAttribute("uv", new Ri(A, m)), y.setAttribute("faceIndex", new Ri(b, g)), e.push(y), r > Qr && r-- } return { lodPlanes: e, sizeLods: n, sigmas: i } }(i)), this._blurMaterial = function (t, e, n) { const i = new Float32Array(Hr), r = new An(0, 1, 0), s = new fr({ name: "SphericalGaussianBlur", defines: { n: Hr, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / n, CUBEUV_MAX_MIP: `${t}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: ns(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t", blending: v, depthTest: !1, depthWrite: !1 }); return s }(i, t, e) } return i } _compileMaterial(t) { const e = new ar(this._lodPlanes[0], t); this._renderer.compile(e, jr) } _sceneToCubeUV(t, e, n, i) { const r = new gr(90, 1, e, n), s = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], a = this._renderer, l = a.autoClear, h = a.toneMapping; a.getClearColor(Wr), a.toneMapping = K, a.autoClear = !1; const c = new Li({ name: "PMREM.Background", side: f, depthWrite: !1, depthTest: !1 }), u = new ar(new hr, c); let d = !1; const p = t.background; p ? p.isColor && (c.color.copy(p), t.background = null, d = !0) : (c.color.copy(Wr), d = !0); for (let e = 0; e < 6; e++) { const n = e % 3; 0 === n ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e])); const l = this._cubeSize; $r(i, n * l, e > 2 ? l : 0, l, l), a.setRenderTarget(i), d && a.render(u, r), a.render(t, r) } u.geometry.dispose(), u.material.dispose(), a.toneMapping = h, a.autoClear = l, t.background = p } _textureToCubeUV(t, e) { const n = this._renderer, i = t.mapping === nt || t.mapping === it; i ? (null === this._cubemapMaterial && (this._cubemapMaterial = es()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = ts()); const r = i ? this._cubemapMaterial : this._equirectMaterial, s = new ar(this._lodPlanes[0], r); r.uniforms.envMap.value = t; const o = this._cubeSize; $r(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(s, jr) } _applyPMREM(t) { const e = this._renderer, n = e.autoClear; e.autoClear = !1; for (let e = 1; e < this._lodPlanes.length; e++) { const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]), i = Kr[(e - 1) % Kr.length]; this._blur(t, e - 1, e, n, i) } e.autoClear = n } _blur(t, e, n, i, r) { const s = this._pingPongRenderTarget; this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r) } _halfBlur(t, e, n, i, r, s, o) { const a = this._renderer, l = this._blurMaterial; "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!"); const h = new ar(this._lodPlanes[i], l), c = l.uniforms, u = this._sizeLods[n] - 1, d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * Hr - 1), p = r / d, f = isFinite(r) ? 1 + Math.floor(3 * p) : Hr; f > Hr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${Hr}`); const m = []; let g = 0; for (let t = 0; t < Hr; ++t) { const e = t / p, n = Math.exp(-e * e / 2); m.push(n), 0 === t ? g += n : t < f && (g += 2 * n) } for (let t = 0; t < m.length; t++)m[t] = m[t] / g; c.envMap.value = t.texture, c.samples.value = f, c.weights.value = m, c.latitudinal.value = "latitudinal" === s, o && (c.poleAxis.value = o); const { _lodMax: v } = this; c.dTheta.value = d, c.mipInt.value = v - n; const A = this._sizeLods[i]; $r(e, 3 * A * (i > v - Qr ? i - v + Qr : 0), 4 * (this._cubeSize - A), 3 * A, 2 * A), a.setRenderTarget(e), a.render(h, jr) } } function Zr(t, e, n) { const i = new fn(t, e, n); return i.texture.mapping = ot, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i } function $r(t, e, n, i, r) { t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r) } function ts() { return new fr({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: ns(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t", blending: v, depthTest: !1, depthWrite: !1 }) } function es() { return new fr({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: ns(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t", blending: v, depthTest: !1, depthWrite: !1 }) } function ns() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function is(t) { let e = new WeakMap, n = null; function i(t) { const n = t.target; n.removeEventListener("dispose", i); const r = e.get(n); void 0 !== r && (e.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const s = r.mapping, o = s === rt || s === st, a = s === nt || s === it; if (o || a) { if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) { r.needsPMREMUpdate = !1; let i = e.get(r); return null === n && (n = new Jr(t)), i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture } if (e.has(r)) return e.get(r).texture; { const s = r.image; if (o && s && s.height > 0 || a && s && function (t) { let e = 0; const n = 6; for (let i = 0; i < n; i++)void 0 !== t[i] && e++; return e === n }(s)) { null === n && (n = new Jr(t)); const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r); return e.set(r, s), r.addEventListener("dispose", i), s.texture } return null } } } return r }, dispose: function () { e = new WeakMap, null !== n && (n.dispose(), n = null) } } } function rs(t) { const e = {}; function n(n) { if (void 0 !== e[n]) return e[n]; let i; switch (n) { case "WEBGL_depth_texture": i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = t.getExtension(n) }return e[n] = i, i } return { has: function (t) { return null !== n(t) }, init: function (t) { t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture") }, get: function (t) { const e = n(t); return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e } } } function ss(t, e, n, i) { const r = {}, s = new WeakMap; function o(t) { const a = t.target; null !== a.index && e.remove(a.index); for (const t in a.attributes) e.remove(a.attributes[t]); a.removeEventListener("dispose", o), delete r[a.id]; const l = s.get(a); l && (e.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries-- } function a(t) { const n = [], i = t.index, r = t.attributes.position; let o = 0; if (null !== i) { const t = i.array; o = i.version; for (let e = 0, i = t.length; e < i; e += 3) { const i = t[e + 0], r = t[e + 1], s = t[e + 2]; n.push(i, r, r, s, s, i) } } else { const t = r.array; o = r.version; for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) { const t = e + 0, i = e + 1, r = e + 2; n.push(t, i, i, r, r, t) } } const a = new (qe(n) ? Ni : Oi)(n, 1); a.version = o; const l = s.get(t); l && e.remove(l), s.set(t, a) } return { get: function (t, e) { return !0 === r[e.id] || (e.addEventListener("dispose", o), r[e.id] = !0, n.memory.geometries++), e }, update: function (t) { const n = t.attributes; for (const t in n) e.update(n[t], 34962); const i = t.morphAttributes; for (const t in i) { const n = i[t]; for (let t = 0, i = n.length; t < i; t++)e.update(n[t], 34962) } }, getWireframeAttribute: function (t) { const e = s.get(t); if (e) { const n = t.index; null !== n && e.version < n.version && a(t) } else a(t); return s.get(t) } } } function os(t, e, n, i) { const r = i.isWebGL2; let s, o, a; this.setMode = function (t) { s = t }, this.setIndex = function (t) { o = t.type, a = t.bytesPerElement }, this.render = function (e, i) { t.drawElements(s, i, o, e * a), n.update(i, s, 1) }, this.renderInstances = function (i, l, h) { if (0 === h) return; let c, u; if (r) c = t, u = "drawElementsInstanced"; else if (c = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); c[u](s, l, o, i * a, h), n.update(l, s, h) } } function as(t) { const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, n, i) { switch (e.calls++, n) { case 4: e.triangles += i * (t / 3); break; case 1: e.lines += i * (t / 2); break; case 3: e.lines += i * (t - 1); break; case 2: e.lines += i * t; break; case 0: e.points += i * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function ls(t, e) { return t[0] - e[0] } function hs(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function cs(t, e, n) { const i = {}, r = new Float32Array(8), s = new WeakMap, o = new pn, a = []; for (let t = 0; t < 8; t++)a[t] = [t, 0]; return { update: function (l, h, c, u) { const d = l.morphTargetInfluences; if (!0 === e.isWebGL2) { const p = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, f = void 0 !== p ? p.length : 0; let m = s.get(h); if (void 0 === m || m.count !== f) { void 0 !== m && m.texture.dispose(); const A = void 0 !== h.morphAttributes.position, b = void 0 !== h.morphAttributes.normal, y = void 0 !== h.morphAttributes.color, x = h.morphAttributes.position || [], _ = h.morphAttributes.normal || [], w = h.morphAttributes.color || []; let E = 0; !0 === A && (E = 1), !0 === b && (E = 2), !0 === y && (E = 3); let C = h.attributes.position.count * E, S = 1; C > e.maxTextureSize && (S = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize); const M = new Float32Array(C * S * 4 * f), P = new mn(M, C, S, f); P.type = _t, P.needsUpdate = !0; const I = 4 * E; for (let D = 0; D < f; D++) { const B = x[D], L = _[D], F = w[D], k = C * S * 4 * D; for (let R = 0; R < B.count; R++) { const O = R * I; !0 === A && (o.fromBufferAttribute(B, R), M[k + O + 0] = o.x, M[k + O + 1] = o.y, M[k + O + 2] = o.z, M[k + O + 3] = 0), !0 === b && (o.fromBufferAttribute(L, R), M[k + O + 4] = o.x, M[k + O + 5] = o.y, M[k + O + 6] = o.z, M[k + O + 7] = 0), !0 === y && (o.fromBufferAttribute(F, R), M[k + O + 8] = o.x, M[k + O + 9] = o.y, M[k + O + 10] = o.z, M[k + O + 11] = 4 === F.itemSize ? o.w : 1) } } function T() { P.dispose(), s.delete(h), h.removeEventListener("dispose", T) } m = { count: f, texture: P, size: new He(C, S) }, s.set(h, m), h.addEventListener("dispose", T) } let g = 0; for (let N = 0; N < d.length; N++)g += d[N]; const v = h.morphTargetsRelative ? 1 : 1 - g; u.getUniforms().setValue(t, "morphTargetBaseInfluence", v), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", m.size) } else { const U = void 0 === d ? 0 : d.length; let z = i[h.id]; if (void 0 === z || z.length !== U) { z = []; for (let j = 0; j < U; j++)z[j] = [j, 0]; i[h.id] = z } for (let W = 0; W < U; W++) { const q = z[W]; q[0] = W, q[1] = d[W] } z.sort(hs); for (let Y = 0; Y < 8; Y++)Y < U && z[Y][1] ? (a[Y][0] = z[Y][0], a[Y][1] = z[Y][1]) : (a[Y][0] = Number.MAX_SAFE_INTEGER, a[Y][1] = 0); a.sort(ls); const V = h.morphAttributes.position, Q = h.morphAttributes.normal; let G = 0; for (let X = 0; X < 8; X++) { const K = a[X], J = K[0], Z = K[1]; J !== Number.MAX_SAFE_INTEGER && Z ? (V && h.getAttribute("morphTarget" + X) !== V[J] && h.setAttribute("morphTarget" + X, V[J]), Q && h.getAttribute("morphNormal" + X) !== Q[J] && h.setAttribute("morphNormal" + X, Q[J]), r[X] = Z, G += Z) : (V && !0 === h.hasAttribute("morphTarget" + X) && h.deleteAttribute("morphTarget" + X), Q && !0 === h.hasAttribute("morphNormal" + X) && h.deleteAttribute("morphNormal" + X), r[X] = 0) } const H = h.morphTargetsRelative ? 1 : 1 - G; u.getUniforms().setValue(t, "morphTargetBaseInfluence", H), u.getUniforms().setValue(t, "morphTargetInfluences", r) } } } } function us(t, e, n, i) { let r = new WeakMap; function s(t) { const e = t.target; e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor) } return { update: function (t) { const o = i.render.frame, a = t.geometry, l = e.get(t, a); return r.get(l) !== o && (e.update(l), r.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l }, dispose: function () { r = new WeakMap } } } const ds = new dn, ps = new mn, fs = new gn, ms = new br, gs = [], vs = [], As = new Float32Array(16), bs = new Float32Array(9), ys = new Float32Array(4); function xs(t, e, n) { const i = t[0]; if (i <= 0 || i > 0) return t; const r = e * n; let s = gs[r]; if (void 0 === s && (s = new Float32Array(r), gs[r] = s), 0 !== e) { i.toArray(s, 0); for (let i = 1, r = 0; i !== e; ++i)r += n, t[i].toArray(s, r) } return s } function _s(t, e) { if (t.length !== e.length) return !1; for (let n = 0, i = t.length; n < i; n++)if (t[n] !== e[n]) return !1; return !0 } function ws(t, e) { for (let n = 0, i = e.length; n < i; n++)t[n] = e[n] } function Es(t, e) { let n = vs[e]; void 0 === n && (n = new Int32Array(e), vs[e] = n); for (let i = 0; i !== e; ++i)n[i] = t.allocateTextureUnit(); return n } function Cs(t, e) { const n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function Ss(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (_s(n, e)) return; t.uniform2fv(this.addr, e), ws(n, e) } } function Ms(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else { if (_s(n, e)) return; t.uniform3fv(this.addr, e), ws(n, e) } } function Ps(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (_s(n, e)) return; t.uniform4fv(this.addr, e), ws(n, e) } } function Is(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (_s(n, e)) return; t.uniformMatrix2fv(this.addr, !1, e), ws(n, e) } else { if (_s(n, i)) return; ys.set(i), t.uniformMatrix2fv(this.addr, !1, ys), ws(n, i) } } function Ts(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (_s(n, e)) return; t.uniformMatrix3fv(this.addr, !1, e), ws(n, e) } else { if (_s(n, i)) return; bs.set(i), t.uniformMatrix3fv(this.addr, !1, bs), ws(n, i) } } function Ds(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (_s(n, e)) return; t.uniformMatrix4fv(this.addr, !1, e), ws(n, e) } else { if (_s(n, i)) return; As.set(i), t.uniformMatrix4fv(this.addr, !1, As), ws(n, i) } } function Bs(t, e) { const n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function Ls(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (_s(n, e)) return; t.uniform2iv(this.addr, e), ws(n, e) } } function Fs(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else { if (_s(n, e)) return; t.uniform3iv(this.addr, e), ws(n, e) } } function ks(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (_s(n, e)) return; t.uniform4iv(this.addr, e), ws(n, e) } } function Rs(t, e) { const n = this.cache; n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e) } function Os(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (_s(n, e)) return; t.uniform2uiv(this.addr, e), ws(n, e) } } function Ns(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else { if (_s(n, e)) return; t.uniform3uiv(this.addr, e), ws(n, e) } } function Us(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (_s(n, e)) return; t.uniform4uiv(this.addr, e), ws(n, e) } } function zs(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(e || ds, r) } function Vs(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || fs, r) } function Qs(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || ms, r) } function Gs(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || ps, r) } function Hs(t, e) { t.uniform1fv(this.addr, e) } function js(t, e) { const n = xs(e, this.size, 2); t.uniform2fv(this.addr, n) } function Ws(t, e) { const n = xs(e, this.size, 3); t.uniform3fv(this.addr, n) } function qs(t, e) { const n = xs(e, this.size, 4); t.uniform4fv(this.addr, n) } function Ys(t, e) { const n = xs(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, n) } function Xs(t, e) { const n = xs(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, n) } function Ks(t, e) { const n = xs(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, n) } function Js(t, e) { t.uniform1iv(this.addr, e) } function Zs(t, e) { t.uniform2iv(this.addr, e) } function $s(t, e) { t.uniform3iv(this.addr, e) } function to(t, e) { t.uniform4iv(this.addr, e) } function eo(t, e) { t.uniform1uiv(this.addr, e) } function no(t, e) { t.uniform2uiv(this.addr, e) } function io(t, e) { t.uniform3uiv(this.addr, e) } function ro(t, e) { t.uniform4uiv(this.addr, e) } function so(t, e, n) { const i = this.cache, r = e.length, s = Es(n, r); _s(i, s) || (t.uniform1iv(this.addr, s), ws(i, s)); for (let t = 0; t !== r; ++t)n.setTexture2D(e[t] || ds, s[t]) } function oo(t, e, n) { const i = this.cache, r = e.length, s = Es(n, r); _s(i, s) || (t.uniform1iv(this.addr, s), ws(i, s)); for (let t = 0; t !== r; ++t)n.setTexture3D(e[t] || fs, s[t]) } function ao(t, e, n) { const i = this.cache, r = e.length, s = Es(n, r); _s(i, s) || (t.uniform1iv(this.addr, s), ws(i, s)); for (let t = 0; t !== r; ++t)n.setTextureCube(e[t] || ms, s[t]) } function lo(t, e, n) { const i = this.cache, r = e.length, s = Es(n, r); _s(i, s) || (t.uniform1iv(this.addr, s), ws(i, s)); for (let t = 0; t !== r; ++t)n.setTexture2DArray(e[t] || ps, s[t]) } class ho { constructor(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return Cs; case 35664: return Ss; case 35665: return Ms; case 35666: return Ps; case 35674: return Is; case 35675: return Ts; case 35676: return Ds; case 5124: case 35670: return Bs; case 35667: case 35671: return Ls; case 35668: case 35672: return Fs; case 35669: case 35673: return ks; case 5125: return Rs; case 36294: return Os; case 36295: return Ns; case 36296: return Us; case 35678: case 36198: case 36298: case 36306: case 35682: return zs; case 35679: case 36299: case 36307: return Vs; case 35680: case 36300: case 36308: case 36293: return Qs; case 36289: case 36303: case 36311: case 36292: return Gs } }(e.type) } } class co { constructor(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return Hs; case 35664: return js; case 35665: return Ws; case 35666: return qs; case 35674: return Ys; case 35675: return Xs; case 35676: return Ks; case 5124: case 35670: return Js; case 35667: case 35671: return Zs; case 35668: case 35672: return $s; case 35669: case 35673: return to; case 5125: return eo; case 36294: return no; case 36295: return io; case 36296: return ro; case 35678: case 36198: case 36298: case 36306: case 35682: return so; case 35679: case 36299: case 36307: return oo; case 35680: case 36300: case 36308: case 36293: return ao; case 36289: case 36303: case 36311: case 36292: return lo } }(e.type) } } class uo { constructor(t) { this.id = t, this.seq = [], this.map = {} } setValue(t, e, n) { const i = this.seq; for (let r = 0, s = i.length; r !== s; ++r) { const s = i[r]; s.setValue(t, e[s.id], n) } } } const po = /(\w+)(\])?(\[|\.)?/g; function fo(t, e) { t.seq.push(e), t.map[e.id] = e } function mo(t, e, n) { const i = t.name, r = i.length; for (po.lastIndex = 0; ;) { const s = po.exec(i), o = po.lastIndex; let a = s[1]; const l = "]" === s[2], h = s[3]; if (l && (a |= 0), void 0 === h || "[" === h && o + 2 === r) { fo(n, void 0 === h ? new ho(a, t, e) : new co(a, t, e)); break } { let t = n.map[a]; void 0 === t && (t = new uo(a), fo(n, t)), n = t } } } class go { constructor(t, e) { this.seq = [], this.map = {}; const n = t.getProgramParameter(e, 35718); for (let i = 0; i < n; ++i) { const n = t.getActiveUniform(e, i); mo(n, t.getUniformLocation(e, n.name), this) } } setValue(t, e, n, i) { const r = this.map[e]; void 0 !== r && r.setValue(t, n, i) } setOptional(t, e, n) { const i = e[n]; void 0 !== i && this.setValue(t, n, i) } static upload(t, e, n, i) { for (let r = 0, s = e.length; r !== s; ++r) { const s = e[r], o = n[s.id]; !1 !== o.needsUpdate && s.setValue(t, o.value, i) } } static seqWithValue(t, e) { const n = []; for (let i = 0, r = t.length; i !== r; ++i) { const r = t[i]; r.id in e && n.push(r) } return n } } function vo(t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), i } let Ao = 0; function bo(t, e, n) { const i = t.getShaderParameter(e, 35713), r = t.getShaderInfoLog(e).trim(); if (i && "" === r) return ""; const s = /ERROR: 0:(\d+)/.exec(r); if (s) { const i = parseInt(s[1]); return n.toUpperCase() + "\n\n" + r + "\n\n" + function (t, e) { const n = t.split("\n"), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, n.length); for (let t = r; t < s; t++) { const r = t + 1; i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`) } return i.join("\n") }(t.getShaderSource(e), i) } return r } function yo(t, e) { const n = function (t) { switch (t) { case Ae: return ["Linear", "( value )"]; case be: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"] } }(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function xo(t, e) { let n; switch (e) { case J: n = "Linear"; break; case Z: n = "Reinhard"; break; case $: n = "OptimizedCineon"; break; case tt: n = "ACESFilmic"; break; case et: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function _o(t) { return "" !== t } function wo(t, e) { const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function Eo(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const Co = /^[ \t]*#include +<([\w\d./]+)>/gm; function So(t) { return t.replace(Co, Mo) } function Mo(t, e) { const n = Dr[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return So(n) } const Po = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Io(t) { return t.replace(Po, To) } function To(t, e, n, i) { let r = ""; for (let t = parseInt(e); t < parseInt(n); t++)r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return r } function Do(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function Bo(t, e, n, i) { const r = t.getContext(), s = n.defines; let o = n.vertexShader, a = n.fragmentShader; const l = function (t) { let e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === c ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === u ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === d && (e = "SHADOWMAP_TYPE_VSM"), e }(n), h = function (t) { let e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case nt: case it: e = "ENVMAP_TYPE_CUBE"; break; case ot: e = "ENVMAP_TYPE_CUBE_UV" }return e }(n), p = function (t) { let e = "ENVMAP_MODE_REFLECTION"; t.envMap && t.envMapMode === it && (e = "ENVMAP_MODE_REFRACTION"); return e }(n), f = function (t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case q: e = "ENVMAP_BLENDING_MULTIPLY"; break; case Y: e = "ENVMAP_BLENDING_MIX"; break; case X: e = "ENVMAP_BLENDING_ADD" }return e }(n), m = function (t) { const e = t.envMapCubeUVHeight; if (null === e) return null; const n = Math.log2(e) - 2, i = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)), texelHeight: i, maxMip: n } }(n), g = n.isWebGL2 ? "" : function (t) { return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(_o).join("\n") }(n), v = function (t) { const e = []; for (const n in t) { const i = t[n]; !1 !== i && e.push("#define " + n + " " + i) } return e.join("\n") }(s), A = r.createProgram(); let b, y, x = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? (b = [v].filter(_o).join("\n"), b.length > 0 && (b += "\n"), y = [g, v].filter(_o).join("\n"), y.length > 0 && (y += "\n")) : (b = [Do(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(_o).join("\n"), y = [g, Do(n), "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + f : "", m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "", m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "", m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== K ? "#define TONE_MAPPING" : "", n.toneMapping !== K ? Dr.tonemapping_pars_fragment : "", n.toneMapping !== K ? xo("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Dr.encodings_pars_fragment, yo("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(_o).join("\n")), o = So(o), o = wo(o, n), o = Eo(o, n), a = So(a), a = wo(a, n), a = Eo(a, n), o = Io(o), a = Io(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (x = "#version 300 es\n", b = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + b, y = ["#define varying in", n.glslVersion === Me ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Me ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y); const _ = x + y + a, w = vo(r, 35633, x + b + o), E = vo(r, 35632, _); if (r.attachShader(A, w), r.attachShader(A, E), void 0 !== n.index0AttributeName ? r.bindAttribLocation(A, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(A, 0, "position"), r.linkProgram(A), t.debug.checkShaderErrors) { const t = r.getProgramInfoLog(A).trim(), e = r.getShaderInfoLog(w).trim(), n = r.getShaderInfoLog(E).trim(); let i = !0, s = !0; if (!1 === r.getProgramParameter(A, 35714)) { i = !1; const e = bo(r, w, "vertex"), n = bo(r, E, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(A, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n) } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1); s && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: b }, fragmentShader: { log: n, prefix: y } }) } let C, S; return r.deleteShader(w), r.deleteShader(E), this.getUniforms = function () { return void 0 === C && (C = new go(r, A)), C }, this.getAttributes = function () { return void 0 === S && (S = function (t, e) { const n = {}, i = t.getProgramParameter(e, 35721); for (let r = 0; r < i; r++) { const i = t.getActiveAttrib(e, r), s = i.name; let o = 1; 35674 === i.type && (o = 2), 35675 === i.type && (o = 3), 35676 === i.type && (o = 4), n[s] = { type: i.type, location: t.getAttribLocation(e, s), locationSize: o } } return n }(r, A)), S }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(A), this.program = void 0 }, this.name = n.shaderName, this.id = Ao++, this.cacheKey = e, this.usedTimes = 1, this.program = A, this.vertexShader = w, this.fragmentShader = E, this } let Lo = 0; class Fo { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(t) { const e = t.vertexShader, n = t.fragmentShader, i = this._getShaderStage(e), r = this._getShaderStage(n), s = this._getShaderCacheForMaterial(t); return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this } remove(t) { const e = this.materialCache.get(t); for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code); return this.materialCache.delete(t), this } getVertexShaderID(t) { return this._getShaderStage(t.vertexShader).id } getFragmentShaderID(t) { return this._getShaderStage(t.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(t) { const e = this.materialCache; let n = e.get(t); return void 0 === n && (n = new Set, e.set(t, n)), n } _getShaderStage(t) { const e = this.shaderCache; let n = e.get(t); return void 0 === n && (n = new ko(t), e.set(t, n)), n } } class ko { constructor(t) { this.id = Lo++, this.code = t, this.usedTimes = 0 } } function Ro(t, e, n, i, r, s, o) { const a = new si, l = new Fo, h = [], c = r.isWebGL2, u = r.logarithmicDepthBuffer, d = r.vertexTextures; let p = r.precision; const g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; return { getParameters: function (s, a, h, v, b) { const y = v.fog, x = b.geometry, _ = s.isMeshStandardMaterial ? v.environment : null, w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || _), E = w && w.mapping === ot ? w.image.height : null, C = g[s.type]; null !== s.precision && (p = r.getMaxPrecision(s.precision), p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead.")); const S = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color, M = void 0 !== S ? S.length : 0; let P, I, T, D, B = 0; if (void 0 !== x.morphAttributes.position && (B = 1), void 0 !== x.morphAttributes.normal && (B = 2), void 0 !== x.morphAttributes.color && (B = 3), C) { const t = Lr[C]; P = t.vertexShader, I = t.fragmentShader } else P = s.vertexShader, I = s.fragmentShader, l.update(s), T = l.getVertexShaderID(s), D = l.getFragmentShaderID(s); const L = t.getRenderTarget(), F = s.alphaTest > 0, k = s.clearcoat > 0, R = s.iridescence > 0; return { isWebGL2: c, shaderID: C, shaderName: s.type, vertexShader: P, fragmentShader: I, defines: s.defines, customVertexShaderID: T, customFragmentShaderID: D, isRawShaderMaterial: !0 === s.isRawShaderMaterial, glslVersion: s.glslVersion, precision: p, instancing: !0 === b.isInstancedMesh, instancingColor: !0 === b.isInstancedMesh && null !== b.instanceColor, supportsVertexTextures: d, outputEncoding: null === L ? t.outputEncoding : !0 === L.isXRRenderTarget ? L.texture.encoding : Ae, map: !!s.map, matcap: !!s.matcap, envMap: !!w, envMapMode: w && w.mapping, envMapCubeUVHeight: E, lightMap: !!s.lightMap, aoMap: !!s.aoMap, emissiveMap: !!s.emissiveMap, bumpMap: !!s.bumpMap, normalMap: !!s.normalMap, objectSpaceNormalMap: s.normalMapType === _e, tangentSpaceNormalMap: s.normalMapType === xe, decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === be, clearcoat: k, clearcoatMap: k && !!s.clearcoatMap, clearcoatRoughnessMap: k && !!s.clearcoatRoughnessMap, clearcoatNormalMap: k && !!s.clearcoatNormalMap, iridescence: R, iridescenceMap: R && !!s.iridescenceMap, iridescenceThicknessMap: R && !!s.iridescenceThicknessMap, displacementMap: !!s.displacementMap, roughnessMap: !!s.roughnessMap, metalnessMap: !!s.metalnessMap, specularMap: !!s.specularMap, specularIntensityMap: !!s.specularIntensityMap, specularColorMap: !!s.specularColorMap, opaque: !1 === s.transparent && s.blending === A, alphaMap: !!s.alphaMap, alphaTest: F, gradientMap: !!s.gradientMap, sheen: s.sheen > 0, sheenColorMap: !!s.sheenColorMap, sheenRoughnessMap: !!s.sheenRoughnessMap, transmission: s.transmission > 0, transmissionMap: !!s.transmissionMap, thicknessMap: !!s.thicknessMap, combine: s.combine, vertexTangents: !!s.normalMap && !!x.attributes.tangent, vertexColors: s.vertexColors, vertexAlphas: !0 === s.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize, vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap), uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap), fog: !!y, useFog: !0 === s.fog, fogExp2: y && y.isFogExp2, flatShading: !!s.flatShading, sizeAttenuation: s.sizeAttenuation, logarithmicDepthBuffer: u, skinning: !0 === b.isSkinnedMesh, morphTargets: void 0 !== x.morphAttributes.position, morphNormals: void 0 !== x.morphAttributes.normal, morphColors: void 0 !== x.morphAttributes.color, morphTargetsCount: M, morphTextureStride: B, numDirLights: a.directional.length, numPointLights: a.point.length, numSpotLights: a.spot.length, numSpotLightMaps: a.spotLightMap.length, numRectAreaLights: a.rectArea.length, numHemiLights: a.hemi.length, numDirLightShadows: a.directionalShadowMap.length, numPointLightShadows: a.pointShadowMap.length, numSpotLightShadows: a.spotShadowMap.length, numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: s.dithering, shadowMapEnabled: t.shadowMap.enabled && h.length > 0, shadowMapType: t.shadowMap.type, toneMapping: s.toneMapped ? t.toneMapping : K, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: s.premultipliedAlpha, doubleSided: s.side === m, flipSided: s.side === f, useDepthPacking: !!s.depthPacking, depthPacking: s.depthPacking || 0, index0AttributeName: s.index0AttributeName, extensionDerivatives: s.extensions && s.extensions.derivatives, extensionFragDepth: s.extensions && s.extensions.fragDepth, extensionDrawBuffers: s.extensions && s.extensions.drawBuffers, extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD, rendererExtensionFragDepth: c || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: c || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: c || i.has("EXT_shader_texture_lod"), customProgramCacheKey: s.customProgramCacheKey() } }, getProgramCacheKey: function (e) { const n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]); return !1 === e.isRawShaderMaterial && (!function (t, e) { t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking) }(n, e), function (t, e) { a.disableAll(), e.isWebGL2 && a.enable(0); e.supportsVertexTextures && a.enable(1); e.instancing && a.enable(2); e.instancingColor && a.enable(3); e.map && a.enable(4); e.matcap && a.enable(5); e.envMap && a.enable(6); e.lightMap && a.enable(7); e.aoMap && a.enable(8); e.emissiveMap && a.enable(9); e.bumpMap && a.enable(10); e.normalMap && a.enable(11); e.objectSpaceNormalMap && a.enable(12); e.tangentSpaceNormalMap && a.enable(13); e.clearcoat && a.enable(14); e.clearcoatMap && a.enable(15); e.clearcoatRoughnessMap && a.enable(16); e.clearcoatNormalMap && a.enable(17); e.iridescence && a.enable(18); e.iridescenceMap && a.enable(19); e.iridescenceThicknessMap && a.enable(20); e.displacementMap && a.enable(21); e.specularMap && a.enable(22); e.roughnessMap && a.enable(23); e.metalnessMap && a.enable(24); e.gradientMap && a.enable(25); e.alphaMap && a.enable(26); e.alphaTest && a.enable(27); e.vertexColors && a.enable(28); e.vertexAlphas && a.enable(29); e.vertexUvs && a.enable(30); e.vertexTangents && a.enable(31); e.uvsVertexOnly && a.enable(32); t.push(a.mask), a.disableAll(), e.fog && a.enable(0); e.useFog && a.enable(1); e.flatShading && a.enable(2); e.logarithmicDepthBuffer && a.enable(3); e.skinning && a.enable(4); e.morphTargets && a.enable(5); e.morphNormals && a.enable(6); e.morphColors && a.enable(7); e.premultipliedAlpha && a.enable(8); e.shadowMapEnabled && a.enable(9); e.physicallyCorrectLights && a.enable(10); e.doubleSided && a.enable(11); e.flipSided && a.enable(12); e.useDepthPacking && a.enable(13); e.dithering && a.enable(14); e.specularIntensityMap && a.enable(15); e.specularColorMap && a.enable(16); e.transmission && a.enable(17); e.transmissionMap && a.enable(18); e.thicknessMap && a.enable(19); e.sheen && a.enable(20); e.sheenColorMap && a.enable(21); e.sheenRoughnessMap && a.enable(22); e.decodeVideoTexture && a.enable(23); e.opaque && a.enable(24); t.push(a.mask) }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join() }, getUniforms: function (t) { const e = g[t.type]; let n; if (e) { const t = Lr[e]; n = pr.clone(t.uniforms) } else n = t.uniforms; return n }, acquireProgram: function (e, n) { let i; for (let t = 0, e = h.length; t < e; t++) { const e = h[t]; if (e.cacheKey === n) { i = e, ++i.usedTimes; break } } return void 0 === i && (i = new Bo(t, n, e, s), h.push(i)), i }, releaseProgram: function (t) { if (0 == --t.usedTimes) { const e = h.indexOf(t); h[e] = h[h.length - 1], h.pop(), t.destroy() } }, releaseShaderCache: function (t) { l.remove(t) }, programs: h, dispose: function () { l.dispose() } } } function Oo() { let t = new WeakMap; return { get: function (e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function (e) { t.delete(e) }, update: function (e, n, i) { t.get(e)[n] = i }, dispose: function () { t = new WeakMap } } } function No(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function Uo(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function zo() { const t = []; let e = 0; const n = [], i = [], r = []; function s(n, i, r, s, o, a) { let l = t[e]; return void 0 === l ? (l = { id: n.id, object: n, geometry: i, material: r, groupOrder: s, renderOrder: n.renderOrder, z: o, group: a }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = o, l.group = a), e++, l } return { opaque: n, transmissive: i, transparent: r, init: function () { e = 0, n.length = 0, i.length = 0, r.length = 0 }, push: function (t, e, o, a, l, h) { const c = s(t, e, o, a, l, h); o.transmission > 0 ? i.push(c) : !0 === o.transparent ? r.push(c) : n.push(c) }, unshift: function (t, e, o, a, l, h) { const c = s(t, e, o, a, l, h); o.transmission > 0 ? i.unshift(c) : !0 === o.transparent ? r.unshift(c) : n.unshift(c) }, finish: function () { for (let n = e, i = t.length; n < i; n++) { const e = t[n]; if (null === e.id) break; e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null } }, sort: function (t, e) { n.length > 1 && n.sort(t || No), i.length > 1 && i.sort(e || Uo), r.length > 1 && r.sort(e || Uo) } } } function Vo() { let t = new WeakMap; return { get: function (e, n) { const i = t.get(e); let r; return void 0 === i ? (r = new zo, t.set(e, [r])) : n >= i.length ? (r = new zo, i.push(r)) : r = i[n], r }, dispose: function () { t = new WeakMap } } } function Qo() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { direction: new An, color: new on }; break; case "SpotLight": n = { position: new An, direction: new An, color: new on, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new An, color: new on, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new An, skyColor: new on, groundColor: new on }; break; case "RectAreaLight": n = { color: new on, position: new An, halfWidth: new An, halfHeight: new An } }return t[e.id] = n, n } } } let Go = 0; function Ho(t, e) { return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0) } function jo(t, e) { const n = new Qo, i = function () { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new He }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new He, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return t[e.id] = n, n } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 }; for (let t = 0; t < 9; t++)r.probe.push(new An); const s = new An, o = new Yn, a = new Yn; return { setup: function (s, o) { let a = 0, l = 0, h = 0; for (let t = 0; t < 9; t++)r.probe[t].set(0, 0, 0); let c = 0, u = 0, d = 0, p = 0, f = 0, m = 0, g = 0, v = 0, A = 0, b = 0; s.sort(Ho); const y = !0 !== o ? Math.PI : 1; for (let t = 0, e = s.length; t < e; t++) { const e = s[t], o = e.color, x = e.intensity, _ = e.distance, w = e.shadow && e.shadow.map ? e.shadow.map.texture : null; if (e.isAmbientLight) a += o.r * x * y, l += o.g * x * y, h += o.b * x * y; else if (e.isLightProbe) for (let t = 0; t < 9; t++)r.probe[t].addScaledVector(e.sh.coefficients[t], x); else if (e.isDirectionalLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity * y), e.castShadow) { const t = e.shadow, n = i.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = w, r.directionalShadowMatrix[c] = e.shadow.matrix, m++ } r.directional[c] = t, c++ } else if (e.isSpotLight) { const t = n.get(e); t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(o).multiplyScalar(x * y), t.distance = _, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, r.spot[d] = t; const s = e.shadow; if (e.map && (r.spotLightMap[A] = e.map, A++, s.updateMatrices(e), e.castShadow && b++), r.spotLightMatrix[d] = s.matrix, e.castShadow) { const t = i.get(e); t.shadowBias = s.bias, t.shadowNormalBias = s.normalBias, t.shadowRadius = s.radius, t.shadowMapSize = s.mapSize, r.spotShadow[d] = t, r.spotShadowMap[d] = w, v++ } d++ } else if (e.isRectAreaLight) { const t = n.get(e); t.color.copy(o).multiplyScalar(x), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[p] = t, p++ } else if (e.isPointLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity * y), t.distance = e.distance, t.decay = e.decay, e.castShadow) { const t = e.shadow, n = i.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = w, r.pointShadowMatrix[u] = e.shadow.matrix, g++ } r.point[u] = t, u++ } else if (e.isHemisphereLight) { const t = n.get(e); t.skyColor.copy(e.color).multiplyScalar(x * y), t.groundColor.copy(e.groundColor).multiplyScalar(x * y), r.hemi[f] = t, f++ } } p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Br.LTC_FLOAT_1, r.rectAreaLTC2 = Br.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Br.LTC_HALF_1, r.rectAreaLTC2 = Br.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a, r.ambient[1] = l, r.ambient[2] = h; const x = r.hash; x.directionalLength === c && x.pointLength === u && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v && x.numSpotMaps === A || (r.directional.length = c, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = v + A - b, r.spotLightMap.length = A, r.numSpotLightShadowsWithMaps = b, x.directionalLength = c, x.pointLength = u, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = f, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = v, x.numSpotMaps = A, r.version = Go++) }, setupView: function (t, e) { let n = 0, i = 0, l = 0, h = 0, c = 0; const u = e.matrixWorldInverse; for (let e = 0, d = t.length; e < d; e++) { const d = t[e]; if (d.isDirectionalLight) { const t = r.directional[n]; t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), n++ } else if (d.isSpotLight) { const t = r.spot[l]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++ } else if (d.isRectAreaLight) { const t = r.rectArea[h]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), a.identity(), o.copy(d.matrixWorld), o.premultiply(u), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), h++ } else if (d.isPointLight) { const t = r.point[i]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++ } else if (d.isHemisphereLight) { const t = r.hemi[c]; t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), c++ } } }, state: r } } function Wo(t, e) { const n = new jo(t, e), i = [], r = []; return { init: function () { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function (t) { n.setup(i, t) }, setupLightsView: function (t) { n.setupView(i, t) }, pushLight: function (t) { i.push(t) }, pushShadow: function (t) { r.push(t) } } } function qo(t, e) { let n = new WeakMap; return { get: function (i, r = 0) { const s = n.get(i); let o; return void 0 === s ? (o = new Wo(t, e), n.set(i, [o])) : r >= s.length ? (o = new Wo(t, e), s.push(o)) : o = s[r], o }, dispose: function () { n = new WeakMap } } } class Yo extends Bi { constructor(t) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t) } copy(t) { return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this } } class Xo extends Bi { constructor(t) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new An, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t) } copy(t) { return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this } } const Ko = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", Jo = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"; function Zo(t, e, n) { let i = new Mr; const r = new He, s = new He, o = new pn, a = new Yo({ depthPacking: ye }), l = new Xo, h = {}, u = n.maxTextureSize, g = { 0: f, 1: p, 2: m }, A = new fr({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new He }, radius: { value: 4 } }, vertexShader: Ko, fragmentShader: Jo }), b = A.clone(); b.defines.HORIZONTAL_PASS = 1; const y = new qi; y.setAttribute("position", new Ri(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const x = new ar(y, A), _ = this; function w(n, i) { const s = e.update(x); A.defines.VSM_SAMPLES !== n.blurSamples && (A.defines.VSM_SAMPLES = n.blurSamples, b.defines.VSM_SAMPLES = n.blurSamples, A.needsUpdate = !0, b.needsUpdate = !0), null === n.mapPass && (n.mapPass = new fn(r.x, r.y)), A.uniforms.shadow_pass.value = n.map.texture, A.uniforms.resolution.value = n.mapSize, A.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, s, A, x, null), b.uniforms.shadow_pass.value = n.mapPass.texture, b.uniforms.resolution.value = n.mapSize, b.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, s, b, x, null) } function E(e, n, i, r, s, o) { let c = null; const u = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial; if (void 0 !== u) c = u; else if (c = !0 === i.isPointLight ? l : a, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) { const t = c.uuid, e = n.uuid; let i = h[t]; void 0 === i && (i = {}, h[t] = i); let r = i[e]; void 0 === r && (r = c.clone(), i[e] = r), c = r } return c.visible = n.visible, c.wireframe = n.wireframe, c.side = o === d ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : g[n.side], c.alphaMap = n.alphaMap, c.alphaTest = n.alphaTest, c.map = n.map, c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.displacementMap = n.displacementMap, c.displacementScale = n.displacementScale, c.displacementBias = n.displacementBias, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), c.nearDistance = r, c.farDistance = s), c } function C(n, r, s, o, a) { if (!1 === n.visible) return; if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === d) && (!n.frustumCulled || i.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld); const i = e.update(n), r = n.material; if (Array.isArray(r)) { const e = i.groups; for (let l = 0, h = e.length; l < h; l++) { const h = e[l], c = r[h.materialIndex]; if (c && c.visible) { const e = E(n, c, o, s.near, s.far, a); t.renderBufferDirect(s, null, i, e, n, h) } } } else if (r.visible) { const e = E(n, r, o, s.near, s.far, a); t.renderBufferDirect(s, null, i, e, n, null) } } const l = n.children; for (let t = 0, e = l.length; t < e; t++)C(l[t], r, s, o, a) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = c, this.render = function (e, n, a) { if (!1 === _.enabled) return; if (!1 === _.autoUpdate && !1 === _.needsUpdate) return; if (0 === e.length) return; const l = t.getRenderTarget(), h = t.getActiveCubeFace(), c = t.getActiveMipmapLevel(), p = t.state; p.setBlending(v), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1); for (let l = 0, h = e.length; l < h; l++) { const h = e[l], c = h.shadow; if (void 0 === c) { console.warn("THREE.WebGLShadowMap:", h, "has no shadow."); continue } if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue; r.copy(c.mapSize); const f = c.getFrameExtents(); if (r.multiply(f), s.copy(c.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / f.x), r.x = s.x * f.x, c.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / f.y), r.y = s.y * f.y, c.mapSize.y = s.y)), null === c.map) { const t = this.type !== d ? { minFilter: ct, magFilter: ct } : {}; c.map = new fn(r.x, r.y, t), c.map.texture.name = h.name + ".shadowMap", c.camera.updateProjectionMatrix() } t.setRenderTarget(c.map), t.clear(); const m = c.getViewportCount(); for (let t = 0; t < m; t++) { const e = c.getViewport(t); o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), p.viewport(o), c.updateMatrices(h, t), i = c.getFrustum(), C(n, a, c.camera, h, this.type) } !0 !== c.isPointLightShadow && this.type === d && w(c, a), c.needsUpdate = !1 } _.needsUpdate = !1, t.setRenderTarget(l, h, c) } } function $o(t, e, n) { const i = n.isWebGL2; const r = new function () { let e = !1; const n = new pn; let i = null; const r = new pn(0, 0, 0, 0); return { setMask: function (n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function (t) { e = t }, setClear: function (e, i, s, o, a) { !0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n)) }, reset: function () { e = !1, i = null, r.set(-1, 0, 0, 0) } } }, s = new function () { let e = !1, n = null, i = null, r = null; return { setTest: function (t) { t ? xt(2929) : _t(2929) }, setMask: function (i) { n === i || e || (t.depthMask(i), n = i) }, setFunc: function (e) { if (i !== e) { switch (e) { case U: t.depthFunc(512); break; case z: t.depthFunc(519); break; case V: t.depthFunc(513); break; case Q: t.depthFunc(515); break; case G: t.depthFunc(514); break; case H: t.depthFunc(518); break; case j: t.depthFunc(516); break; case W: t.depthFunc(517); break; default: t.depthFunc(515) }i = e } }, setLocked: function (t) { e = t }, setClear: function (e) { r !== e && (t.clearDepth(e), r = e) }, reset: function () { e = !1, n = null, i = null, r = null } } }, o = new function () { let e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, h = null; return { setTest: function (t) { e || (t ? xt(2960) : _t(2960)) }, setMask: function (i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function (e, n, o) { i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o) }, setOp: function (e, n, i) { o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i) }, setLocked: function (t) { e = t }, setClear: function (e) { h !== e && (t.clearStencil(e), h = e) }, reset: function () { e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, h = null } } }, c = new WeakMap, u = new WeakMap; let d = {}, p = {}, g = new WeakMap, q = [], Y = null, X = !1, K = null, J = null, Z = null, $ = null, tt = null, et = null, nt = null, it = !1, rt = null, st = null, ot = null, at = null, lt = null; const ht = t.getParameter(35661); let ct = !1, ut = 0; const dt = t.getParameter(7938); -1 !== dt.indexOf("WebGL") ? (ut = parseFloat(/^WebGL (\d)/.exec(dt)[1]), ct = ut >= 1) : -1 !== dt.indexOf("OpenGL ES") && (ut = parseFloat(/^OpenGL ES (\d)/.exec(dt)[1]), ct = ut >= 2); let pt = null, ft = {}; const mt = t.getParameter(3088), gt = t.getParameter(2978), vt = (new pn).fromArray(mt), At = (new pn).fromArray(gt); function bt(e, n, i) { const r = new Uint8Array(4), s = t.createTexture(); t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728); for (let e = 0; e < i; e++)t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r); return s } const yt = {}; function xt(e) { !0 !== d[e] && (t.enable(e), d[e] = !0) } function _t(e) { !1 !== d[e] && (t.disable(e), d[e] = !1) } yt[3553] = bt(3553, 3553, 1), yt[34067] = bt(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), xt(2929), s.setFunc(Q), St(!1), Mt(l), xt(2884), Ct(v); const wt = { [w]: 32774, [E]: 32778, [C]: 32779 }; if (i) wt[S] = 32775, wt[M] = 32776; else { const t = e.get("EXT_blend_minmax"); null !== t && (wt[S] = t.MIN_EXT, wt[M] = t.MAX_EXT) } const Et = { [P]: 0, [I]: 1, [T]: 768, [B]: 770, [N]: 776, [R]: 774, [F]: 772, [D]: 769, [L]: 771, [O]: 775, [k]: 773 }; function Ct(e, n, i, r, s, o, a, l) { if (e !== v) { if (!1 === X && (xt(3042), X = !0), e === _) s = s || n, o = o || i, a = a || r, n === J && s === tt || (t.blendEquationSeparate(wt[n], wt[s]), J = n, tt = s), i === Z && r === $ && o === et && a === nt || (t.blendFuncSeparate(Et[i], Et[r], Et[o], Et[a]), Z = i, $ = r, et = o, nt = a), K = e, it = !1; else if (e !== K || l !== it) { if (J === w && tt === w || (t.blendEquation(32774), J = w, tt = w), l) switch (e) { case A: t.blendFuncSeparate(1, 771, 1, 771); break; case b: t.blendFunc(1, 1); break; case y: t.blendFuncSeparate(0, 769, 0, 1); break; case x: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case A: t.blendFuncSeparate(770, 771, 1, 771); break; case b: t.blendFunc(770, 1); break; case y: t.blendFuncSeparate(0, 769, 0, 1); break; case x: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }Z = null, $ = null, et = null, nt = null, K = e, it = l } } else !0 === X && (_t(3042), X = !1) } function St(e) { rt !== e && (e ? t.frontFace(2304) : t.frontFace(2305), rt = e) } function Mt(e) { e !== a ? (xt(2884), e !== st && (e === l ? t.cullFace(1029) : e === h ? t.cullFace(1028) : t.cullFace(1032))) : _t(2884), st = e } function Pt(e, n, i) { e ? (xt(32823), at === n && lt === i || (t.polygonOffset(n, i), at = n, lt = i)) : _t(32823) } return { buffers: { color: r, depth: s, stencil: o }, enable: xt, disable: _t, bindFramebuffer: function (e, n) { return p[e] !== n && (t.bindFramebuffer(e, n), p[e] = n, i && (36009 === e && (p[36160] = n), 36160 === e && (p[36009] = n)), !0) }, drawBuffers: function (i, r) { let s = q, o = !1; if (i) if (s = g.get(r), void 0 === s && (s = [], g.set(r, s)), i.isWebGLMultipleRenderTargets) { const t = i.texture; if (s.length !== t.length || 36064 !== s[0]) { for (let e = 0, n = t.length; e < n; e++)s[e] = 36064 + e; s.length = t.length, o = !0 } } else 36064 !== s[0] && (s[0] = 36064, o = !0); else 1029 !== s[0] && (s[0] = 1029, o = !0); o && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s)) }, useProgram: function (e) { return Y !== e && (t.useProgram(e), Y = e, !0) }, setBlending: Ct, setMaterial: function (t, e) { t.side === m ? _t(2884) : xt(2884); let n = t.side === f; e && (n = !n), St(n), t.blending === A && !1 === t.transparent ? Ct(v) : Ct(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite); const i = t.stencilWrite; o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Pt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? xt(32926) : _t(32926) }, setFlipSided: St, setCullFace: Mt, setLineWidth: function (e) { e !== ot && (ct && t.lineWidth(e), ot = e) }, setPolygonOffset: Pt, setScissorTest: function (t) { t ? xt(3089) : _t(3089) }, activeTexture: function (e) { void 0 === e && (e = 33984 + ht - 1), pt !== e && (t.activeTexture(e), pt = e) }, bindTexture: function (e, n, i) { void 0 === i && (i = null === pt ? 33984 + ht - 1 : pt); let r = ft[i]; void 0 === r && (r = { type: void 0, texture: void 0 }, ft[i] = r), r.type === e && r.texture === n || (pt !== i && (t.activeTexture(i), pt = i), t.bindTexture(e, n || yt[e]), r.type = e, r.texture = n) }, unbindTexture: function () { const e = ft[pt]; void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, compressedTexImage3D: function () { try { t.compressedTexImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, updateUBOMapping: function (e, n) { let i = u.get(n); void 0 === i && (i = new WeakMap, u.set(n, i)); let r = i.get(e); void 0 === r && (r = t.getUniformBlockIndex(n, e.name), i.set(e, r)) }, uniformBlockBinding: function (e, n) { const i = u.get(n).get(e); c.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), c.set(n, i)) }, texStorage2D: function () { try { t.texStorage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texStorage3D: function () { try { t.texStorage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texSubImage2D: function () { try { t.texSubImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texSubImage3D: function () { try { t.texSubImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, compressedTexSubImage2D: function () { try { t.compressedTexSubImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, compressedTexSubImage3D: function () { try { t.compressedTexSubImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (e) { !1 === vt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), vt.copy(e)) }, viewport: function (e) { !1 === At.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), At.copy(e)) }, reset: function () { t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), d = {}, pt = null, ft = {}, p = {}, g = new WeakMap, q = [], Y = null, X = !1, K = null, J = null, Z = null, $ = null, tt = null, et = null, nt = null, it = !1, rt = null, st = null, ot = null, at = null, lt = null, vt.set(0, 0, t.canvas.width, t.canvas.height), At.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), o.reset() } } } function ta(t, e, n, i, r, s, o) { const a = r.isWebGL2, l = r.maxTextures, h = r.maxCubemapSize, c = r.maxTextureSize, u = r.maxSamples, d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, p = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), f = new WeakMap; let m; const g = new WeakMap; let v = !1; try { v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) { } function A(t, e) { return v ? new OffscreenCanvas(t, e) : Ye("canvas") } function b(t, e, n, i) { let r = 1; if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const i = e ? ze : Math.floor, s = i(r * t.width), o = i(r * t.height); void 0 === m && (m = A(s, o)); const a = n ? A(s, o) : m; a.width = s, a.height = o; return a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function y(t) { return Ne(t.width) && Ne(t.height) } function x(t, e) { return t.generateMipmaps && e && t.minFilter !== ct && t.minFilter !== pt } function _(e) { t.generateMipmap(e) } function w(n, i, r, s, o = !1) { if (!1 === a) return i; if (null !== n) { if (void 0 !== t[n]) return t[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let l = i; return 6403 === i && (5126 === r && (l = 33326), 5131 === r && (l = 33325), 5121 === r && (l = 33321)), 33319 === i && (5126 === r && (l = 33328), 5131 === r && (l = 33327), 5121 === r && (l = 33323)), 6408 === i && (5126 === r && (l = 34836), 5131 === r && (l = 34842), 5121 === r && (l = s === be && !1 === o ? 35907 : 32856), 32819 === r && (l = 32854), 32820 === r && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"), l } function E(t, e, n) { return !0 === x(t, n) || t.isFramebufferTexture && t.minFilter !== ct && t.minFilter !== pt ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1 } function C(t) { return t === ct || t === ut || t === dt ? 9728 : 9729 } function S(t) { const e = t.target; e.removeEventListener("dispose", S), function (t) { const e = i.get(t); if (void 0 === e.__webglInit) return; const n = t.source, r = g.get(n); if (r) { const i = r[e.__cacheKey]; i.usedTimes--, 0 === i.usedTimes && P(t), 0 === Object.keys(r).length && g.delete(n) } i.remove(t) }(e), e.isVideoTexture && f.delete(e) } function M(e) { const n = e.target; n.removeEventListener("dispose", M), function (e) { const n = e.texture, r = i.get(e), s = i.get(n); void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--); e.depthTexture && e.depthTexture.dispose(); if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]); else { if (t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer) for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)r.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]); r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer) } if (e.isWebGLMultipleRenderTargets) for (let e = 0, r = n.length; e < r; e++) { const r = i.get(n[e]); r.__webglTexture && (t.deleteTexture(r.__webglTexture), o.memory.textures--), i.remove(n[e]) } i.remove(n), i.remove(e) }(n) } function P(e) { const n = i.get(e); t.deleteTexture(n.__webglTexture); const r = e.source; delete g.get(r)[n.__cacheKey], o.memory.textures-- } let I = 0; function T(t, e) { const r = i.get(t); if (t.isVideoTexture && function (t) { const e = o.render.frame; f.get(t) !== e && (f.set(t, e), t.update()) }(t), !1 === t.isRenderTargetTexture && t.version > 0 && r.__version !== t.version) { const n = t.image; if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else { if (!1 !== n.complete) return void k(r, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.bindTexture(3553, r.__webglTexture, 33984 + e) } const D = { [at]: 10497, [lt]: 33071, [ht]: 33648 }, B = { [ct]: 9728, [ut]: 9984, [dt]: 9986, [pt]: 9729, [ft]: 9985, [mt]: 9987 }; function L(n, s, o) { if (o ? (t.texParameteri(n, 10242, D[s.wrapS]), t.texParameteri(n, 10243, D[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, D[s.wrapR]), t.texParameteri(n, 10240, B[s.magFilter]), t.texParameteri(n, 10241, B[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === lt && s.wrapT === lt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, C(s.magFilter)), t.texParameteri(n, 10241, C(s.minFilter)), s.minFilter !== ct && s.minFilter !== pt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) { const o = e.get("EXT_texture_filter_anisotropic"); if (s.magFilter === ct) return; if (s.minFilter !== dt && s.minFilter !== mt) return; if (s.type === _t && !1 === e.has("OES_texture_float_linear")) return; if (!1 === a && s.type === wt && !1 === e.has("OES_texture_half_float_linear")) return; (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy) } } function F(e, n) { let i = !1; void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S)); const r = n.source; let s = g.get(r); void 0 === s && (s = {}, g.set(r, s)); const a = function (t) { const e = []; return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.encoding), e.join() }(n); if (a !== e.__cacheKey) { void 0 === s[a] && (s[a] = { texture: t.createTexture(), usedTimes: 0 }, o.memory.textures++, i = !0), s[a].usedTimes++; const r = s[e.__cacheKey]; void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && P(n)), e.__cacheKey = a, e.__webglTexture = s[a].texture } return i } function k(e, r, o) { let l = 3553; (r.isDataArrayTexture || r.isCompressedArrayTexture) && (l = 35866), r.isData3DTexture && (l = 32879); const h = F(e, r), u = r.source; n.bindTexture(l, e.__webglTexture, 33984 + o); const d = i.get(u); if (u.version !== d.__version || !0 === h) { n.activeTexture(33984 + o), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0); const e = function (t) { return !a && (t.wrapS !== lt || t.wrapT !== lt || t.minFilter !== ct && t.minFilter !== pt) }(r) && !1 === y(r.image); let i = b(r.image, e, !1, c); i = V(r, i); const p = y(i) || a, f = s.convert(r.format, r.encoding); let m, g = s.convert(r.type), v = w(r.internalFormat, f, g, r.encoding, r.isVideoTexture); L(l, r, p); const A = r.mipmaps, C = a && !0 !== r.isVideoTexture, S = void 0 === d.__version || !0 === h, M = E(r, i, p); if (r.isDepthTexture) v = 6402, a ? v = r.type === _t ? 36012 : r.type === xt ? 33190 : r.type === St ? 35056 : 33189 : r.type === _t && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Bt && 6402 === v && r.type !== bt && r.type !== xt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = xt, g = s.convert(r.type)), r.format === Lt && 6402 === v && (v = 34041, r.type !== St && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = St, g = s.convert(r.type))), S && (C ? n.texStorage2D(3553, 1, v, i.width, i.height) : n.texImage2D(3553, 0, v, i.width, i.height, 0, f, g, null)); else if (r.isDataTexture) if (A.length > 0 && p) { C && S && n.texStorage2D(3553, M, v, A[0].width, A[0].height); for (let t = 0, e = A.length; t < e; t++)m = A[t], C ? n.texSubImage2D(3553, t, 0, 0, m.width, m.height, f, g, m.data) : n.texImage2D(3553, t, v, m.width, m.height, 0, f, g, m.data); r.generateMipmaps = !1 } else C ? (S && n.texStorage2D(3553, M, v, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, i.width, i.height, f, g, i.data)) : n.texImage2D(3553, 0, v, i.width, i.height, 0, f, g, i.data); else if (r.isCompressedTexture) if (r.isCompressedArrayTexture) { C && S && n.texStorage3D(35866, M, v, A[0].width, A[0].height, i.depth); for (let t = 0, e = A.length; t < e; t++)m = A[t], r.format !== It ? null !== f ? C ? n.compressedTexSubImage3D(35866, t, 0, 0, 0, m.width, m.height, i.depth, f, m.data, 0, 0) : n.compressedTexImage3D(35866, t, v, m.width, m.height, i.depth, 0, m.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? n.texSubImage3D(35866, t, 0, 0, 0, m.width, m.height, i.depth, f, g, m.data) : n.texImage3D(35866, t, v, m.width, m.height, i.depth, 0, f, g, m.data) } else { C && S && n.texStorage2D(3553, M, v, A[0].width, A[0].height); for (let t = 0, e = A.length; t < e; t++)m = A[t], r.format !== It ? null !== f ? C ? n.compressedTexSubImage2D(3553, t, 0, 0, m.width, m.height, f, m.data) : n.compressedTexImage2D(3553, t, v, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? n.texSubImage2D(3553, t, 0, 0, m.width, m.height, f, g, m.data) : n.texImage2D(3553, t, v, m.width, m.height, 0, f, g, m.data) } else if (r.isDataArrayTexture) C ? (S && n.texStorage3D(35866, M, v, i.width, i.height, i.depth), n.texSubImage3D(35866, 0, 0, 0, 0, i.width, i.height, i.depth, f, g, i.data)) : n.texImage3D(35866, 0, v, i.width, i.height, i.depth, 0, f, g, i.data); else if (r.isData3DTexture) C ? (S && n.texStorage3D(32879, M, v, i.width, i.height, i.depth), n.texSubImage3D(32879, 0, 0, 0, 0, i.width, i.height, i.depth, f, g, i.data)) : n.texImage3D(32879, 0, v, i.width, i.height, i.depth, 0, f, g, i.data); else if (r.isFramebufferTexture) { if (S) if (C) n.texStorage2D(3553, M, v, i.width, i.height); else { let t = i.width, e = i.height; for (let i = 0; i < M; i++)n.texImage2D(3553, i, v, t, e, 0, f, g, null), t >>= 1, e >>= 1 } } else if (A.length > 0 && p) { C && S && n.texStorage2D(3553, M, v, A[0].width, A[0].height); for (let t = 0, e = A.length; t < e; t++)m = A[t], C ? n.texSubImage2D(3553, t, 0, 0, f, g, m) : n.texImage2D(3553, t, v, f, g, m); r.generateMipmaps = !1 } else C ? (S && n.texStorage2D(3553, M, v, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, f, g, i)) : n.texImage2D(3553, 0, v, f, g, i); x(r, p) && _(l), d.__version = u.version, r.onUpdate && r.onUpdate(r) } e.__version = r.version } function R(e, r, o, a, l) { const h = s.convert(o.format, o.encoding), c = s.convert(o.type), u = w(o.internalFormat, h, c, o.encoding); i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, h, c, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, h, c, null)), n.bindFramebuffer(36160, e), z(r) ? d.framebufferTexture2DMultisampleEXT(36160, a, l, i.get(o).__webglTexture, 0, U(r)) : (3553 === l || l >= 34069 && l <= 34074) && t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null) } function O(e, n, i) { if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) { let r = 33189; if (i || z(n)) { const e = n.depthTexture; e && e.isDepthTexture && (e.type === _t ? r = 36012 : e.type === xt && (r = 33190)); const i = U(n); z(n) ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height) } else t.renderbufferStorage(36161, r, n.width, n.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (n.depthBuffer && n.stencilBuffer) { const r = U(n); i && !1 === z(n) ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : z(n) ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture]; for (let r = 0; r < e.length; r++) { const o = e[r], a = s.convert(o.format, o.encoding), l = s.convert(o.type), h = w(o.internalFormat, a, l, o.encoding), c = U(n); i && !1 === z(n) ? t.renderbufferStorageMultisample(36161, c, h, n.width, n.height) : z(n) ? d.renderbufferStorageMultisampleEXT(36161, c, h, n.width, n.height) : t.renderbufferStorage(36161, h, n.width, n.height) } } t.bindRenderbuffer(36161, null) } function N(e) { const r = i.get(e), s = !0 === e.isWebGLCubeRenderTarget; if (e.depthTexture && !r.__autoAllocateDepthBuffer) { if (s) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, r) { if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), T(r.depthTexture, 0); const s = i.get(r.depthTexture).__webglTexture, o = U(r); if (r.depthTexture.format === Bt) z(r) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : t.framebufferTexture2D(36160, 36096, 3553, s, 0); else { if (r.depthTexture.format !== Lt) throw new Error("Unknown depthTexture format"); z(r) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : t.framebufferTexture2D(36160, 33306, 3553, s, 0) } }(r.__webglFramebuffer, e) } else if (s) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), O(r.__webglDepthbuffer[i], e, !1) } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), O(r.__webglDepthbuffer, e, !1); n.bindFramebuffer(36160, null) } function U(t) { return Math.min(u, t.samples) } function z(t) { const n = i.get(t); return a && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture } function V(t, n) { const i = t.encoding, r = t.format, s = t.type; return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === Pe || i !== Ae && (i === be ? !1 === a ? !0 === e.has("EXT_sRGB") && r === It ? (t.format = Pe, t.minFilter = pt, t.generateMipmaps = !1) : n = ln.sRGBToLinear(n) : r === It && s === gt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n } this.allocateTextureUnit = function () { const t = I; return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), I += 1, t }, this.resetTextureUnits = function () { I = 0 }, this.setTexture2D = T, this.setTexture2DArray = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? k(r, t, e) : n.bindTexture(35866, r.__webglTexture, 33984 + e) }, this.setTexture3D = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? k(r, t, e) : n.bindTexture(32879, r.__webglTexture, 33984 + e) }, this.setTextureCube = function (e, r) { const o = i.get(e); e.version > 0 && o.__version !== e.version ? function (e, r, o) { if (6 !== r.image.length) return; const l = F(e, r), c = r.source; n.bindTexture(34067, e.__webglTexture, 33984 + o); const u = i.get(c); if (c.version !== u.__version || !0 === l) { n.activeTexture(33984 + o), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0); const e = r.isCompressedTexture || r.image[0].isCompressedTexture, i = r.image[0] && r.image[0].isDataTexture, d = []; for (let t = 0; t < 6; t++)d[t] = e || i ? i ? r.image[t].image : r.image[t] : b(r.image[t], !1, !0, h), d[t] = V(r, d[t]); const p = d[0], f = y(p) || a, m = s.convert(r.format, r.encoding), g = s.convert(r.type), v = w(r.internalFormat, m, g, r.encoding), A = a && !0 !== r.isVideoTexture, C = void 0 === u.__version || !0 === l; let S, M = E(r, p, f); if (L(34067, r, f), e) { A && C && n.texStorage2D(34067, M, v, p.width, p.height); for (let t = 0; t < 6; t++) { S = d[t].mipmaps; for (let e = 0; e < S.length; e++) { const i = S[e]; r.format !== It ? null !== m ? A ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, i.width, i.height, m, i.data) : n.compressedTexImage2D(34069 + t, e, v, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : A ? n.texSubImage2D(34069 + t, e, 0, 0, i.width, i.height, m, g, i.data) : n.texImage2D(34069 + t, e, v, i.width, i.height, 0, m, g, i.data) } } } else { S = r.mipmaps, A && C && (S.length > 0 && M++, n.texStorage2D(34067, M, v, d[0].width, d[0].height)); for (let t = 0; t < 6; t++)if (i) { A ? n.texSubImage2D(34069 + t, 0, 0, 0, d[t].width, d[t].height, m, g, d[t].data) : n.texImage2D(34069 + t, 0, v, d[t].width, d[t].height, 0, m, g, d[t].data); for (let e = 0; e < S.length; e++) { const i = S[e].image[t].image; A ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, m, g, i.data) : n.texImage2D(34069 + t, e + 1, v, i.width, i.height, 0, m, g, i.data) } } else { A ? n.texSubImage2D(34069 + t, 0, 0, 0, m, g, d[t]) : n.texImage2D(34069 + t, 0, v, m, g, d[t]); for (let e = 0; e < S.length; e++) { const i = S[e]; A ? n.texSubImage2D(34069 + t, e + 1, 0, 0, m, g, i.image[t]) : n.texImage2D(34069 + t, e + 1, v, m, g, i.image[t]) } } } x(r, f) && _(34067), u.__version = c.version, r.onUpdate && r.onUpdate(r) } e.__version = r.version }(o, e, r) : n.bindTexture(34067, o.__webglTexture, 33984 + r) }, this.rebindTextures = function (t, e, n) { const r = i.get(t); void 0 !== e && R(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && N(t) }, this.setupRenderTarget = function (e) { const l = e.texture, h = i.get(e), c = i.get(l); e.addEventListener("dispose", M), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()), c.__version = l.version, o.memory.textures++); const u = !0 === e.isWebGLCubeRenderTarget, d = !0 === e.isWebGLMultipleRenderTargets, p = y(e) || a; if (u) { h.__webglFramebuffer = []; for (let e = 0; e < 6; e++)h.__webglFramebuffer[e] = t.createFramebuffer() } else { if (h.__webglFramebuffer = t.createFramebuffer(), d) if (r.drawBuffers) { const n = e.texture; for (let e = 0, r = n.length; e < r; e++) { const r = i.get(n[e]); void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (a && e.samples > 0 && !1 === z(e)) { const i = d ? l : [l]; h.__webglMultisampledFramebuffer = t.createFramebuffer(), h.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer); for (let n = 0; n < i.length; n++) { const r = i[n]; h.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(36161, h.__webglColorRenderbuffer[n]); const o = s.convert(r.format, r.encoding), a = s.convert(r.type), l = w(r.internalFormat, o, a, r.encoding, !0 === e.isXRRenderTarget), c = U(e); t.renderbufferStorageMultisample(36161, c, l, e.width, e.height), t.framebufferRenderbuffer(36160, 36064 + n, 36161, h.__webglColorRenderbuffer[n]) } t.bindRenderbuffer(36161, null), e.depthBuffer && (h.__webglDepthRenderbuffer = t.createRenderbuffer(), O(h.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null) } } if (u) { n.bindTexture(34067, c.__webglTexture), L(34067, l, p); for (let t = 0; t < 6; t++)R(h.__webglFramebuffer[t], e, l, 36064, 34069 + t); x(l, p) && _(34067), n.unbindTexture() } else if (d) { const t = e.texture; for (let r = 0, s = t.length; r < s; r++) { const s = t[r], o = i.get(s); n.bindTexture(3553, o.__webglTexture), L(3553, s, p), R(h.__webglFramebuffer, e, s, 36064 + r, 3553), x(s, p) && _(3553) } n.unbindTexture() } else { let t = 3553; (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (a ? t = e.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(t, c.__webglTexture), L(t, l, p), R(h.__webglFramebuffer, e, l, 36064, t), x(l, p) && _(t), n.unbindTexture() } e.depthBuffer && N(e) }, this.updateRenderTargetMipmap = function (t) { const e = y(t) || a, r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]; for (let s = 0, o = r.length; s < o; s++) { const o = r[s]; if (x(o, e)) { const e = t.isWebGLCubeRenderTarget ? 34067 : 3553, r = i.get(o).__webglTexture; n.bindTexture(e, r), _(e), n.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (e) { if (a && e.samples > 0 && !1 === z(e)) { const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture], s = e.width, o = e.height; let a = 16384; const l = [], h = e.stencilBuffer ? 33306 : 36096, c = i.get(e), u = !0 === e.isWebGLMultipleRenderTargets; if (u) for (let e = 0; e < r.length; e++)n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + e, 36161, null), n.bindFramebuffer(36160, c.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + e, 3553, null, 0); n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer); for (let n = 0; n < r.length; n++) { l.push(36064 + n), e.depthBuffer && l.push(h); const d = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues; if (!1 === d && (e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024)), u && t.framebufferRenderbuffer(36008, 36064, 36161, c.__webglColorRenderbuffer[n]), !0 === d && (t.invalidateFramebuffer(36008, [h]), t.invalidateFramebuffer(36009, [h])), u) { const e = i.get(r[n]).__webglTexture; t.framebufferTexture2D(36009, 36064, 3553, e, 0) } t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, 9728), p && t.invalidateFramebuffer(36008, l) } if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), u) for (let e = 0; e < r.length; e++) { n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + e, 36161, c.__webglColorRenderbuffer[e]); const s = i.get(r[e]).__webglTexture; n.bindFramebuffer(36160, c.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + e, 3553, s, 0) } n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer) } }, this.setupDepthRenderbuffer = N, this.setupFrameBufferTexture = R, this.useMultisampledRTT = z } function ea(t, e, n) { const i = n.isWebGL2; return { convert: function (n, r = null) { let s; if (n === gt) return 5121; if (n === Et) return 32819; if (n === Ct) return 32820; if (n === vt) return 5120; if (n === At) return 5122; if (n === bt) return 5123; if (n === yt) return 5124; if (n === xt) return 5125; if (n === _t) return 5126; if (n === wt) return i ? 5131 : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null); if (n === Mt) return 6406; if (n === It) return 6408; if (n === Tt) return 6409; if (n === Dt) return 6410; if (n === Bt) return 6402; if (n === Lt) return 34041; if (n === Pt) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408; if (n === Pe) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null; if (n === Ft) return 6403; if (n === kt) return 36244; if (n === Rt) return 33319; if (n === Ot) return 33320; if (n === Nt) return 36249; if (n === Ut || n === zt || n === Vt || n === Qt) if (r === be) { if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null; if (n === Ut) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (n === zt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (n === Vt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (n === Qt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null; if (n === Ut) return s.COMPRESSED_RGB_S3TC_DXT1_EXT; if (n === zt) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (n === Vt) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (n === Qt) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (n === Gt || n === Ht || n === jt || n === Wt) { if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null; if (n === Gt) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (n === Ht) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (n === jt) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (n === Wt) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (n === qt) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null; if (n === Yt || n === Xt) { if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null; if (n === Yt) return r === be ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2; if (n === Xt) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC } if (n === Kt || n === Jt || n === Zt || n === $t || n === te || n === ee || n === ne || n === ie || n === re || n === se || n === oe || n === ae || n === le || n === he) { if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null; if (n === Kt) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR; if (n === Jt) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR; if (n === Zt) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR; if (n === $t) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR; if (n === te) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR; if (n === ee) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR; if (n === ne) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR; if (n === ie) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR; if (n === re) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR; if (n === se) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR; if (n === oe) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR; if (n === ae) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR; if (n === le) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR; if (n === he) return r === be ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR } if (n === ce) { if (s = e.get("EXT_texture_compression_bptc"), null === s) return null; if (n === ce) return r === be ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT } return n === St ? i ? 34042 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null } } } class na extends gr { constructor(t = []) { super(), this.isArrayCamera = !0, this.cameras = t } } class ia extends bi { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const ra = { type: "move" }; class sa { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new ia, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new ia, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new An, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new An), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new ia, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new An, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new An), this._grip } dispatchEvent(t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this } connect(t) { if (t && t.hand) { const e = this._hand; if (e) for (const n of t.hand.values()) this._getHandJoint(e, n) } return this.dispatchEvent({ type: "connected", data: t }), this } disconnect(t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(t, e, n) { let i = null, r = null, s = null; const o = this._targetRay, a = this._grip, l = this._hand; if (t && "visible-blurred" !== e.session.visibilityState) { if (l && t.hand) { s = !0; for (const i of t.hand.values()) { const t = e.getJointPose(i, n), r = this._getHandJoint(l, i); null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t } const i = l.joints["index-finger-tip"], r = l.joints["thumb-tip"], o = i.position.distanceTo(r.position), a = .02, h = .005; l.inputState.pinching && o > a + h ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && o <= a - h && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1)); null !== o && (i = e.getPose(t.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(ra))) } return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this } _getHandJoint(t, e) { if (void 0 === t.joints[e.jointName]) { const n = new ia; n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n) } return t.joints[e.jointName] } } class oa extends dn { constructor(t, e, n, i, r, s, o, a, l, h) { if ((h = void 0 !== h ? h : Bt) !== Bt && h !== Lt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && h === Bt && (n = xt), void 0 === n && h === Lt && (n = St), super(null, i, r, s, o, a, h, n, l), this.isDepthTexture = !0, this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : ct, this.minFilter = void 0 !== a ? a : ct, this.flipY = !1, this.generateMipmaps = !1 } } class aa extends Ie { constructor(t, e) { super(); const n = this; let i = null, r = 1, s = null, o = "local-floor", a = null, l = null, h = null, c = null, u = null, d = null; const p = e.getContextAttributes(); let f = null, m = null; const g = [], v = [], A = new Set, b = new Map, y = new gr; y.layers.enable(1), y.viewport = new pn; const x = new gr; x.layers.enable(2), x.viewport = new pn; const _ = [y, x], w = new na; w.layers.enable(1), w.layers.enable(2); let E = null, C = null; function S(t) { const e = v.indexOf(t.inputSource); if (-1 === e) return; const n = g[e]; void 0 !== n && n.dispatchEvent({ type: t.type, data: t.inputSource }) } function M() { i.removeEventListener("select", S), i.removeEventListener("selectstart", S), i.removeEventListener("selectend", S), i.removeEventListener("squeeze", S), i.removeEventListener("squeezestart", S), i.removeEventListener("squeezeend", S), i.removeEventListener("end", M), i.removeEventListener("inputsourceschange", P); for (let t = 0; t < g.length; t++) { const e = v[t]; null !== e && (v[t] = null, g[t].disconnect(e)) } E = null, C = null, t.setRenderTarget(f), u = null, c = null, h = null, i = null, m = null, L.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function P(t) { for (let e = 0; e < t.removed.length; e++) { const n = t.removed[e], i = v.indexOf(n); i >= 0 && (v[i] = null, g[i].disconnect(n)) } for (let e = 0; e < t.added.length; e++) { const n = t.added[e]; let i = v.indexOf(n); if (-1 === i) { for (let t = 0; t < g.length; t++) { if (t >= v.length) { v.push(n), i = t; break } if (null === v[t]) { v[t] = n, i = t; break } } if (-1 === i) break } const r = g[i]; r && r.connect(n) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) { let e = g[t]; return void 0 === e && (e = new sa, g[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function (t) { let e = g[t]; return void 0 === e && (e = new sa, g[t] = e), e.getGripSpace() }, this.getHand = function (t) { let e = g[t]; return void 0 === e && (e = new sa, g[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function (t) { r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (t) { o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return a || s }, this.setReferenceSpace = function (t) { a = t }, this.getBaseLayer = function () { return null !== c ? c : u }, this.getBinding = function () { return h }, this.getFrame = function () { return d }, this.getSession = function () { return i }, this.setSession = async function (l) { if (i = l, null !== i) { if (f = t.getRenderTarget(), i.addEventListener("select", S), i.addEventListener("selectstart", S), i.addEventListener("selectend", S), i.addEventListener("squeeze", S), i.addEventListener("squeezestart", S), i.addEventListener("squeezeend", S), i.addEventListener("end", M), i.addEventListener("inputsourceschange", P), !0 !== p.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) { const n = { antialias: void 0 !== i.renderState.layers || p.antialias, alpha: p.alpha, depth: p.depth, stencil: p.stencil, framebufferScaleFactor: r }; u = new XRWebGLLayer(i, e, n), i.updateRenderState({ baseLayer: u }), m = new fn(u.framebufferWidth, u.framebufferHeight, { format: It, type: gt, encoding: t.outputEncoding, stencilBuffer: p.stencil }) } else { let n = null, s = null, o = null; p.depth && (o = p.stencil ? 35056 : 33190, n = p.stencil ? Lt : Bt, s = p.stencil ? St : xt); const a = { colorFormat: 32856, depthFormat: o, scaleFactor: r }; h = new XRWebGLBinding(i, e), c = h.createProjectionLayer(a), i.updateRenderState({ layers: [c] }), m = new fn(c.textureWidth, c.textureHeight, { format: It, type: gt, depthTexture: new oa(c.textureWidth, c.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n), stencilBuffer: p.stencil, encoding: t.outputEncoding, samples: p.antialias ? 4 : 0 }); t.properties.get(m).__ignoreDepthValues = c.ignoreDepthValues } m.isXRRenderTarget = !0, this.setFoveation(1), a = null, s = await i.requestReferenceSpace(o), L.setContext(i), L.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; const I = new An, T = new An; function D(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert() } this.updateCamera = function (t) { if (null === i) return; w.near = x.near = y.near = t.near, w.far = x.far = y.far = t.far, E === w.near && C === w.far || (i.updateRenderState({ depthNear: w.near, depthFar: w.far }), E = w.near, C = w.far); const e = t.parent, n = w.cameras; D(w, e); for (let t = 0; t < n.length; t++)D(n[t], e); w.matrixWorld.decompose(w.position, w.quaternion, w.scale), t.matrix.copy(w.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale); const r = t.children; for (let t = 0, e = r.length; t < e; t++)r[t].updateMatrixWorld(!0); 2 === n.length ? function (t, e, n) { I.setFromMatrixPosition(e.matrixWorld), T.setFromMatrixPosition(n.matrixWorld); const i = I.distanceTo(T), r = e.projectionMatrix.elements, s = n.projectionMatrix.elements, o = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], h = (r[9] - 1) / r[5], c = (r[8] - 1) / r[0], u = (s[8] + 1) / s[0], d = o * c, p = o * u, f = i / (-c + u), m = f * -c; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert(); const g = o + f, v = a + f, A = d - m, b = p + (i - m), y = l * a / v * g, x = h * a / v * g; t.projectionMatrix.makePerspective(A, b, y, x, g, v) }(w, y, x) : w.projectionMatrix.copy(y.projectionMatrix) }, this.getCamera = function () { return w }, this.getFoveation = function () { return null !== c ? c.fixedFoveation : null !== u ? u.fixedFoveation : void 0 }, this.setFoveation = function (t) { null !== c && (c.fixedFoveation = t), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = t) }, this.getPlanes = function () { return A }; let B = null; const L = new Pr; L.setAnimationLoop((function (e, i) { if (l = i.getViewerPose(a || s), d = i, null !== l) { const e = l.views; null !== u && (t.setRenderTargetFramebuffer(m, u.framebuffer), t.setRenderTarget(m)); let n = !1; e.length !== w.cameras.length && (w.cameras.length = 0, n = !0); for (let i = 0; i < e.length; i++) { const r = e[i]; let s = null; if (null !== u) s = u.getViewport(r); else { const e = h.getViewSubImage(c, r); s = e.viewport, 0 === i && (t.setRenderTargetTextures(m, e.colorTexture, c.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(m)) } let o = _[i]; void 0 === o && (o = new gr, o.layers.enable(i), o.viewport = new pn, _[i] = o), o.matrix.fromArray(r.transform.matrix), o.projectionMatrix.fromArray(r.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === i && w.matrix.copy(o.matrix), !0 === n && w.cameras.push(o) } } for (let t = 0; t < g.length; t++) { const e = v[t], n = g[t]; null !== e && void 0 !== n && n.update(e, i, a || s) } if (B && B(e, i), i.detectedPlanes) { n.dispatchEvent({ type: "planesdetected", data: i.detectedPlanes }); let t = null; for (const e of A) i.detectedPlanes.has(e) || (null === t && (t = []), t.push(e)); if (null !== t) for (const e of t) A.delete(e), b.delete(e), n.dispatchEvent({ type: "planeremoved", data: e }); for (const t of i.detectedPlanes) if (A.has(t)) { const e = b.get(t); t.lastChangedTime > e && (b.set(t, t.lastChangedTime), n.dispatchEvent({ type: "planechanged", data: t })) } else A.add(t), b.set(t, i.lastChangedTime), n.dispatchEvent({ type: "planeadded", data: t }) } d = null })), this.setAnimationLoop = function (t) { B = t }, this.dispose = function () { } } } function la(t, e) { function n(n, i) { n.opacity.value = i.opacity, i.color && n.diffuse.value.copy(i.color), i.emissive && n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (n.map.value = i.map), i.alphaMap && (n.alphaMap.value = i.alphaMap), i.bumpMap && (n.bumpMap.value = i.bumpMap, n.bumpScale.value = i.bumpScale, i.side === f && (n.bumpScale.value *= -1)), i.displacementMap && (n.displacementMap.value = i.displacementMap, n.displacementScale.value = i.displacementScale, n.displacementBias.value = i.displacementBias), i.emissiveMap && (n.emissiveMap.value = i.emissiveMap), i.normalMap && (n.normalMap.value = i.normalMap, n.normalScale.value.copy(i.normalScale), i.side === f && n.normalScale.value.negate()), i.specularMap && (n.specularMap.value = i.specularMap), i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest); const r = e.get(i).envMap; if (r && (n.envMap.value = r, n.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = i.reflectivity, n.ior.value = i.ior, n.refractionRatio.value = i.refractionRatio), i.lightMap) { n.lightMap.value = i.lightMap; const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1; n.lightMapIntensity.value = i.lightMapIntensity * e } let s, o; i.aoMap && (n.aoMap.value = i.aoMap, n.aoMapIntensity.value = i.aoMapIntensity), i.map ? s = i.map : i.specularMap ? s = i.specularMap : i.displacementMap ? s = i.displacementMap : i.normalMap ? s = i.normalMap : i.bumpMap ? s = i.bumpMap : i.roughnessMap ? s = i.roughnessMap : i.metalnessMap ? s = i.metalnessMap : i.alphaMap ? s = i.alphaMap : i.emissiveMap ? s = i.emissiveMap : i.clearcoatMap ? s = i.clearcoatMap : i.clearcoatNormalMap ? s = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? s = i.clearcoatRoughnessMap : i.iridescenceMap ? s = i.iridescenceMap : i.iridescenceThicknessMap ? s = i.iridescenceThicknessMap : i.specularIntensityMap ? s = i.specularIntensityMap : i.specularColorMap ? s = i.specularColorMap : i.transmissionMap ? s = i.transmissionMap : i.thicknessMap ? s = i.thicknessMap : i.sheenColorMap ? s = i.sheenColorMap : i.sheenRoughnessMap && (s = i.sheenRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), n.uvTransform.value.copy(s.matrix)), i.aoMap ? o = i.aoMap : i.lightMap && (o = i.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), n.uv2Transform.value.copy(o.matrix)) } return { refreshFogUniforms: function (e, n) { n.color.getRGB(e.fogColor.value, dr(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density) }, refreshMaterialUniforms: function (t, i, r, s, o) { i.isMeshBasicMaterial || i.isMeshLambertMaterial ? n(t, i) : i.isMeshToonMaterial ? (n(t, i), function (t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap) }(t, i)) : i.isMeshPhongMaterial ? (n(t, i), function (t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4) }(t, i)) : i.isMeshStandardMaterial ? (n(t, i), function (t, n) { t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap); n.metalnessMap && (t.metalnessMap.value = n.metalnessMap); const i = e.get(n).envMap; i && (t.envMapIntensity.value = n.envMapIntensity) }(t, i), i.isMeshPhysicalMaterial && function (t, e, n) { t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)); e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === f && t.clearcoatNormalScale.value.negate())); e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap)); e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)); t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap); e.specularColorMap && (t.specularColorMap.value = e.specularColorMap) }(t, i, o)) : i.isMeshMatcapMaterial ? (n(t, i), function (t, e) { e.matcap && (t.matcap.value = e.matcap) }(t, i)) : i.isMeshDepthMaterial ? n(t, i) : i.isMeshDistanceMaterial ? (n(t, i), function (t, e) { t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, i)) : i.isMeshNormalMaterial ? n(t, i) : i.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, i), i.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest); let r; e.map ? r = e.map : e.alphaMap && (r = e.alphaMap); void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) }(t, i, r, s) : i.isSpriteMaterial ? function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest); let n; e.map ? n = e.map : e.alphaMap && (n = e.alphaMap); void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)) }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function ha(t, e, n, i) { let r = {}, s = {}, o = []; const a = n.isWebGL2 ? t.getParameter(35375) : 0; function l(t, e, n) { const i = t.value; if (void 0 === n[e]) { if ("number" == typeof i) n[e] = i; else { const t = Array.isArray(i) ? i : [i], r = []; for (let e = 0; e < t.length; e++)r.push(t[e].clone()); n[e] = r } return !0 } if ("number" == typeof i) { if (n[e] !== i) return n[e] = i, !0 } else { const t = Array.isArray(n[e]) ? n[e] : [n[e]], r = Array.isArray(i) ? i : [i]; for (let e = 0; e < t.length; e++) { const n = t[e]; if (!1 === n.equals(r[e])) return n.copy(r[e]), !0 } } return !1 } function h(t) { const e = { boundary: 0, storage: 0 }; return "number" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e } function c(e) { const n = e.target; n.removeEventListener("dispose", c); const i = o.indexOf(n.__bindingPointIndex); o.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id] } return { bind: function (t, e) { const n = e.program; i.uniformBlockBinding(t, n) }, update: function (n, u) { let d = r[n.id]; void 0 === d && (!function (t) { const e = t.uniforms; let n = 0; const i = 16; let r = 0; for (let t = 0, s = e.length; t < s; t++) { const s = e[t], o = { boundary: 0, storage: 0 }, a = Array.isArray(s.value) ? s.value : [s.value]; for (let t = 0, e = a.length; t < e; t++) { const e = h(a[t]); o.boundary += e.boundary, o.storage += e.storage } if (s.__data = new Float32Array(o.storage / Float32Array.BYTES_PER_ELEMENT), s.__offset = n, t > 0) { r = n % i; 0 !== r && i - r - o.boundary < 0 && (n += i - r, s.__offset = n) } n += o.storage } r = n % i, r > 0 && (n += i - r); t.__size = n, t.__cache = {} }(n), d = function (e) { const n = function () { for (let t = 0; t < a; t++)if (-1 === o.indexOf(t)) return o.push(t), t; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 }(); e.__bindingPointIndex = n; const i = t.createBuffer(), r = e.__size, s = e.usage; return t.bindBuffer(35345, i), t.bufferData(35345, r, s), t.bindBuffer(35345, null), t.bindBufferBase(35345, n, i), i }(n), r[n.id] = d, n.addEventListener("dispose", c)); const p = u.program; i.updateUBOMapping(n, p); const f = e.render.frame; s[n.id] !== f && (!function (e) { const n = r[e.id], i = e.uniforms, s = e.__cache; t.bindBuffer(35345, n); for (let e = 0, n = i.length; e < n; e++) { const n = i[e]; if (!0 === l(n, e, s)) { const e = n.__offset, i = Array.isArray(n.value) ? n.value : [n.value]; let r = 0; for (let s = 0; s < i.length; s++) { const o = i[s], a = h(o); "number" == typeof o ? (n.__data[0] = o, t.bufferSubData(35345, e + r, n.__data)) : o.isMatrix3 ? (n.__data[0] = o.elements[0], n.__data[1] = o.elements[1], n.__data[2] = o.elements[2], n.__data[3] = o.elements[0], n.__data[4] = o.elements[3], n.__data[5] = o.elements[4], n.__data[6] = o.elements[5], n.__data[7] = o.elements[0], n.__data[8] = o.elements[6], n.__data[9] = o.elements[7], n.__data[10] = o.elements[8], n.__data[11] = o.elements[0]) : (o.toArray(n.__data, r), r += a.storage / Float32Array.BYTES_PER_ELEMENT) } t.bufferSubData(35345, e, n.__data) } } t.bindBuffer(35345, null) }(n), s[n.id] = f) }, dispose: function () { for (const e in r) t.deleteBuffer(r[e]); o = [], r = {}, s = {} } } } function ca(t = {}) { this.isWebGLRenderer = !0; const e = void 0 !== t.canvas ? t.canvas : function () { const t = Ye("canvas"); return t.style.display = "block", t }(), n = void 0 !== t.context ? t.context : null, i = void 0 === t.depth || t.depth, s = void 0 === t.stencil || t.stencil, o = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, h = void 0 !== t.powerPreference ? t.powerPreference : "default", c = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat; let u; u = null !== n ? n.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha; let d = null, m = null; const v = [], A = []; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Ae, this.physicallyCorrectLights = !1, this.toneMapping = K, this.toneMappingExposure = 1; const b = this; let y = !1, x = 0, _ = 0, w = null, E = -1, C = null; const S = new pn, M = new pn; let P = null, I = e.width, T = e.height, D = 1, B = null, L = null; const F = new pn(0, 0, I, T), k = new pn(0, 0, I, T); let R = !1; const O = new Mr; let N = !1, U = !1, z = null; const V = new Yn, Q = new He, G = new An, H = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function j() { return null === w ? D : 1 } let W, q, Y, X, J, Z, $, tt, et, nt, it, rt, st, ot, at, lt, ht, ct, ut, dt, pt, ft, vt, At, bt = n; function yt(t, n) { for (let i = 0; i < t.length; i++) { const r = t[i], s = e.getContext(r, n); if (null !== s) return s } return null } try { const t = { alpha: !0, depth: i, stencil: s, antialias: o, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: h, failIfMajorPerformanceCaveat: c }; if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${r}`), e.addEventListener("webglcontextlost", Ct, !1), e.addEventListener("webglcontextrestored", St, !1), e.addEventListener("webglcontextcreationerror", Mt, !1), null === bt) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === b.isWebGL1Renderer && e.shift(), bt = yt(e, t), null === bt) throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === bt.getShaderPrecisionFormat && (bt.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } function xt() { W = new rs(bt), q = new Nr(bt, W, t), W.init(q), ft = new ea(bt, W, q), Y = new $o(bt, W, q), X = new as, J = new Oo, Z = new ta(bt, W, Y, J, q, ft, X), $ = new zr(b), tt = new is(b), et = new Ir(bt, q), vt = new Rr(bt, W, et, q), nt = new ss(bt, et, X, vt), it = new us(bt, nt, et, X), ut = new cs(bt, q, Z), lt = new Ur(J), rt = new Ro(b, $, tt, W, q, vt, lt), st = new la(b, J), ot = new Vo, at = new qo(W, q), ct = new kr(b, $, tt, Y, it, u, a), ht = new Zo(b, it, q), At = new ha(bt, X, q, Y), dt = new Or(bt, W, X, q), pt = new os(bt, W, X, q), X.programs = rt.programs, b.capabilities = q, b.extensions = W, b.properties = J, b.renderLists = ot, b.shadowMap = ht, b.state = Y, b.info = X } xt(); const Et = new aa(b, bt); function Ct(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0 } function St() { console.log("THREE.WebGLRenderer: Context Restored."), y = !1; const t = X.autoReset, e = ht.enabled, n = ht.autoUpdate, i = ht.needsUpdate, r = ht.type; xt(), X.autoReset = t, ht.enabled = e, ht.autoUpdate = n, ht.needsUpdate = i, ht.type = r } function Mt(t) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage) } function Pt(t) { const e = t.target; e.removeEventListener("dispose", Pt), function (t) { (function (t) { const e = J.get(t).programs; void 0 !== e && (e.forEach((function (t) { rt.releaseProgram(t) })), t.isShaderMaterial && rt.releaseShaderCache(t)) })(t), J.remove(t) }(e) } this.xr = Et, this.getContext = function () { return bt }, this.getContextAttributes = function () { return bt.getContextAttributes() }, this.forceContextLoss = function () { const t = W.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { const t = W.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return D }, this.setPixelRatio = function (t) { void 0 !== t && (D = t, this.setSize(I, T, !1)) }, this.getSize = function (t) { return t.set(I, T) }, this.setSize = function (t, n, i) { Et.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = t, T = n, e.width = Math.floor(t * D), e.height = Math.floor(n * D), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function (t) { return t.set(I * D, T * D).floor() }, this.setDrawingBufferSize = function (t, n, i) { I = t, T = n, D = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function (t) { return t.copy(S) }, this.getViewport = function (t) { return t.copy(F) }, this.setViewport = function (t, e, n, i) { t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i), Y.viewport(S.copy(F).multiplyScalar(D).floor()) }, this.getScissor = function (t) { return t.copy(k) }, this.setScissor = function (t, e, n, i) { t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, n, i), Y.scissor(M.copy(k).multiplyScalar(D).floor()) }, this.getScissorTest = function () { return R }, this.setScissorTest = function (t) { Y.setScissorTest(R = t) }, this.setOpaqueSort = function (t) { B = t }, this.setTransparentSort = function (t) { L = t }, this.getClearColor = function (t) { return t.copy(ct.getClearColor()) }, this.setClearColor = function () { ct.setClearColor.apply(ct, arguments) }, this.getClearAlpha = function () { return ct.getClearAlpha() }, this.setClearAlpha = function () { ct.setClearAlpha.apply(ct, arguments) }, this.clear = function (t = !0, e = !0, n = !0) { let i = 0; t && (i |= 16384), e && (i |= 256), n && (i |= 1024), bt.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", Ct, !1), e.removeEventListener("webglcontextrestored", St, !1), e.removeEventListener("webglcontextcreationerror", Mt, !1), ot.dispose(), at.dispose(), J.dispose(), $.dispose(), tt.dispose(), it.dispose(), vt.dispose(), At.dispose(), rt.dispose(), Et.dispose(), Et.removeEventListener("sessionstart", Dt), Et.removeEventListener("sessionend", Bt), z && (z.dispose(), z = null), Lt.stop() }, this.renderBufferDirect = function (t, e, n, i, r, s) { null === e && (e = H); const o = r.isMesh && r.matrixWorld.determinant() < 0, a = function (t, e, n, i, r) { !0 !== e.isScene && (e = H); Z.resetTextureUnits(); const s = e.fog, o = i.isMeshStandardMaterial ? e.environment : null, a = null === w ? b.outputEncoding : !0 === w.isXRRenderTarget ? w.texture.encoding : Ae, l = (i.isMeshStandardMaterial ? tt : $).get(i.envMap || o), h = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize, c = !!i.normalMap && !!n.attributes.tangent, u = !!n.morphAttributes.position, d = !!n.morphAttributes.normal, p = !!n.morphAttributes.color, f = i.toneMapped ? b.toneMapping : K, g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color, v = void 0 !== g ? g.length : 0, A = J.get(i), y = m.state.lights; if (!0 === N && (!0 === U || t !== C)) { const e = t === C && i.id === E; lt.setState(i, t, e) } let x = !1; i.version === A.__version ? A.needsLights && A.lightsStateVersion !== y.state.version || A.outputEncoding !== a || r.isInstancedMesh && !1 === A.instancing ? x = !0 : r.isInstancedMesh || !0 !== A.instancing ? r.isSkinnedMesh && !1 === A.skinning ? x = !0 : r.isSkinnedMesh || !0 !== A.skinning ? A.envMap !== l || !0 === i.fog && A.fog !== s ? x = !0 : void 0 === A.numClippingPlanes || A.numClippingPlanes === lt.numPlanes && A.numIntersection === lt.numIntersection ? (A.vertexAlphas !== h || A.vertexTangents !== c || A.morphTargets !== u || A.morphNormals !== d || A.morphColors !== p || A.toneMapping !== f || !0 === q.isWebGL2 && A.morphTargetsCount !== v) && (x = !0) : x = !0 : x = !0 : x = !0 : (x = !0, A.__version = i.version); let _ = A.currentProgram; !0 === x && (_ = Nt(i, e, r)); let S = !1, M = !1, P = !1; const I = _.getUniforms(), B = A.uniforms; Y.useProgram(_.program) && (S = !0, M = !0, P = !0); i.id !== E && (E = i.id, M = !0); if (S || C !== t) { if (I.setValue(bt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && I.setValue(bt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), C !== t && (C = t, M = !0, P = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) { const e = I.map.cameraPosition; void 0 !== e && e.setValue(bt, G.setFromMatrixPosition(t.matrixWorld)) } (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && I.setValue(bt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && I.setValue(bt, "viewMatrix", t.matrixWorldInverse) } if (r.isSkinnedMesh) { I.setOptional(bt, r, "bindMatrix"), I.setOptional(bt, r, "bindMatrixInverse"); const t = r.skeleton; t && (q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), I.setValue(bt, "boneTexture", t.boneTexture, Z), I.setValue(bt, "boneTextureSize", t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const L = n.morphAttributes; (void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === q.isWebGL2) && ut.update(r, n, i, _); (M || A.receiveShadow !== r.receiveShadow) && (A.receiveShadow = r.receiveShadow, I.setValue(bt, "receiveShadow", r.receiveShadow)); i.isMeshGouraudMaterial && null !== i.envMap && (B.envMap.value = l, B.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1); M && (I.setValue(bt, "toneMappingExposure", b.toneMappingExposure), A.needsLights && (k = P, (F = B).ambientLightColor.needsUpdate = k, F.lightProbe.needsUpdate = k, F.directionalLights.needsUpdate = k, F.directionalLightShadows.needsUpdate = k, F.pointLights.needsUpdate = k, F.pointLightShadows.needsUpdate = k, F.spotLights.needsUpdate = k, F.spotLightShadows.needsUpdate = k, F.rectAreaLights.needsUpdate = k, F.hemisphereLights.needsUpdate = k), s && !0 === i.fog && st.refreshFogUniforms(B, s), st.refreshMaterialUniforms(B, i, D, T, z), go.upload(bt, A.uniformsList, B, Z)); var F, k; i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (go.upload(bt, A.uniformsList, B, Z), i.uniformsNeedUpdate = !1); i.isSpriteMaterial && I.setValue(bt, "center", r.center); if (I.setValue(bt, "modelViewMatrix", r.modelViewMatrix), I.setValue(bt, "normalMatrix", r.normalMatrix), I.setValue(bt, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) { const t = i.uniformsGroups; for (let e = 0, n = t.length; e < n; e++)if (q.isWebGL2) { const n = t[e]; At.update(n, _), At.bind(n, _) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return _ }(t, e, n, i, r); Y.setMaterial(i, o); let l = n.index, h = 1; !0 === i.wireframe && (l = nt.getWireframeAttribute(n), h = 2); const c = n.drawRange, u = n.attributes.position; let d = c.start * h, p = (c.start + c.count) * h; null !== s && (d = Math.max(d, s.start * h), p = Math.min(p, (s.start + s.count) * h)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != u && (d = Math.max(d, 0), p = Math.min(p, u.count)); const f = p - d; if (f < 0 || f === 1 / 0) return; let g; vt.setup(r, i, a, n, l); let v = dt; if (null !== l && (g = et.get(l), v = pt, v.setIndex(g)), r.isMesh) !0 === i.wireframe ? (Y.setLineWidth(i.wireframeLinewidth * j()), v.setMode(1)) : v.setMode(4); else if (r.isLine) { let t = i.linewidth; void 0 === t && (t = 1), Y.setLineWidth(t * j()), r.isLineSegments ? v.setMode(1) : r.isLineLoop ? v.setMode(2) : v.setMode(3) } else r.isPoints ? v.setMode(0) : r.isSprite && v.setMode(4); if (r.isInstancedMesh) v.renderInstances(d, f, r.count); else if (n.isInstancedBufferGeometry) { const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0, e = Math.min(n.instanceCount, t); v.renderInstances(d, f, e) } else v.render(d, f) }, this.compile = function (t, e) { function n(t, e, n) { !0 === t.transparent && t.side === g ? (t.side = f, t.needsUpdate = !0, Nt(t, e, n), t.side = p, t.needsUpdate = !0, Nt(t, e, n), t.side = g) : Nt(t, e, n) } m = at.get(t), m.init(), A.push(m), t.traverseVisible((function (t) { t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t)) })), m.setupLights(b.physicallyCorrectLights), t.traverse((function (e) { const i = e.material; if (i) if (Array.isArray(i)) for (let r = 0; r < i.length; r++) { n(i[r], t, e) } else n(i, t, e) })), A.pop(), m = null }; let Tt = null; function Dt() { Lt.stop() } function Bt() { Lt.start() } const Lt = new Pr; function Ft(t, e, n, i) { if (!1 === t.visible) return; if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || O.intersectsSprite(t)) { i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V); const e = it.update(t), r = t.material; r.visible && d.push(t, e, r, n, G.z, null) } } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== X.render.frame && (t.skeleton.update(), t.skeleton.frame = X.render.frame), !t.frustumCulled || O.intersectsObject(t))) { i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V); const e = it.update(t), r = t.material; if (Array.isArray(r)) { const i = e.groups; for (let s = 0, o = i.length; s < o; s++) { const o = i[s], a = r[o.materialIndex]; a && a.visible && d.push(t, e, a, n, G.z, o) } } else r.visible && d.push(t, e, r, n, G.z, null) } const r = t.children; for (let t = 0, s = r.length; t < s; t++)Ft(r[t], e, n, i) } function kt(t, e, n, i) { const r = t.opaque, s = t.transmissive, a = t.transparent; m.setupLightsView(n), s.length > 0 && function (t, e, n) { const i = q.isWebGL2; null === z && (z = new fn(1, 1, { generateMipmaps: !0, type: W.has("EXT_color_buffer_half_float") ? wt : gt, minFilter: mt, samples: i && !0 === o ? 4 : 0 })); b.getDrawingBufferSize(Q), i ? z.setSize(Q.x, Q.y) : z.setSize(ze(Q.x), ze(Q.y)); const r = b.getRenderTarget(); b.setRenderTarget(z), b.clear(); const s = b.toneMapping; b.toneMapping = K, Rt(t, e, n), b.toneMapping = s, Z.updateMultisampleRenderTarget(z), Z.updateRenderTargetMipmap(z), b.setRenderTarget(r) }(r, e, n), i && Y.viewport(S.copy(i)), r.length > 0 && Rt(r, e, n), s.length > 0 && Rt(s, e, n), a.length > 0 && Rt(a, e, n), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1) } function Rt(t, e, n) { const i = !0 === e.isScene ? e.overrideMaterial : null; for (let r = 0, s = t.length; r < s; r++) { const s = t[r], o = s.object, a = s.geometry, l = null === i ? s.material : i, h = s.group; o.layers.test(n.layers) && Ot(o, e, n, a, l, h) } } function Ot(t, e, n, i, r, s) { t.onBeforeRender(b, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(b, e, n, i, t, s), !0 === r.transparent && r.side === g ? (r.side = f, r.needsUpdate = !0, b.renderBufferDirect(n, e, i, r, t, s), r.side = p, r.needsUpdate = !0, b.renderBufferDirect(n, e, i, r, t, s), r.side = g) : b.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(b, e, n, i, r, s) } function Nt(t, e, n) { !0 !== e.isScene && (e = H); const i = J.get(t), r = m.state.lights, s = m.state.shadowsArray, o = r.state.version, a = rt.getParameters(t, r.state, s, e, n), l = rt.getProgramCacheKey(a); let h = i.programs; i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? tt : $).get(t.envMap || i.environment), void 0 === h && (t.addEventListener("dispose", Pt), h = new Map, i.programs = h); let c = h.get(l); if (void 0 !== c) { if (i.currentProgram === c && i.lightsStateVersion === o) return Ut(t, a), c } else a.uniforms = rt.getUniforms(t), t.onBuild(n, a, b), t.onBeforeCompile(a, b), c = rt.acquireProgram(a, l), h.set(l, c), i.uniforms = a.uniforms; const u = i.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = lt.uniform), Ut(t, a), i.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotLightMatrix.value = r.state.spotLightMatrix, u.spotLightMap.value = r.state.spotLightMap, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix); const d = c.getUniforms(), p = go.seqWithValue(d.seq, u); return i.currentProgram = c, i.uniformsList = p, c } function Ut(t, e) { const n = J.get(t); n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping } Lt.setAnimationLoop((function (t) { Tt && Tt(t) })), "undefined" != typeof self && Lt.setContext(self), this.setAnimationLoop = function (t) { Tt = t, Et.setAnimationLoop(t), null === t ? Lt.stop() : Lt.start() }, Et.addEventListener("sessionstart", Dt), Et.addEventListener("sessionend", Bt), this.render = function (t, e) { if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === y) return; !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === Et.enabled && !0 === Et.isPresenting && (!0 === Et.cameraAutoUpdate && Et.updateCamera(e), e = Et.getCamera()), !0 === t.isScene && t.onBeforeRender(b, t, e, w), m = at.get(t, A.length), m.init(), A.push(m), V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), O.setFromProjectionMatrix(V), U = this.localClippingEnabled, N = lt.init(this.clippingPlanes, U, e), d = ot.get(t, v.length), d.init(), v.push(d), Ft(t, e, 0, b.sortObjects), d.finish(), !0 === b.sortObjects && d.sort(B, L), !0 === N && lt.beginShadows(); const n = m.state.shadowsArray; if (ht.render(n, t, e), !0 === N && lt.endShadows(), !0 === this.info.autoReset && this.info.reset(), ct.render(d, t), m.setupLights(b.physicallyCorrectLights), e.isArrayCamera) { const n = e.cameras; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; kt(d, t, i, i.viewport) } } else kt(d, t, e); null !== w && (Z.updateMultisampleRenderTarget(w), Z.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(b, t, e), vt.resetDefaultState(), E = -1, C = null, A.pop(), m = A.length > 0 ? A[A.length - 1] : null, v.pop(), d = v.length > 0 ? v[v.length - 1] : null }, this.getActiveCubeFace = function () { return x }, this.getActiveMipmapLevel = function () { return _ }, this.getRenderTarget = function () { return w }, this.setRenderTargetTextures = function (t, e, n) { J.get(t.texture).__webglTexture = e, J.get(t.depthTexture).__webglTexture = n; const i = J.get(t); i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === W.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (t, e) { const n = J.get(t); n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e }, this.setRenderTarget = function (t, e = 0, n = 0) { w = t, x = e, _ = n; let i = !0, r = null, s = !1, o = !1; if (t) { const n = J.get(t); void 0 !== n.__useDefaultFramebuffer ? (Y.bindFramebuffer(36160, null), i = !1) : void 0 === n.__webglFramebuffer ? Z.setupRenderTarget(t) : n.__hasExternalTextures && Z.rebindTextures(t, J.get(t.texture).__webglTexture, J.get(t.depthTexture).__webglTexture); const a = t.texture; (a.isData3DTexture || a.isDataArrayTexture || a.isCompressedArrayTexture) && (o = !0); const l = J.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (r = l[e], s = !0) : r = q.isWebGL2 && t.samples > 0 && !1 === Z.useMultisampledRTT(t) ? J.get(t).__webglMultisampledFramebuffer : l, S.copy(t.viewport), M.copy(t.scissor), P = t.scissorTest } else S.copy(F).multiplyScalar(D).floor(), M.copy(k).multiplyScalar(D).floor(), P = R; if (Y.bindFramebuffer(36160, r) && q.drawBuffers && i && Y.drawBuffers(t, r), Y.viewport(S), Y.scissor(M), Y.setScissorTest(P), s) { const i = J.get(t.texture); bt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n) } else if (o) { const i = J.get(t.texture), r = e || 0; bt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r) } E = -1 }, this.readRenderTargetPixels = function (t, e, n, i, r, s, o) { if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let a = J.get(t).__webglFramebuffer; if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) { Y.bindFramebuffer(36160, a); try { const o = t.texture, a = o.format, l = o.type; if (a !== It && ft.convert(a) !== bt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const h = l === wt && (W.has("EXT_color_buffer_half_float") || q.isWebGL2 && W.has("EXT_color_buffer_float")); if (!(l === gt || ft.convert(l) === bt.getParameter(35738) || l === _t && (q.isWebGL2 || W.has("OES_texture_float") || W.has("WEBGL_color_buffer_float")) || h)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && bt.readPixels(e, n, i, r, ft.convert(a), ft.convert(l), s) } finally { const t = null !== w ? J.get(w).__webglFramebuffer : null; Y.bindFramebuffer(36160, t) } } }, this.copyFramebufferToTexture = function (t, e, n = 0) { const i = Math.pow(2, -n), r = Math.floor(e.image.width * i), s = Math.floor(e.image.height * i); Z.setTexture2D(e, 0), bt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s), Y.unbindTexture() }, this.copyTextureToTexture = function (t, e, n, i = 0) { const r = e.image.width, s = e.image.height, o = ft.convert(n.format), a = ft.convert(n.type); Z.setTexture2D(n, 0), bt.pixelStorei(37440, n.flipY), bt.pixelStorei(37441, n.premultiplyAlpha), bt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? bt.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? bt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : bt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && bt.generateMipmap(3553), Y.unbindTexture() }, this.copyTextureToTexture3D = function (t, e, n, i, r = 0) { if (b.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const s = t.max.x - t.min.x + 1, o = t.max.y - t.min.y + 1, a = t.max.z - t.min.z + 1, l = ft.convert(i.format), h = ft.convert(i.type); let c; if (i.isData3DTexture) Z.setTexture3D(i, 0), c = 32879; else { if (!i.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); Z.setTexture2DArray(i, 0), c = 35866 } bt.pixelStorei(37440, i.flipY), bt.pixelStorei(37441, i.premultiplyAlpha), bt.pixelStorei(3317, i.unpackAlignment); const u = bt.getParameter(3314), d = bt.getParameter(32878), p = bt.getParameter(3316), f = bt.getParameter(3315), m = bt.getParameter(32877), g = n.isCompressedTexture ? n.mipmaps[0] : n.image; bt.pixelStorei(3314, g.width), bt.pixelStorei(32878, g.height), bt.pixelStorei(3316, t.min.x), bt.pixelStorei(3315, t.min.y), bt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isData3DTexture ? bt.texSubImage3D(c, r, e.x, e.y, e.z, s, o, a, l, h, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), bt.compressedTexSubImage3D(c, r, e.x, e.y, e.z, s, o, a, l, g.data)) : bt.texSubImage3D(c, r, e.x, e.y, e.z, s, o, a, l, h, g), bt.pixelStorei(3314, u), bt.pixelStorei(32878, d), bt.pixelStorei(3316, p), bt.pixelStorei(3315, f), bt.pixelStorei(32877, m), 0 === r && i.generateMipmaps && bt.generateMipmap(c), Y.unbindTexture() }, this.initTexture = function (t) { t.isCubeTexture ? Z.setTextureCube(t, 0) : t.isData3DTexture ? Z.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? Z.setTexture2DArray(t, 0) : Z.setTexture2D(t, 0), Y.unbindTexture() }, this.resetState = function () { x = 0, _ = 0, w = null, Y.reset(), vt.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } (class extends ca { }).prototype.isWebGL1Renderer = !0; class ua extends bi { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this } toJSON(t) { const e = super.toJSON(t); return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.backgroundIntensity = this.backgroundIntensity), e } get autoUpdate() { return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate } set autoUpdate(t) { console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = t } } class da { constructor(t, e) { this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Se, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Fe() } onUploadCallback() { } set needsUpdate(t) { !0 === t && this.version++ } setUsage(t) { return this.usage = t, this } copy(t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this } copyAt(t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++)this.array[t + i] = e.array[n + i]; return this } set(t, e = 0) { return this.array.set(t, e), this } clone(t) { void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Fe()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(e, this.stride); return n.setUsage(this.usage), n } onUpload(t) { return this.onUploadCallback = t, this } toJSON(t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Fe()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const pa = new An; class fa { constructor(t, e, n, i = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = i } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(t) { this.data.needsUpdate = t } applyMatrix4(t) { for (let e = 0, n = this.data.count; e < n; e++)pa.fromBufferAttribute(this, e), pa.applyMatrix4(t), this.setXYZ(e, pa.x, pa.y, pa.z); return this } applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++)pa.fromBufferAttribute(this, e), pa.applyNormalMatrix(t), this.setXYZ(e, pa.x, pa.y, pa.z); return this } transformDirection(t) { for (let e = 0, n = this.count; e < n; e++)pa.fromBufferAttribute(this, e), pa.transformDirection(t), this.setXYZ(e, pa.x, pa.y, pa.z); return this } setX(t, e) { return this.normalized && (e = Qe(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this } setY(t, e) { return this.normalized && (e = Qe(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this } setZ(t, e) { return this.normalized && (e = Qe(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this } setW(t, e) { return this.normalized && (e = Qe(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this } getX(t) { let e = this.data.array[t * this.data.stride + this.offset]; return this.normalized && (e = Ve(e, this.array)), e } getY(t) { let e = this.data.array[t * this.data.stride + this.offset + 1]; return this.normalized && (e = Ve(e, this.array)), e } getZ(t) { let e = this.data.array[t * this.data.stride + this.offset + 2]; return this.normalized && (e = Ve(e, this.array)), e } getW(t) { let e = this.data.array[t * this.data.stride + this.offset + 3]; return this.normalized && (e = Ve(e, this.array)), e } setXY(t, e, n) { return t = t * this.data.stride + this.offset, this.normalized && (e = Qe(e, this.array), n = Qe(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this } setXYZ(t, e, n, i) { return t = t * this.data.stride + this.offset, this.normalized && (e = Qe(e, this.array), n = Qe(n, this.array), i = Qe(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this } setXYZW(t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.normalized && (e = Qe(e, this.array), n = Qe(n, this.array), i = Qe(i, this.array), r = Qe(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this } clone(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return new Ri(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new fa(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } const ma = new An, ga = new pn, va = new pn, Aa = new An, ba = new Yn; class ya extends ar { constructor(t, e) { super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Yn, this.bindMatrixInverse = new Yn } copy(t, e) { return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this } bind(t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const t = new pn, e = this.geometry.attributes.skinWeight; for (let n = 0, i = e.count; n < i; n++) { t.fromBufferAttribute(e, n); const i = 1 / t.manhattanLength(); i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w) } } updateMatrixWorld(t) { super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(t, e) { const n = this.skeleton, i = this.geometry; ga.fromBufferAttribute(i.attributes.skinIndex, t), va.fromBufferAttribute(i.attributes.skinWeight, t), ma.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0); for (let t = 0; t < 4; t++) { const i = va.getComponent(t); if (0 !== i) { const r = ga.getComponent(t); ba.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Aa.copy(ma).applyMatrix4(ba), i) } } return e.applyMatrix4(this.bindMatrixInverse) } } class xa extends bi { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class _a extends dn { constructor(t = null, e = 1, n = 1, i, r, s, o, a, l = ct, h = ct, c, u) { super(null, s, o, a, l, h, i, r, c, u), this.isDataTexture = !0, this.image = { data: t, width: e, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const wa = new Yn, Ea = new Yn; class Ca { constructor(t = [], e = []) { this.uuid = Fe(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const t = this.bones, e = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses(); else if (t.length !== e.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++)this.boneInverses.push(new Yn) } } calculateInverses() { this.boneInverses.length = 0; for (let t = 0, e = this.bones.length; t < e; t++) { const e = new Yn; this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e) } } pose() { for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && e.matrixWorld.copy(this.boneInverses[t]).invert() } for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) } } update() { const t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture; for (let i = 0, r = t.length; i < r; i++) { const r = t[i] ? t[i].matrixWorld : Ea; wa.multiplyMatrices(r, e[i]), wa.toArray(n, 16 * i) } null !== i && (i.needsUpdate = !0) } clone() { return new Ca(this.bones, this.boneInverses) } computeBoneTexture() { let t = Math.sqrt(4 * this.bones.length); t = Ue(t), t = Math.max(t, 4); const e = new Float32Array(t * t * 4); e.set(this.boneMatrices); const n = new _a(e, t, t, It, _t); return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this } getBoneByName(t) { for (let e = 0, n = this.bones.length; e < n; e++) { const n = this.bones[e]; if (n.name === t) return n } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(t, e) { this.uuid = t.uuid; for (let n = 0, i = t.bones.length; n < i; n++) { const i = t.bones[n]; let r = e[i]; void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new xa), this.bones.push(r), this.boneInverses.push((new Yn).fromArray(t.boneInverses[n])) } return this.init(), this } toJSON() { const t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; t.uuid = this.uuid; const e = this.bones, n = this.boneInverses; for (let i = 0, r = e.length; i < r; i++) { const r = e[i]; t.bones.push(r.uuid); const s = n[i]; t.boneInverses.push(s.toArray()) } return t } } class Sa extends Ri { constructor(t, e, n, i = 1) { super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i } copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this } toJSON() { const t = super.toJSON(); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } } const Ma = new Yn, Pa = new Yn, Ia = [], Ta = new Yn, Da = new ar; class Ba extends ar { constructor(t, e, n) { super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new Sa(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1; for (let t = 0; t < n; t++)this.setMatrixAt(t, Ta) } copy(t, e) { return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this } getColorAt(t, e) { e.fromArray(this.instanceColor.array, 3 * t) } getMatrixAt(t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) } raycast(t, e) { const n = this.matrixWorld, i = this.count; if (Da.geometry = this.geometry, Da.material = this.material, void 0 !== Da.material) for (let r = 0; r < i; r++) { this.getMatrixAt(r, Ma), Pa.multiplyMatrices(n, Ma), Da.matrixWorld = Pa, Da.raycast(t, Ia); for (let t = 0, n = Ia.length; t < n; t++) { const n = Ia[t]; n.instanceId = r, n.object = this, e.push(n) } Ia.length = 0 } } setColorAt(t, e) { null === this.instanceColor && (this.instanceColor = new Sa(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t) } setMatrixAt(t, e) { e.toArray(this.instanceMatrix.array, 16 * t) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class La extends Bi { constructor(t) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new on(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this } } const Fa = new An, ka = new An, Ra = new Yn, Oa = new qn, Na = new Un; class Ua extends bi { constructor(t = new qi, e = new La) { super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t, e) { return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this } computeLineDistances() { const t = this.geometry; if (null === t.index) { const e = t.attributes.position, n = [0]; for (let t = 1, i = e.count; t < i; t++)Fa.fromBufferAttribute(e, t - 1), ka.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Fa.distanceTo(ka); t.setAttribute("lineDistance", new Ui(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Line.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), Na.copy(n.boundingSphere), Na.applyMatrix4(i), Na.radius += r, !1 === t.ray.intersectsSphere(Na)) return; Ra.copy(i).invert(), Oa.copy(t.ray).applyMatrix4(Ra); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, l = new An, h = new An, c = new An, u = new An, d = this.isLineSegments ? 2 : 1, p = n.index, f = n.attributes.position; if (null !== p) { for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) { const i = p.getX(n), r = p.getX(n + 1); l.fromBufferAttribute(f, i), h.fromBufferAttribute(f, r); if (Oa.distanceSqToSegment(l, h, u, c) > a) continue; u.applyMatrix4(this.matrixWorld); const s = t.ray.origin.distanceTo(u); s < t.near || s > t.far || e.push({ distance: s, point: c.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else { for (let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1; n < i; n += d) { l.fromBufferAttribute(f, n), h.fromBufferAttribute(f, n + 1); if (Oa.distanceSqToSegment(l, h, u, c) > a) continue; u.applyMatrix4(this.matrixWorld); const i = t.ray.origin.distanceTo(u); i < t.near || i > t.far || e.push({ distance: i, point: c.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const t = this.geometry.morphAttributes, e = Object.keys(t); if (e.length > 0) { const n = t[e[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, e = n.length; t < e; t++) { const e = n[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t } } } } } const za = new An, Va = new An; class Qa extends Ua { constructor(t, e) { super(t, e), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const t = this.geometry; if (null === t.index) { const e = t.attributes.position, n = []; for (let t = 0, i = e.count; t < i; t += 2)za.fromBufferAttribute(e, t), Va.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + za.distanceTo(Va); t.setAttribute("lineDistance", new Ui(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class Ga extends Ua { constructor(t, e) { super(t, e), this.isLineLoop = !0, this.type = "LineLoop" } } class Ha extends Bi { constructor(t) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new on(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this } } const ja = new Yn, Wa = new qn, qa = new Un, Ya = new An; class Xa extends bi { constructor(t = new qi, e = new Ha) { super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t, e) { return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this } raycast(t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Points.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), qa.copy(n.boundingSphere), qa.applyMatrix4(i), qa.radius += r, !1 === t.ray.intersectsSphere(qa)) return; ja.copy(i).invert(), Wa.copy(t.ray).applyMatrix4(ja); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, l = n.index, h = n.attributes.position; if (null !== l) { for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) { const r = l.getX(n); Ya.fromBufferAttribute(h, r), Ka(Ya, r, a, i, t, e, this) } } else { for (let n = Math.max(0, s.start), r = Math.min(h.count, s.start + s.count); n < r; n++)Ya.fromBufferAttribute(h, n), Ka(Ya, n, a, i, t, e, this) } } updateMorphTargets() { const t = this.geometry.morphAttributes, e = Object.keys(t); if (e.length > 0) { const n = t[e[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, e = n.length; t < e; t++) { const e = n[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t } } } } } function Ka(t, e, n, i, r, s, o) { const a = Wa.distanceSqToPoint(t); if (a < n) { const n = new An; Wa.closestPointToPoint(t, n), n.applyMatrix4(i); const l = r.ray.origin.distanceTo(n); if (l < r.near || l > r.far) return; s.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: o }) } } class Ja extends dn { constructor(t, e, n, i, r, s, o, a, l, h, c, u) { super(null, s, o, a, l, h, i, r, c, u), this.isCompressedTexture = !0, this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } } class Za extends Ja { constructor(t, e, n, i, r, s) { super(t, e, n, r, s), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = lt } } class $a { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) } getPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e } getSpacedPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e } getLength() { const t = this.getLengths(); return t[t.length - 1] } getLengths(t = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const e = []; let n, i = this.getPoint(0), r = 0; e.push(0); for (let s = 1; s <= t; s++)n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n; return this.cacheArcLengths = e, e } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(t, e) { const n = this.getLengths(); let i = 0; const r = n.length; let s; s = e || t * n[r - 1]; let o, a = 0, l = r - 1; for (; a <= l;)if (i = Math.floor(a + (l - a) / 2), o = n[i] - s, o < 0) a = i + 1; else { if (!(o > 0)) { l = i; break } l = i - 1 } if (i = l, n[i] === s) return i / (r - 1); const h = n[i]; return (i + (s - h) / (n[i + 1] - h)) / (r - 1) } getTangent(t, e) { const n = 1e-4; let i = t - n, r = t + n; i < 0 && (i = 0), r > 1 && (r = 1); const s = this.getPoint(i), o = this.getPoint(r), a = e || (s.isVector2 ? new He : new An); return a.copy(o).sub(s).normalize(), a } getTangentAt(t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) } computeFrenetFrames(t, e) { const n = new An, i = [], r = [], s = [], o = new An, a = new Yn; for (let e = 0; e <= t; e++) { const n = e / t; i[e] = this.getTangentAt(n, new An) } r[0] = new An, s[0] = new An; let l = Number.MAX_VALUE; const h = Math.abs(i[0].x), c = Math.abs(i[0].y), u = Math.abs(i[0].z); h <= l && (l = h, n.set(1, 0, 0)), c <= l && (l = c, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]); for (let e = 1; e <= t; e++) { if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) { o.normalize(); const t = Math.acos(ke(i[e - 1].dot(i[e]), -1, 1)); r[e].applyMatrix4(a.makeRotationAxis(o, t)) } s[e].crossVectors(i[e], r[e]) } if (!0 === e) { let e = Math.acos(ke(r[0].dot(r[t]), -1, 1)); e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e); for (let n = 1; n <= t; n++)r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n]) } return { tangents: i, normals: r, binormals: s } } clone() { return (new this.constructor).copy(this) } copy(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } toJSON() { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t } fromJSON(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } } function tl() { let t = 0, e = 0, n = 0, i = 0; function r(r, s, o, a) { t = r, e = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a } return { initCatmullRom: function (t, e, n, i, s) { r(e, n, s * (n - t), s * (i - e)) }, initNonuniformCatmullRom: function (t, e, n, i, s, o, a) { let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o, h = (n - e) / o - (i - e) / (o + a) + (i - n) / a; l *= o, h *= o, r(e, n, l, h) }, calc: function (r) { const s = r * r; return t + e * r + n * s + i * (s * r) } } } const el = new An, nl = new tl, il = new tl, rl = new tl; class sl extends $a { constructor(t = [], e = !1, n = "centripetal", i = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i } getPoint(t, e = new An) { const n = e, i = this.points, r = i.length, s = (r - (this.closed ? 0 : 1)) * t; let o, a, l = Math.floor(s), h = s - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === h && l === r - 1 && (l = r - 2, h = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (el.subVectors(i[0], i[1]).add(i[0]), o = el); const c = i[l % r], u = i[(l + 1) % r]; if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (el.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = el), "centripetal" === this.curveType || "chordal" === this.curveType) { const t = "chordal" === this.curveType ? .5 : .25; let e = Math.pow(o.distanceToSquared(c), t), n = Math.pow(c.distanceToSquared(u), t), i = Math.pow(u.distanceToSquared(a), t); n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), nl.initNonuniformCatmullRom(o.x, c.x, u.x, a.x, e, n, i), il.initNonuniformCatmullRom(o.y, c.y, u.y, a.y, e, n, i), rl.initNonuniformCatmullRom(o.z, c.z, u.z, a.z, e, n, i) } else "catmullrom" === this.curveType && (nl.initCatmullRom(o.x, c.x, u.x, a.x, this.tension), il.initCatmullRom(o.y, c.y, u.y, a.y, this.tension), rl.initCatmullRom(o.z, c.z, u.z, a.z, this.tension)); return n.set(nl.calc(h), il.calc(h), rl.calc(h)), n } copy(t) { super.copy(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push(n.clone()) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this } toJSON() { const t = super.toJSON(); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { const n = this.points[e]; t.points.push(n.toArray()) } return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t } fromJSON(t) { super.fromJSON(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new An).fromArray(n)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this } } const ol = new An, al = new An, ll = new An, hl = new Ti; class cl extends qi { constructor(t = null, e = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: t, thresholdAngle: e }, null !== t) { const n = 4, i = Math.pow(10, n), r = Math.cos(Be * e), s = t.getIndex(), o = t.getAttribute("position"), a = s ? s.count : o.count, l = [0, 0, 0], h = ["a", "b", "c"], c = new Array(3), u = {}, d = []; for (let t = 0; t < a; t += 3) { s ? (l[0] = s.getX(t), l[1] = s.getX(t + 1), l[2] = s.getX(t + 2)) : (l[0] = t, l[1] = t + 1, l[2] = t + 2); const { a: e, b: n, c: a } = hl; if (e.fromBufferAttribute(o, l[0]), n.fromBufferAttribute(o, l[1]), a.fromBufferAttribute(o, l[2]), hl.getNormal(ll), c[0] = `${Math.round(e.x * i)},${Math.round(e.y * i)},${Math.round(e.z * i)}`, c[1] = `${Math.round(n.x * i)},${Math.round(n.y * i)},${Math.round(n.z * i)}`, c[2] = `${Math.round(a.x * i)},${Math.round(a.y * i)},${Math.round(a.z * i)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0]) for (let t = 0; t < 3; t++) { const e = (t + 1) % 3, n = c[t], i = c[e], s = hl[h[t]], o = hl[h[e]], a = `${n}_${i}`, p = `${i}_${n}`; p in u && u[p] ? (ll.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(o.x, o.y, o.z)), u[p] = null) : a in u || (u[a] = { index0: l[t], index1: l[e], normal: ll.clone() }) } } for (const t in u) if (u[t]) { const { index0: e, index1: n } = u[t]; ol.fromBufferAttribute(o, e), al.fromBufferAttribute(o, n), d.push(ol.x, ol.y, ol.z), d.push(al.x, al.y, al.z) } this.setAttribute("position", new Ui(d, 3)) } } } class ul extends qi { constructor(t = 1, e = 32, n = 16, i = 0, r = 2 * Math.PI, s = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: s, thetaLength: o }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n)); const a = Math.min(s + o, Math.PI); let l = 0; const h = [], c = new An, u = new An, d = [], p = [], f = [], m = []; for (let d = 0; d <= n; d++) { const g = [], v = d / n; let A = 0; 0 == d && 0 == s ? A = .5 / e : d == n && a == Math.PI && (A = -.5 / e); for (let n = 0; n <= e; n++) { const a = n / e; c.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o), c.y = t * Math.cos(s + v * o), c.z = t * Math.sin(i + a * r) * Math.sin(s + v * o), p.push(c.x, c.y, c.z), u.copy(c).normalize(), f.push(u.x, u.y, u.z), m.push(a + A, 1 - v), g.push(l++) } h.push(g) } for (let t = 0; t < n; t++)for (let i = 0; i < e; i++) { const e = h[t][i + 1], r = h[t][i], o = h[t + 1][i], l = h[t + 1][i + 1]; (0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || a < Math.PI) && d.push(r, o, l) } this.setIndex(d), this.setAttribute("position", new Ui(p, 3)), this.setAttribute("normal", new Ui(f, 3)), this.setAttribute("uv", new Ui(m, 2)) } static fromJSON(t) { return new ul(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength) } } class dl extends qi { constructor(t = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: t }, null !== t) { const e = [], n = new Set, i = new An, r = new An; if (null !== t.index) { const s = t.attributes.position, o = t.index; let a = t.groups; 0 === a.length && (a = [{ start: 0, count: o.count, materialIndex: 0 }]); for (let t = 0, l = a.length; t < l; ++t) { const l = a[t], h = l.start; for (let t = h, a = h + l.count; t < a; t += 3)for (let a = 0; a < 3; a++) { const l = o.getX(t + a), h = o.getX(t + (a + 1) % 3); i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, h), !0 === pl(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z)) } } } else { const s = t.attributes.position; for (let t = 0, o = s.count / 3; t < o; t++)for (let o = 0; o < 3; o++) { const a = 3 * t + o, l = 3 * t + (o + 1) % 3; i.fromBufferAttribute(s, a), r.fromBufferAttribute(s, l), !0 === pl(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z)) } } this.setAttribute("position", new Ui(e, 3)) } } } function pl(t, e, n) { const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`; return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i), n.add(r), !0) } class fl extends fr { constructor(t) { super(t), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class ml extends Bi { constructor(t) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new on(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new on(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xe, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t) } copy(t) { return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this } } class gl extends ml { constructor(t) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new He(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return ke(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new on(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new on(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new on(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(t) } get sheen() { return this._sheen } set sheen(t) { this._sheen > 0 != t > 0 && this.version++, this._sheen = t } get clearcoat() { return this._clearcoat } set clearcoat(t) { this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t } get iridescence() { return this._iridescence } set iridescence(t) { this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t } get transmission() { return this._transmission } set transmission(t) { this._transmission > 0 != t > 0 && this.version++, this._transmission = t } copy(t) { return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this } } function vl(t, e, n) { return bl(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) } function Al(t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) } function bl(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) } function yl(t) { const e = t.length, n = new Array(e); for (let t = 0; t !== e; ++t)n[t] = t; return n.sort((function (e, n) { return t[e] - t[n] })), n } function xl(t, e, n) { const i = t.length, r = new t.constructor(i); for (let s = 0, o = 0; o !== i; ++s) { const i = n[s] * e; for (let n = 0; n !== e; ++n)r[o++] = t[i + n] } return r } function _l(t, e, n, i) { let r = 1, s = t[0]; for (; void 0 !== s && void 0 === s[i];)s = t[r++]; if (void 0 === s) return; let o = s[i]; if (void 0 !== o) if (Array.isArray(o)) do { o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++] } while (void 0 !== s); else if (void 0 !== o.toArray) do { o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++] } while (void 0 !== s); else do { o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++] } while (void 0 !== s) } class wl { constructor(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(t) { const e = this.parameterPositions; let n = this._cachedIndex, i = e[n], r = e[n - 1]; t: { e: { let s; n: { i: if (!(t < i)) { for (let s = n + 2; ;) { if (void 0 === i) { if (t < r) break i; return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } if (n === s) break; if (r = i, i = e[++n], t < i) break e } s = e.length; break n } if (t >= r) break t; { const o = e[1]; t < o && (n = 2, r = o); for (let s = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0); if (n === s) break; if (i = r, r = e[--n - 1], t >= r) break e } s = n, n = 0 } } for (; n < s;) { const i = n + s >>> 1; t < e[i] ? s = i : n = i + 1 } if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0); if (void 0 === i) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, t, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(t) { const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i; for (let t = 0; t !== i; ++t)e[t] = n[r + t]; return e } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class El extends wl { constructor(t, e, n, i) { super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: fe, endingEnd: fe } } intervalChanged_(t, e, n) { const i = this.parameterPositions; let r = t - 2, s = t + 1, o = i[r], a = i[s]; if (void 0 === o) switch (this.getSettings_().endingStart) { case me: r = t, o = 2 * e - n; break; case ge: r = i.length - 2, o = e + i[r] - i[r + 1]; break; default: r = t, o = n }if (void 0 === a) switch (this.getSettings_().endingEnd) { case me: s = t, a = 2 * n - e; break; case ge: s = 1, a = n + i[1] - i[0]; break; default: s = t - 1, a = e }const l = .5 * (n - e), h = this.valueSize; this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * h, this._offsetNext = s * h } interpolate_(t, e, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = t * o, l = a - o, h = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (n - e) / (i - e), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, A = (-1 - d) * m + (1.5 + d) * f + .5 * p, b = d * m - d * f; for (let t = 0; t !== o; ++t)r[t] = g * s[h + t] + v * s[l + t] + A * s[a + t] + b * s[c + t]; return r } } class Cl extends wl { constructor(t, e, n, i) { super(t, e, n, i) } interpolate_(t, e, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = t * o, l = a - o, h = (n - e) / (i - e), c = 1 - h; for (let t = 0; t !== o; ++t)r[t] = s[l + t] * c + s[a + t] * h; return r } } class Sl extends wl { constructor(t, e, n, i) { super(t, e, n, i) } interpolate_(t) { return this.copySampleValue_(t - 1) } } class Ml { constructor(t, e, n, i) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = Al(e, this.TimeBufferType), this.values = Al(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } static toJSON(t) { const e = t.constructor; let n; if (e.toJSON !== this.toJSON) n = e.toJSON(t); else { n = { name: t.name, times: Al(t.times, Array), values: Al(t.values, Array) }; const e = t.getInterpolation(); e !== t.DefaultInterpolation && (n.interpolation = e) } return n.type = t.ValueTypeName, n } InterpolantFactoryMethodDiscrete(t) { return new Sl(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodLinear(t) { return new Cl(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodSmooth(t) { return new El(this.times, this.values, this.getValueSize(), t) } setInterpolation(t) { let e; switch (t) { case ue: e = this.InterpolantFactoryMethodDiscrete; break; case de: e = this.InterpolantFactoryMethodLinear; break; case pe: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return ue; case this.InterpolantFactoryMethodLinear: return de; case this.InterpolantFactoryMethodSmooth: return pe } } getValueSize() { return this.values.length / this.times.length } shift(t) { if (0 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] += t } return this } scale(t) { if (1 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] *= t } return this } trim(t, e) { const n = this.times, i = n.length; let r = 0, s = i - 1; for (; r !== i && n[r] < t;)++r; for (; -1 !== s && n[s] > e;)--s; if (++s, 0 !== r || s !== i) { r >= s && (s = Math.max(s, 1), r = s - 1); const t = this.getValueSize(); this.times = vl(n, r, s), this.values = vl(this.values, r * t, s * t) } return this } validate() { let t = !0; const e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); const n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let s = null; for (let e = 0; e !== r; e++) { const i = n[e]; if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1; break } if (null !== s && s > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1; break } s = i } if (void 0 !== i && bl(i)) for (let e = 0, n = i.length; e !== n; ++e) { const n = i[e]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1; break } } return t } optimize() { const t = vl(this.times), e = vl(this.values), n = this.getValueSize(), i = this.getInterpolation() === pe, r = t.length - 1; let s = 1; for (let o = 1; o < r; ++o) { let r = !1; const a = t[o]; if (a !== t[o + 1] && (1 !== o || a !== t[0])) if (i) r = !0; else { const t = o * n, i = t - n, s = t + n; for (let o = 0; o !== n; ++o) { const n = e[t + o]; if (n !== e[i + o] || n !== e[s + o]) { r = !0; break } } } if (r) { if (o !== s) { t[s] = t[o]; const i = o * n, r = s * n; for (let t = 0; t !== n; ++t)e[r + t] = e[i + t] } ++s } } if (r > 0) { t[s] = t[r]; for (let t = r * n, i = s * n, o = 0; o !== n; ++o)e[i + o] = e[t + o]; ++s } return s !== t.length ? (this.times = vl(t, 0, s), this.values = vl(e, 0, s * n)) : (this.times = t, this.values = e), this } clone() { const t = vl(this.times, 0), e = vl(this.values, 0), n = new (0, this.constructor)(this.name, t, e); return n.createInterpolant = this.createInterpolant, n } } Ml.prototype.TimeBufferType = Float32Array, Ml.prototype.ValueBufferType = Float32Array, Ml.prototype.DefaultInterpolation = de; class Pl extends Ml { } Pl.prototype.ValueTypeName = "bool", Pl.prototype.ValueBufferType = Array, Pl.prototype.DefaultInterpolation = ue, Pl.prototype.InterpolantFactoryMethodLinear = void 0, Pl.prototype.InterpolantFactoryMethodSmooth = void 0; class Il extends Ml { } Il.prototype.ValueTypeName = "color"; class Tl extends Ml { } Tl.prototype.ValueTypeName = "number"; class Dl extends wl { constructor(t, e, n, i) { super(t, e, n, i) } interpolate_(t, e, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = (n - e) / (i - e); let l = t * o; for (let t = l + o; l !== t; l += 4)vn.slerpFlat(r, 0, s, l - o, s, l, a); return r } } class Bl extends Ml { InterpolantFactoryMethodLinear(t) { return new Dl(this.times, this.values, this.getValueSize(), t) } } Bl.prototype.ValueTypeName = "quaternion", Bl.prototype.DefaultInterpolation = de, Bl.prototype.InterpolantFactoryMethodSmooth = void 0; class Ll extends Ml { } Ll.prototype.ValueTypeName = "string", Ll.prototype.ValueBufferType = Array, Ll.prototype.DefaultInterpolation = ue, Ll.prototype.InterpolantFactoryMethodLinear = void 0, Ll.prototype.InterpolantFactoryMethodSmooth = void 0; class Fl extends Ml { } Fl.prototype.ValueTypeName = "vector"; class kl { constructor(t, e = -1, n, i = 2500) { this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Fe(), this.duration < 0 && this.resetDuration() } static parse(t) { const e = [], n = t.tracks, i = 1 / (t.fps || 1); for (let t = 0, r = n.length; t !== r; ++t)e.push(Rl(n[t]).scale(i)); const r = new this(t.name, t.duration, e, t.blendMode); return r.uuid = t.uuid, r } static toJSON(t) { const e = [], n = t.tracks, i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }; for (let t = 0, i = n.length; t !== i; ++t)e.push(Ml.toJSON(n[t])); return i } static CreateFromMorphTargetSequence(t, e, n, i) { const r = e.length, s = []; for (let t = 0; t < r; t++) { let o = [], a = []; o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0); const l = yl(o); o = xl(o, 1, l), a = xl(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new Tl(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n)) } return new this(t, -1, s) } static findByName(t, e) { let n = t; if (!Array.isArray(t)) { const e = t; n = e.geometry && e.geometry.animations || e.animations } for (let t = 0; t < n.length; t++)if (n[t].name === e) return n[t]; return null } static CreateClipsFromMorphTargetSequences(t, e, n) { const i = {}, r = /^([\w-]*?)([\d]+)$/; for (let e = 0, n = t.length; e < n; e++) { const n = t[e], s = n.name.match(r); if (s && s.length > 1) { const t = s[1]; let e = i[t]; e || (i[t] = e = []), e.push(n) } } const s = []; for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n)); return s } static parseAnimation(t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (t, e, n, i, r) { if (0 !== n.length) { const s = [], o = []; _l(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o)) } }, i = [], r = t.name || "default", s = t.fps || 30, o = t.blendMode; let a = t.length || -1; const l = t.hierarchy || []; for (let t = 0; t < l.length; t++) { const r = l[t].keys; if (r && 0 !== r.length) if (r[0].morphTargets) { const t = {}; let e; for (e = 0; e < r.length; e++)if (r[e].morphTargets) for (let n = 0; n < r[e].morphTargets.length; n++)t[r[e].morphTargets[n]] = -1; for (const n in t) { const t = [], s = []; for (let i = 0; i !== r[e].morphTargets.length; ++i) { const i = r[e]; t.push(i.time), s.push(i.morphTarget === n ? 1 : 0) } i.push(new Tl(".morphTargetInfluence[" + n + "]", t, s)) } a = t.length * s } else { const s = ".bones[" + e[t].name + "]"; n(Fl, s + ".position", r, "pos", i), n(Bl, s + ".quaternion", r, "rot", i), n(Fl, s + ".scale", r, "scl", i) } } if (0 === i.length) return null; return new this(r, a, i, o) } resetDuration() { let t = 0; for (let e = 0, n = this.tracks.length; e !== n; ++e) { const n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this } trim() { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this } validate() { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t } optimize() { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this } clone() { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function Rl(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Tl; case "vector": case "vector2": case "vector3": case "vector4": return Fl; case "color": return Il; case "quaternion": return Bl; case "bool": case "boolean": return Pl; case "string": return Ll }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); if (void 0 === t.times) { const e = [], n = []; _l(t.keys, e, n, "value"), t.times = e, t.values = n } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } const Ol = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; class Nl { constructor(t, e, n) { const i = this; let r, s = !1, o = 0, a = 0; const l = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), s = !0 }, this.itemEnd = function (t) { o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function (t) { return r ? r(t) : t }, this.setURLModifier = function (t) { return r = t, this }, this.addHandler = function (t, e) { return l.push(t, e), this }, this.removeHandler = function (t) { const e = l.indexOf(t); return -1 !== e && l.splice(e, 2), this }, this.getHandler = function (t) { for (let e = 0, n = l.length; e < n; e += 2) { const n = l[e], i = l[e + 1]; if (n.global && (n.lastIndex = 0), n.test(t)) return i } return null } } } const Ul = new Nl; class zl { constructor(t) { this.manager = void 0 !== t ? t : Ul, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(t, e) { const n = this; return new Promise((function (i, r) { n.load(t, i, e, r) })) } parse() { } setCrossOrigin(t) { return this.crossOrigin = t, this } setWithCredentials(t) { return this.withCredentials = t, this } setPath(t) { return this.path = t, this } setResourcePath(t) { return this.resourcePath = t, this } setRequestHeader(t) { return this.requestHeader = t, this } } const Vl = {}; class Ql extends Error { constructor(t, e) { super(t), this.response = e } } class Gl extends zl { constructor(t) { super(t) } load(t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = Ol.get(t); if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => { e && e(r), this.manager.itemEnd(t) }), 0), r; if (void 0 !== Vl[t]) return void Vl[t].push({ onLoad: e, onProgress: n, onError: i }); Vl[t] = [], Vl[t].push({ onLoad: e, onProgress: n, onError: i }); const s = new Request(t, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o = this.mimeType, a = this.responseType; fetch(s).then((e => { if (200 === e.status || 0 === e.status) { if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e; const n = Vl[t], i = e.body.getReader(), r = e.headers.get("Content-Length") || e.headers.get("X-File-Size"), s = r ? parseInt(r) : 0, o = 0 !== s; let a = 0; const l = new ReadableStream({ start(t) { !function e() { i.read().then((({ done: i, value: r }) => { if (i) t.close(); else { a += r.byteLength; const i = new ProgressEvent("progress", { lengthComputable: o, loaded: a, total: s }); for (let t = 0, e = n.length; t < e; t++) { const e = n[t]; e.onProgress && e.onProgress(i) } t.enqueue(r), e() } })) }() } }); return new Response(l) } throw new Ql(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e) })).then((t => { switch (a) { case "arraybuffer": return t.arrayBuffer(); case "blob": return t.blob(); case "document": return t.text().then((t => (new DOMParser).parseFromString(t, o))); case "json": return t.json(); default: if (void 0 === o) return t.text(); { const e = /charset="?([^;"\s]*)"?/i.exec(o), n = e && e[1] ? e[1].toLowerCase() : void 0, i = new TextDecoder(n); return t.arrayBuffer().then((t => i.decode(t))) } } })).then((e => { Ol.add(t, e); const n = Vl[t]; delete Vl[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onLoad && i.onLoad(e) } })).catch((e => { const n = Vl[t]; if (void 0 === n) throw this.manager.itemError(t), e; delete Vl[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onError && i.onError(e) } this.manager.itemError(t) })).finally((() => { this.manager.itemEnd(t) })), this.manager.itemStart(t) } setResponseType(t) { return this.responseType = t, this } setMimeType(t) { return this.mimeType = t, this } } class Hl extends zl { constructor(t) { super(t) } load(t, e, n, i) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, s = Ol.get(t); if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () { e && e(s), r.manager.itemEnd(t) }), 0), s; const o = Ye("img"); function a() { h(), Ol.add(t, this), e && e(this), r.manager.itemEnd(t) } function l(e) { h(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) } function h() { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1) } return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o } } class jl extends zl { constructor(t) { super(t) } load(t, e, n, i) { const r = new dn, s = new Hl(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function (t) { r.image = t, r.needsUpdate = !0, void 0 !== e && e(r) }), n, i), r } } class Wl extends bi { constructor(t, e = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new on(t), this.intensity = e } dispose() { } copy(t, e) { return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this } toJSON(t) { const e = super.toJSON(t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } } const ql = new Yn, Yl = new An, Xl = new An; class Kl { constructor(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new He(512, 512), this.map = null, this.mapPass = null, this.matrix = new Yn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Mr, this._frameExtents = new He(1, 1), this._viewportCount = 1, this._viewports = [new pn(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(t) { const e = this.camera, n = this.matrix; Yl.setFromMatrixPosition(t.matrixWorld), e.position.copy(Yl), Xl.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Xl), e.updateMatrixWorld(), ql.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ql), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(ql) } getViewport(t) { return this._viewports[t] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } } class Jl extends Kl { constructor() { super(new gr(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(t) { const e = this.camera, n = 2 * Le * t.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = t.distance || e.far; n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t) } copy(t) { return super.copy(t), this.focus = t.focus, this } } class Zl extends Wl { constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 2) { super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(bi.DefaultUp), this.updateMatrix(), this.target = new bi, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.map = null, this.shadow = new Jl } get power() { return this.intensity * Math.PI } set power(t) { this.intensity = t / Math.PI } dispose() { this.shadow.dispose() } copy(t, e) { return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } } const $l = new Yn, th = new An, eh = new An; class nh extends Kl { constructor() { super(new gr(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new He(4, 2), this._viewportCount = 6, this._viewports = [new pn(2, 1, 1, 1), new pn(0, 1, 1, 1), new pn(3, 1, 1, 1), new pn(1, 1, 1, 1), new pn(3, 0, 1, 1), new pn(1, 0, 1, 1)], this._cubeDirections = [new An(1, 0, 0), new An(-1, 0, 0), new An(0, 0, 1), new An(0, 0, -1), new An(0, 1, 0), new An(0, -1, 0)], this._cubeUps = [new An(0, 1, 0), new An(0, 1, 0), new An(0, 1, 0), new An(0, 1, 0), new An(0, 0, 1), new An(0, 0, -1)] } updateMatrices(t, e = 0) { const n = this.camera, i = this.matrix, r = t.distance || n.far; r !== n.far && (n.far = r, n.updateProjectionMatrix()), th.setFromMatrixPosition(t.matrixWorld), n.position.copy(th), eh.copy(n.position), eh.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(eh), n.updateMatrixWorld(), i.makeTranslation(-th.x, -th.y, -th.z), $l.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix($l) } } class ih extends Wl { constructor(t, e, n = 0, i = 2) { super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new nh } get power() { return 4 * this.intensity * Math.PI } set power(t) { this.intensity = t / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(t, e) { return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } } class rh extends Kl { constructor() { super(new Vr(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class sh extends Wl { constructor(t, e) { super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(bi.DefaultUp), this.updateMatrix(), this.target = new bi, this.shadow = new rh } dispose() { this.shadow.dispose() } copy(t) { return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } } class oh { static decodeText(t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let n = 0, i = t.length; n < i; n++)e += String.fromCharCode(t[n]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } } static extractUrlBase(t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.slice(0, e + 1) } static resolveURL(t, e) { return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t) } } class ah extends qi { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(t) { return super.copy(t), this.instanceCount = t.instanceCount, this } toJSON() { const t = super.toJSON(); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t } } class lh extends zl { constructor(t) { super(t), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(t) { return this.options = t, this } load(t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, s = Ol.get(t); if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () { e && e(s), r.manager.itemEnd(t) }), 0), s; const o = {}; o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function (t) { return t.blob() })).then((function (t) { return createImageBitmap(t, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function (n) { Ol.add(t, n), e && e(n), r.manager.itemEnd(t) })).catch((function (e) { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) })), r.manager.itemStart(t) } } class hh { constructor(t = !0) { this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = ch(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const e = ch(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } } function ch() { return ("undefined" == typeof performance ? Date : performance).now() } const uh = "\\[\\]\\.:\\/", dh = new RegExp("[" + uh + "]", "g"), ph = "[^" + uh + "]", fh = "[^" + uh.replace("\\.", "") + "]", mh = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", ph) + /(WCOD+)?/.source.replace("WCOD", fh) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ph) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ph) + "$"), gh = ["material", "materials", "bones", "map"]; class vh { constructor(t, e, n) { this.path = e, this.parsedPath = n || vh.parseTrackName(e), this.node = vh.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(t, e, n) { return t && t.isAnimationObjectGroup ? new vh.Composite(t, e, n) : new vh(t, e, n) } static sanitizeNodeName(t) { return t.replace(/\s/g, "_").replace(dh, "") } static parseTrackName(t) { const e = mh.exec(t); if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { const t = n.nodeName.substring(i + 1); -1 !== gh.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n } static findNode(t, e) { if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n } if (t.children) { const n = function (t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.name === e || r.uuid === e) return r; const s = n(r.children); if (s) return s } return null }, i = n(t.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(t, e) { t[e] = this.targetObject[this.propertyName] } _getValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)t[e++] = n[i] } _getValue_arrayElement(t, e) { t[e] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(t, e) { this.resolvedProperty.toArray(t, e) } _setValue_direct(t, e) { this.targetObject[this.propertyName] = t[e] } _setValue_direct_setNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++] } _setValue_array_setNeedsUpdate(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(t, e) { this.resolvedProperty[this.propertyIndex] = t[e] } _setValue_arrayElement_setNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(t, e) { this.resolvedProperty.fromArray(t, e) } _setValue_fromArray_setNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(t, e) { this.bind(), this.getValue(t, e) } _setValue_unbound(t, e) { this.bind(), this.setValue(t, e) } bind() { let t = this.node; const e = this.parsedPath, n = e.objectName, i = e.propertyName; let r = e.propertyIndex; if (t || (t = vh.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let i = e.objectIndex; switch (n) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (let e = 0; e < t.length; e++)if (t[e].name === i) { i = e; break } break; case "map": if ("map" in t) { t = t.map; break } if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); t = t.material.map; break; default: if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[n] }if (void 0 !== i) { if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[i] } } const s = t[i]; if (void 0 === s) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t) } let o = this.Versioning.None; this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate); let a = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]) } a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } vh.Composite = class { constructor(t, e, n) { const i = n || vh.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, i) } getValue(t, e) { this.bind(); const n = this._targetGroup.nCachedObjects_, i = this._bindings[n]; void 0 !== i && i.getValue(t, e) } setValue(t, e) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(t, e) } bind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() } unbind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }, vh.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, vh.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, vh.prototype.GetterByBindingType = [vh.prototype._getValue_direct, vh.prototype._getValue_array, vh.prototype._getValue_arrayElement, vh.prototype._getValue_toArray], vh.prototype.SetterByBindingTypeAndVersioning = [[vh.prototype._setValue_direct, vh.prototype._setValue_direct_setNeedsUpdate, vh.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [vh.prototype._setValue_array, vh.prototype._setValue_array_setNeedsUpdate, vh.prototype._setValue_array_setMatrixWorldNeedsUpdate], [vh.prototype._setValue_arrayElement, vh.prototype._setValue_arrayElement_setNeedsUpdate, vh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [vh.prototype._setValue_fromArray, vh.prototype._setValue_fromArray_setNeedsUpdate, vh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; new Float32Array(1); class Ah extends da { constructor(t, e, n = 1) { super(t, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n } copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this } clone(t) { const e = super.clone(t); return e.meshPerAttribute = this.meshPerAttribute, e } toJSON(t) { const e = super.toJSON(t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e } } class bh { constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this } set(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this } copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this } makeSafe() { const t = 1e-6; return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this } setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) } setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(ke(e / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } const yh = new An, xh = new An; const _h = new An, wh = new mr; class Eh extends Qa { constructor(t) { const e = new qi, n = new La({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], s = {}; function o(t, e) { a(t), a(e) } function a(t) { i.push(0, 0, 0), r.push(0, 0, 0), void 0 === s[t] && (s[t] = []), s[t].push(i.length / 3 - 1) } o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"), e.setAttribute("position", new Ui(i, 3)), e.setAttribute("color", new Ui(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update(); const l = new on(16755200), h = new on(16711680), c = new on(43775), u = new on(16777215), d = new on(3355443); this.setColors(l, h, c, u, d) } setColors(t, e, n, i, r) { const s = this.geometry.getAttribute("color"); s.setXYZ(0, t.r, t.g, t.b), s.setXYZ(1, t.r, t.g, t.b), s.setXYZ(2, t.r, t.g, t.b), s.setXYZ(3, t.r, t.g, t.b), s.setXYZ(4, t.r, t.g, t.b), s.setXYZ(5, t.r, t.g, t.b), s.setXYZ(6, t.r, t.g, t.b), s.setXYZ(7, t.r, t.g, t.b), s.setXYZ(8, t.r, t.g, t.b), s.setXYZ(9, t.r, t.g, t.b), s.setXYZ(10, t.r, t.g, t.b), s.setXYZ(11, t.r, t.g, t.b), s.setXYZ(12, t.r, t.g, t.b), s.setXYZ(13, t.r, t.g, t.b), s.setXYZ(14, t.r, t.g, t.b), s.setXYZ(15, t.r, t.g, t.b), s.setXYZ(16, t.r, t.g, t.b), s.setXYZ(17, t.r, t.g, t.b), s.setXYZ(18, t.r, t.g, t.b), s.setXYZ(19, t.r, t.g, t.b), s.setXYZ(20, t.r, t.g, t.b), s.setXYZ(21, t.r, t.g, t.b), s.setXYZ(22, t.r, t.g, t.b), s.setXYZ(23, t.r, t.g, t.b), s.setXYZ(24, e.r, e.g, e.b), s.setXYZ(25, e.r, e.g, e.b), s.setXYZ(26, e.r, e.g, e.b), s.setXYZ(27, e.r, e.g, e.b), s.setXYZ(28, e.r, e.g, e.b), s.setXYZ(29, e.r, e.g, e.b), s.setXYZ(30, e.r, e.g, e.b), s.setXYZ(31, e.r, e.g, e.b), s.setXYZ(32, n.r, n.g, n.b), s.setXYZ(33, n.r, n.g, n.b), s.setXYZ(34, n.r, n.g, n.b), s.setXYZ(35, n.r, n.g, n.b), s.setXYZ(36, n.r, n.g, n.b), s.setXYZ(37, n.r, n.g, n.b), s.setXYZ(38, i.r, i.g, i.b), s.setXYZ(39, i.r, i.g, i.b), s.setXYZ(40, r.r, r.g, r.b), s.setXYZ(41, r.r, r.g, r.b), s.setXYZ(42, r.r, r.g, r.b), s.setXYZ(43, r.r, r.g, r.b), s.setXYZ(44, r.r, r.g, r.b), s.setXYZ(45, r.r, r.g, r.b), s.setXYZ(46, r.r, r.g, r.b), s.setXYZ(47, r.r, r.g, r.b), s.setXYZ(48, r.r, r.g, r.b), s.setXYZ(49, r.r, r.g, r.b), s.needsUpdate = !0 } update() { const t = this.geometry, e = this.pointMap; wh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ch("c", e, t, wh, 0, 0, -1), Ch("t", e, t, wh, 0, 0, 1), Ch("n1", e, t, wh, -1, -1, -1), Ch("n2", e, t, wh, 1, -1, -1), Ch("n3", e, t, wh, -1, 1, -1), Ch("n4", e, t, wh, 1, 1, -1), Ch("f1", e, t, wh, -1, -1, 1), Ch("f2", e, t, wh, 1, -1, 1), Ch("f3", e, t, wh, -1, 1, 1), Ch("f4", e, t, wh, 1, 1, 1), Ch("u1", e, t, wh, .7, 1.1, -1), Ch("u2", e, t, wh, -.7, 1.1, -1), Ch("u3", e, t, wh, 0, 2, -1), Ch("cf1", e, t, wh, -1, 0, 1), Ch("cf2", e, t, wh, 1, 0, 1), Ch("cf3", e, t, wh, 0, -1, 1), Ch("cf4", e, t, wh, 0, 1, 1), Ch("cn1", e, t, wh, -1, 0, -1), Ch("cn2", e, t, wh, 1, 0, -1), Ch("cn3", e, t, wh, 0, -1, -1), Ch("cn4", e, t, wh, 0, 1, -1), t.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function Ch(t, e, n, i, r, s, o) { _h.set(r, s, o).unproject(i); const a = e[t]; if (void 0 !== a) { const t = n.getAttribute("position"); for (let e = 0, n = a.length; e < n; e++)t.setXYZ(a[e], _h.x, _h.y, _h.z) } } function Sh(t) { return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document).querySelector(t) } function Mh(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document; return Array.prototype.slice.call(e.querySelectorAll(t)) } let Ph, Ih; function Th(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: r } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r), Ph = Symbol.iterator; class Dh { constructor(t) { if (Th(this, "components", []), Th(this, "args", []), Th(this, "negationSelector", null), void 0 === t.selector) throw new Error(`The component "${t.name}" does not implement the selector property, or it is not available statically`); this.Component = t, this.inited = !1 } init() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document; if (this.inited) return this; if (this.inited = !0, this.Component.isSingleton) { const e = Sh(this.Component.selector, t); return e && (this.components = [new this.Component(e, ...this.args)]), this } const e = Mh(this.Component.selector, t); this.components = []; for (let t = 0; t < e.length; t++)null !== this.negationSelector && !1 !== e[t].matches(this.negationSelector) || this.components.push(new this.Component(e[t], ...this.args)); return this } with() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return this.args = [...e], this } not(t) { return this.negationSelector = t, this } make(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)n[i - 1] = arguments[i]; const r = new this.Component(t, ...n); return this.components.push(r), r } get() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; return null !== t ? this.components[t] || null : this.components } first() { return this.get(0) } forEach(t) { for (let e = 0; e < this.components.length; e++)t(this.components[e]); return this } callAll(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)n[i - 1] = arguments[i]; for (let e = 0; e < this.components.length; e++)this.components[e][t](...n); return this } destroy() { return this.callAll("destroy"), this } [Ph]() { return this.components.values() } } function Bh(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Ih = Symbol.iterator; class Lh { constructor() { Bh(this, "_store", {}) } add() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; for (let t = 0; t < e.length; t++)void 0 === e[t].negationSelector ? e[t].selector ? this._store[e[t].name] = new Dh(e[t]).init() : this._store[e[t].constructor.name || e[t].name] = e[t] : this._store[e[t].Component.name] = e[t].init() } get(t) { var e, n; return "string" == typeof t ? null !== (n = this._store[t]) && void 0 !== n ? n : null : null !== (e = this._store[t.name]) && void 0 !== e ? e : null } [Ih]() { return Object.values(this._store).values() } } var Fh = { html: document.documentElement, body: document.body, window: { w: window.innerWidth, h: window.innerHeight, dpr: window.devicePixelRatio, fullHeight: window.innerHeight }, keys: { UP: 38, DOWN: 40, ENTER: 13, ESC: 27, HOME: 36, END: 35 }, isTouch: !1, isIOS: ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document, urlParams: new URLSearchParams(window.location.search), pointer: { x: 0, y: 0, gl: new He, glNormalized: new He, isDragging: !1 }, cookieNoticeAccepted: !1, staticComponents: new Lh, components: new Lh, ASS: null, Taxi: null, AssetLoader: null, GlobalEvents: null, ScrollAnimations: null, WebGL: null, MainScene: null, mq: {}, animConfig: { duration: .7, staggerAmount: .2 }, pinType: "transform", labels: [] }; function kh() { if (!(this instanceof kh)) return new kh; this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = [] } var Rh = window.document.documentElement, Oh = Rh.matches || Rh.webkitMatchesSelector || Rh.mozMatchesSelector || Rh.oMatchesSelector || Rh.msMatchesSelector; kh.prototype.matchesSelector = function (t, e) { return Oh.call(t, e) }, kh.prototype.querySelectorAll = function (t, e) { return e.querySelectorAll(t) }, kh.prototype.indexes = []; var Nh = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; kh.prototype.indexes.push({ name: "ID", selector: function (t) { var e; if (e = t.match(Nh)) return e[0].slice(1) }, element: function (t) { if (t.id) return [t.id] } }); var Uh = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; kh.prototype.indexes.push({ name: "CLASS", selector: function (t) { var e; if (e = t.match(Uh)) return e[0].slice(1) }, element: function (t) { var e = t.className; if (e) { if ("string" == typeof e) return e.split(/\s/); if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/) } } }); var zh, Vh = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g; kh.prototype.indexes.push({ name: "TAG", selector: function (t) { var e; if (e = t.match(Vh)) return e[0].toUpperCase() }, element: function (t) { return [t.nodeName.toUpperCase()] } }), kh.prototype.indexes.default = { name: "UNIVERSAL", selector: function () { return !0 }, element: function () { return [!0] } }, zh = "function" == typeof window.Map ? window.Map : function () { function t() { this.map = {} } return t.prototype.get = function (t) { return this.map[t + " "] }, t.prototype.set = function (t, e) { this.map[t + " "] = e }, t }(); var Qh = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g; function Gh(t, e) { var n, i, r, s, o, a, l = (t = t.slice(0).concat(t.default)).length, h = e, c = []; do { if (Qh.exec(""), (r = Qh.exec(h)) && (h = r[3], r[2] || !h)) for (n = 0; n < l; n++)if (o = (a = t[n]).selector(r[1])) { for (i = c.length, s = !1; i--;)if (c[i].index === a && c[i].key === o) { s = !0; break } s || c.push({ index: a, key: o }); break } } while (r); return c } function Hh(t, e) { var n, i, r; for (n = 0, i = t.length; n < i; n++)if (r = t[n], e.isPrototypeOf(r)) return r } function jh(t, e) { return t.id - e.id } kh.prototype.logDefaultIndexUsed = function () { }, kh.prototype.add = function (t, e) { var n, i, r, s, o, a, l, h, c = this.activeIndexes, u = this.selectors, d = this.selectorObjects; if ("string" == typeof t) { for (d[(n = { id: this.uid++, selector: t, data: e }).id] = n, l = Gh(this.indexes, t), i = 0; i < l.length; i++)s = (h = l[i]).key, (o = Hh(c, r = h.index)) || ((o = Object.create(r)).map = new zh, c.push(o)), r === this.indexes.default && this.logDefaultIndexUsed(n), (a = o.map.get(s)) || (a = [], o.map.set(s, a)), a.push(n); this.size++, u.push(t) } }, kh.prototype.remove = function (t, e) { if ("string" == typeof t) { var n, i, r, s, o, a, l, h, c = this.activeIndexes, u = this.selectors = [], d = this.selectorObjects, p = {}, f = 1 === arguments.length; for (n = Gh(this.indexes, t), r = 0; r < n.length; r++)for (i = n[r], s = c.length; s--;)if (a = c[s], i.index.isPrototypeOf(a)) { if (l = a.map.get(i.key)) for (o = l.length; o--;)(h = l[o]).selector !== t || !f && h.data !== e || (l.splice(o, 1), p[h.id] = !0); break } for (r in p) delete d[r], this.size--; for (r in d) u.push(d[r].selector) } }, kh.prototype.queryAll = function (t) { if (!this.selectors.length) return []; var e, n, i, r, s, o, a, l, h = {}, c = [], u = this.querySelectorAll(this.selectors.join(", "), t); for (e = 0, i = u.length; e < i; e++)for (s = u[e], n = 0, r = (o = this.matches(s)).length; n < r; n++)h[(l = o[n]).id] ? a = h[l.id] : (a = { id: l.id, selector: l.selector, data: l.data, elements: [] }, h[l.id] = a, c.push(a)), a.elements.push(s); return c.sort(jh) }, kh.prototype.matches = function (t) { if (!t) return []; var e, n, i, r, s, o, a, l, h, c, u, d = this.activeIndexes, p = {}, f = []; for (e = 0, r = d.length; e < r; e++)if (l = (a = d[e]).element(t)) for (n = 0, s = l.length; n < s; n++)if (h = a.map.get(l[n])) for (i = 0, o = h.length; i < o; i++)!p[u = (c = h[i]).id] && this.matchesSelector(t, c.selector) && (p[u] = !0, f.push(c)); return f.sort(jh) }; const Wh = {}, qh = {}, Yh = ["mouseenter", "mouseleave", "pointerenter", "pointerleave", "blur", "focus"]; function Xh(t) { void 0 === qh[t] && (qh[t] = []) } function Kh(t) { return "string" == typeof t ? document.querySelectorAll(t) : t } function Jh(t) { let e = function (t, e) { const n = []; let i = e; do { if (1 !== i.nodeType) break; const e = t.matches(i); e.length && n.push({ delegatedTarget: i, stack: e }) } while (i = i.parentElement); return n }(Wh[t.type], t.target); if (e.length) for (let n = 0; n < e.length; n++)for (let i = 0; i < e[n].stack.length; i++)-1 !== Yh.indexOf(t.type) ? (Zh(t, e[n].delegatedTarget), t.target === e[n].delegatedTarget && e[n].stack[i].data(t)) : (Zh(t, e[n].delegatedTarget), e[n].stack[i].data(t)) } function Zh(t, e) { Object.defineProperty(t, "currentTarget", { configurable: !0, enumerable: !0, get: () => e }) } function $h(t) { return JSON.parse(JSON.stringify(t)) } const tc = new class { bindAll(t, e) { e || (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t))); for (let n = 0; n < e.length; n++)t[e[n]] = t[e[n]].bind(t) } on(t, e, n, i) { const r = t.split(" "); for (let t = 0; t < r.length; t++)if ("function" != typeof e || void 0 !== n) if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(r[t], n, i); else { e = Kh(e); for (let s = 0; s < e.length; s++)e[s].addEventListener(r[t], n, i) } else Xh(r[t]), qh[r[t]].push(e) } delegate(t, e, n) { const i = t.split(" "); for (let t = 0; t < i.length; t++) { let r = Wh[i[t]]; void 0 === r && (r = new kh, Wh[i[t]] = r, -1 !== Yh.indexOf(i[t]) ? document.addEventListener(i[t], Jh, !0) : document.addEventListener(i[t], Jh)), r.add(e, n) } } off(t, e, n, i) { const r = t.split(" "); for (let t = 0; t < r.length; t++) { if (void 0 === e) { qh[r[t]] = []; continue } if ("function" == typeof e) { Xh(r[t]); for (let n = 0; n < qh[r[t]].length; n++)qh[r[t]][n] === e && qh[r[t]].splice(n, 1); continue } const s = Wh[r[t]]; if (void 0 === s || (s.remove(e, n), 0 !== s.size)) if (void 0 === e.removeEventListener) { e = Kh(e); for (let s = 0; s < e.length; s++)e[s].removeEventListener(r[t], n, i) } else e.removeEventListener(r[t], n, i); else delete Wh[r[t]], -1 !== Yh.indexOf(r[t]) ? document.removeEventListener(r[t], Jh, !0) : document.removeEventListener(r[t], Jh) } } emit(t, ...e) { !function (t, e) { if (qh[t]) for (let n = 0; n < qh[t].length; n++)qh[t][n](...e) }(t, e) } debugDelegated() { return $h(Wh) } debugBus() { return $h(qh) } }; var ec = tc; function nc(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class ic { static enablePointerEvents() { void 0 === ic.enabled.pointerEvents && (ic.enabled.pointerEvents = !0, ec.on("mousemove touchmove", window, ic.handleMousemove, { passive: !0 }), ec.on("mousedown touchstart", window, ic.handleMousedown), ec.on("mouseup touchend", window, ic.handleMouseup)) } static enableResize() { let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; void 0 === ic.enabled.resize && (ic.enabled.resize = !0, t ? ec.on("resize", window, function (t, e) { let n = null; return function () { clearTimeout(n); const i = arguments, r = this; n = setTimeout((function () { t.apply(r, i) }), e) } }((t => ic.handleResize(t)), t)) : ec.on("resize", window, ic.handleResize)) } static enableRAF() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; void 0 === ic.enabled.raf && (ic.enabled.raf = !0, t ? (ic.currentRafId = null, t.ticker.add(ic.handleRaf)) : ic.currentRafId = window.requestAnimationFrame(ic.handleRaf)) } static enableDrag() { void 0 === ic.enabled.drag && (ic.enabled.drag = !0) } static handleMousemove(t) { if (Fh.pointer.x = t.changedTouches ? t.changedTouches[0].clientX : t.clientX, Fh.pointer.y = t.changedTouches ? t.changedTouches[0].clientY : t.clientY, Fh.pointer.gl.set(Fh.pointer.x - Fh.window.w / 2, -Fh.pointer.y + Fh.window.h / 2), Fh.pointer.glNormalized.set(Fh.pointer.x / Fh.window.w * 2 - 1, -Fh.pointer.y / Fh.window.h * 2 + 1), t.changedTouches ? ec.emit(ic.TOUCHMOVE, t) : ec.emit(ic.MOUSEMOVE, t), Fh.pointer.isDragging) { const e = { deltaX: Fh.pointer.x - ic.dragInfo.px, deltaY: Fh.pointer.y - ic.dragInfo.py, startX: ic.dragInfo.x, startY: ic.dragInfo.y, totalX: Fh.pointer.x - ic.dragInfo.x, totalY: Fh.pointer.y - ic.dragInfo.y }; ec.emit(t.changedTouches ? ic.TOUCHDRAG : ic.MOUSEDRAG, t, e), ic.dragInfo.px = Fh.pointer.x, ic.dragInfo.py = Fh.pointer.y } } static handleMousedown(t) { if ("touchstart" === t.type) this.stopMouseDown = !0; else { if (this.stopMouseDown) return void (this.stopMouseDown = !1); this.stopMouseDown = !1 } ic.handleMousemove(t), ic.enabled.drag && (Fh.pointer.isDragging = !0, ic.dragInfo.x = ic.dragInfo.px = Fh.pointer.x, ic.dragInfo.y = ic.dragInfo.py = Fh.pointer.y), ec.emit(ic.POINTERDOWN, t) } static handleMouseup(t) { if (Fh.pointer.isDragging = !1, "touchend" === t.type) this.stopMouseUp = !0; else { if (this.stopMouseUp) return void (this.stopMouseUp = !1); this.stopMouseUp = !1 } this.stopMouseDown = !1, ic.handleMousemove(t), ic.dragInfo = { x: 0, y: 0, px: 0, py: 0 }, ec.emit(ic.POINTERUP, t) } static handleResize(t) { Fh.isTouch && Fh.window.w === window.innerWidth || (Fh.window.w = window.innerWidth, Fh.window.h = window.innerHeight, Fh.window.fullHeight = document.querySelector(".height-div").clientHeight, Fh.isIOS && Fh.window.fullHeight === Fh.window.h && (Fh.window.fullHeight *= 1.2), ec.emit(ic.RESIZE, t)) } static handleRaf(t) { Fh.Gui && Fh.Gui.fps.begin(), ec.emit(ic.RAF, t), null !== ic.currentRafId && (ic.currentRafId = window.requestAnimationFrame(ic.handleRaf)), Fh.Gui && Fh.Gui.fps.end() } static detectTouchDevice() { "ontouchstart" in document.documentElement && (Fh.isTouch = !0, Fh.html.classList.add("is-touch")) } } nc(ic, "MOUSEMOVE", "global:mousemove"), nc(ic, "TOUCHMOVE", "global:touchmove"), nc(ic, "MOUSEDRAG", "global:mousedrag"), nc(ic, "TOUCHDRAG", "global:touchdrag"), nc(ic, "POINTERMOVE", `${ic.MOUSEMOVE} ${ic.TOUCHMOVE}`), nc(ic, "POINTERDRAG", `${ic.TOUCHDRAG} ${ic.MOUSEDRAG}`), nc(ic, "POINTERDOWN", "global:pointerdown"), nc(ic, "POINTERUP", "global:pointerup"), nc(ic, "RAF", "global:raf"), nc(ic, "RESIZE", "global:resize"), nc(ic, "currentRafId", null), nc(ic, "enabled", {}), nc(ic, "dragInfo", { x: 0, y: 0, px: 0, py: 0 }), nc(ic, "stopMouseDown", !1), nc(ic, "stopMouseUp", !1); n(5306); function rc(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class sc { constructor() { rc(this, "fire", (t => { let e = 0; const n = this.callbacks.length; for (; e < n; e++)this.callbacks[e].cb(t) })), this.callbacks = [], ec.on(ic.RAF, this.fire) } add(t, e) { this.callbacks.push({ index: e, cb: t }), this.callbacks.sort(this.sort) } remove(t) { for (let e = 0; e < this.callbacks.length; e++)this.callbacks[e].cb === t && this.callbacks.splice(e, 1) } sort(t, e) { return t.index > e.index ? 1 : -1 } } class oc { constructor(t = 4) { this.pool = t, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0 } _initWorker(t) { if (!this.workers[t]) { const e = this.workerCreator(); e.addEventListener("message", this._onMessage.bind(this, t)), this.workers[t] = e } } _getIdleWorker() { for (let t = 0; t < this.pool; t++)if (!(this.workerStatus & 1 << t)) return t; return -1 } _onMessage(t, e) { const n = this.workersResolve[t]; if (n && n(e), this.queue.length) { const { resolve: e, msg: n, transfer: i } = this.queue.shift(); this.workersResolve[t] = e, this.workers[t].postMessage(n, i) } else this.workerStatus ^= 1 << t } setWorkerCreator(t) { this.workerCreator = t } setWorkerLimit(t) { this.pool = t } postMessage(t, e) { return new Promise((n => { const i = this._getIdleWorker(); -1 !== i ? (this._initWorker(i), this.workerStatus |= 1 << i, this.workersResolve[i] = n, this.workers[i].postMessage(t, e)) : this.queue.push({ resolve: n, msg: t, transfer: e }) })) } dispose() { this.workers.forEach((t => t.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0 } } var ac = n(8764).lW; const lc = 0, hc = 2; class cc { constructor() { this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null } } class uc { constructor(t, e, n, i) { this._dataView = new DataView(t.buffer, t.byteOffset + e, n), this._littleEndian = i, this._offset = 0 } _nextUint8() { const t = this._dataView.getUint8(this._offset); return this._offset += 1, t } _nextUint16() { const t = this._dataView.getUint16(this._offset, this._littleEndian); return this._offset += 2, t } _nextUint32() { const t = this._dataView.getUint32(this._offset, this._littleEndian); return this._offset += 4, t } _nextUint64() { const t = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian); return this._offset += 8, t } _nextInt32() { const t = this._dataView.getInt32(this._offset, this._littleEndian); return this._offset += 4, t } _skip(t) { return this._offset += t, this } _scan(t, e = 0) { const n = this._offset; let i = 0; for (; this._dataView.getUint8(this._offset) !== e && i < t;)i++, this._offset++; return i < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i) } } new Uint8Array([0]); const dc = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]; function pc(t) { return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(t) : ac.from(t).toString("utf8") } var fc = n(8764).lW; let mc, gc, vc; const Ac = { env: { emscripten_notify_memory_growth: function (t) { vc = new Uint8Array(gc.exports.memory.buffer) } } }; class bc { init() { return mc || (mc = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + yc).then((t => t.arrayBuffer())).then((t => WebAssembly.instantiate(t, Ac))).then(this._init) : WebAssembly.instantiate(fc.from(yc, "base64"), Ac).then(this._init), mc) } _init(t) { gc = t.instance, Ac.env.emscripten_notify_memory_growth(0) } decode(t, e = 0) { if (!gc) throw new Error("ZSTDDecoder: Await .init() before decoding."); const n = t.byteLength, i = gc.exports.malloc(n); vc.set(t, i), e = e || Number(gc.exports.ZSTD_findDecompressedSize(i, n)); const r = gc.exports.malloc(e), s = gc.exports.ZSTD_decompress(r, e, i, n), o = vc.slice(r, r + s); return gc.exports.free(i), gc.exports.free(r), o } } const yc = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", xc = new WeakMap; let _c, wc = 0; class Ec extends zl { constructor(t) { super(t), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new oc, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.') } setTranscoderPath(t) { return this.transcoderPath = t, this } setWorkerLimit(t) { return this.workerPool.setWorkerLimit(t), this } detectSupport(t) { return this.workerConfig = { astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: t.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, t.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this } init() { if (!this.transcoderPending) { const t = new Gl(this.manager); t.setPath(this.transcoderPath), t.setWithCredentials(this.withCredentials); const e = t.loadAsync("basis_transcoder.js"), n = new Gl(this.manager); n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials); const i = n.loadAsync("basis_transcoder.wasm"); this.transcoderPending = Promise.all([e, i]).then((([t, e]) => { const n = Ec.BasisWorker.toString(), i = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Ec.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Ec.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Ec.BasisFormat), "/* basis_transcoder.js */", t, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([i])), this.transcoderBinary = e, this.workerPool.setWorkerCreator((() => { const t = new Worker(this.workerSourceURL), e = this.transcoderBinary.slice(0); return t.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: e }, [e]), t })) })), wc > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), wc++ } return this.transcoderPending } load(t, e, n, i) { if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."); const r = new Gl(this.manager); r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(t, (t => { if (xc.has(t)) { return xc.get(t).promise.then(e).catch(i) } this._createTexture(t).then((t => e ? e(t) : null)).catch(i) }), n, i) } _createTextureFrom(t, e) { const { mipmaps: n, width: i, height: r, format: s, type: o, error: a, dfdTransferFn: l, dfdFlags: h } = t; if ("error" === o) return Promise.reject(a); const c = e.layerCount > 1 ? new Za(n, i, r, e.layerCount, s, gt) : new Ja(n, i, r, s, gt); return c.minFilter = 1 === n.length ? pt : mt, c.magFilter = pt, c.generateMipmaps = !1, c.needsUpdate = !0, c.encoding = 2 === l ? be : Ae, c.premultiplyAlpha = !!(1 & h), c } async _createTexture(t, e = {}) { const n = function (t) { const e = new Uint8Array(t.buffer, t.byteOffset, dc.length); if (e[0] !== dc[0] || e[1] !== dc[1] || e[2] !== dc[2] || e[3] !== dc[3] || e[4] !== dc[4] || e[5] !== dc[5] || e[6] !== dc[6] || e[7] !== dc[7] || e[8] !== dc[8] || e[9] !== dc[9] || e[10] !== dc[10] || e[11] !== dc[11]) throw new Error("Missing KTX 2.0 identifier."); const n = new cc, i = 17 * Uint32Array.BYTES_PER_ELEMENT, r = new uc(t, dc.length, i, !0); n.vkFormat = r._nextUint32(), n.typeSize = r._nextUint32(), n.pixelWidth = r._nextUint32(), n.pixelHeight = r._nextUint32(), n.pixelDepth = r._nextUint32(), n.layerCount = r._nextUint32(), n.faceCount = r._nextUint32(); const s = r._nextUint32(); n.supercompressionScheme = r._nextUint32(); const o = r._nextUint32(), a = r._nextUint32(), l = r._nextUint32(), h = r._nextUint32(), c = r._nextUint64(), u = r._nextUint64(), d = new uc(t, dc.length + i, 3 * s * 8, !0); for (let e = 0; e < s; e++)n.levels.push({ levelData: new Uint8Array(t.buffer, t.byteOffset + d._nextUint64(), d._nextUint64()), uncompressedByteLength: d._nextUint64() }); const p = new uc(t, o, a, !0), f = { vendorId: p._skip(4)._nextUint16(), descriptorType: p._nextUint16(), versionNumber: p._nextUint16(), descriptorBlockSize: p._nextUint16(), colorModel: p._nextUint8(), colorPrimaries: p._nextUint8(), transferFunction: p._nextUint8(), flags: p._nextUint8(), texelBlockDimension: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], bytesPlane: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], samples: [] }, m = (f.descriptorBlockSize / 4 - 6) / 4; for (let t = 0; t < m; t++) { const e = { bitOffset: p._nextUint16(), bitLength: p._nextUint8(), channelType: p._nextUint8(), samplePosition: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 }; 64 & e.channelType ? (e.sampleLower = p._nextInt32(), e.sampleUpper = p._nextInt32()) : (e.sampleLower = p._nextUint32(), e.sampleUpper = p._nextUint32()), f.samples[t] = e } n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f); const g = new uc(t, l, h, !0); for (; g._offset < h;) { const t = g._nextUint32(), e = g._scan(t), i = pc(e), r = g._scan(t - e.byteLength); n.keyValue[i] = i.match(/^ktx/i) ? pc(r) : r, g._offset % 4 && g._skip(4 - g._offset % 4) } if (u <= 0) return n; const v = new uc(t, c, u, !0), A = v._nextUint16(), b = v._nextUint16(), y = v._nextUint32(), x = v._nextUint32(), _ = v._nextUint32(), w = v._nextUint32(), E = []; for (let t = 0; t < s; t++)E.push({ imageFlags: v._nextUint32(), rgbSliceByteOffset: v._nextUint32(), rgbSliceByteLength: v._nextUint32(), alphaSliceByteOffset: v._nextUint32(), alphaSliceByteLength: v._nextUint32() }); const C = c + v._offset, S = C + y, M = S + x, P = M + _, I = new Uint8Array(t.buffer, t.byteOffset + C, y), T = new Uint8Array(t.buffer, t.byteOffset + S, x), D = new Uint8Array(t.buffer, t.byteOffset + M, _), B = new Uint8Array(t.buffer, t.byteOffset + P, w); return n.globalData = { endpointCount: A, selectorCount: b, imageDescs: E, endpointsData: I, selectorsData: T, tablesData: D, extendedData: B }, n }(new Uint8Array(t)); if (0 !== n.vkFormat) return async function (t) { const { vkFormat: e, pixelWidth: n, pixelHeight: i, pixelDepth: r } = t; if (void 0 === Cc[e]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat."); const s = t.levels[0]; let o, a; if (t.supercompressionScheme === lc) o = s.levelData; else { if (t.supercompressionScheme !== hc) throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme."); _c || (_c = new Promise((async t => { const e = new bc; await e.init(), t(e) }))), o = (await _c).decode(s.levelData, s.uncompressedByteLength) } a = Sc[e] === _t ? new Float32Array(o.buffer, o.byteOffset, o.byteLength / Float32Array.BYTES_PER_ELEMENT) : Sc[e] === wt ? new Uint16Array(o.buffer, o.byteOffset, o.byteLength / Uint16Array.BYTES_PER_ELEMENT) : o; const l = 0 === r ? new _a(a, n, i) : new gn(a, n, i, r); return l.type = Sc[e], l.format = Cc[e], l.encoding = Mc[e] || Ae, l.needsUpdate = !0, Promise.resolve(l) }(n); const i = e, r = this.init().then((() => this.workerPool.postMessage({ type: "transcode", buffer: t, taskConfig: i }, [t]))).then((t => this._createTextureFrom(t.data, n))); return xc.set(t, { promise: r }), r } dispose() { return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), wc--, this } } Ec.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, Ec.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, Ec.EngineFormat = { RGBAFormat: It, RGBA_ASTC_4x4_Format: Kt, RGBA_BPTC_Format: ce, RGBA_ETC2_EAC_Format: Xt, RGBA_PVRTC_4BPPV1_Format: jt, RGBA_S3TC_DXT5_Format: Qt, RGB_ETC1_Format: qt, RGB_ETC2_Format: Yt, RGB_PVRTC_4BPPV1_Format: Gt, RGB_S3TC_DXT1_Format: Ut }, Ec.BasisWorker = function () { let t, e, n; const i = _EngineFormat, r = _TranscoderFormat, s = _BasisFormat; self.addEventListener("message", (function (o) { const u = o.data; switch (u.type) { case "init": t = u.config, d = u.transcoderBinary, e = new Promise((t => { n = { wasmBinary: d, onRuntimeInitialized: t }, BASIS(n) })).then((() => { n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.") })); break; case "transcode": e.then((() => { try { const { width: e, height: o, hasAlpha: d, mipmaps: p, format: f, dfdTransferFn: m, dfdFlags: g } = function (e) { const o = new n.KTX2File(new Uint8Array(e)); function u() { o.close(), o.delete() } if (!o.isValid()) throw u(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file"); const d = o.isUASTC() ? s.UASTC_4x4 : s.ETC1S, p = o.getWidth(), f = o.getHeight(), m = o.getLayers() || 1, g = o.getLevels(), v = o.getHasAlpha(), A = o.getDFDTransferFunc(), b = o.getDFDFlags(), { transcoderFormat: y, engineFormat: x } = function (e, n, o, c) { let u, d; const p = e === s.ETC1S ? a : l; for (let i = 0; i < p.length; i++) { const r = p[i]; if (t[r.if] && (r.basisFormat.includes(e) && !(c && r.transcoderFormat.length < 2) && (!r.needsPowerOfTwo || h(n) && h(o)))) return u = r.transcoderFormat[c ? 1 : 0], d = r.engineFormat[c ? 1 : 0], { transcoderFormat: u, engineFormat: d } } return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), u = r.RGBA32, d = i.RGBAFormat, { transcoderFormat: u, engineFormat: d } }(d, p, f, v); if (!p || !f || !g) throw u(), new Error("THREE.KTX2Loader:\tInvalid texture"); if (!o.startTranscoding()) throw u(), new Error("THREE.KTX2Loader: .startTranscoding failed"); const _ = []; for (let t = 0; t < g; t++) { const e = []; let n, i; for (let r = 0; r < m; r++) { const s = o.getImageLevelInfo(t, r, 0); n = s.origWidth, i = s.origHeight; const a = new Uint8Array(o.getImageTranscodedSizeInBytes(t, r, 0, y)); if (!o.transcodeImage(a, t, r, 0, y, 0, -1, -1)) throw u(), new Error("THREE.KTX2Loader: .transcodeImage failed."); e.push(a) } _.push({ data: c(e), width: n, height: i }) } return u(), { width: p, height: f, hasAlpha: v, mipmaps: _, format: x, dfdTransferFn: A, dfdFlags: b } }(u.buffer), v = []; for (let t = 0; t < p.length; ++t)v.push(p[t].data.buffer); self.postMessage({ type: "transcode", id: u.id, width: e, height: o, hasAlpha: d, mipmaps: p, format: f, dfdTransferFn: m, dfdFlags: g }, v) } catch (t) { console.error(t), self.postMessage({ type: "error", id: u.id, error: t.message }) } })) }var d })); const o = [{ if: "astcSupported", basisFormat: [s.UASTC_4x4], transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4], engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 }, { if: "bptcSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [r.BC7_M5, r.BC7_M5], engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 }, { if: "dxtSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [r.BC1, r.BC3], engineFormat: [i.RGB_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 }, { if: "etc2Supported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [r.ETC1, r.ETC2], engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 }, { if: "etc1Supported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [r.ETC1], engineFormat: [i.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 }, { if: "pvrtcSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA], engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 }], a = o.sort((function (t, e) { return t.priorityETC1S - e.priorityETC1S })), l = o.sort((function (t, e) { return t.priorityUASTC - e.priorityUASTC })); function h(t) { return t <= 2 || 0 == (t & t - 1) && 0 !== t } function c(t) { let e = 0; for (const n of t) e += n.byteLength; const n = new Uint8Array(e); let i = 0; for (const e of t) n.set(e, i), i += e.byteLength; return n } }; const Cc = { 109: It, 97: It, 37: It, 43: It, 103: Rt, 83: Rt, 16: Rt, 22: Rt, 100: Ft, 76: Ft, 15: Ft, 9: Ft }, Sc = { 109: _t, 97: wt, 37: gt, 43: gt, 103: _t, 83: wt, 16: gt, 22: gt, 100: _t, 76: wt, 15: gt, 9: gt }, Mc = { 43: be, 22: be, 15: be }; class Pc extends zl { constructor(t) { super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (t) { return new Fc(t) })), this.register((function (t) { return new Vc(t) })), this.register((function (t) { return new Qc(t) })), this.register((function (t) { return new Rc(t) })), this.register((function (t) { return new Oc(t) })), this.register((function (t) { return new Nc(t) })), this.register((function (t) { return new Uc(t) })), this.register((function (t) { return new Lc(t) })), this.register((function (t) { return new zc(t) })), this.register((function (t) { return new kc(t) })), this.register((function (t) { return new Dc(t) })), this.register((function (t) { return new Gc(t) })), this.register((function (t) { return new Hc(t) })) } load(t, e, n, i) { const r = this; let s; s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : oh.extractUrlBase(t), this.manager.itemStart(t); const o = function (e) { i ? i(e) : console.error(e), r.manager.itemError(t), r.manager.itemEnd(t) }, a = new Gl(this.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function (n) { try { r.parse(n, s, (function (n) { e(n), r.manager.itemEnd(t) }), o) } catch (t) { o(t) } }), n, o) } setDRACOLoader(t) { return this.dracoLoader = t, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(t) { return this.ktx2Loader = t, this } setMeshoptDecoder(t) { return this.meshoptDecoder = t, this } register(t) { return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this } unregister(t) { return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this } parse(t, e, n, i) { let r; const s = {}, o = {}; if ("string" == typeof t) r = JSON.parse(t); else if (t instanceof ArrayBuffer) { if (oh.decodeText(new Uint8Array(t, 0, 4)) === jc) { try { s[Tc.KHR_BINARY_GLTF] = new Yc(t) } catch (t) { return void (i && i(t)) } r = JSON.parse(s[Tc.KHR_BINARY_GLTF].content) } else r = JSON.parse(oh.decodeText(new Uint8Array(t))) } else r = t; if (void 0 === r.asset || r.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const a = new bu(r, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); a.fileLoader.setRequestHeader(this.requestHeader); for (let t = 0; t < this.pluginCallbacks.length; t++) { const e = this.pluginCallbacks[t](a); o[e.name] = e, s[e.name] = !0 } if (r.extensionsUsed) for (let t = 0; t < r.extensionsUsed.length; ++t) { const e = r.extensionsUsed[t], n = r.extensionsRequired || []; switch (e) { case Tc.KHR_MATERIALS_UNLIT: s[e] = new Bc; break; case Tc.KHR_DRACO_MESH_COMPRESSION: s[e] = new Xc(r, this.dracoLoader); break; case Tc.KHR_TEXTURE_TRANSFORM: s[e] = new Kc; break; case Tc.KHR_MESH_QUANTIZATION: s[e] = new Jc; break; default: n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".') } } a.setExtensions(s), a.setPlugins(o), a.parse(n, i) } parseAsync(t, e) { const n = this; return new Promise((function (i, r) { n.parse(t, e, i, r) })) } } function Ic() { let t = {}; return { get: function (e) { return t[e] }, add: function (e, n) { t[e] = n }, remove: function (e) { delete t[e] }, removeAll: function () { t = {} } } } const Tc = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class Dc { constructor(t) { this.parser = t, this.name = Tc.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const t = this.parser, e = this.parser.json.nodes || []; for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light) } } _loadLight(t) { const e = this.parser, n = "light:" + t; let i = e.cache.get(n); if (i) return i; const r = e.json, s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t]; let o; const a = new on(16777215); void 0 !== s.color && a.fromArray(s.color); const l = void 0 !== s.range ? s.range : 0; switch (s.type) { case "directional": o = new sh(a), o.target.position.set(0, 0, -1), o.add(o.target); break; case "point": o = new ih(a), o.distance = l; break; case "spot": o = new Zl(a), o.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, o.angle = s.spot.outerConeAngle, o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type) }return o.position.set(0, 0, 0), o.decay = 2, pu(o, s), void 0 !== s.intensity && (o.intensity = s.intensity), o.name = e.createUniqueName(s.name || "light_" + t), i = Promise.resolve(o), e.cache.add(n, i), i } getDependency(t, e) { if ("light" === t) return this._loadLight(e) } createNodeAttachment(t) { const e = this, n = this.parser, i = n.json.nodes[t], r = (i.extensions && i.extensions[this.name] || {}).light; return void 0 === r ? null : this._loadLight(r).then((function (t) { return n._getNodeRef(e.cache, r, t) })) } } class Bc { constructor() { this.name = Tc.KHR_MATERIALS_UNLIT } getMaterialType() { return Li } extendParams(t, e, n) { const i = []; t.color = new on(1, 1, 1), t.opacity = 1; const r = e.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { const e = r.baseColorFactor; t.color.fromArray(e), t.opacity = e[3] } void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture, be)) } return Promise.all(i) } } class Lc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(t, e) { const n = this.parser.json.materials[t]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const i = n.extensions[this.name].emissiveStrength; return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve() } } class Fc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_CLEARCOAT } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? gl : null } extendMaterialParams(t, e) { const n = this.parser, i = n.json.materials[t]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) { const t = s.clearcoatNormalTexture.scale; e.clearcoatNormalScale = new He(t, t) } return Promise.all(r) } } class kc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_IRIDESCENCE } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? gl : null } extendMaterialParams(t, e) { const n = this.parser, i = n.json.materials[t]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return void 0 !== s.iridescenceFactor && (e.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && r.push(n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (e.iridescenceIOR = s.iridescenceIor), void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (e.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (e.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(e, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(r) } } class Rc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_SHEEN } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? gl : null } extendMaterialParams(t, e) { const n = this.parser, i = n.json.materials[t]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = []; e.sheenColor = new on(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1; const s = i.extensions[this.name]; return void 0 !== s.sheenColorFactor && e.sheenColor.fromArray(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && (e.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture, be)), void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(r) } } class Oc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_TRANSMISSION } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? gl : null } extendMaterialParams(t, e) { const n = this.parser, i = n.json.materials[t]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(r) } } class Nc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_VOLUME } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? gl : null } extendMaterialParams(t, e) { const n = this.parser, i = n.json.materials[t]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)), e.attenuationDistance = s.attenuationDistance || 1 / 0; const o = s.attenuationColor || [1, 1, 1]; return e.attenuationColor = new on(o[0], o[1], o[2]), Promise.all(r) } } class Uc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_IOR } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? gl : null } extendMaterialParams(t, e) { const n = this.parser.json.materials[t]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const i = n.extensions[this.name]; return e.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve() } } class zc { constructor(t) { this.parser = t, this.name = Tc.KHR_MATERIALS_SPECULAR } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? gl : null } extendMaterialParams(t, e) { const n = this.parser, i = n.json.materials[t]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture)); const o = s.specularColorFactor || [1, 1, 1]; return e.specularColor = new on(o[0], o[1], o[2]), void 0 !== s.specularColorTexture && r.push(n.assignTexture(e, "specularColorMap", s.specularColorTexture, be)), Promise.all(r) } } class Vc { constructor(t) { this.parser = t, this.name = Tc.KHR_TEXTURE_BASISU } loadTexture(t) { const e = this.parser, n = e.json, i = n.textures[t]; if (!i.extensions || !i.extensions[this.name]) return null; const r = i.extensions[this.name], s = e.options.ktx2Loader; if (!s) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return e.loadTextureImage(t, r.source, s) } } class Qc { constructor(t) { this.parser = t, this.name = Tc.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(t) { const e = this.name, n = this.parser, i = n.json, r = i.textures[t]; if (!r.extensions || !r.extensions[e]) return null; const s = r.extensions[e], o = i.images[s.source]; let a = n.textureLoader; if (o.uri) { const t = n.options.manager.getHandler(o.uri); null !== t && (a = t) } return this.detectSupport().then((function (r) { if (r) return n.loadTextureImage(t, s.source, a); if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(t) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (t) { const e = new Image; e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function () { t(1 === e.height) } }))), this.isSupported } } class Gc { constructor(t) { this.name = Tc.EXT_MESHOPT_COMPRESSION, this.parser = t } loadBufferView(t) { const e = this.parser.json, n = e.bufferViews[t]; if (n.extensions && n.extensions[this.name]) { const t = n.extensions[this.name], i = this.parser.getDependency("buffer", t.buffer), r = this.parser.options.meshoptDecoder; if (!r || !r.supported) { if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return i.then((function (e) { const n = t.byteOffset || 0, i = t.byteLength || 0, s = t.count, o = t.byteStride, a = new Uint8Array(e, n, i); return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, o, a, t.mode, t.filter).then((function (t) { return t.buffer })) : r.ready.then((function () { const e = new ArrayBuffer(s * o); return r.decodeGltfBuffer(new Uint8Array(e), s, o, a, t.mode, t.filter), e })) })) } return null } } class Hc { constructor(t) { this.name = Tc.EXT_MESH_GPU_INSTANCING, this.parser = t } createNodeMesh(t) { const e = this.parser.json, n = e.nodes[t]; if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null; const i = e.meshes[n.mesh]; for (const t of i.primitives) if (t.mode !== eu.TRIANGLES && t.mode !== eu.TRIANGLE_STRIP && t.mode !== eu.TRIANGLE_FAN && void 0 !== t.mode) return null; const r = n.extensions[this.name].attributes, s = [], o = {}; for (const t in r) s.push(this.parser.getDependency("accessor", r[t]).then((e => (o[t] = e, o[t])))); return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(t)), Promise.all(s).then((t => { const e = t.pop(), n = e.isGroup ? e.children : [e], i = t[0].count, r = []; for (const t of n) { const e = new Yn, n = new An, s = new vn, a = new An(1, 1, 1), l = new Ba(t.geometry, t.material, i); for (let t = 0; t < i; t++)o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, t), o.ROTATION && s.fromBufferAttribute(o.ROTATION, t), o.SCALE && a.fromBufferAttribute(o.SCALE, t), l.setMatrixAt(t, e.compose(n, s, a)); for (const e in o) "TRANSLATION" !== e && "ROTATION" !== e && "SCALE" !== e && t.geometry.setAttribute(e, o[e]); bi.prototype.copy.call(l, t), l.frustumCulled = !1, this.parser.assignFinalMaterial(l), r.push(l) } return e.isGroup ? (e.clear(), e.add(...r), e) : r[0] }))) } } const jc = "glTF", Wc = 1313821514, qc = 5130562; class Yc { constructor(t) { this.name = Tc.KHR_BINARY_GLTF, this.content = null, this.body = null; const e = new DataView(t, 0, 12); if (this.header = { magic: oh.decodeText(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, !0), length: e.getUint32(8, !0) }, this.header.magic !== jc) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, i = new DataView(t, 12); let r = 0; for (; r < n;) { const e = i.getUint32(r, !0); r += 4; const n = i.getUint32(r, !0); if (r += 4, n === Wc) { const n = new Uint8Array(t, 12 + r, e); this.content = oh.decodeText(n) } else if (n === qc) { const n = 12 + r; this.body = t.slice(n, n + e) } r += e } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class Xc { constructor(t, e) { if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = Tc.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload() } decodePrimitive(t, e) { const n = this.json, i = this.dracoLoader, r = t.extensions[this.name].bufferView, s = t.extensions[this.name].attributes, o = {}, a = {}, l = {}; for (const t in s) { const e = ou[t] || t.toLowerCase(); o[e] = s[t] } for (const e in t.attributes) { const i = ou[e] || e.toLowerCase(); if (void 0 !== s[e]) { const r = n.accessors[t.attributes[e]], s = nu[r.componentType]; l[i] = s.name, a[i] = !0 === r.normalized } } return e.getDependency("bufferView", r).then((function (t) { return new Promise((function (e) { i.decodeDracoFile(t, (function (t) { for (const e in t.attributes) { const n = t.attributes[e], i = a[e]; void 0 !== i && (n.normalized = i) } e(t) }), o, l) })) })) } } class Kc { constructor() { this.name = Tc.KHR_TEXTURE_TRANSFORM } extendTexture(t, e) { return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t } } class Jc { constructor() { this.name = Tc.KHR_MESH_QUANTIZATION } } class Zc extends wl { constructor(t, e, n, i) { super(t, e, n, i) } copySampleValue_(t) { const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i * 3 + i; for (let t = 0; t !== i; t++)e[t] = n[r + t]; return e } interpolate_(t, e, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = 2 * o, l = 3 * o, h = i - e, c = (n - e) / h, u = c * c, d = u * c, p = t * l, f = p - l, m = -2 * d + 3 * u, g = d - u, v = 1 - m, A = g - u + c; for (let t = 0; t !== o; t++) { const e = s[f + t + o], n = s[f + t + a] * h, i = s[p + t + o], l = s[p + t] * h; r[t] = v * e + A * n + m * i + g * l } return r } } const $c = new vn; class tu extends Zc { interpolate_(t, e, n, i) { const r = super.interpolate_(t, e, n, i); return $c.fromArray(r).normalize().toArray(r), r } } const eu = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, nu = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, iu = { 9728: ct, 9729: pt, 9984: ut, 9985: ft, 9986: dt, 9987: mt }, ru = { 33071: lt, 33648: ht, 10497: at }, su = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, ou = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, au = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, lu = { CUBICSPLINE: void 0, LINEAR: de, STEP: ue }, hu = "OPAQUE", cu = "MASK", uu = "BLEND"; function du(t, e, n) { for (const i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i]) } function pu(t, e) { void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function fu(t, e) { if (t.updateMorphTargets(), void 0 !== e.weights) for (let n = 0, i = e.weights.length; n < i; n++)t.morphTargetInfluences[n] = e.weights[n]; if (e.extras && Array.isArray(e.extras.targetNames)) { const n = e.extras.targetNames; if (t.morphTargetInfluences.length === n.length) { t.morphTargetDictionary = {}; for (let e = 0, i = n.length; e < i; e++)t.morphTargetDictionary[n[e]] = e } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function mu(t) { const e = t.extensions && t.extensions[Tc.KHR_DRACO_MESH_COMPRESSION]; let n; return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + gu(e.attributes) : t.indices + ":" + gu(t.attributes) + ":" + t.mode, n } function gu(t) { let e = ""; const n = Object.keys(t).sort(); for (let i = 0, r = n.length; i < r; i++)e += n[i] + ":" + t[n[i]] + ";"; return e } function vu(t) { switch (t) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } const Au = new Yn; class bu { constructor(t = {}, e = {}) { this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new Ic, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let n = !1, i = !1, r = -1; "undefined" != typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new jl(this.options.manager) : this.textureLoader = new lh(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Gl(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(t) { this.extensions = t } setPlugins(t) { this.plugins = t } parse(t, e) { const n = this, i = this.json, r = this.extensions; this.cache.removeAll(), this._invokeAll((function (t) { return t._markDefs && t._markDefs() })), Promise.all(this._invokeAll((function (t) { return t.beforeRoot && t.beforeRoot() }))).then((function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) })).then((function (e) { const s = { scene: e[0][i.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: i.asset, parser: n, userData: {} }; du(r, s, i), pu(s, i), Promise.all(n._invokeAll((function (t) { return t.afterRoot && t.afterRoot(s) }))).then((function () { t(s) })) })).catch(e) } _markDefs() { const t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || []; for (let n = 0, i = e.length; n < i; n++) { const i = e[n].joints; for (let e = 0, n = i.length; e < n; e++)t[i[e]].isBone = !0 } for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera) } } _addNodeRef(t, e) { void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++) } _getNodeRef(t, e, n) { if (t.refs[e] <= 1) return n; const i = n.clone(), r = (t, e) => { const n = this.associations.get(t); null != n && this.associations.set(e, n); for (const [n, i] of t.children.entries()) r(i, e.children[n]) }; return r(n, i), i.name += "_instance_" + t.uses[e]++, i } _invokeOne(t) { const e = Object.values(this.plugins); e.push(this); for (let n = 0; n < e.length; n++) { const i = t(e[n]); if (i) return i } return null } _invokeAll(t) { const e = Object.values(this.plugins); e.unshift(this); const n = []; for (let i = 0; i < e.length; i++) { const r = t(e[i]); r && n.push(r) } return n } getDependency(t, e) { const n = t + ":" + e; let i = this.cache.get(n); if (!i) { switch (t) { case "scene": i = this.loadScene(e); break; case "node": i = this._invokeOne((function (t) { return t.loadNode && t.loadNode(e) })); break; case "mesh": i = this._invokeOne((function (t) { return t.loadMesh && t.loadMesh(e) })); break; case "accessor": i = this.loadAccessor(e); break; case "bufferView": i = this._invokeOne((function (t) { return t.loadBufferView && t.loadBufferView(e) })); break; case "buffer": i = this.loadBuffer(e); break; case "material": i = this._invokeOne((function (t) { return t.loadMaterial && t.loadMaterial(e) })); break; case "texture": i = this._invokeOne((function (t) { return t.loadTexture && t.loadTexture(e) })); break; case "skin": i = this.loadSkin(e); break; case "animation": i = this._invokeOne((function (t) { return t.loadAnimation && t.loadAnimation(e) })); break; case "camera": i = this.loadCamera(e); break; default: if (i = this._invokeOne((function (n) { return n != this && n.getDependency && n.getDependency(t, e) })), !i) throw new Error("Unknown type: " + t) }this.cache.add(n, i) } return i } getDependencies(t) { let e = this.cache.get(t); if (!e) { const n = this, i = this.json[t + ("mesh" === t ? "es" : "s")] || []; e = Promise.all(i.map((function (e, i) { return n.getDependency(t, i) }))), this.cache.add(t, e) } return e } loadBuffer(t) { const e = this.json.buffers[t], n = this.fileLoader; if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported."); if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[Tc.KHR_BINARY_GLTF].body); const i = this.options; return new Promise((function (t, r) { n.load(oh.resolveURL(e.uri, i.path), t, void 0, (function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".')) })) })) } loadBufferView(t) { const e = this.json.bufferViews[t]; return this.getDependency("buffer", e.buffer).then((function (t) { const n = e.byteLength || 0, i = e.byteOffset || 0; return t.slice(i, i + n) })) } loadAccessor(t) { const e = this, n = this.json, i = this.json.accessors[t]; if (void 0 === i.bufferView && void 0 === i.sparse) { const t = su[i.type], e = nu[i.componentType], n = !0 === i.normalized, r = new e(i.count * t); return Promise.resolve(new Ri(r, t, n)) } const r = []; return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (t) { const r = t[0], s = su[i.type], o = nu[i.componentType], a = o.BYTES_PER_ELEMENT, l = a * s, h = i.byteOffset || 0, c = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0, u = !0 === i.normalized; let d, p; if (c && c !== l) { const t = Math.floor(h / c), n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count; let l = e.cache.get(n); l || (d = new o(r, t * c, i.count * c / a), l = new da(d, c / a), e.cache.add(n, l)), p = new fa(l, s, h % c / a, u) } else d = null === r ? new o(i.count * s) : new o(r, h, i.count * s), p = new Ri(d, s, u); if (void 0 !== i.sparse) { const e = su.SCALAR, n = nu[i.sparse.indices.componentType], a = i.sparse.indices.byteOffset || 0, l = i.sparse.values.byteOffset || 0, h = new n(t[1], a, i.sparse.count * e), c = new o(t[2], l, i.sparse.count * s); null !== r && (p = new Ri(p.array.slice(), p.itemSize, p.normalized)); for (let t = 0, e = h.length; t < e; t++) { const e = h[t]; if (p.setX(e, c[t * s]), s >= 2 && p.setY(e, c[t * s + 1]), s >= 3 && p.setZ(e, c[t * s + 2]), s >= 4 && p.setW(e, c[t * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return p })) } loadTexture(t) { const e = this.json, n = this.options, i = e.textures[t].source, r = e.images[i]; let s = this.textureLoader; if (r.uri) { const t = n.manager.getHandler(r.uri); null !== t && (s = t) } return this.loadTextureImage(t, i, s) } loadTextureImage(t, e, n) { const i = this, r = this.json, s = r.textures[t], o = r.images[e], a = (o.uri || o.bufferView) + ":" + s.sampler; if (this.textureCache[a]) return this.textureCache[a]; const l = this.loadImageSource(e, n).then((function (e) { e.flipY = !1, e.name = s.name || o.name || ""; const n = (r.samplers || {})[s.sampler] || {}; return e.magFilter = iu[n.magFilter] || pt, e.minFilter = iu[n.minFilter] || mt, e.wrapS = ru[n.wrapS] || at, e.wrapT = ru[n.wrapT] || at, i.associations.set(e, { textures: t }), e })).catch((function () { return null })); return this.textureCache[a] = l, l } loadImageSource(t, e) { const n = this, i = this.json, r = this.options; if (void 0 !== this.sourceCache[t]) return this.sourceCache[t].then((t => t.clone())); const s = i.images[t], o = self.URL || self.webkitURL; let a = s.uri || "", l = !1; if (void 0 !== s.bufferView) a = n.getDependency("bufferView", s.bufferView).then((function (t) { l = !0; const e = new Blob([t], { type: s.mimeType }); return a = o.createObjectURL(e), a })); else if (void 0 === s.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView"); const h = Promise.resolve(a).then((function (t) { return new Promise((function (n, i) { let s = n; !0 === e.isImageBitmapLoader && (s = function (t) { const e = new dn(t); e.needsUpdate = !0, n(e) }), e.load(oh.resolveURL(t, r.path), s, void 0, i) })) })).then((function (t) { var e; return !0 === l && o.revokeObjectURL(a), t.userData.mimeType = s.mimeType || ((e = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), t })).catch((function (t) { throw console.error("THREE.GLTFLoader: Couldn't load texture", a), t })); return this.sourceCache[t] = h, h } assignTexture(t, e, n, i) { const r = this; return this.getDependency("texture", n.index).then((function (s) { if (!s) return null; if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), r.extensions[Tc.KHR_TEXTURE_TRANSFORM]) { const t = void 0 !== n.extensions ? n.extensions[Tc.KHR_TEXTURE_TRANSFORM] : void 0; if (t) { const e = r.associations.get(s); s = r.extensions[Tc.KHR_TEXTURE_TRANSFORM].extendTexture(s, t), r.associations.set(s, e) } } return void 0 !== i && (s.encoding = i), t[e] = s, s })) } assignFinalMaterial(t) { const e = t.geometry; let n = t.material; const i = void 0 === e.attributes.tangent, r = void 0 !== e.attributes.color, s = void 0 === e.attributes.normal; if (t.isPoints) { const t = "PointsMaterial:" + n.uuid; let e = this.cache.get(t); e || (e = new Ha, Bi.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e } else if (t.isLine) { const t = "LineBasicMaterial:" + n.uuid; let e = this.cache.get(t); e || (e = new La, Bi.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e } if (i || r || s) { let t = "ClonedMaterial:" + n.uuid + ":"; i && (t += "derivative-tangents:"), r && (t += "vertex-colors:"), s && (t += "flat-shading:"); let e = this.cache.get(t); e || (e = n.clone(), r && (e.vertexColors = !0), s && (e.flatShading = !0), i && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e } n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n } getMaterialType() { return ml } loadMaterial(t) { const e = this, n = this.json, i = this.extensions, r = n.materials[t]; let s; const o = {}, a = []; if ((r.extensions || {})[Tc.KHR_MATERIALS_UNLIT]) { const t = i[Tc.KHR_MATERIALS_UNLIT]; s = t.getMaterialType(), a.push(t.extendParams(o, r, e)) } else { const n = r.pbrMetallicRoughness || {}; if (o.color = new on(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) { const t = n.baseColorFactor; o.color.fromArray(t), o.opacity = t[3] } void 0 !== n.baseColorTexture && a.push(e.assignTexture(o, "map", n.baseColorTexture, be)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (a.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), a.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (e) { return e.getMaterialType && e.getMaterialType(t) })), a.push(Promise.all(this._invokeAll((function (e) { return e.extendMaterialParams && e.extendMaterialParams(t, o) })))) } !0 === r.doubleSided && (o.side = m); const l = r.alphaMode || hu; if (l === uu ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, l === cu && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Li && (a.push(e.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new He(1, 1), void 0 !== r.normalTexture.scale)) { const t = r.normalTexture.scale; o.normalScale.set(t, t) } return void 0 !== r.occlusionTexture && s !== Li && (a.push(e.assignTexture(o, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Li && (o.emissive = (new on).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== Li && a.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture, be)), Promise.all(a).then((function () { const n = new s(o); return r.name && (n.name = r.name), pu(n, r), e.associations.set(n, { materials: t }), r.extensions && du(i, n, r), n })) } createUniqueName(t) { const e = vh.sanitizeNodeName(t || ""); let n = e; for (let t = 1; this.nodeNamesUsed[n]; ++t)n = e + "_" + t; return this.nodeNamesUsed[n] = !0, n } loadGeometries(t) { const e = this, n = this.extensions, i = this.primitiveCache; function r(t) { return n[Tc.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function (n) { return yu(n, t, e) })) } const s = []; for (let n = 0, o = t.length; n < o; n++) { const o = t[n], a = mu(o), l = i[a]; if (l) s.push(l.promise); else { let t; t = o.extensions && o.extensions[Tc.KHR_DRACO_MESH_COMPRESSION] ? r(o) : yu(new qi, o, e), i[a] = { primitive: o, promise: t }, s.push(t) } } return Promise.all(s) } loadMesh(t) { const e = this, n = this.json, i = this.extensions, r = n.meshes[t], s = r.primitives, o = []; for (let t = 0, e = s.length; t < e; t++) { const e = void 0 === s[t].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new ml({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: p })), a.DefaultMaterial) : this.getDependency("material", s[t].material); o.push(e) } var a; return o.push(e.loadGeometries(s)), Promise.all(o).then((function (n) { const o = n.slice(0, n.length - 1), a = n[n.length - 1], l = []; for (let n = 0, h = a.length; n < h; n++) { const h = a[n], c = s[n]; let u; const d = o[n]; if (c.mode === eu.TRIANGLES || c.mode === eu.TRIANGLE_STRIP || c.mode === eu.TRIANGLE_FAN || void 0 === c.mode) u = !0 === r.isSkinnedMesh ? new ya(h, d) : new ar(h, d), !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), c.mode === eu.TRIANGLE_STRIP ? u.geometry = xu(u.geometry, 1) : c.mode === eu.TRIANGLE_FAN && (u.geometry = xu(u.geometry, ve)); else if (c.mode === eu.LINES) u = new Qa(h, d); else if (c.mode === eu.LINE_STRIP) u = new Ua(h, d); else if (c.mode === eu.LINE_LOOP) u = new Ga(h, d); else { if (c.mode !== eu.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode); u = new Xa(h, d) } Object.keys(u.geometry.morphAttributes).length > 0 && fu(u, r), u.name = e.createUniqueName(r.name || "mesh_" + t), pu(u, r), c.extensions && du(i, u, c), e.assignFinalMaterial(u), l.push(u) } for (let n = 0, i = l.length; n < i; n++)e.associations.set(l[n], { meshes: t, primitives: n }); if (1 === l.length) return l[0]; const h = new ia; e.associations.set(h, { meshes: t }); for (let t = 0, e = l.length; t < e; t++)h.add(l[t]); return h })) } loadCamera(t) { let e; const n = this.json.cameras[t], i = n[n.type]; if (i) return "perspective" === n.type ? e = new gr(Ge.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new Vr(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), pu(e, n), Promise.resolve(e); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(t) { const e = this.json.skins[t], n = []; for (let t = 0, i = e.joints.length; t < i; t++)n.push(this.getDependency("node", e.joints[t])); return void 0 !== e.inverseBindMatrices ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function (t) { const n = t.pop(), i = t, r = [], s = []; for (let t = 0, o = i.length; t < o; t++) { const o = i[t]; if (o) { r.push(o); const e = new Yn; null !== n && e.fromArray(n.array, 16 * t), s.push(e) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t]) } return new Ca(r, s) })) } loadAnimation(t) { const e = this.json.animations[t], n = [], i = [], r = [], s = [], o = []; for (let t = 0, a = e.channels.length; t < a; t++) { const a = e.channels[t], l = e.samplers[a.sampler], h = a.target, c = h.node, u = void 0 !== e.parameters ? e.parameters[l.input] : l.input, d = void 0 !== e.parameters ? e.parameters[l.output] : l.output; n.push(this.getDependency("node", c)), i.push(this.getDependency("accessor", u)), r.push(this.getDependency("accessor", d)), s.push(l), o.push(h) } return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o)]).then((function (n) { const i = n[0], r = n[1], s = n[2], o = n[3], a = n[4], l = []; for (let t = 0, e = i.length; t < e; t++) { const e = i[t], n = r[t], h = s[t], c = o[t], u = a[t]; if (void 0 === e) continue; let d; switch (e.updateMatrix(), au[u.path]) { case au.weights: d = Tl; break; case au.rotation: d = Bl; break; default: d = Fl }const p = e.name ? e.name : e.uuid, f = void 0 !== c.interpolation ? lu[c.interpolation] : de, m = []; au[u.path] === au.weights ? e.traverse((function (t) { t.morphTargetInfluences && m.push(t.name ? t.name : t.uuid) })) : m.push(p); let g = h.array; if (h.normalized) { const t = vu(g.constructor), e = new Float32Array(g.length); for (let n = 0, i = g.length; n < i; n++)e[n] = g[n] * t; g = e } for (let t = 0, e = m.length; t < e; t++) { const e = new d(m[t] + "." + au[u.path], n.array, g, f); "CUBICSPLINE" === c.interpolation && (e.createInterpolant = function (t) { return new (this instanceof Bl ? tu : Zc)(this.times, this.values, this.getValueSize() / 3, t) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(e) } } const h = e.name ? e.name : "animation_" + t; return new kl(h, void 0, l) })) } createNodeMesh(t) { const e = this.json, n = this, i = e.nodes[t]; return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (t) { const e = n._getNodeRef(n.meshCache, i.mesh, t); return void 0 !== i.weights && e.traverse((function (t) { if (t.isMesh) for (let e = 0, n = i.weights.length; e < n; e++)t.morphTargetInfluences[e] = i.weights[e] })), e })) } loadNode(t) { const e = this.json, n = this.extensions, i = this, r = e.nodes[t], s = r.name ? i.createUniqueName(r.name) : ""; return function () { const e = [], n = i._invokeOne((function (e) { return e.createNodeMesh && e.createNodeMesh(t) })); n && e.push(n), void 0 !== r.camera && e.push(i.getDependency("camera", r.camera).then((function (t) { return i._getNodeRef(i.cameraCache, r.camera, t) }))), i._invokeAll((function (e) { return e.createNodeAttachment && e.createNodeAttachment(t) })).forEach((function (t) { e.push(t) })); const s = [], o = r.children || []; for (let t = 0, e = o.length; t < e; t++)s.push(i.getDependency("node", o[t])); const a = void 0 === r.skin ? Promise.resolve(null) : i.getDependency("skin", r.skin); return Promise.all([Promise.all(e), Promise.all(s), a]) }().then((function (e) { const o = e[0], a = e[1], l = e[2]; let h; if (h = !0 === r.isBone ? new xa : o.length > 1 ? new ia : 1 === o.length ? o[0] : new bi, h !== o[0]) for (let t = 0, e = o.length; t < e; t++)h.add(o[t]); if (r.name && (h.userData.name = r.name, h.name = s), pu(h, r), r.extensions && du(n, h, r), void 0 !== r.matrix) { const t = new Yn; t.fromArray(r.matrix), h.applyMatrix4(t) } else void 0 !== r.translation && h.position.fromArray(r.translation), void 0 !== r.rotation && h.quaternion.fromArray(r.rotation), void 0 !== r.scale && h.scale.fromArray(r.scale); i.associations.has(h) || i.associations.set(h, {}), i.associations.get(h).nodes = t, null !== l && h.traverse((function (t) { t.isSkinnedMesh && t.bind(l, Au) })); for (let t = 0, e = a.length; t < e; t++)h.add(a[t]); return h })) } loadScene(t) { const e = this.extensions, n = this.json.scenes[t], i = this, r = new ia; n.name && (r.name = i.createUniqueName(n.name)), pu(r, n), n.extensions && du(e, r, n); const s = n.nodes || [], o = []; for (let t = 0, e = s.length; t < e; t++)o.push(i.getDependency("node", s[t])); return Promise.all(o).then((function (t) { for (let e = 0, n = t.length; e < n; e++)r.add(t[e]); return i.associations = (t => { const e = new Map; for (const [t, n] of i.associations) (t instanceof Bi || t instanceof dn) && e.set(t, n); return t.traverse((t => { const n = i.associations.get(t); null != n && e.set(t, n) })), e })(r), r })) } } function yu(t, e, n) { const i = e.attributes, r = []; function s(e, i) { return n.getDependency("accessor", e).then((function (e) { t.setAttribute(i, e) })) } for (const e in i) { const n = ou[e] || e.toLowerCase(); n in t.attributes || r.push(s(i[e], n)) } if (void 0 !== e.indices && !t.index) { const i = n.getDependency("accessor", e.indices).then((function (e) { t.setIndex(e) })); r.push(i) } return pu(t, e), function (t, e, n) { const i = e.attributes, r = new xn; if (void 0 === i.POSITION) return; { const t = n.json.accessors[i.POSITION], e = t.min, s = t.max; if (void 0 === e || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (r.set(new An(e[0], e[1], e[2]), new An(s[0], s[1], s[2])), t.normalized) { const e = vu(nu[t.componentType]); r.min.multiplyScalar(e), r.max.multiplyScalar(e) } } const s = e.targets; if (void 0 !== s) { const t = new An, e = new An; for (let i = 0, r = s.length; i < r; i++) { const r = s[i]; if (void 0 !== r.POSITION) { const i = n.json.accessors[r.POSITION], s = i.min, o = i.max; if (void 0 !== s && void 0 !== o) { if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), i.normalized) { const t = vu(nu[i.componentType]); e.multiplyScalar(t) } t.max(e) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(t) } t.boundingBox = r; const o = new Un; r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, t.boundingSphere = o }(t, e, n), Promise.all(r).then((function () { return void 0 !== e.targets ? function (t, e, n) { let i = !1, r = !1, s = !1; for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (s = !0), i && r && s) break } if (!i && !r && !s) return Promise.resolve(t); const o = [], a = [], l = []; for (let h = 0, c = e.length; h < c; h++) { const c = e[h]; if (i) { const e = void 0 !== c.POSITION ? n.getDependency("accessor", c.POSITION) : t.attributes.position; o.push(e) } if (r) { const e = void 0 !== c.NORMAL ? n.getDependency("accessor", c.NORMAL) : t.attributes.normal; a.push(e) } if (s) { const e = void 0 !== c.COLOR_0 ? n.getDependency("accessor", c.COLOR_0) : t.attributes.color; l.push(e) } } return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then((function (e) { const n = e[0], o = e[1], a = e[2]; return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = o), s && (t.morphAttributes.color = a), t.morphTargetsRelative = !0, t })) }(t, e.targets, n) : t })) } function xu(t, e) { let n = t.getIndex(); if (null === n) { const e = [], i = t.getAttribute("position"); if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t; for (let t = 0; t < i.count; t++)e.push(t); t.setIndex(e), n = t.getIndex() } const i = n.count - 2, r = []; if (e === ve) for (let t = 1; t <= i; t++)r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1)); else for (let t = 0; t < i; t++)t % 2 == 0 ? (r.push(n.getX(t)), r.push(n.getX(t + 1)), r.push(n.getX(t + 2))) : (r.push(n.getX(t + 2)), r.push(n.getX(t + 1)), r.push(n.getX(t))); r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = t.clone(); return s.setIndex(r), s } const _u = new WeakMap; class wu extends zl { constructor(t) { super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(t) { return this.decoderPath = t, this } setDecoderConfig(t) { return this.decoderConfig = t, this } setWorkerLimit(t) { return this.workerLimit = t, this } load(t, e, n, i) { const r = new Gl(this.manager); r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(t, (t => { this.decodeDracoFile(t, e).catch(i) }), n, i) } decodeDracoFile(t, e, n, i) { const r = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: i || this.defaultAttributeTypes, useUniqueIDs: !!n }; return this.decodeGeometry(t, r).then(e) } decodeGeometry(t, e) { const n = JSON.stringify(e); if (_u.has(t)) { const e = _u.get(t); if (e.key === n) return e.promise; if (0 === t.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let i; const r = this.workerNextTaskID++, s = t.byteLength, o = this._getWorker(r, s).then((n => (i = n, new Promise(((n, s) => { i._callbacks[r] = { resolve: n, reject: s }, i.postMessage({ type: "decode", id: r, taskConfig: e, buffer: t }, [t]) }))))).then((t => this._createGeometry(t.geometry))); return o.catch((() => !0)).then((() => { i && r && this._releaseTask(i, r) })), _u.set(t, { key: n, promise: o }), o } _createGeometry(t) { const e = new qi; t.index && e.setIndex(new Ri(t.index.array, 1)); for (let n = 0; n < t.attributes.length; n++) { const i = t.attributes[n], r = i.name, s = i.array, o = i.itemSize; e.setAttribute(r, new Ri(s, o)) } return e } _loadLibrary(t, e) { const n = new Gl(this.manager); return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise(((e, i) => { n.load(t, e, void 0, i) })) } preload() { return this._initDecoder(), this } _initDecoder() { if (this.decoderPending) return this.decoderPending; const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, e = []; return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then((e => { const n = e[0]; t || (this.decoderConfig.wasmBinary = e[1]); const i = Eu.toString(), r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([r])) })), this.decoderPending } _getWorker(t, e) { return this._initDecoder().then((() => { if (this.workerPool.length < this.workerLimit) { const t = new Worker(this.workerSourceURL); t._callbacks = {}, t._taskCosts = {}, t._taskLoad = 0, t.postMessage({ type: "init", decoderConfig: this.decoderConfig }), t.onmessage = function (e) { const n = e.data; switch (n.type) { case "decode": t._callbacks[n.id].resolve(n); break; case "error": t._callbacks[n.id].reject(n); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"') } }, this.workerPool.push(t) } else this.workerPool.sort((function (t, e) { return t._taskLoad > e._taskLoad ? -1 : 1 })); const n = this.workerPool[this.workerPool.length - 1]; return n._taskCosts[t] = e, n._taskLoad += e, n })) } _releaseTask(t, e) { t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e] } debug() { console.log("Task load: ", this.workerPool.map((t => t._taskLoad))) } dispose() { for (let t = 0; t < this.workerPool.length; ++t)this.workerPool[t].terminate(); return this.workerPool.length = 0, this } } function Eu() { let t, e; function n(t, e, n, i, r, s) { const o = s.num_components(), a = n.num_points() * o, l = a * r.BYTES_PER_ELEMENT, h = function (t, e) { switch (e) { case Float32Array: return t.DT_FLOAT32; case Int8Array: return t.DT_INT8; case Int16Array: return t.DT_INT16; case Int32Array: return t.DT_INT32; case Uint8Array: return t.DT_UINT8; case Uint16Array: return t.DT_UINT16; case Uint32Array: return t.DT_UINT32 } }(t, r), c = t._malloc(l); e.GetAttributeDataArrayForAllPoints(n, s, h, l, c); const u = new r(t.HEAPF32.buffer, c, a).slice(); return t._free(c), { name: i, array: u, itemSize: o } } onmessage = function (i) { const r = i.data; switch (r.type) { case "init": t = r.decoderConfig, e = new Promise((function (e) { t.onModuleLoaded = function (t) { e({ draco: t }) }, DracoDecoderModule(t) })); break; case "decode": const i = r.buffer, s = r.taskConfig; e.then((t => { const e = t.draco, o = new e.Decoder, a = new e.DecoderBuffer; a.Init(new Int8Array(i), i.byteLength); try { const t = function (t, e, i, r) { const s = r.attributeIDs, o = r.attributeTypes; let a, l; const h = e.GetEncodedGeometryType(i); if (h === t.TRIANGULAR_MESH) a = new t.Mesh, l = e.DecodeBufferToMesh(i, a); else { if (h !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); a = new t.PointCloud, l = e.DecodeBufferToPointCloud(i, a) } if (!l.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg()); const c = { index: null, attributes: [] }; for (const i in s) { const l = self[o[i]]; let h, u; if (r.useUniqueIDs) u = s[i], h = e.GetAttributeByUniqueId(a, u); else { if (u = e.GetAttributeId(a, t[s[i]]), -1 === u) continue; h = e.GetAttribute(a, u) } c.attributes.push(n(t, e, a, i, l, h)) } h === t.TRIANGULAR_MESH && (c.index = function (t, e, n) { const i = n.num_faces(), r = 3 * i, s = 4 * r, o = t._malloc(s); e.GetTrianglesUInt32Array(n, s, o); const a = new Uint32Array(t.HEAPF32.buffer, o, r).slice(); return t._free(o), { array: a, itemSize: 1 } }(t, e, a)); return t.destroy(a), c }(e, o, a, s), i = t.attributes.map((t => t.array.buffer)); t.index && i.push(t.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: t }, i) } catch (t) { console.error(t), self.postMessage({ type: "error", id: r.id, error: t.message }) } finally { e.destroy(a), e.destroy(o) } })) } } } function Cu(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Su { constructor() { var t = this; let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "AssetsProgress"; Cu(this, "load", (function () { let { element: e = document.body, progress: n = !0 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; e && (t.element = e, t.addFonts(), t.addMedia()); let i = 0; if (n) for (let e = 0; e < t.promisesToLoad.length; e++)t.promisesToLoad[e].then((() => { i++, t.progressCallback(100 * i / t.promisesToLoad.length) })); return t.loaded = new Promise((e => { Promise.all(t.promisesToLoad).then((() => { t.reset(), e(), ec.emit("AssetsLoaded") })) })), t.loaded })), Cu(this, "progressCallback", (t => { ec.emit(this.progressEventName, { percent: Math.ceil(t) }) })), Cu(this, "add", (t => (this.promisesToLoad.push(t), t))), Cu(this, "addMedia", (() => { const t = this.element.querySelectorAll('img:not([lazy="full"])'); for (let e = 0; e < t.length; e++)t[e].getAttribute("src") && this.addImage(t[e]); const e = this.element.querySelectorAll("video:not([lazy])"); for (let t = 0; t < e.length; t++)this.add(new Promise((n => { e[t].crossOrigin = "", e[t].addEventListener("canplaythrough", (function i() { e[t].removeEventListener("canplaythrough", i), e[t].addEventListener("timeupdate", (function i() { e[t].removeEventListener("timeupdate", i), e[t].pause(), n() })) })), e[t].addEventListener("error", n), Fh.isIOS && e[t].addEventListener("suspend", n), "" === e[t].src && e[t].dataset.src && (e[t].src = e[t].dataset.src), e[t].load(), e[t].play() }))) })), Cu(this, "addFonts", (() => { document.fonts && this.add(document.fonts.ready), !this.fontsLoaded && window.Typekit && this.add(new Promise((t => { window.Typekit.load({ active: () => { this.fontsLoaded = !0, t() } }) }))) })), Cu(this, "loadJson", (t => (this.jsons[t] || (this.jsons[t] = this.add(new Promise(((e, n) => { fetch(t, { headers: { "Content-Type": "application/json" } }).then((n => { if (!n.ok) throw new Error("Network response was not ok for request: ", t); e(n.json()) }), n) })))), this.jsons[t]))), Cu(this, "loadGltf", (t => (this.gltfs[t] || (this.gltfs[t] = this.add(new Promise(((e, n) => { this.gltfLoader.load(t, (t => { e(t) }), void 0, n) })))), this.gltfs[t]))), Cu(this, "loadTexture", ((t, e) => (this.textures[t] || (this.textures[t] = this.add(new Promise(((n, i) => { this.textureLoader.load(t, (t => { requestIdleCallback((() => { n(Fh.WebGL.generateTexture(t, e)) }), { timeout: 2e3 }) }), void 0, (e => { i(e), console.error(t) })) })))), this.textures[t]))), Cu(this, "reset", (() => { this.promisesToLoad = [] })), this.promisesToLoad = [], this.fontsLoaded = !1, this.loaded = !1, this.progressEventName = e, this.jsons = {}, this.gltfs = {}, this.textures = {}, this.ktxTextures = {}, this.textureLoader = new jl, this.ktxLoader = new Ec, this.ktxLoader.setTranscoderPath(`${Fh.publicUrl}basis/`), this.gltfLoader = new Pc, this.dracoLoader = new wu, this.dracoLoader.setDecoderPath(`${Fh.publicUrl}draco/`), this.gltfLoader.setDRACOLoader(this.dracoLoader) } addImage(t) { return this.add(new Promise((e => { t.complete && 0 !== t.naturalWidth ? e(t) : (t.addEventListener("load", (() => { e(t) })), t.addEventListener("error", (() => { e(t) }))) }))) } loadKtxTexture(t, e) { return this.ktxTextures[t] || (this.ktxTextures[t] = this.add(new Promise(((n, i) => { this.ktxLoader.load(t, (t => { n(Fh.WebGL.generateTexture(t, e)) }), void 0, (e => { console.error(e, null == e ? void 0 : e.name, null == e ? void 0 : e.stack, null == e ? void 0 : e.message, null == e ? void 0 : e.cause, t), i(e) })) })))), this.ktxTextures[t] } } function Mu(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Pu(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } window.requestIdleCallback = window.requestIdleCallback || function (t) { const e = Date.now(); return setTimeout((() => { t({ didTimeout: !1, timeRemaining: () => Math.max(0, 2e3 - (Date.now() - e)) }) }), 1) }; var Iu, Tu, Du, Bu, Lu, Fu, ku, Ru, Ou, Nu, Uu, zu = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, Vu = { duration: .5, overwrite: !1, delay: 0 }, Qu = 1e8, Gu = 1 / Qu, Hu = 2 * Math.PI, ju = Hu / 4, Wu = 0, qu = Math.sqrt, Yu = Math.cos, Xu = Math.sin, Ku = function (t) { return "string" == typeof t }, Ju = function (t) { return "function" == typeof t }, Zu = function (t) { return "number" == typeof t }, $u = function (t) { return void 0 === t }, td = function (t) { return "object" == typeof t }, ed = function (t) { return !1 !== t }, nd = function () { return "undefined" != typeof window }, id = function (t) { return Ju(t) || Ku(t) }, rd = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, sd = Array.isArray, od = /(?:-?\.?\d|\.)+/gi, ad = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, ld = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, hd = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, cd = /[+-]=-?[.\d]+/, ud = /[^,'"\[\]\s]+/gi, dd = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, pd = {}, fd = {}, md = function (t) { return (fd = Hd(t, pd)) && jf }, gd = function (t, e) { return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()") }, vd = function (t, e) { return !e && console.warn(t) }, Ad = function (t, e) { return t && (pd[t] = e) && fd && (fd[t] = e) || pd }, bd = function () { return 0 }, yd = { suppressEvents: !0, isStart: !0, kill: !1 }, xd = { suppressEvents: !0, kill: !1 }, _d = { suppressEvents: !0 }, wd = {}, Ed = [], Cd = {}, Sd = {}, Md = {}, Pd = 30, Id = [], Td = "", Dd = function (t) { var e, n, i = t[0]; if (td(i) || Ju(i) || (t = [t]), !(e = (i._gsap || {}).harness)) { for (n = Id.length; n-- && !Id[n].targetTest(i);); e = Id[n] } for (n = t.length; n--;)t[n] && (t[n]._gsap || (t[n]._gsap = new of(t[n], e))) || t.splice(n, 1); return t }, Bd = function (t) { return t._gsap || Dd(wp(t))[0]._gsap }, Ld = function (t, e, n) { return (n = t[e]) && Ju(n) ? t[e]() : $u(n) && t.getAttribute && t.getAttribute(e) || n }, Fd = function (t, e) { return (t = t.split(",")).forEach(e) || t }, kd = function (t) { return Math.round(1e5 * t) / 1e5 || 0 }, Rd = function (t) { return Math.round(1e7 * t) / 1e7 || 0 }, Od = function (t, e) { var n = e.charAt(0), i = parseFloat(e.substr(2)); return t = parseFloat(t), "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i }, Nd = function (t, e) { for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;); return i < n }, Ud = function () { var t, e, n = Ed.length, i = Ed.slice(0); for (Cd = {}, Ed.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0) }, zd = function (t, e, n, i) { Ed.length && !Tu && Ud(), t.render(e, n, i || Tu && e < 0 && (t._initted || t._startAt)), Ed.length && !Tu && Ud() }, Vd = function (t) { var e = parseFloat(t); return (e || 0 === e) && (t + "").match(ud).length < 2 ? e : Ku(t) ? t.trim() : t }, Qd = function (t) { return t }, Gd = function (t, e) { for (var n in e) n in t || (t[n] = e[n]); return t }, Hd = function (t, e) { for (var n in e) t[n] = e[n]; return t }, jd = function t(e, n) { for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = td(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]); return e }, Wd = function (t, e) { var n, i = {}; for (n in t) n in e || (i[n] = t[n]); return i }, qd = function (t) { var e, n = t.parent || Bu, i = t.keyframes ? (e = sd(t.keyframes), function (t, n) { for (var i in n) i in t || "duration" === i && e || "ease" === i || (t[i] = n[i]) }) : Gd; if (ed(t.inherit)) for (; n;)i(t, n.vars.defaults), n = n.parent || n._dp; return t }, Yd = function (t, e, n, i, r) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var s, o = t[i]; if (r) for (s = e[r]; o && o[r] > s;)o = o._prev; return o ? (e._next = o._next, o._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = o, e.parent = e._dp = t, e }, Xd = function (t, e, n, i) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var r = e._prev, s = e._next; r ? r._next = s : t[n] === e && (t[n] = s), s ? s._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null }, Kd = function (t, e) { t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0 }, Jd = function (t, e) { if (t && (!e || e._end > t._dur || e._start < 0)) for (var n = t; n;)n._dirty = 1, n = n.parent; return t }, Zd = function (t) { for (var e = t.parent; e && e.parent;)e._dirty = 1, e.totalDuration(), e = e.parent; return t }, $d = function (t, e, n, i) { return t._startAt && (Tu ? t._startAt.revert(xd) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, i)) }, tp = function t(e) { return !e || e._ts && t(e.parent) }, ep = function (t) { return t._repeat ? np(t._tTime, t = t.duration() + t._rDelay) * t : 0 }, np = function (t, e) { var n = Math.floor(t /= e); return t && n === t ? n - 1 : n }, ip = function (t, e) { return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur) }, rp = function (t) { return t._end = Rd(t._start + (t._tDur / Math.abs(t._ts || t._rts || Gu) || 0)) }, sp = function (t, e) { var n = t._dp; return n && n.smoothChildTiming && t._ts && (t._start = Rd(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), rp(t), n._dirty || Jd(n, t)), t }, op = function (t, e) { var n; if ((e._time || e._initted && !e._dur) && (n = ip(t.rawTime(), e), (!e._dur || Ap(0, e.totalDuration(), n) - e._tTime > Gu) && e.render(n, !0)), Jd(t, e)._dp && t._initted && t._time >= t._dur && t._ts) { if (t._dur < t.duration()) for (n = t; n._dp;)n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp; t._zTime = -Gu } }, ap = function (t, e, n, i) { return e.parent && Kd(e), e._start = Rd((Zu(n) ? n : n || t !== Bu ? mp(t, n, e) : t._time) + e._delay), e._end = Rd(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Yd(t, e, "_first", "_last", t._sort ? "_start" : 0), up(e) || (t._recent = e), i || op(t, e), t._ts < 0 && sp(t, t._tTime), t }, lp = function (t, e) { return (pd.ScrollTrigger || gd("scrollTrigger", e)) && pd.ScrollTrigger.create(e, t) }, hp = function (t, e, n, i, r) { return ff(t, e, r), t._initted ? !n && t._pt && !Tu && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && Ou !== Wp.frame ? (Ed.push(t), t._lazy = [r, i], 1) : void 0 : 1 }, cp = function t(e) { var n = e.parent; return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n)) }, up = function (t) { var e = t.data; return "isFromStart" === e || "isStart" === e }, dp = function (t, e, n, i) { var r = t._repeat, s = Rd(e) || 0, o = t._tTime / t._tDur; return o && !i && (t._time *= s / t._dur), t._dur = s, t._tDur = r ? r < 0 ? 1e10 : Rd(s * (r + 1) + t._rDelay * r) : s, o > 0 && !i && sp(t, t._tTime = t._tDur * o), t.parent && rp(t), n || Jd(t.parent, t), t }, pp = function (t) { return t instanceof lf ? Jd(t) : dp(t, t._dur) }, fp = { _start: 0, endTime: bd, totalDuration: bd }, mp = function t(e, n, i) { var r, s, o, a = e.labels, l = e._recent || fp, h = e.duration() >= Qu ? l.endTime(!1) : e._dur; return Ku(n) && (isNaN(n) || n in a) ? (s = n.charAt(0), o = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = h), a[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), o && i && (s = s / 100 * (sd(i) ? i[0] : i).totalDuration()), r > 1 ? t(e, n.substr(0, r - 1), i) + s : h + s)) : null == n ? h : +n }, gp = function (t, e, n) { var i, r, s = Zu(e[1]), o = (s ? 2 : 1) + (t < 2 ? 0 : 1), a = e[o]; if (s && (a.duration = e[1]), a.parent = n, t) { for (i = a, r = n; r && !("immediateRender" in i);)i = r.vars.defaults || {}, r = ed(r.vars.inherit) && r.parent; a.immediateRender = ed(i.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1] } return new bf(e[0], a, e[o + 1]) }, vp = function (t, e) { return t || 0 === t ? e(t) : e }, Ap = function (t, e, n) { return n < t ? t : n > e ? e : n }, bp = function (t, e) { return Ku(t) && (e = dd.exec(t)) ? e[1] : "" }, yp = [].slice, xp = function (t, e) { return t && td(t) && "length" in t && (!e && !t.length || t.length - 1 in t && td(t[0])) && !t.nodeType && t !== Lu }, _p = function (t, e, n) { return void 0 === n && (n = []), t.forEach((function (t) { var i; return Ku(t) && !e || xp(t, 1) ? (i = n).push.apply(i, wp(t)) : n.push(t) })) || n }, wp = function (t, e, n) { return Du && !e && Du.selector ? Du.selector(t) : !Ku(t) || n || !Fu && qp() ? sd(t) ? _p(t, n) : xp(t) ? yp.call(t, 0) : t ? [t] : [] : yp.call((e || ku).querySelectorAll(t), 0) }, Ep = function (t) { return t = wp(t)[0] || vd("Invalid scope") || {}, function (e) { var n = t.current || t.nativeElement || t; return wp(e, n.querySelectorAll ? n : n === t ? vd("Invalid scope") || ku.createElement("div") : t) } }, Cp = function (t) { return t.sort((function () { return .5 - Math.random() })) }, Sp = function (t) { if (Ju(t)) return t; var e = td(t) ? t : { each: t }, n = tf(e.ease), i = e.from || 0, r = parseFloat(e.base) || 0, s = {}, o = i > 0 && i < 1, a = isNaN(i) || o, l = e.axis, h = i, c = i; return Ku(i) ? h = c = { center: .5, edges: .5, end: 1 }[i] || 0 : !o && a && (h = i[0], c = i[1]), function (t, o, u) { var d, p, f, m, g, v, A, b, y, x = (u || e).length, _ = s[x]; if (!_) { if (!(y = "auto" === e.grid ? 0 : (e.grid || [1, Qu])[1])) { for (A = -Qu; A < (A = u[y++].getBoundingClientRect().left) && y < x;); y-- } for (_ = s[x] = [], d = a ? Math.min(y, x) * h - .5 : i % y, p = y === Qu ? 0 : a ? x * c / y - .5 : i / y | 0, A = 0, b = Qu, v = 0; v < x; v++)f = v % y - d, m = p - (v / y | 0), _[v] = g = l ? Math.abs("y" === l ? m : f) : qu(f * f + m * m), g > A && (A = g), g < b && (b = g); "random" === i && Cp(_), _.max = A - b, _.min = b, _.v = x = (parseFloat(e.amount) || parseFloat(e.each) * (y > x ? x - 1 : l ? "y" === l ? x / y : y : Math.max(y, x / y)) || 0) * ("edges" === i ? -1 : 1), _.b = x < 0 ? r - x : r, _.u = bp(e.amount || e.each) || 0, n = n && x < 0 ? Zp(n) : n } return x = (_[t] - _.min) / _.max || 0, Rd(_.b + (n ? n(x) : x) * _.v) + _.u } }, Mp = function (t) { var e = Math.pow(10, ((t + "").split(".")[1] || "").length); return function (n) { var i = Rd(Math.round(parseFloat(n) / t) * t * e); return (i - i % 1) / e + (Zu(n) ? 0 : bp(n)) } }, Pp = function (t, e) { var n, i, r = sd(t); return !r && td(t) && (n = r = t.radius || Qu, t.values ? (t = wp(t.values), (i = !Zu(t[0])) && (n *= n)) : t = Mp(t.increment)), vp(e, r ? Ju(t) ? function (e) { return i = t(e), Math.abs(i - e) <= n ? i : e } : function (e) { for (var r, s, o = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = Qu, h = 0, c = t.length; c--;)(r = i ? (r = t[c].x - o) * r + (s = t[c].y - a) * s : Math.abs(t[c] - o)) < l && (l = r, h = c); return h = !n || l <= n ? t[h] : e, i || h === e || Zu(e) ? h : h + bp(e) } : Mp(t)) }, Ip = function (t, e, n, i) { return vp(sd(t) ? !e : !0 === n ? !!(n = 0) : !i, (function () { return sd(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i })) }, Tp = function (t, e, n) { return vp(n, (function (n) { return t[~~e(n)] })) }, Dp = function (t) { for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s));)i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? ud : od), o += t.substr(s, e - s) + Ip(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1; return o + t.substr(s, t.length - s) }, Bp = function (t, e, n, i, r) { var s = e - t, o = i - n; return vp(r, (function (e) { return n + ((e - t) / s * o || 0) })) }, Lp = function (t, e, n) { var i, r, s, o = t.labels, a = Qu; for (i in o) (r = o[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i, a = r); return s }, Fp = function (t, e, n) { var i, r, s, o = t.vars, a = o[e], l = Du, h = t._ctx; if (a) return i = o[e + "Params"], r = o.callbackScope || t, n && Ed.length && Ud(), h && (Du = h), s = i ? a.apply(r, i) : a.call(r), Du = l, s }, kp = function (t) { return Kd(t), t.scrollTrigger && t.scrollTrigger.kill(!!Tu), t.progress() < 1 && Fp(t, "onInterrupt"), t }, Rp = function (t) { var e = (t = !t.name && t.default || t).name, n = Ju(t), i = e && !n && t.init ? function () { this._props = [] } : t, r = { init: bd, render: Pf, add: df, kill: Tf, modifier: If, rawVars: 0 }, s = { targetTest: 0, get: 0, getSetter: Ef, aliases: {}, register: 0 }; if (qp(), t !== i) { if (Sd[e]) return; Gd(i, Gd(Wd(t, r), s)), Hd(i.prototype, Hd(r, Wd(t, s))), Sd[i.prop = e] = i, t.targetTest && (Id.push(i), wd[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin" } Ad(e, i), t.register && t.register(jf, i, Lf) }, Op = 255, Np = { aqua: [0, Op, Op], lime: [0, Op, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, Op], navy: [0, 0, 128], white: [Op, Op, Op], olive: [128, 128, 0], yellow: [Op, Op, 0], orange: [Op, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [Op, 0, 0], pink: [Op, 192, 203], cyan: [0, Op, Op], transparent: [Op, Op, Op, 0] }, Up = function (t, e, n) { return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * Op + .5 | 0 }, zp = function (t, e, n) { var i, r, s, o, a, l, h, c, u, d, p = t ? Zu(t) ? [t >> 16, t >> 8 & Op, t & Op] : 0 : Np.black; if (!p) { if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Np[t]) p = Np[t]; else if ("#" === t.charAt(0)) { if (t.length < 6 && (i = t.charAt(1), r = t.charAt(2), s = t.charAt(3), t = "#" + i + i + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & Op, p & Op, parseInt(t.substr(7), 16) / 255]; p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & Op, t & Op] } else if ("hsl" === t.substr(0, 3)) if (p = d = t.match(od), e) { if (~t.indexOf("=")) return p = t.match(ad), n && p.length < 4 && (p[3] = 1), p } else o = +p[0] % 360 / 360, a = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), p.length > 3 && (p[3] *= 1), p[0] = Up(o + 1 / 3, i, r), p[1] = Up(o, i, r), p[2] = Up(o - 1 / 3, i, r); else p = t.match(od) || Np.transparent; p = p.map(Number) } return e && !d && (i = p[0] / Op, r = p[1] / Op, s = p[2] / Op, l = ((h = Math.max(i, r, s)) + (c = Math.min(i, r, s))) / 2, h === c ? o = a = 0 : (u = h - c, a = l > .5 ? u / (2 - h - c) : u / (h + c), o = h === i ? (r - s) / u + (r < s ? 6 : 0) : h === r ? (s - i) / u + 2 : (i - r) / u + 4, o *= 60), p[0] = ~~(o + .5), p[1] = ~~(100 * a + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p }, Vp = function (t) { var e = [], n = [], i = -1; return t.split(Gp).forEach((function (t) { var r = t.match(ld) || []; e.push.apply(e, r), n.push(i += r.length + 1) })), e.c = n, e }, Qp = function (t, e, n) { var i, r, s, o, a = "", l = (t + a).match(Gp), h = e ? "hsla(" : "rgba(", c = 0; if (!l) return t; if (l = l.map((function (t) { return (t = zp(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")" })), n && (s = Vp(t), (i = n.c).join(a) !== s.c.join(a))) for (o = (r = t.replace(Gp, "1").split(ld)).length - 1; c < o; c++)a += r[c] + (~i.indexOf(c) ? l.shift() || h + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift()); if (!r) for (o = (r = t.split(Gp)).length - 1; c < o; c++)a += r[c] + l[c]; return a + r[o] }, Gp = function () { var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b"; for (t in Np) e += "|" + t + "\\b"; return new RegExp(e + ")", "gi") }(), Hp = /hsl[a]?\(/, jp = function (t) { var e, n = t.join(" "); if (Gp.lastIndex = 0, Gp.test(n)) return e = Hp.test(n), t[1] = Qp(t[1], e), t[0] = Qp(t[0], e, Vp(t[1])), !0 }, Wp = function () { var t, e, n, i, r, s, o = Date.now, a = 500, l = 33, h = o(), c = h, u = 1e3 / 240, d = u, p = [], f = function n(f) { var m, g, v, A, b = o() - c, y = !0 === f; if (b > a && (h += b - l), ((m = (v = (c += b) - h) - d) > 0 || y) && (A = ++i.frame, r = v - 1e3 * i.time, i.time = v /= 1e3, d += m + (m >= u ? 4 : u - m), g = 1), y || (t = e(n)), g) for (s = 0; s < p.length; s++)p[s](v, r, A, f) }; return i = { time: 0, frame: 0, tick: function () { f(!0) }, deltaRatio: function (t) { return r / (1e3 / (t || 60)) }, wake: function () { Ru && (!Fu && nd() && (Lu = Fu = window, ku = Lu.document || {}, pd.gsap = jf, (Lu.gsapVersions || (Lu.gsapVersions = [])).push(jf.version), md(fd || Lu.GreenSockGlobals || !Lu.gsap && Lu || {}), n = Lu.requestAnimationFrame), t && i.sleep(), e = n || function (t) { return setTimeout(t, d - 1e3 * i.time + 1 | 0) }, Uu = 1, f(2)) }, sleep: function () { (n ? Lu.cancelAnimationFrame : clearTimeout)(t), Uu = 0, e = bd }, lagSmoothing: function (t, e) { a = t || 1 / 0, l = Math.min(e || 33, a) }, fps: function (t) { u = 1e3 / (t || 240), d = 1e3 * i.time + u }, add: function (t, e, n) { var r = e ? function (e, n, s, o) { t(e, n, s, o), i.remove(r) } : t; return i.remove(t), p[n ? "unshift" : "push"](r), qp(), r }, remove: function (t, e) { ~(e = p.indexOf(t)) && p.splice(e, 1) && s >= e && s-- }, _listeners: p }, i }(), qp = function () { return !Uu && Wp.wake() }, Yp = {}, Xp = /^[\d.\-M][\d.\-,\s]/, Kp = /["']/g, Jp = function (t) { for (var e, n, i, r = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++)n = s[a], e = a !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[o] = isNaN(i) ? i.replace(Kp, "").trim() : +i, o = n.substr(e + 1).trim(); return r }, Zp = function (t) { return function (e) { return 1 - t(1 - e) } }, $p = function t(e, n) { for (var i, r = e._first; r;)r instanceof lf ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next }, tf = function (t, e) { return t && (Ju(t) ? t : Yp[t] || function (t) { var e, n, i, r, s = (t + "").split("("), o = Yp[s[0]]; return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [Jp(s[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(Vd)) : Yp._CE && Xp.test(t) ? Yp._CE("", t) : o }(t)) || e }, ef = function (t, e, n, i) { void 0 === n && (n = function (t) { return 1 - e(1 - t) }), void 0 === i && (i = function (t) { return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2 }); var r, s = { easeIn: e, easeOut: n, easeInOut: i }; return Fd(t, (function (t) { for (var e in Yp[t] = pd[t] = s, Yp[r = t.toLowerCase()] = n, s) Yp[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Yp[t + "." + e] = s[e] })), s }, nf = function (t) { return function (e) { return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2 } }, rf = function t(e, n, i) { var r = n >= 1 ? n : 1, s = (i || (e ? .3 : .45)) / (n < 1 ? n : 1), o = s / Hu * (Math.asin(1 / r) || 0), a = function (t) { return 1 === t ? 1 : r * Math.pow(2, -10 * t) * Xu((t - o) * s) + 1 }, l = "out" === e ? a : "in" === e ? function (t) { return 1 - a(1 - t) } : nf(a); return s = Hu / s, l.config = function (n, i) { return t(e, n, i) }, l }, sf = function t(e, n) { void 0 === n && (n = 1.70158); var i = function (t) { return t ? --t * t * ((n + 1) * t + n) + 1 : 0 }, r = "out" === e ? i : "in" === e ? function (t) { return 1 - i(1 - t) } : nf(i); return r.config = function (n) { return t(e, n) }, r }; Fd("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) { var n = e < 5 ? e + 1 : e; ef(t + ",Power" + (n - 1), e ? function (t) { return Math.pow(t, n) } : function (t) { return t }, (function (t) { return 1 - Math.pow(1 - t, n) }), (function (t) { return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2 })) })), Yp.Linear.easeNone = Yp.none = Yp.Linear.easeIn, ef("Elastic", rf("in"), rf("out"), rf()), function (t, e) { var n = 1 / e, i = function (i) { return i < n ? t * i * i : i < .7272727272727273 ? t * Math.pow(i - 1.5 / e, 2) + .75 : i < .9090909090909092 ? t * (i -= 2.25 / e) * i + .9375 : t * Math.pow(i - 2.625 / e, 2) + .984375 }; ef("Bounce", (function (t) { return 1 - i(1 - t) }), i) }(7.5625, 2.75), ef("Expo", (function (t) { return t ? Math.pow(2, 10 * (t - 1)) : 0 })), ef("Circ", (function (t) { return -(qu(1 - t * t) - 1) })), ef("Sine", (function (t) { return 1 === t ? 1 : 1 - Yu(t * ju) })), ef("Back", sf("in"), sf("out"), sf()), Yp.SteppedEase = Yp.steps = pd.SteppedEase = { config: function (t, e) { void 0 === t && (t = 1); var n = 1 / t, i = t + (e ? 0 : 1), r = e ? 1 : 0, s = 1 - Gu; return function (t) { return ((i * Ap(0, s, t) | 0) + r) * n } } }, Vu.ease = Yp["quad.out"], Fd("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) { return Td += t + "," + t + "Params," })); var of = function (t, e) { this.id = Wu++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : Ld, this.set = e ? e.getSetter : Ef }, af = function () { function t(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, dp(this, +t.duration, 1, 1), this.data = t.data, Du && (this._ctx = Du, Du.data.push(this)), Uu || Wp.wake() } var e = t.prototype; return e.delay = function (t) { return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay }, e.duration = function (t) { return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur }, e.totalDuration = function (t) { return arguments.length ? (this._dirty = 0, dp(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (t, e) { if (qp(), !arguments.length) return this._tTime; var n = this._dp; if (n && n.smoothChildTiming && this._ts) { for (sp(this, t), !n._dp || n.parent || op(n, this); n && n.parent;)n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && ap(this._dp, this, this._start - this._delay) } return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === Gu || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), zd(this, t, e)), this }, e.time = function (t, e) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + ep(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time }, e.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, e.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + ep(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, e.iteration = function (t, e) { var n = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? np(this._tTime, n) + 1 : 1 }, e.timeScale = function (t) { if (!arguments.length) return this._rts === -Gu ? 0 : this._rts; if (this._rts === t) return this; var e = this.parent && this._ts ? ip(this.parent._time, this) : this._tTime; return this._rts = +t || 0, this._ts = this._ps || t === -Gu ? 0 : this._rts, this.totalTime(Ap(-this._delay, this._tDur, e), !0), rp(this), Zd(this) }, e.paused = function (t) { return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (qp(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== Gu && (this._tTime -= Gu)))), this) : this._ps }, e.startTime = function (t) { if (arguments.length) { this._start = t; var e = this.parent || this._dp; return e && (e._sort || !this.parent) && ap(e, this, t - this._delay), this } return this._start }, e.endTime = function (t) { return this._start + (ed(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, e.rawTime = function (t) { var e = this.parent || this._dp; return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ip(e.rawTime(t), this) : this._tTime : this._tTime }, e.revert = function (t) { void 0 === t && (t = _d); var e = Tu; return Tu = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), Tu = e, this }, e.globalTime = function (t) { for (var e = this, n = arguments.length ? t : e.rawTime(); e;)n = e._start + n / (e._ts || 1), e = e._dp; return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(t) : n }, e.repeat = function (t) { return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, pp(this)) : -2 === this._repeat ? 1 / 0 : this._repeat }, e.repeatDelay = function (t) { if (arguments.length) { var e = this._time; return this._rDelay = t, pp(this), e ? this.time(e) : this } return this._rDelay }, e.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, e.seek = function (t, e) { return this.totalTime(mp(this, t), ed(e)) }, e.restart = function (t, e) { return this.play().totalTime(t ? -this._delay : 0, ed(e)) }, e.play = function (t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, e.reverse = function (t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, e.pause = function (t, e) { return null != t && this.seek(t, e), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (t) { return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -Gu : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = this._act = 0, this._zTime = -Gu, this }, e.isActive = function () { var t, e = this.parent || this._dp, n = this._start; return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - Gu)) }, e.eventCallback = function (t, e, n) { var i = this.vars; return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t] }, e.then = function (t) { var e = this; return new Promise((function (n) { var i = Ju(t) ? t : Qd, r = function () { var t = e.then; e.then = null, Ju(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t }; e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r })) }, e.kill = function () { kp(this) }, t }(); Gd(af.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -Gu, _prom: 0, _ps: !1, _rts: 1 }); var lf = function (t) { function e(e, n) { var i; return void 0 === e && (e = {}), (i = t.call(this, e) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = ed(e.sortChildren), Bu && ap(e.parent || Bu, Mu(i), n), e.reversed && i.reverse(), e.paused && i.paused(!0), e.scrollTrigger && lp(Mu(i), e.scrollTrigger), i } Pu(e, t); var n = e.prototype; return n.to = function (t, e, n) { return gp(0, arguments, this), this }, n.from = function (t, e, n) { return gp(1, arguments, this), this }, n.fromTo = function (t, e, n, i) { return gp(2, arguments, this), this }, n.set = function (t, e, n) { return e.duration = 0, e.parent = this, qd(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new bf(t, e, mp(this, n), 1), this }, n.call = function (t, e, n) { return ap(this, bf.delayedCall(0, t, e), n) }, n.staggerTo = function (t, e, n, i, r, s, o) { return n.duration = e, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = o, n.parent = this, new bf(t, n, mp(this, r)), this }, n.staggerFrom = function (t, e, n, i, r, s, o) { return n.runBackwards = 1, qd(n).immediateRender = ed(n.immediateRender), this.staggerTo(t, e, n, i, r, s, o) }, n.staggerFromTo = function (t, e, n, i, r, s, o, a) { return i.startAt = n, qd(i).immediateRender = ed(i.immediateRender), this.staggerTo(t, e, i, r, s, o, a) }, n.render = function (t, e, n) { var i, r, s, o, a, l, h, c, u, d, p, f, m = this._time, g = this._dirty ? this.totalDuration() : this._tDur, v = this._dur, A = t <= 0 ? 0 : Rd(t), b = this._zTime < 0 != t < 0 && (this._initted || !v); if (this !== Bu && A > g && t >= 0 && (A = g), A !== this._tTime || n || b) { if (m !== this._time && v && (A += this._time - m, t += this._time - m), i = A, u = this._start, l = !(c = this._ts), b && (v || (m = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) { if (p = this._yoyo, a = v + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * a + t, e, n); if (i = Rd(A % a), A === g ? (o = this._repeat, i = v) : ((o = ~~(A / a)) && o === A / a && (i = v, o--), i > v && (i = v)), d = np(this._tTime, a), !m && this._tTime && d !== o && (d = o), p && 1 & o && (i = v - i, f = 1), o !== d && !this._lock) { var y = p && 1 & d, x = y === (p && 1 & o); if (o < d && (y = !y), m = y ? 0 : v, this._lock = 1, this.render(m || (f ? 0 : Rd(o * a)), e, !v)._lock = 0, this._tTime = A, !e && this.parent && Fp(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (v = this._dur, g = this._tDur, x && (this._lock = 2, m = y ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this; $p(this, f) } } if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (t, e, n) { var i; if (n > e) for (i = t._first; i && i._start <= n;) { if ("isPause" === i.data && i._start > e) return i; i = i._next } else for (i = t._last; i && i._start >= n;) { if ("isPause" === i.data && i._start < e) return i; i = i._prev } }(this, Rd(m), Rd(i)), h && (A -= i - (i = h._start))), this._tTime = A, this._time = i, this._act = !c, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, m = 0), !m && i && !e && (Fp(this, "onStart"), this._tTime !== A)) return this; if (i >= m && t >= 0) for (r = this._first; r;) { if (s = r._next, (r._act || i >= r._start) && r._ts && h !== r) { if (r.parent !== this) return this.render(t, e, n); if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) { h = 0, s && (A += this._zTime = -Gu); break } } r = s } else { r = this._last; for (var _ = t < 0 ? t : i; r;) { if (s = r._prev, (r._act || _ <= r._end) && r._ts && h !== r) { if (r.parent !== this) return this.render(t, e, n); if (r.render(r._ts > 0 ? (_ - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (_ - r._start) * r._ts, e, n || Tu && (r._initted || r._startAt)), i !== this._time || !this._ts && !l) { h = 0, s && (A += this._zTime = _ ? -Gu : Gu); break } } r = s } } if (h && !e && (this.pause(), h.render(i >= m ? 0 : -Gu)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = u, rp(this), this.render(t, e, n); this._onUpdate && !e && Fp(this, "onUpdate", !0), (A === g && this._tTime >= this.totalDuration() || !A && m) && (u !== this._start && Math.abs(c) === Math.abs(this._ts) || this._lock || ((t || !v) && (A === g && this._ts > 0 || !A && this._ts < 0) && Kd(this, 1), e || t < 0 && !m || !A && !m && g || (Fp(this, A === g && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(A < g && this.timeScale() > 0) && this._prom()))) } return this }, n.add = function (t, e) { var n = this; if (Zu(e) || (e = mp(this, e, t)), !(t instanceof af)) { if (sd(t)) return t.forEach((function (t) { return n.add(t, e) })), this; if (Ku(t)) return this.addLabel(t, e); if (!Ju(t)) return this; t = bf.delayedCall(0, t) } return this !== t ? ap(this, t, e) : this }, n.getChildren = function (t, e, n, i) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -Qu); for (var r = [], s = this._first; s;)s._start >= i && (s instanceof bf ? e && r.push(s) : (n && r.push(s), t && r.push.apply(r, s.getChildren(!0, e, n)))), s = s._next; return r }, n.getById = function (t) { for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)if (e[n].vars.id === t) return e[n] }, n.remove = function (t) { return Ku(t) ? this.removeLabel(t) : Ju(t) ? this.killTweensOf(t) : (Xd(this, t), t === this._recent && (this._recent = this._last), Jd(this)) }, n.totalTime = function (e, n) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Rd(Wp.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime }, n.addLabel = function (t, e) { return this.labels[t] = mp(this, e), this }, n.removeLabel = function (t) { return delete this.labels[t], this }, n.addPause = function (t, e, n) { var i = bf.delayedCall(0, e || bd, n); return i.data = "isPause", this._hasPause = 1, ap(this, i, mp(this, t)) }, n.removePause = function (t) { var e = this._first; for (t = mp(this, t); e;)e._start === t && "isPause" === e.data && Kd(e), e = e._next }, n.killTweensOf = function (t, e, n) { for (var i = this.getTweensOf(t, n), r = i.length; r--;)hf !== i[r] && i[r].kill(t, e); return this }, n.getTweensOf = function (t, e) { for (var n, i = [], r = wp(t), s = this._first, o = Zu(e); s;)s instanceof bf ? Nd(s._targets, r) && (o ? (!hf || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n), s = s._next; return i }, n.tweenTo = function (t, e) { e = e || {}; var n, i = this, r = mp(i, t), s = e, o = s.startAt, a = s.onStart, l = s.onStartParams, h = s.immediateRender, c = bf.to(i, Gd({ ease: e.ease || "none", lazy: !1, immediateRender: !1, time: r, overwrite: "auto", duration: e.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale()) || Gu, onStart: function () { if (i.pause(), !n) { var t = e.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale()); c._dur !== t && dp(c, t, 0, 1).render(c._time, !0, !0), n = 1 } a && a.apply(c, l || []) } }, e)); return h ? c.render(0) : c }, n.tweenFromTo = function (t, e, n) { return this.tweenTo(e, Gd({ startAt: { time: mp(this, t) } }, n)) }, n.recent = function () { return this._recent }, n.nextLabel = function (t) { return void 0 === t && (t = this._time), Lp(this, mp(this, t)) }, n.previousLabel = function (t) { return void 0 === t && (t = this._time), Lp(this, mp(this, t), 1) }, n.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + Gu) }, n.shiftChildren = function (t, e, n) { void 0 === n && (n = 0); for (var i, r = this._first, s = this.labels; r;)r._start >= n && (r._start += t, r._end += t), r = r._next; if (e) for (i in s) s[i] >= n && (s[i] += t); return Jd(this) }, n.invalidate = function (e) { var n = this._first; for (this._lock = 0; n;)n.invalidate(e), n = n._next; return t.prototype.invalidate.call(this, e) }, n.clear = function (t) { void 0 === t && (t = !0); for (var e, n = this._first; n;)e = n._next, this.remove(n), n = e; return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Jd(this) }, n.totalDuration = function (t) { var e, n, i, r = 0, s = this, o = s._last, a = Qu; if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t)); if (s._dirty) { for (i = s.parent; o;)e = o._prev, o._dirty && o.totalDuration(), (n = o._start) > a && s._sort && o._ts && !s._lock ? (s._lock = 1, ap(s, o, n - o._delay, 1)._lock = 0) : a = n, n < 0 && o._ts && (r -= n, (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -Infinity), a = 0), o._end > r && o._ts && (r = o._end), o = e; dp(s, s === Bu && s._time > r ? s._time : r, 1, 1), s._dirty = 0 } return s._tDur }, e.updateRoot = function (t) { if (Bu._ts && (zd(Bu, ip(t, Bu)), Ou = Wp.frame), Wp.frame >= Pd) { Pd += zu.autoSleep || 120; var e = Bu._first; if ((!e || !e._ts) && zu.autoSleep && Wp._listeners.length < 2) { for (; e && !e._ts;)e = e._next; e || Wp.sleep() } } }, e }(af); Gd(lf.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var hf, cf, uf = function (t, e, n, i, r, s, o) { var a, l, h, c, u, d, p, f, m = new Lf(this._pt, t, e, 0, 1, Mf, null, r), g = 0, v = 0; for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = Dp(i)), s && (s(f = [n, i], t, e), n = f[0], i = f[1]), l = n.match(hd) || []; a = hd.exec(i);)c = a[0], u = i.substring(g, a.index), h ? h = (h + 1) % 5 : "rgba(" === u.substr(-5) && (h = 1), c !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = { _next: m._pt, p: u || 1 === v ? u : ",", s: d, c: "=" === c.charAt(1) ? Od(d, c) - d : parseFloat(c) - d, m: h && h < 4 ? Math.round : 0 }, g = hd.lastIndex); return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = o, (cd.test(i) || p) && (m.e = 0), this._pt = m, m }, df = function (t, e, n, i, r, s, o, a, l, h) { Ju(i) && (i = i(r || 0, t, s)); var c, u = t[e], d = "get" !== n ? n : Ju(u) ? l ? t[e.indexOf("set") || !Ju(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u, p = Ju(u) ? l ? _f : xf : yf; if (Ku(i) && (~i.indexOf("random(") && (i = Dp(i)), "=" === i.charAt(1) && ((c = Od(d, i) + (bp(d) || 0)) || 0 === c) && (i = c)), !h || d !== i || cf) return isNaN(d * i) || "" === i ? (!u && !(e in t) && gd(e, i), uf.call(this, t, e, d, i, p, a || zu.stringFilter, l)) : (c = new Lf(this._pt, t, e, +d || 0, i - (d || 0), "boolean" == typeof u ? Sf : Cf, 0, p), l && (c.fp = l), o && c.modifier(o, this, t), this._pt = c) }, pf = function (t, e, n, i, r, s) { var o, a, l, h; if (Sd[t] && !1 !== (o = new Sd[t]).init(r, o.rawVars ? e[t] : function (t, e, n, i, r) { if (Ju(t) && (t = gf(t, r, e, n, i)), !td(t) || t.style && t.nodeType || sd(t) || rd(t)) return Ku(t) ? gf(t, r, e, n, i) : t; var s, o = {}; for (s in t) o[s] = gf(t[s], r, e, n, i); return o }(e[t], i, r, s, n), n, i, s) && (n._pt = a = new Lf(n._pt, r, t, 0, 1, o.render, o, 0, o.priority), n !== Nu)) for (l = n._ptLookup[n._targets.indexOf(r)], h = o._props.length; h--;)l[o._props[h]] = a; return o }, ff = function t(e, n, i) { var r, s, o, a, l, h, c, u, d, p, f, m, g, v = e.vars, A = v.ease, b = v.startAt, y = v.immediateRender, x = v.lazy, _ = v.onUpdate, w = v.onUpdateParams, E = v.callbackScope, C = v.runBackwards, S = v.yoyoEase, M = v.keyframes, P = v.autoRevert, I = e._dur, T = e._startAt, D = e._targets, B = e.parent, L = B && "nested" === B.data ? B.vars.targets : D, F = "auto" === e._overwrite && !Iu, k = e.timeline; if (k && (!M || !A) && (A = "none"), e._ease = tf(A, Vu.ease), e._yEase = S ? Zp(tf(!0 === S ? A : S, Vu.ease)) : 0, S && e._yoyo && !e._repeat && (S = e._yEase, e._yEase = e._ease, e._ease = S), e._from = !k && !!v.runBackwards, !k || M && !v.stagger) { if (m = (u = D[0] ? Bd(D[0]).harness : 0) && v[u.prop], r = Wd(v, wd), T && (T._zTime < 0 && T.progress(1), n < 0 && C && y && !P ? T.render(-1, !0) : T.revert(C && I ? xd : yd), T._lazy = 0), b) { if (Kd(e._startAt = bf.set(D, Gd({ data: "isStart", overwrite: !1, parent: B, immediateRender: !0, lazy: !T && ed(x), startAt: null, delay: 0, onUpdate: _, onUpdateParams: w, callbackScope: E, stagger: 0 }, b))), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (Tu || !y && !P) && e._startAt.revert(xd), y && I && n <= 0 && i <= 0) return void (n && (e._zTime = n)) } else if (C && I && !T) if (n && (y = !1), o = Gd({ overwrite: !1, data: "isFromStart", lazy: y && !T && ed(x), immediateRender: y, stagger: 0, parent: B }, r), m && (o[u.prop] = m), Kd(e._startAt = bf.set(D, o)), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (Tu ? e._startAt.revert(xd) : e._startAt.render(-1, !0)), e._zTime = n, y) { if (!n) return } else t(e._startAt, Gu, Gu); for (e._pt = e._ptCache = 0, x = I && ed(x) || x && !I, s = 0; s < D.length; s++) { if (c = (l = D[s])._gsap || Dd(D)[s]._gsap, e._ptLookup[s] = p = {}, Cd[c.id] && Ed.length && Ud(), f = L === D ? s : L.indexOf(l), u && !1 !== (d = new u).init(l, m || r, e, f, L) && (e._pt = a = new Lf(e._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function (t) { p[t] = a })), d.priority && (h = 1)), !u || m) for (o in r) Sd[o] && (d = pf(o, r, e, f, l, L)) ? d.priority && (h = 1) : p[o] = a = df.call(e, l, o, "get", r[o], f, L, 0, v.stringFilter); e._op && e._op[s] && e.kill(l, e._op[s]), F && e._pt && (hf = e, Bu.killTweensOf(l, p, e.globalTime(n)), g = !e.parent, hf = 0), e._pt && x && (Cd[c.id] = 1) } h && Bf(e), e._onInit && e._onInit(e) } e._onUpdate = _, e._initted = (!e._op || e._pt) && !g, M && n <= 0 && k.render(Qu, !0, !0) }, mf = function (t, e, n, i) { var r, s, o = e.ease || i || "power1.inOut"; if (sd(e)) s = n[t] || (n[t] = []), e.forEach((function (t, n) { return s.push({ t: n / (e.length - 1) * 100, v: t, e: o }) })); else for (r in e) s = n[r] || (n[r] = []), "ease" === r || s.push({ t: parseFloat(t), v: e[r], e: o }) }, gf = function (t, e, n, i, r) { return Ju(t) ? t.call(e, n, i, r) : Ku(t) && ~t.indexOf("random(") ? Dp(t) : t }, vf = Td + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Af = {}; Fd(vf + ",id,stagger,delay,duration,paused,scrollTrigger", (function (t) { return Af[t] = 1 })); var bf = function (t) { function e(e, n, i, r) { var s; "number" == typeof n && (i.duration = n, n = i, i = null); var o, a, l, h, c, u, d, p, f = (s = t.call(this, r ? n : qd(n)) || this).vars, m = f.duration, g = f.delay, v = f.immediateRender, A = f.stagger, b = f.overwrite, y = f.keyframes, x = f.defaults, _ = f.scrollTrigger, w = f.yoyoEase, E = n.parent || Bu, C = (sd(e) || rd(e) ? Zu(e[0]) : "length" in n) ? [e] : wp(e); if (s._targets = C.length ? Dd(C) : vd("GSAP target " + e + " not found. https://greensock.com", !zu.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = b, y || A || id(m) || id(g)) { if (n = s.vars, (o = s.timeline = new lf({ data: "nested", defaults: x || {}, targets: E && "nested" === E.data ? E.vars.targets : C })).kill(), o.parent = o._dp = Mu(s), o._start = 0, A || id(m) || id(g)) { if (h = C.length, d = A && Sp(A), td(A)) for (c in A) ~vf.indexOf(c) && (p || (p = {}), p[c] = A[c]); for (a = 0; a < h; a++)(l = Wd(n, Af)).stagger = 0, w && (l.yoyoEase = w), p && Hd(l, p), u = C[a], l.duration = +gf(m, Mu(s), a, u, C), l.delay = (+gf(g, Mu(s), a, u, C) || 0) - s._delay, !A && 1 === h && l.delay && (s._delay = g = l.delay, s._start += g, l.delay = 0), o.to(u, l, d ? d(a, u, C) : 0), o._ease = Yp.none; o.duration() ? m = g = 0 : s.timeline = 0 } else if (y) { qd(Gd(o.vars.defaults, { ease: "none" })), o._ease = tf(y.ease || n.ease || "none"); var S, M, P, I = 0; if (sd(y)) y.forEach((function (t) { return o.to(C, t, ">") })), o.duration(); else { for (c in l = {}, y) "ease" === c || "easeEach" === c || mf(c, y[c], l, y.easeEach); for (c in l) for (S = l[c].sort((function (t, e) { return t.t - e.t })), I = 0, a = 0; a < S.length; a++)(P = { ease: (M = S[a]).e, duration: (M.t - (a ? S[a - 1].t : 0)) / 100 * m })[c] = M.v, o.to(C, P, I), I += P.duration; o.duration() < m && o.to({}, { duration: m - o.duration() }) } } m || s.duration(m = o.duration()) } else s.timeline = 0; return !0 !== b || Iu || (hf = Mu(s), Bu.killTweensOf(C), hf = 0), ap(E, Mu(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), (v || !m && !y && s._start === Rd(E._time) && ed(v) && tp(Mu(s)) && "nested" !== E.data) && (s._tTime = -Gu, s.render(Math.max(0, -g) || 0)), _ && lp(Mu(s), _), s } Pu(e, t); var n = e.prototype; return n.render = function (t, e, n) { var i, r, s, o, a, l, h, c, u, d = this._time, p = this._tDur, f = this._dur, m = t < 0, g = t > p - Gu && !m ? p : t < Gu ? 0 : t; if (f) { if (g !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m) { if (i = g, c = this.timeline, this._repeat) { if (o = f + this._rDelay, this._repeat < -1 && m) return this.totalTime(100 * o + t, e, n); if (i = Rd(g % o), g === p ? (s = this._repeat, i = f) : ((s = ~~(g / o)) && s === g / o && (i = f, s--), i > f && (i = f)), (l = this._yoyo && 1 & s) && (u = this._yEase, i = f - i), a = np(this._tTime, o), i === d && !n && this._initted) return this._tTime = g, this; s !== a && (c && this._yEase && $p(c, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(Rd(o * s), !0).invalidate()._lock = 0)) } if (!this._initted) { if (hp(this, m ? t : i, n, e, g)) return this._tTime = 0, this; if (d !== this._time) return this; if (f !== this._dur) return this.render(t, e, n) } if (this._tTime = g, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (u || this._ease)(i / f), this._from && (this.ratio = h = 1 - h), i && !d && !e && (Fp(this, "onStart"), this._tTime !== g)) return this; for (r = this._pt; r;)r.r(h, r.d), r = r._next; c && c.render(t < 0 ? t : !i && l ? -Gu : c._dur * c._ease(i / this._dur), e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (m && $d(this, t, 0, n), Fp(this, "onUpdate")), this._repeat && s !== a && this.vars.onRepeat && !e && this.parent && Fp(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && $d(this, t, 0, !0), (t || !f) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && Kd(this, 1), e || m && !d || !(g || d || l) || (Fp(this, g === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < p && this.timeScale() > 0) && this._prom())) } } else !function (t, e, n, i) { var r, s, o, a = t.ratio, l = e < 0 || !e && (!t._start && cp(t) && (t._initted || !up(t)) || (t._ts < 0 || t._dp._ts < 0) && !up(t)) ? 0 : 1, h = t._rDelay, c = 0; if (h && t._repeat && (c = Ap(0, t._tDur, e), s = np(c, h), t._yoyo && 1 & s && (l = 1 - l), s !== np(t._tTime, h) && (a = 1 - l, t.vars.repeatRefresh && t._initted && t.invalidate())), l !== a || Tu || i || t._zTime === Gu || !e && t._zTime) { if (!t._initted && hp(t, e, i, n, c)) return; for (o = t._zTime, t._zTime = e || (n ? Gu : 0), n || (n = e && !o), t.ratio = l, t._from && (l = 1 - l), t._time = 0, t._tTime = c, r = t._pt; r;)r.r(l, r.d), r = r._next; e < 0 && $d(t, e, 0, !0), t._onUpdate && !n && Fp(t, "onUpdate"), c && t._repeat && !n && t.parent && Fp(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === l && (l && Kd(t, 1), n || Tu || (Fp(t, l ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom())) } else t._zTime || (t._zTime = e) }(this, t, e, n); return this }, n.targets = function () { return this._targets }, n.invalidate = function (e) { return (!e || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(e), t.prototype.invalidate.call(this, e) }, n.resetTo = function (t, e, n, i) { Uu || Wp.wake(), this._ts || this.play(); var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts); return this._initted || ff(this, r), function (t, e, n, i, r, s, o) { var a, l, h, c, u = (t._pt && t._ptCache || (t._ptCache = {}))[e]; if (!u) for (u = t._ptCache[e] = [], h = t._ptLookup, c = t._targets.length; c--;) { if ((a = h[c][e]) && a.d && a.d._pt) for (a = a.d._pt; a && a.p !== e && a.fp !== e;)a = a._next; if (!a) return cf = 1, t.vars[e] = "+=0", ff(t, o), cf = 0, 1; u.push(a) } for (c = u.length; c--;)(a = (l = u[c])._pt || l).s = !i && 0 !== i || r ? a.s + (i || 0) + s * a.c : i, a.c = n - a.s, l.e && (l.e = kd(n) + bp(l.e)), l.b && (l.b = a.s + bp(l.b)) }(this, t, e, n, i, this._ease(r / this._dur), r) ? this.resetTo(t, e, n, i) : (sp(this, 0), this.parent || Yd(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, n.kill = function (t, e) { if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? kp(this) : this; if (this.timeline) { var n = this.timeline.totalDuration(); return this.timeline.killTweensOf(t, e, hf && !0 !== hf.vars.overwrite)._first || kp(this), this.parent && n !== this.timeline.totalDuration() && dp(this, this._dur * this.timeline._tDur / n, 0, 1), this } var i, r, s, o, a, l, h, c = this._targets, u = t ? wp(t) : c, d = this._ptLookup, p = this._pt; if ((!e || "all" === e) && function (t, e) { for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];); return n < 0 }(c, u)) return "all" === e && (this._pt = 0), kp(this); for (i = this._op = this._op || [], "all" !== e && (Ku(e) && (a = {}, Fd(e, (function (t) { return a[t] = 1 })), e = a), e = function (t, e) { var n, i, r, s, o = t[0] ? Bd(t[0]).harness : 0, a = o && o.aliases; if (!a) return e; for (i in n = Hd({}, e), a) if (i in n) for (r = (s = a[i].split(",")).length; r--;)n[s[r]] = n[i]; return n }(c, e)), h = c.length; h--;)if (~u.indexOf(c[h])) for (a in r = d[h], "all" === e ? (i[h] = e, o = r, s = {}) : (s = i[h] = i[h] || {}, o = e), o) (l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || Xd(this, l, "_pt"), delete r[a]), "all" !== s && (s[a] = 1); return this._initted && !this._pt && p && kp(this), this }, e.to = function (t, n) { return new e(t, n, arguments[2]) }, e.from = function (t, e) { return gp(1, arguments) }, e.delayedCall = function (t, n, i, r) { return new e(n, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: t, onComplete: n, onReverseComplete: n, onCompleteParams: i, onReverseCompleteParams: i, callbackScope: r }) }, e.fromTo = function (t, e, n) { return gp(2, arguments) }, e.set = function (t, n) { return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n) }, e.killTweensOf = function (t, e, n) { return Bu.killTweensOf(t, e, n) }, e }(af); Gd(bf.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), Fd("staggerTo,staggerFrom,staggerFromTo", (function (t) { bf[t] = function () { var e = new lf, n = yp.call(arguments, 0); return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n) } })); var yf = function (t, e, n) { return t[e] = n }, xf = function (t, e, n) { return t[e](n) }, _f = function (t, e, n, i) { return t[e](i.fp, n) }, wf = function (t, e, n) { return t.setAttribute(e, n) }, Ef = function (t, e) { return Ju(t[e]) ? xf : $u(t[e]) && t.setAttribute ? wf : yf }, Cf = function (t, e) { return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e) }, Sf = function (t, e) { return e.set(e.t, e.p, !!(e.s + e.c * t), e) }, Mf = function (t, e) { var n = e._pt, i = ""; if (!t && e.b) i = e.b; else if (1 === t && e.e) i = e.e; else { for (; n;)i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next; i += e.c } e.set(e.t, e.p, i, e) }, Pf = function (t, e) { for (var n = e._pt; n;)n.r(t, n.d), n = n._next }, If = function (t, e, n, i) { for (var r, s = this._pt; s;)r = s._next, s.p === i && s.modifier(t, e, n), s = r }, Tf = function (t) { for (var e, n, i = this._pt; i;)n = i._next, i.p === t && !i.op || i.op === t ? Xd(this, i, "_pt") : i.dep || (e = 1), i = n; return !e }, Df = function (t, e, n, i) { i.mSet(t, e, i.m.call(i.tween, n, i.mt), i) }, Bf = function (t) { for (var e, n, i, r, s = t._pt; s;) { for (e = s._next, n = i; n && n.pr > s.pr;)n = n._next; (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s, (s._next = n) ? n._prev = s : r = s, s = e } t._pt = i }, Lf = function () { function t(t, e, n, i, r, s, o, a, l) { this.t = e, this.s = i, this.c = r, this.p = n, this.r = s || Cf, this.d = o || this, this.set = a || yf, this.pr = l || 0, this._next = t, t && (t._prev = this) } return t.prototype.modifier = function (t, e, n) { this.mSet = this.mSet || this.set, this.set = Df, this.m = t, this.mt = n, this.tween = e }, t }(); Fd(Td + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) { return wd[t] = 1 })), pd.TweenMax = pd.TweenLite = bf, pd.TimelineLite = pd.TimelineMax = lf, Bu = new lf({ sortChildren: !1, defaults: Vu, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), zu.stringFilter = jp; var Ff = [], kf = {}, Rf = [], Of = 0, Nf = function (t) { return (kf[t] || Rf).map((function (t) { return t() })) }, Uf = function () { var t = Date.now(), e = []; t - Of > 2 && (Nf("matchMediaInit"), Ff.forEach((function (t) { var n, i, r, s, o = t.queries, a = t.conditions; for (i in o) (n = Lu.matchMedia(o[i]).matches) && (r = 1), n !== a[i] && (a[i] = n, s = 1); s && (t.revert(), r && e.push(t)) })), Nf("matchMediaRevert"), e.forEach((function (t) { return t.onMatch(t) })), Of = t, Nf("matchMedia")) }, zf = function () { function t(t, e) { this.selector = e && Ep(e), this.data = [], this._r = [], this.isReverted = !1, t && this.add(t) } var e = t.prototype; return e.add = function (t, e, n) { Ju(t) && (n = e, e = t, t = Ju); var i = this, r = function () { var t, r = Du, s = i.selector; return r && r !== i && r.data.push(i), n && (i.selector = Ep(n)), Du = i, t = e.apply(i, arguments), Ju(t) && i._r.push(t), Du = r, i.selector = s, i.isReverted = !1, t }; return i.last = r, t === Ju ? r(i) : t ? i[t] = r : r }, e.ignore = function (t) { var e = Du; Du = null, t(this), Du = e }, e.getTweens = function () { var e = []; return this.data.forEach((function (n) { return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof bf && !(n.parent && "nested" === n.parent.data) && e.push(n) })), e }, e.clear = function () { this._r.length = this.data.length = 0 }, e.kill = function (t, e) { var n = this; if (t) { var i = this.getTweens(); this.data.forEach((function (t) { "isFlip" === t.data && (t.revert(), t.getChildren(!0, !0, !1).forEach((function (t) { return i.splice(i.indexOf(t), 1) }))) })), i.map((function (t) { return { g: t.globalTime(0), t: t } })).sort((function (t, e) { return e.g - t.g || -1 })).forEach((function (e) { return e.t.revert(t) })), this.data.forEach((function (e) { return !(e instanceof af) && e.revert && e.revert(t) })), this._r.forEach((function (e) { return e(t, n) })), this.isReverted = !0 } else this.data.forEach((function (t) { return t.kill && t.kill() })); if (this.clear(), e) { var r = Ff.indexOf(this); ~r && Ff.splice(r, 1) } }, e.revert = function (t) { this.kill(t || {}) }, t }(), Vf = function () { function t(t) { this.contexts = [], this.scope = t } var e = t.prototype; return e.add = function (t, e, n) { td(t) || (t = { matches: t }); var i, r, s, o = new zf(0, n || this.scope), a = o.conditions = {}; for (r in this.contexts.push(o), e = o.add("onMatch", e), o.queries = t, t) "all" === r ? s = 1 : (i = Lu.matchMedia(t[r])) && (Ff.indexOf(o) < 0 && Ff.push(o), (a[r] = i.matches) && (s = 1), i.addListener ? i.addListener(Uf) : i.addEventListener("change", Uf)); return s && e(o), this }, e.revert = function (t) { this.kill(t || {}) }, e.kill = function (t) { this.contexts.forEach((function (e) { return e.kill(t, !0) })) }, t }(), Qf = { registerPlugin: function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; e.forEach((function (t) { return Rp(t) })) }, timeline: function (t) { return new lf(t) }, getTweensOf: function (t, e) { return Bu.getTweensOf(t, e) }, getProperty: function (t, e, n, i) { Ku(t) && (t = wp(t)[0]); var r = Bd(t || {}).get, s = n ? Qd : Vd; return "native" === n && (n = ""), t ? e ? s((Sd[e] && Sd[e].get || r)(t, e, n, i)) : function (e, n, i) { return s((Sd[e] && Sd[e].get || r)(t, e, n, i)) } : t }, quickSetter: function (t, e, n) { if ((t = wp(t)).length > 1) { var i = t.map((function (t) { return jf.quickSetter(t, e, n) })), r = i.length; return function (t) { for (var e = r; e--;)i[e](t) } } t = t[0] || {}; var s = Sd[e], o = Bd(t), a = o.harness && (o.harness.aliases || {})[e] || e, l = s ? function (e) { var i = new s; Nu._pt = 0, i.init(t, n ? e + n : e, Nu, 0, [t]), i.render(1, i), Nu._pt && Pf(1, Nu) } : o.set(t, a); return s ? l : function (e) { return l(t, a, n ? e + n : e, o, 1) } }, quickTo: function (t, e, n) { var i, r = jf.to(t, Hd(((i = {})[e] = "+=0.1", i.paused = !0, i), n || {})), s = function (t, n, i) { return r.resetTo(e, t, n, i) }; return s.tween = r, s }, isTweening: function (t) { return Bu.getTweensOf(t, !0).length > 0 }, defaults: function (t) { return t && t.ease && (t.ease = tf(t.ease, Vu.ease)), jd(Vu, t || {}) }, config: function (t) { return jd(zu, t || {}) }, registerEffect: function (t) { var e = t.name, n = t.effect, i = t.plugins, r = t.defaults, s = t.extendTimeline; (i || "").split(",").forEach((function (t) { return t && !Sd[t] && !pd[t] && vd(e + " effect requires " + t + " plugin.") })), Md[e] = function (t, e, i) { return n(wp(t), Gd(e || {}, r), i) }, s && (lf.prototype[e] = function (t, n, i) { return this.add(Md[e](t, td(n) ? n : (i = n) && {}, this), i) }) }, registerEase: function (t, e) { Yp[t] = tf(e) }, parseEase: function (t, e) { return arguments.length ? tf(t, e) : Yp }, getById: function (t) { return Bu.getById(t) }, exportRoot: function (t, e) { void 0 === t && (t = {}); var n, i, r = new lf(t); for (r.smoothChildTiming = ed(t.smoothChildTiming), Bu.remove(r), r._dp = 0, r._time = r._tTime = Bu._time, n = Bu._first; n;)i = n._next, !e && !n._dur && n instanceof bf && n.vars.onComplete === n._targets[0] || ap(r, n, n._start - n._delay), n = i; return ap(Bu, r, 0), r }, context: function (t, e) { return t ? new zf(t, e) : Du }, matchMedia: function (t) { return new Vf(t) }, matchMediaRefresh: function () { return Ff.forEach((function (t) { var e, n, i = t.conditions; for (n in i) i[n] && (i[n] = !1, e = 1); e && t.revert() })) || Uf() }, addEventListener: function (t, e) { var n = kf[t] || (kf[t] = []); ~n.indexOf(e) || n.push(e) }, removeEventListener: function (t, e) { var n = kf[t], i = n && n.indexOf(e); i >= 0 && n.splice(i, 1) }, utils: { wrap: function t(e, n, i) { var r = n - e; return sd(e) ? Tp(e, t(0, e.length), n) : vp(i, (function (t) { return (r + (t - e) % r) % r + e })) }, wrapYoyo: function t(e, n, i) { var r = n - e, s = 2 * r; return sd(e) ? Tp(e, t(0, e.length - 1), n) : vp(i, (function (t) { return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t) })) }, distribute: Sp, random: Ip, snap: Pp, normalize: function (t, e, n) { return Bp(t, e, 0, 1, n) }, getUnit: bp, clamp: function (t, e, n) { return vp(n, (function (n) { return Ap(t, e, n) })) }, splitColor: zp, toArray: wp, selector: Ep, mapRange: Bp, pipe: function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return function (t) { return e.reduce((function (t, e) { return e(t) }), t) } }, unitize: function (t, e) { return function (n) { return t(parseFloat(n)) + (e || bp(n)) } }, interpolate: function t(e, n, i, r) { var s = isNaN(e + n) ? 0 : function (t) { return (1 - t) * e + t * n }; if (!s) { var o, a, l, h, c, u = Ku(e), d = {}; if (!0 === i && (r = 1) && (i = null), u) e = { p: e }, n = { p: n }; else if (sd(e) && !sd(n)) { for (l = [], h = e.length, c = h - 2, a = 1; a < h; a++)l.push(t(e[a - 1], e[a])); h--, s = function (t) { t *= h; var e = Math.min(c, ~~t); return l[e](t - e) }, i = n } else r || (e = Hd(sd(e) ? [] : {}, e)); if (!l) { for (o in n) df.call(d, e, o, "get", n[o]); s = function (t) { return Pf(t, d) || (u ? e.p : e) } } } return vp(i, s) }, shuffle: Cp }, install: md, effects: Md, ticker: Wp, updateRoot: lf.updateRoot, plugins: Sd, globalTimeline: Bu, core: { PropTween: Lf, globals: Ad, Tween: bf, Timeline: lf, Animation: af, getCache: Bd, _removeLinkedListItem: Xd, reverting: function () { return Tu }, context: function (t) { return t && Du && (Du.data.push(t), t._ctx = Du), Du }, suppressOverwrites: function (t) { return Iu = t } } }; Fd("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) { return Qf[t] = bf[t] })), Wp.add(lf.updateRoot), Nu = Qf.to({}, { duration: 0 }); var Gf = function (t, e) { for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;)n = n._next; return n }, Hf = function (t, e) { return { name: t, rawVars: 1, init: function (t, n, i) { i._onInit = function (t) { var i, r; if (Ku(n) && (i = {}, Fd(n, (function (t) { return i[t] = 1 })), n = i), e) { for (r in i = {}, n) i[r] = e(n[r]); n = i } !function (t, e) { var n, i, r, s = t._targets; for (n in e) for (i = s.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = Gf(r, n)), r && r.modifier && r.modifier(e[n], t, s[i], n)) }(t, n) } } } }, jf = Qf.registerPlugin({ name: "attr", init: function (t, e, n, i, r) { var s, o, a; for (s in this.tween = n, e) a = t.getAttribute(s) || "", (o = this.add(t, "setAttribute", (a || 0) + "", e[s], i, r, 0, 0, s)).op = s, o.b = a, this._props.push(s) }, render: function (t, e) { for (var n = e._pt; n;)Tu ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), n = n._next } }, { name: "endArray", init: function (t, e) { for (var n = e.length; n--;)this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1) } }, Hf("roundProps", Mp), Hf("modifiers"), Hf("snap", Pp)) || Qf; bf.version = lf.version = jf.version = "3.11.4", Ru = 1, nd() && qp(); Yp.Power0, Yp.Power1, Yp.Power2, Yp.Power3, Yp.Power4, Yp.Linear, Yp.Quad, Yp.Cubic, Yp.Quart, Yp.Quint, Yp.Strong; var Wf, qf, Yf, Xf, Kf, Jf, Zf, $f, tm = Yp.Elastic, em = (Yp.Back, Yp.SteppedEase, Yp.Bounce, Yp.Sine, Yp.Expo, Yp.Circ, {}), nm = 180 / Math.PI, im = Math.PI / 180, rm = Math.atan2, sm = /([A-Z])/g, om = /(left|right|width|margin|padding|x)/i, am = /[\s,\(]\S/, lm = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, hm = function (t, e) { return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, cm = function (t, e) { return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, um = function (t, e) { return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e) }, dm = function (t, e) { var n = e.s + e.c * t; e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e) }, pm = function (t, e) { return e.set(e.t, e.p, t ? e.e : e.b, e) }, fm = function (t, e) { return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e) }, mm = function (t, e, n) { return t.style[e] = n }, gm = function (t, e, n) { return t.style.setProperty(e, n) }, vm = function (t, e, n) { return t._gsap[e] = n }, Am = function (t, e, n) { return t._gsap.scaleX = t._gsap.scaleY = n }, bm = function (t, e, n, i, r) { var s = t._gsap; s.scaleX = s.scaleY = n, s.renderTransform(r, s) }, ym = function (t, e, n, i, r) { var s = t._gsap; s[e] = n, s.renderTransform(r, s) }, xm = "transform", _m = xm + "Origin", wm = function (t, e) { var n = this, i = this.target, r = i.style; if (t in em) { if (this.tfm = this.tfm || {}, "transform" !== t && (~(t = lm[t] || t).indexOf(",") ? t.split(",").forEach((function (t) { return n.tfm[t] = Vm(i, t) })) : this.tfm[t] = i._gsap.x ? i._gsap[t] : Vm(i, t)), this.props.indexOf(xm) >= 0) return; i._gsap.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(_m, e, "")), t = xm } (r || e) && this.props.push(t, e, r[t]) }, Em = function (t) { t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate")) }, Cm = function () { var t, e, n = this.props, i = this.target, r = i.style, s = i._gsap; for (t = 0; t < n.length; t += 3)n[t + 1] ? i[n[t]] = n[t + 2] : n[t + 2] ? r[n[t]] = n[t + 2] : r.removeProperty(n[t].replace(sm, "-$1").toLowerCase()); if (this.tfm) { for (e in this.tfm) s[e] = this.tfm[e]; s.svg && (s.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), !(t = Zf()) || t.isStart || r[xm] || (Em(r), s.uncache = 1) } }, Sm = function (t, e) { var n = { target: t, props: [], revert: Cm, save: wm }; return e && e.split(",").forEach((function (t) { return n.save(t) })), n }, Mm = function (t, e) { var n = qf.createElementNS ? qf.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : qf.createElement(t); return n.style ? n : qf.createElement(t) }, Pm = function t(e, n, i) { var r = getComputedStyle(e); return r[n] || r.getPropertyValue(n.replace(sm, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, Tm(n) || n, 1) || "" }, Im = "O,Moz,ms,Ms,Webkit".split(","), Tm = function (t, e, n) { var i = (e || Kf).style, r = 5; if (t in i && !n) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(Im[r] + t in i);); return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Im[r] : "") + t }, Dm = function () { "undefined" != typeof window && window.document && (Wf = window, qf = Wf.document, Yf = qf.documentElement, Kf = Mm("div") || { style: {} }, Mm("div"), xm = Tm(xm), _m = xm + "Origin", Kf.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", $f = !!Tm("perspective"), Zf = jf.core.reverting, Xf = 1) }, Bm = function t(e) { var n, i = Mm("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, o = this.style.cssText; if (Yf.appendChild(i), i.appendChild(this), this.style.display = "block", e) try { n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t } catch (t) { } else this._gsapBBox && (n = this._gsapBBox()); return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), Yf.removeChild(i), this.style.cssText = o, n }, Lm = function (t, e) { for (var n = e.length; n--;)if (t.hasAttribute(e[n])) return t.getAttribute(e[n]) }, Fm = function (t) { var e; try { e = t.getBBox() } catch (n) { e = Bm.call(t, !0) } return e && (e.width || e.height) || t.getBBox === Bm || (e = Bm.call(t, !0)), !e || e.width || e.x || e.y ? e : { x: +Lm(t, ["x", "cx", "x1"]) || 0, y: +Lm(t, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, km = function (t) { return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Fm(t)) }, Rm = function (t, e) { if (e) { var n = t.style; e in em && e !== _m && (e = xm), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(sm, "-$1").toLowerCase())) : n.removeAttribute(e) } }, Om = function (t, e, n, i, r, s) { var o = new Lf(t._pt, e, n, 0, 1, s ? fm : pm); return t._pt = o, o.b = i, o.e = r, t._props.push(n), o }, Nm = { deg: 1, rad: 1, turn: 1 }, Um = { grid: 1, flex: 1 }, zm = function t(e, n, i, r) { var s, o, a, l, h = parseFloat(i) || 0, c = (i + "").trim().substr((h + "").length) || "px", u = Kf.style, d = om.test(n), p = "svg" === e.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r; return r === c || !h || Nm[r] || Nm[c] ? h : ("px" !== c && !g && (h = t(e, n, i, "px")), l = e.getCTM && km(e), !v && "%" !== c || !em[n] && !~n.indexOf("adius") ? (u[d ? "width" : "height"] = m + (g ? c : r), o = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode, l && (o = (e.ownerSVGElement || {}).parentNode), o && o !== qf && o.appendChild || (o = qf.body), (a = o._gsap) && v && a.width && d && a.time === Wp.time && !a.uncache ? kd(h / a.width * m) : ((v || "%" === c) && !Um[Pm(o, "display")] && (u.position = Pm(e, "position")), o === e && (u.position = "static"), o.appendChild(Kf), s = Kf[f], o.removeChild(Kf), u.position = "absolute", d && v && ((a = Bd(o)).time = Wp.time, a.width = o[f]), kd(g ? s * h / m : s && h ? m / s * h : 0))) : (s = l ? e.getBBox()[d ? "width" : "height"] : e[f], kd(v ? h / s * m : h / 100 * s))) }, Vm = function (t, e, n, i) { var r; return Xf || Dm(), e in lm && "transform" !== e && ~(e = lm[e]).indexOf(",") && (e = e.split(",")[0]), em[e] && "transform" !== e ? (r = $m(t, i), r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : tg(Pm(t, _m)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Wm[e] && Wm[e](t, e, n) || Pm(t, e) || Ld(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? zm(t, e, r, n) + n : r }, Qm = function (t, e, n, i) { if (!n || "none" === n) { var r = Tm(e, t, 1), s = r && Pm(t, r, 1); s && s !== n ? (e = r, n = s) : "borderColor" === e && (n = Pm(t, "borderTopColor")) } var o, a, l, h, c, u, d, p, f, m, g, v = new Lf(this._pt, t.style, e, 0, 1, Mf), A = 0, b = 0; if (v.b = n, v.e = i, n += "", "auto" === (i += "") && (t.style[e] = i, i = Pm(t, e) || i, t.style[e] = n), jp(o = [n, i]), i = o[1], l = (n = o[0]).match(ld) || [], (i.match(ld) || []).length) { for (; a = ld.exec(i);)d = a[0], f = i.substring(A, a.index), c ? c = (c + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (c = 1), d !== (u = l[b++] || "") && (h = parseFloat(u) || 0, g = u.substr((h + "").length), "=" === d.charAt(1) && (d = Od(h, d) + g), p = parseFloat(d), m = d.substr((p + "").length), A = ld.lastIndex - m.length, m || (m = m || zu.units[e] || g, A === i.length && (i += m, v.e += m)), g !== m && (h = zm(t, e, u, m) || 0), v._pt = { _next: v._pt, p: f || 1 === b ? f : ",", s: h, c: p - h, m: c && c < 4 || "zIndex" === e ? Math.round : 0 }); v.c = A < i.length ? i.substring(A, i.length) : "" } else v.r = "display" === e && "none" === i ? fm : pm; return cd.test(i) && (v.e = 0), this._pt = v, v }, Gm = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, Hm = function (t) { var e = t.split(" "), n = e[0], i = e[1] || "50%"; return "top" !== n && "bottom" !== n && "left" !== i && "right" !== i || (t = n, n = i, i = t), e[0] = Gm[n] || n, e[1] = Gm[i] || i, e.join(" ") }, jm = function (t, e) { if (e.tween && e.tween._time === e.tween._dur) { var n, i, r, s = e.t, o = s.style, a = e.u, l = s._gsap; if ("all" === a || !0 === a) o.cssText = "", i = 1; else for (r = (a = a.split(",")).length; --r > -1;)n = a[r], em[n] && (i = 1, n = "transformOrigin" === n ? _m : xm), Rm(s, n); i && (Rm(s, xm), l && (l.svg && s.removeAttribute("transform"), $m(s, 1), l.uncache = 1, Em(o))) } }, Wm = { clearProps: function (t, e, n, i, r) { if ("isFromStart" !== r.data) { var s = t._pt = new Lf(t._pt, e, n, 0, 0, jm); return s.u = i, s.pr = -10, s.tween = r, t._props.push(n), 1 } } }, qm = [1, 0, 0, 1, 0, 0], Ym = {}, Xm = function (t) { return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t }, Km = function (t) { var e = Pm(t, xm); return Xm(e) ? qm : e.substr(7).match(ad).map(kd) }, Jm = function (t, e) { var n, i, r, s, o = t._gsap || Bd(t), a = t.style, l = Km(t); return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? qm : l : (l !== qm || t.offsetParent || t === Yf || o.svg || (r = a.display, a.display = "block", (n = t.parentNode) && t.offsetParent || (s = 1, i = t.nextElementSibling, Yf.appendChild(t)), l = Km(t), r ? a.display = r : Rm(t, "display"), s && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : Yf.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l) }, Zm = function (t, e, n, i, r, s) { var o, a, l, h = t._gsap, c = r || Jm(t, !0), u = h.xOrigin || 0, d = h.yOrigin || 0, p = h.xOffset || 0, f = h.yOffset || 0, m = c[0], g = c[1], v = c[2], A = c[3], b = c[4], y = c[5], x = e.split(" "), _ = parseFloat(x[0]) || 0, w = parseFloat(x[1]) || 0; n ? c !== qm && (a = m * A - g * v) && (l = _ * (-g / a) + w * (m / a) - (m * y - g * b) / a, _ = _ * (A / a) + w * (-v / a) + (v * y - A * b) / a, w = l) : (_ = (o = Fm(t)).x + (~x[0].indexOf("%") ? _ / 100 * o.width : _), w = o.y + (~(x[1] || x[0]).indexOf("%") ? w / 100 * o.height : w)), i || !1 !== i && h.smooth ? (b = _ - u, y = w - d, h.xOffset = p + (b * m + y * v) - b, h.yOffset = f + (b * g + y * A) - y) : h.xOffset = h.yOffset = 0, h.xOrigin = _, h.yOrigin = w, h.smooth = !!i, h.origin = e, h.originIsAbsolute = !!n, t.style[_m] = "0px 0px", s && (Om(s, h, "xOrigin", u, _), Om(s, h, "yOrigin", d, w), Om(s, h, "xOffset", p, h.xOffset), Om(s, h, "yOffset", f, h.yOffset)), t.setAttribute("data-svg-origin", _ + " " + w) }, $m = function (t, e) { var n = t._gsap || new of(t); if ("x" in n && !e && !n.uncache) return n; var i, r, s, o, a, l, h, c, u, d, p, f, m, g, v, A, b, y, x, _, w, E, C, S, M, P, I, T, D, B, L, F, k = t.style, R = n.scaleX < 0, O = "px", N = "deg", U = getComputedStyle(t), z = Pm(t, _m) || "0"; return i = r = s = l = h = c = u = d = p = 0, o = a = 1, n.svg = !(!t.getCTM || !km(t)), U.translate && ("none" === U.translate && "none" === U.scale && "none" === U.rotate || (k[xm] = ("none" !== U.translate ? "translate3d(" + (U.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== U.rotate ? "rotate(" + U.rotate + ") " : "") + ("none" !== U.scale ? "scale(" + U.scale.split(" ").join(",") + ") " : "") + ("none" !== U[xm] ? U[xm] : "")), k.scale = k.rotate = k.translate = "none"), g = Jm(t, n.svg), n.svg && (n.uncache ? (M = t.getBBox(), z = n.xOrigin - M.x + "px " + (n.yOrigin - M.y) + "px", S = "") : S = !e && t.getAttribute("data-svg-origin"), Zm(t, S || z, !!S || n.originIsAbsolute, !1 !== n.smooth, g)), f = n.xOrigin || 0, m = n.yOrigin || 0, g !== qm && (y = g[0], x = g[1], _ = g[2], w = g[3], i = E = g[4], r = C = g[5], 6 === g.length ? (o = Math.sqrt(y * y + x * x), a = Math.sqrt(w * w + _ * _), l = y || x ? rm(x, y) * nm : 0, (u = _ || w ? rm(_, w) * nm + l : 0) && (a *= Math.abs(Math.cos(u * im))), n.svg && (i -= f - (f * y + m * _), r -= m - (f * x + m * w))) : (F = g[6], B = g[7], I = g[8], T = g[9], D = g[10], L = g[11], i = g[12], r = g[13], s = g[14], h = (v = rm(F, D)) * nm, v && (S = E * (A = Math.cos(-v)) + I * (b = Math.sin(-v)), M = C * A + T * b, P = F * A + D * b, I = E * -b + I * A, T = C * -b + T * A, D = F * -b + D * A, L = B * -b + L * A, E = S, C = M, F = P), c = (v = rm(-_, D)) * nm, v && (A = Math.cos(-v), L = w * (b = Math.sin(-v)) + L * A, y = S = y * A - I * b, x = M = x * A - T * b, _ = P = _ * A - D * b), l = (v = rm(x, y)) * nm, v && (S = y * (A = Math.cos(v)) + x * (b = Math.sin(v)), M = E * A + C * b, x = x * A - y * b, C = C * A - E * b, y = S, E = M), h && Math.abs(h) + Math.abs(l) > 359.9 && (h = l = 0, c = 180 - c), o = kd(Math.sqrt(y * y + x * x + _ * _)), a = kd(Math.sqrt(C * C + F * F)), v = rm(E, C), u = Math.abs(v) > 2e-4 ? v * nm : 0, p = L ? 1 / (L < 0 ? -L : L) : 0), n.svg && (S = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Xm(Pm(t, xm)), S && t.setAttribute("transform", S))), Math.abs(u) > 90 && Math.abs(u) < 270 && (R ? (o *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, u += u <= 0 ? 180 : -180)), e = e || n.uncache, n.x = i - ((n.xPercent = i && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + O, n.y = r - ((n.yPercent = r && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + O, n.z = s + O, n.scaleX = kd(o), n.scaleY = kd(a), n.rotation = kd(l) + N, n.rotationX = kd(h) + N, n.rotationY = kd(c) + N, n.skewX = u + N, n.skewY = d + N, n.transformPerspective = p + O, (n.zOrigin = parseFloat(z.split(" ")[2]) || 0) && (k[_m] = tg(z)), n.xOffset = n.yOffset = 0, n.force3D = zu.force3D, n.renderTransform = n.svg ? ag : $f ? og : ng, n.uncache = 0, n }, tg = function (t) { return (t = t.split(" "))[0] + " " + t[1] }, eg = function (t, e, n) { var i = bp(e); return kd(parseFloat(e) + parseFloat(zm(t, "x", n + "px", i))) + i }, ng = function (t, e) { e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, og(t, e) }, ig = "0deg", rg = "0px", sg = ") ", og = function (t, e) { var n = e || this, i = n.xPercent, r = n.yPercent, s = n.x, o = n.y, a = n.z, l = n.rotation, h = n.rotationY, c = n.rotationX, u = n.skewX, d = n.skewY, p = n.scaleX, f = n.scaleY, m = n.transformPerspective, g = n.force3D, v = n.target, A = n.zOrigin, b = "", y = "auto" === g && t && 1 !== t || !0 === g; if (A && (c !== ig || h !== ig)) { var x, _ = parseFloat(h) * im, w = Math.sin(_), E = Math.cos(_); _ = parseFloat(c) * im, x = Math.cos(_), s = eg(v, s, w * x * -A), o = eg(v, o, -Math.sin(_) * -A), a = eg(v, a, E * x * -A + A) } m !== rg && (b += "perspective(" + m + sg), (i || r) && (b += "translate(" + i + "%, " + r + "%) "), (y || s !== rg || o !== rg || a !== rg) && (b += a !== rg || y ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + sg), l !== ig && (b += "rotate(" + l + sg), h !== ig && (b += "rotateY(" + h + sg), c !== ig && (b += "rotateX(" + c + sg), u === ig && d === ig || (b += "skew(" + u + ", " + d + sg), 1 === p && 1 === f || (b += "scale(" + p + ", " + f + sg), v.style[xm] = b || "translate(0, 0)" }, ag = function (t, e) { var n, i, r, s, o, a = e || this, l = a.xPercent, h = a.yPercent, c = a.x, u = a.y, d = a.rotation, p = a.skewX, f = a.skewY, m = a.scaleX, g = a.scaleY, v = a.target, A = a.xOrigin, b = a.yOrigin, y = a.xOffset, x = a.yOffset, _ = a.forceCSS, w = parseFloat(c), E = parseFloat(u); d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= im, p *= im, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, s = Math.cos(d - p) * g, p && (f *= im, o = Math.tan(p - f), r *= o = Math.sqrt(1 + o * o), s *= o, f && (o = Math.tan(f), n *= o = Math.sqrt(1 + o * o), i *= o)), n = kd(n), i = kd(i), r = kd(r), s = kd(s)) : (n = m, s = g, i = r = 0), (w && !~(c + "").indexOf("px") || E && !~(u + "").indexOf("px")) && (w = zm(v, "x", c, "px"), E = zm(v, "y", u, "px")), (A || b || y || x) && (w = kd(w + A - (A * n + b * r) + y), E = kd(E + b - (A * i + b * s) + x)), (l || h) && (o = v.getBBox(), w = kd(w + l / 100 * o.width), E = kd(E + h / 100 * o.height)), o = "matrix(" + n + "," + i + "," + r + "," + s + "," + w + "," + E + ")", v.setAttribute("transform", o), _ && (v.style[xm] = o) }, lg = function (t, e, n, i, r) { var s, o, a = 360, l = Ku(r), h = parseFloat(r) * (l && ~r.indexOf("rad") ? nm : 1) - i, c = i + h + "deg"; return l && ("short" === (s = r.split("_")[1]) && (h %= a) !== h % 180 && (h += h < 0 ? a : -360), "cw" === s && h < 0 ? h = (h + 36e9) % a - ~~(h / a) * a : "ccw" === s && h > 0 && (h = (h - 36e9) % a - ~~(h / a) * a)), t._pt = o = new Lf(t._pt, e, n, i, h, cm), o.e = c, o.u = "deg", t._props.push(n), o }, hg = function (t, e) { for (var n in e) t[n] = e[n]; return t }, cg = function (t, e, n) { var i, r, s, o, a, l, h, c = hg({}, n._gsap), u = n.style; for (r in c.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), u[xm] = e, i = $m(n, 1), Rm(n, xm), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[xm], u[xm] = e, i = $m(n, 1), u[xm] = s), em) (s = c[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = bp(s) !== (h = bp(o)) ? zm(n, r, s, h) : parseFloat(s), l = parseFloat(o), t._pt = new Lf(t._pt, i, r, a, l - a, hm), t._pt.u = h || 0, t._props.push(r)); hg(i, c) }; Fd("padding,margin,Width,Radius", (function (t, e) { var n = "Top", i = "Right", r = "Bottom", s = "Left", o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) { return e < 2 ? t + n : "border" + n + t })); Wm[e > 1 ? "border" + t : t] = function (t, e, n, i, r) { var s, a; if (arguments.length < 4) return s = o.map((function (e) { return Vm(t, e, n) })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a; s = (i + "").split(" "), a = {}, o.forEach((function (t, e) { return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0] })), t.init(e, a, r) } })); var ug, dg, pg, fg = { name: "css", register: Dm, targetTest: function (t) { return t.style && t.nodeType }, init: function (t, e, n, i, r) { var s, o, a, l, h, c, u, d, p, f, m, g, v, A, b, y, x = this._props, _ = t.style, w = n.vars.startAt; for (u in Xf || Dm(), this.styles = this.styles || Sm(t), y = this.styles.props, this.tween = n, e) if ("autoRound" !== u && (o = e[u], !Sd[u] || !pf(u, e, n, i, t, r))) if (h = typeof o, c = Wm[u], "function" === h && (h = typeof (o = o.call(n, i, t, r))), "string" === h && ~o.indexOf("random(") && (o = Dp(o)), c) c(this, t, u, o, n) && (b = 1); else if ("--" === u.substr(0, 2)) s = (getComputedStyle(t).getPropertyValue(u) + "").trim(), o += "", Gp.lastIndex = 0, Gp.test(s) || (d = bp(s), p = bp(o)), p ? d !== p && (s = zm(t, u, s, p) + p) : d && (o += d), this.add(_, "setProperty", s, o, i, r, 0, 0, u), x.push(u), y.push(u, 0, _[u]); else if ("undefined" !== h) { if (w && u in w ? (s = "function" == typeof w[u] ? w[u].call(n, i, t, r) : w[u], Ku(s) && ~s.indexOf("random(") && (s = Dp(s)), bp(s + "") || (s += zu.units[u] || bp(Vm(t, u)) || ""), "=" === (s + "").charAt(1) && (s = Vm(t, u))) : s = Vm(t, u), l = parseFloat(s), (f = "string" === h && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), a = parseFloat(o), u in lm && ("autoAlpha" === u && (1 === l && "hidden" === Vm(t, "visibility") && a && (l = 0), y.push("visibility", 0, _.visibility), Om(this, _, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== u && "transform" !== u && ~(u = lm[u]).indexOf(",") && (u = u.split(",")[0])), m = u in em) if (this.styles.save(u), g || ((v = t._gsap).renderTransform && !e.parseTransform || $m(t, e.parseTransform), A = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new Lf(this._pt, _, xm, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === u) this._pt = new Lf(this._pt, v, "scaleY", v.scaleY, (f ? Od(v.scaleY, f + a) : a) - v.scaleY || 0, hm), this._pt.u = 0, x.push("scaleY", u), u += "X"; else { if ("transformOrigin" === u) { y.push(_m, 0, _[_m]), o = Hm(o), v.svg ? Zm(t, o, 0, A, 0, this) : ((p = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && Om(this, v, "zOrigin", v.zOrigin, p), Om(this, _, u, tg(s), tg(o))); continue } if ("svgOrigin" === u) { Zm(t, o, 1, A, 0, this); continue } if (u in Ym) { lg(this, v, u, l, f ? Od(l, f + o) : o); continue } if ("smoothOrigin" === u) { Om(this, v, "smooth", v.smooth, o); continue } if ("force3D" === u) { v[u] = o; continue } if ("transform" === u) { cg(this, o, t); continue } } else u in _ || (u = Tm(u) || u); if (m || (a || 0 === a) && (l || 0 === l) && !am.test(o) && u in _) a || (a = 0), (d = (s + "").substr((l + "").length)) !== (p = bp(o) || (u in zu.units ? zu.units[u] : d)) && (l = zm(t, u, s, p)), this._pt = new Lf(this._pt, m ? v : _, u, l, (f ? Od(l, f + a) : a) - l, m || "px" !== p && "zIndex" !== u || !1 === e.autoRound ? hm : dm), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = s, this._pt.r = um); else if (u in _) Qm.call(this, t, u, s, f ? f + o : o); else if (u in t) this.add(t, u, s || t[u], f ? f + o : o, i, r); else if ("parseTransform" !== u) { gd(u, o); continue } m || (u in _ ? y.push(u, 0, _[u]) : y.push(u, 1, s || t[u])), x.push(u) } b && Bf(this) }, render: function (t, e) { if (e.tween._time || !Zf()) for (var n = e._pt; n;)n.r(t, n.d), n = n._next; else e.styles.revert() }, get: Vm, aliases: lm, getSetter: function (t, e, n) { var i = lm[e]; return i && i.indexOf(",") < 0 && (e = i), e in em && e !== _m && (t._gsap.x || Vm(t, "x")) ? n && Jf === n ? "scale" === e ? Am : vm : (Jf = n || {}) && ("scale" === e ? bm : ym) : t.style && !$u(t.style[e]) ? mm : ~e.indexOf("-") ? gm : Ef(t, e) }, core: { _removeProperty: Rm, _getMatrix: Jm } }; jf.utils.checkPrefix = Tm, jf.core.getStyleSaver = Sm, pg = Fd((ug = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (dg = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) { em[t] = 1 })), Fd(dg, (function (t) { zu.units[t] = "deg", Ym[t] = 1 })), lm[pg[13]] = ug + "," + dg, Fd("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) { var e = t.split(":"); lm[e[1]] = pg[e[0]] })), Fd("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) { zu.units[t] = "px" })), jf.registerPlugin(fg); var mg = jf.registerPlugin(fg) || jf; mg.core.Tween; function gg(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function vg(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? gg(Object(n), !0).forEach((function (e) { Ag(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : gg(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Ag(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var bg = { name: "scramble", extendTimeline: !0, effect: (t, e) => { t[0].original || (t[0].original = t[0].innerText); const n = { text: e.replacingText || t[0].original, chars: e.animationChars || (e.useSpecialChars ? '!@£$%&}{"?><][+=-_QWEZXCVBNM' : "AZERTYUIOPQSDFGHJKLMWXCVBN"), revealDelay: e.revealDelay, speed: e.speed }; e.fixedHeight && mg.set(t[0], { height: t[0].offsetHeight }); const i = e.fixedHeight, r = e.timelineEasing, s = e.words, o = e.onComplete, a = e.wordFixedHeight; if (delete e.replacingText, delete e.animationChars, delete e.speed, delete e.revealDelay, delete e.useSpecialChars, delete e.fixedHeight, delete e.words, delete e.timelineEasing, delete e.onComplete, delete e.wordFixedHeight, s) { let l = 0; const h = mg.timeline({ paused: !0 }), c = e.duration / (t[0].innerText.length - (s.length - 1)); for (let t = 0; t < s.length; t++) { const i = s[t].offsetWidth + 1, r = s[t].innerText.length * c; mg.set(s[t], { width: i, whiteSpace: e.whiteSpace }), a && mg.set(s[t], { height: () => s[t].offsetHeight, whiteSpace: e.whiteSpace }), delete e.whiteSpace, h.to(s[t], vg(vg({}, e), {}, { duration: l + r, scrambleText: vg(vg({}, n), {}, { revealDelay: l, text: s[t].innerText }) }), 0), l += r } return mg.to(h, { duration: h.duration(), progress: 1, ease: r, onComplete: () => { i && mg.set(t[0], { clearProps: "height" }), o && o() } }) } return mg.to(t[0], vg(vg({}, e), {}, { scrambleText: n, onComplete: () => { i && mg.set(t[0], { clearProps: "height" }), o && o() } })) }, defaults: { duration: 1.2, ease: "linear", onComplete: null, replacingText: null, animationChars: null, speed: 1, revealDelay: .2, useSpecialChars: !0, fixedHeight: !1, wordFixedHeight: !1, whiteSpace: "nowrap", words: null, timelineEasing: "power1.in" } }; var yg = { title: { name: "title", extendTimeline: !0, effect: (t, e) => { const n = e.duration / t.length, i = e.duration; return mg.set(t, { opacity: 0 }), delete e.staggerAmount, delete e.duration, mg.timeline(e).fromTo(t, { x: 70 }, { x: 0, duration: i - n, stagger: { amount: n }, ease: e.defaults.ease }).to(t, { opacity: 1, duration: 0, stagger: { amount: i / 2 } }, 0) }, defaults: { duration: Fh.animConfig.duration, staggerAmount: Fh.animConfig.staggerAmount, defaults: { ease: "power2.out" } } }, flicker: { name: "flicker", extendTimeline: !0, effect: (t, e) => { mg.set(t[0], { opacity: 0 }); return t[0].style.pointerEvents = "auto", mg.timeline(e).set(t[0], { opacity: 1, delay: .4 }).set(t[0], { opacity: 0, delay: .05 }).set(t[0], { opacity: 1, delay: .05 }) }, defaults: {} }, flickerOut: { name: "flickerOut", extendTimeline: !0, effect: (t, e) => { mg.set(t[0], { opacity: 1 }); return t[0].style.pointerEvents = "none", mg.timeline(e).set(t[0], { opacity: 0, delay: 0 }).set(t[0], { opacity: 1, delay: .05 }).set(t[0], { opacity: 0, delay: .05 }) }, defaults: {} }, scramble: bg, swipeLines: { name: "swipeLines", extendTimeline: !0, effect: (t, e) => { const { el: n, lines: i } = t[0], r = Fh.animConfig.duration; mg.set(n, { opacity: 0 }); return mg.timeline(e).fromTo(i, { xPercent: 15 }, { xPercent: 0, duration: .4, stagger: .05, ease: "power4.out" }).set(n, { opacity: 1 }, .1).set(n, { opacity: 0 }, r / 5).set(n, { opacity: 1 }, r / 5 + .04).set(n, { opacity: 0 }, r / 2).set(n, { opacity: 1 }, r / 2 + .04) }, defaults: { defaults: { ease: "power2.out" } } } }; function xg(t) { return Function('"use strict";return (' + t + ")")() } function _g(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function wg(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? _g(Object(n), !0).forEach((function (e) { Eg(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _g(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Eg(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Cg { constructor() { Eg(this, "onResize", (() => { for (let t = 0; t < this.resizeTweens.length; t++) { const e = this.resizeTweens[t].tween.progress(); this.resizeTweens[t].tween.scrollTrigger && this.resizeTweens[t].tween.scrollTrigger.kill(), this.resizeTweens[t].tween.kill(), this.resizeTweens[t].tween._onResize && this.resizeTweens[t].tween._onResize(), 0 === e && (this.resizeTweens[t].tween = mg.effects[this.resizeTweens[t].preset](this.resizeTweens[t].tweenEl, wg({}, this.resizeTweens[t].from))) } })), this.fromAttr = "animate-from", this.toAttr = "animate-to", this.mqAttr = "animate-mq", this.els = [], this.resizeTweens = [], this.mirrorGlProps = { x: "position.x", y: "position.y", z: "position.z", rotationX: "rotation.x", rotationY: "rotation.y", rotationZ: "rotation.z" }, ec.on(ic.RESIZE, this.onResize), this.registerGsapPlugins(), this.registerGsapEffects() } build(t) { const e = (t || document).querySelectorAll(`[${this.fromAttr}], [${this.toAttr}]`), n = e.length; for (let t = 0; t < n; t++) { if (e[t].attributes[this.mqAttr] && "" !== e[t].attributes[this.mqAttr].value && !Fh.mq[e[t].attributes[this.mqAttr].value].matches) continue; if (e[t].attributes[this.fromAttr] && "" === e[t].attributes[this.fromAttr].value && e[t].attributes[this.toAttr] && "" === e[t].attributes[this.toAttr].value) continue; let n = { uniforms: {} }; const i = { ease: "none", duration: 1.5, scrollTrigger: { trigger: e[t], start: "top 90%", once: !0 } }, r = e[t].hasAttribute("dom2webgl"); let s, o = null, a = e[t], l = !1, h = !1; if (r && (o = e[t].getBoundingClientRect()), e[t].attributes[this.fromAttr] && (l = xg(`{${e[t].attributes[this.fromAttr].value}}`), r)) { const t = this.parseGlPropsFrom(l, n, o); l = t.from, n = t.glProps } if (e[t].attributes[this.toAttr] && (h = wg(wg({}, i), xg(`{${e[t].attributes[this.toAttr].value}}`)), r && (h = this.parseGlPropsTo(h, o))), (h.stagger || l.stagger) && e[t].children.length && (a = e[t].children), i.scrollTrigger = Object.assign(i.scrollTrigger, l.scrollTrigger), delete l.scrollTrigger, !a.length && a.hasAttribute("dom2webgl") && (a._glProps || (a._glProps = n), i.scrollTrigger.pin && (this.updateGlPropsPinPos(i, a), i.scrollTrigger.onUpdate = () => { this.updateGlPropsPinPos(i, a) })), l && l.preset) { const t = l.preset; delete l.preset, yg[t].defaults.scrollTrigger && (i.scrollTrigger = Object.assign(i.scrollTrigger, yg[t].defaults.scrollTrigger)), l.scrollTrigger = i.scrollTrigger; const e = wg({}, l); s = mg.effects[t](a, l), yg[t].resize && this.resizeTweens.push({ tween: s, preset: t, tweenEl: a, from: e }) } else l && h ? (h = Object.assign(i, h), s = mg.fromTo(a, l, h)) : !h && l ? (l = Object.assign(i, l), s = mg.from(a, l)) : (h = Object.assign(i, h), s = mg.to(a, h)); s.scrollTrigger && s.scrollTrigger.disable(), s.pause(), this.els.push({ el: e[t], tween: s }) } } enable() { for (let t = 0; t < this.els.length; t++)this.els[t].tween.scrollTrigger && (this.els[t].tween.scrollTrigger.enable(), this.els[t].tween.scrollTrigger && this.els[t].tween.scrollTrigger.isActive && !this.els[t].tween.scrollTrigger.vars.scrub && this.els[t].tween.restart(!0)) } parseGlPropsFrom(t, e, n) { t.glProps = {}, Object.prototype.hasOwnProperty.call(t, "uniforms") && (t.glProps.uniforms = wg({}, t.uniforms), e.uniforms = wg({}, t.uniforms), delete t.uniforms); for (const i in t) if (Object.prototype.hasOwnProperty.call(this.mirrorGlProps, i)) { const r = this.parseMirroredValue(i, t[i], n); t.glProps[this.mirrorGlProps[i]] = r, e[this.mirrorGlProps[i]] = r } return { from: t, glProps: e } } parseGlPropsTo(t, e) { t.glProps = {}, Object.prototype.hasOwnProperty.call(t, "uniforms") && (t.glProps.uniforms = wg({}, t.uniforms), delete t.uniforms); for (const n in t) if (Object.prototype.hasOwnProperty.call(this.mirrorGlProps, n)) { const i = this.parseMirroredValue(n, t[n], e); t.glProps[this.mirrorGlProps[n]] = i } return t } parseMirroredValue(t, e, n) { if ("string" == typeof e && e.includes("%")) { e = ("x" === t ? n.width : n.height) * parseFloat(e) * .01 } return t.includes("rotation") && (e = Ge.degToRad(e)), e } updateGlPropsPinPos(t, e) { t.scrollTrigger.horizontal ? e._glProps["position.x"] = mg.getProperty(e, "x") : e._glProps["position.y"] = mg.getProperty(e, "y") } registerGsapEffects() { for (const t in yg) yg[t].extendTimeline && mg.registerEffect(yg[t]) } registerGsapPlugins() { mg.registerPlugin({ name: "glProps", init(t, e) { for (const n in e) if ("object" != typeof e[n]) this.add(t._glProps, n, t._glProps[n], e[n]); else for (const i in e[n]) this.add(t._glProps[n], i, t._glProps[n][i], e[n][i]), this._props.push(i) } }) } destroy() { for (let t = 0; t < this.els.length; t++)this.els[t].tween.scrollTrigger && this.els[t].tween.scrollTrigger.kill(!1), this.els[t].tween && this.els[t].tween.kill(); this.els = [], this.resizeTweens = [] } } class Sg { static init() { document.location.hash && Sg.focus(document.getElementById(window.location.hash.replace("#", "")), !0), ec.on("hashchange", window, (() => { Sg.focus(document.getElementById(window.location.hash.replace("#", "")), !0) })) } static isFocusable(t) { return Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector), t.matches("input:not([disabled]), a, button, textarea, select, iframe, object, [tabindex]") } static focusTrapElement(t) { const e = t.parentNode, n = document.createElement("div"); n.setAttribute("data-focus-trap", "pre"), n.setAttribute("tabindex", "0"); const i = document.createElement("div"); i.setAttribute("data-focus-trap", "post"), i.setAttribute("tabindex", "0"), ec.on("focus", i, (() => this.focusFirstChild(t))), ec.on("focus", n, (() => this.focusLastChild(t))), e.insertBefore(n, t), e.insertBefore(i, t.nextSibling) } static focusFirstChild(t) { for (let e = 0; e < t.children.length; e++) { const n = t.children[e]; if (Sg.focus(n) || Sg.focusFirstChild(n)) return !0 } return !1 } static focusLastChild(t) { for (let e = t.children.length - 1; e >= 0; e--) { const n = t.children[e]; if (Sg.focus(n) || Sg.focusLastChild(n)) return !0 } return !1 } static focus(t) { if (null == t) return !1; !0 === (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) && !1 === Sg.isFocusable(t) && (t.setAttribute("tabindex", "-1"), ec.on("blur", t, Sg.removeTabIndex), ec.on("focusout", t, Sg.removeTabIndex)); try { t.focus() } catch (t) { } return document.activeElement === t } static removeTabIndex() { this.removeAttribute("tabindex"), ec.off("blur", this, Sg.removeTabIndex), ec.off("focusout", this, Sg.removeTabIndex) } } var Mg = Sg; const Pg = new DOMParser; function Ig(t) { const e = new URL(t, window.location.origin); let n = null; return e.hash.length && (n = t.replace(e.hash, "")), { hasHash: e.hash.length > 0, pathname: e.pathname, host: e.host, raw: t, href: n || e.href } } function Tg(t) { "HEAD" === t.parentNode.tagName ? document.head.appendChild(Dg(t)) : document.body.appendChild(Dg(t)) } function Dg(t) { const e = document.createElement("SCRIPT"); for (let n = 0; n < t.attributes.length; n++) { const i = t.attributes[n]; e.setAttribute(i.nodeName, i.nodeValue) } return t.innerHTML && (e.innerHTML = t.innerHTML), e } class Bg { constructor({ wrapper: t }) { this.wrapper = t } leave(t) { return new Promise((e => { this.onLeave({ ...t, done: e }) })) } enter(t) { return new Promise((e => { this.onEnter({ ...t, done: e }) })) } onLeave({ from: t, trigger: e, done: n }) { n() } onEnter({ to: t, trigger: e, done: n }) { n() } } class Lg { constructor({ content: t, page: e, title: n, wrapper: i }) { this._contentString = t.outerHTML, this._DOM = null, this.page = e, this.title = n, this.wrapper = i, this.content = this.wrapper.lastElementChild } onEnter() { } onEnterCompleted() { } onLeave() { } onLeaveCompleted() { } initialLoad() { this.onEnter(), this.onEnterCompleted() } update() { document.title = this.title, this.wrapper.appendChild(this._DOM.firstElementChild), this.content = this.wrapper.lastElementChild, this._DOM = null } createDom() { this._DOM || (this._DOM = document.createElement("div"), this._DOM.innerHTML = this._contentString) } remove() { this.wrapper.firstElementChild.remove() } enter(t, e) { return new Promise((n => { this.onEnter(), t.enter({ trigger: e, to: this.content }).then((() => { this.onEnterCompleted(), n() })) })) } leave(t, e, n) { return new Promise((i => { this.onLeave(), t.leave({ trigger: e, from: this.content }).then((() => { n && this.remove(), this.onLeaveCompleted(), i() })) })) } } class Fg { data = new Map; regexCache = new Map; add(t, e, n) { this.data.has(t) || (this.data.set(t, new Map), this.regexCache.set(t, new RegExp(`^${t}$`))), this.data.get(t).set(e, n), this.regexCache.set(e, new RegExp(`^${e}$`)) } findMatch(t, e) { for (const [n, i] of this.data) if (t.pathname.match(this.regexCache.get(n))) { for (const [t, n] of i) if (e.pathname.match(this.regexCache.get(t))) return n; break } return null } } const kg = "A transition is currently in progress"; class Rg { isTransitioning = !1; currentCacheEntry = null; cache = new Map; constructor(t = {}) { const { links: e = "a:not([target]):not([href^=\\#]):not([data-taxi-ignore])", removeOldContent: n = !0, allowInterruption: i = !1, bypassCache: r = !1, renderers: s = { default: Lg }, transitions: o = { default: Bg }, reloadJsFilter: a = (t => void 0 !== t.dataset.taxiReload) } = t; this.renderers = s, this.transitions = o, this.defaultRenderer = this.renderers.default || Lg, this.defaultTransition = this.transitions.default || Bg, this.wrapper = document.querySelector("[data-taxi]"), this.reloadJsFilter = a, this.removeOldContent = n, this.allowInterruption = i, this.bypassCache = r, this.cache = new Map, this.isPopping = !1, this.attachEvents(e), this.currentLocation = Ig(window.location.href), this.cache.set(this.currentLocation.href, this.createCacheEntry(document.cloneNode(!0))), this.currentCacheEntry = this.cache.get(this.currentLocation.href), this.currentCacheEntry.renderer.initialLoad() } setDefaultRenderer(t) { this.defaultRenderer = this.renderers[t] } setDefaultTransition(t) { this.defaultTransition = this.transitions[t] } addRoute(t, e, n) { this.router || (this.router = new Fg), this.router.add(t, e, n) } preload(t, e = !1) { return t = Ig(t).href, this.cache.has(t) ? Promise.resolve() : this.fetch(t, !1).then((async n => { this.cache.set(t, this.createCacheEntry(n)), e && this.cache.get(t).renderer.createDom() })) } updateCache(t) { const e = Ig(t || window.location.href).href; this.cache.has(e) && this.cache.delete(e), this.cache.set(e, this.createCacheEntry(document.cloneNode(!0))) } clearCache(t) { const e = Ig(t || window.location.href).href; this.cache.has(e) && this.cache.delete(e) } navigateTo(t, e = !1, n = !1) { return new Promise(((i, r) => { if (!this.allowInterruption && this.isTransitioning) return void r(new Error(kg)); this.isTransitioning = !0, this.isPopping = !0, this.targetLocation = Ig(t), this.popTarget = window.location.href; const s = new (this.chooseTransition(e))({ wrapper: this.wrapper }); let o; if (this.bypassCache || !this.cache.has(this.targetLocation.href) || this.cache.get(this.targetLocation.href).skipCache) { const t = this.fetch(this.targetLocation.raw).then((t => { this.cache.set(this.targetLocation.href, this.createCacheEntry(t)), this.cache.get(this.targetLocation.href).renderer.createDom() })); o = this.beforeFetch(this.targetLocation, s, n).then((async () => t.then((async t => await this.afterFetch(this.targetLocation, s, this.cache.get(this.targetLocation.href), n))))) } else this.cache.get(this.targetLocation.href).renderer.createDom(), o = this.beforeFetch(this.targetLocation, s, n).then((async () => await this.afterFetch(this.targetLocation, s, this.cache.get(this.targetLocation.href), n))); o.then((() => { i() })) })) } on(t, e) { ec.on(t, e) } off(t, e) { ec.off(t, e) } beforeFetch(t, e, n) { return ec.emit("NAVIGATE_OUT", { from: this.currentCacheEntry, trigger: n }), new Promise((i => { this.currentCacheEntry.renderer.leave(e, n, this.removeOldContent).then((() => { "popstate" !== n && window.history.pushState({}, "", t.raw), i() })) })) } afterFetch(t, e, n, i) { return this.currentLocation = t, this.popTarget = this.currentLocation.href, new Promise((t => { n.renderer.update(), ec.emit("NAVIGATE_IN", { from: this.currentCacheEntry, to: n, trigger: i }), this.reloadJsFilter && this.loadScripts(n.scripts), n.renderer.enter(e, i).then((() => { ec.emit("NAVIGATE_END", { from: this.currentCacheEntry, to: n, trigger: i }), this.currentCacheEntry = n, this.isTransitioning = !1, this.isPopping = !1, t() })) })) } loadScripts(t) { const e = [...t], n = Array.from(document.querySelectorAll("script")).filter(this.reloadJsFilter); for (let t = 0; t < n.length; t++)for (let r = 0; r < e.length; r++)if (n[t].outerHTML === e[r].outerHTML) { (i = n[t]).parentNode.replaceChild(Dg(i), i), e.splice(r, 1); break } var i; for (const t of e) Tg(t) } attachEvents(t) { ec.delegate("click", t, this.onClick), ec.on("popstate", window, this.onPopstate) } onClick = t => { if (!t.metaKey && !t.ctrlKey) { const e = Ig(t.currentTarget.href); if (this.currentLocation = Ig(window.location.href), this.currentLocation.host !== e.host) return; if (this.currentLocation.href !== e.href || this.currentLocation.hasHash && !e.hasHash) return t.preventDefault(), void this.navigateTo(e.raw, t.currentTarget.dataset.transition || !1, t.currentTarget).catch((t => console.warn(t))); this.currentLocation.hasHash || e.hasHash || t.preventDefault() } }; onPopstate = () => !(window.location.pathname === this.currentLocation.pathname && !this.isPopping) && (this.allowInterruption || !this.isTransitioning && !this.isPopping ? (this.isPopping || (this.popTarget = window.location.href), this.isPopping = !0, void this.navigateTo(window.location.href, !1, "popstate")) : (window.history.pushState({}, "", this.popTarget), console.warn(kg), !1)); fetch(t, e = !0) { return new Promise(((n, i) => { fetch(t, { mode: "same-origin", method: "GET", headers: { "X-Requested-With": "Taxi" }, credentials: "same-origin" }).then((n => (n.ok || (i("Taxi encountered a non 2xx HTTP status code"), e && (window.location.href = t)), n.text()))).then((t => { var e; n("string" == typeof (e = t) ? Pg.parseFromString(e, "text/html") : e) })).catch((n => { i(n), e && (window.location.href = t) })) })) } chooseTransition(t) { if (t) return this.transitions[t]; const e = this.router?findMatch(this.currentLocation, this.targetLocation); return e ? this.transitions[e] : this.defaultTransition } createCacheEntry(t) { const e = t.querySelector("[data-taxi-view]"), n = e.dataset.taxiView.length ? this.renderers[e.dataset.taxiView] : this.defaultRenderer; return n || console.warn(`The Renderer "${e.dataset.taxiView}" was set in the data-taxi-view of the requested page, but not registered in Taxi.`), { page: t, content: e, skipCache: e.hasAttribute("data-taxi-nocache"), scripts: this.reloadJsFilter ? Array.from(t.querySelectorAll("script")).filter(this.reloadJsFilter) : [], title: t.title, renderer: new n({ wrapper: this.wrapper, title: t.title, content: e, page: t }) } } } function Og(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Ng { constructor(t) { Og(this, "el", null), Og(this, "dom", {}), Og(this, "_eventStack", []), this.el = t } populateDom() { this.dom = {}; const t = `${this.constructor.selector.replace(/[.#]/g, "")}`, e = Mh(`[class^="${t}:"], [class*=" ${t}:"]`, this.el); if (e.length) for (let n = 0; n < e.length; n++) { const i = e[n].classList.value.match(new RegExp(`${t}[:-]([^ ]+)`)); if (i) { if (this.dom[i[1]] || (this.dom[i[1]] = e[n]), !this.dom[i[1] + "Array"]) { this.dom[i[1] + "Array"] = [e[n]]; continue } this.dom[i[1] + "Array"].push(e[n]) } } } on(t, e, n, i) { ec.on(t, e, n, i), this._eventStack.push({ event: t, el: e, callback: n, options: i }) } delegate(t, e, n) { ec.delegate(t, e, n), this._eventStack.push({ event: t, el: e, callback: n, options: void 0 }) } off(t, e, n, i) { ec.off(t, e, n, i) } emit(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)n[i - 1] = arguments[i]; ec.emit(t, ...n) } destroy() { for (let t = 0; t < this._eventStack.length; t++) { const { event: e, el: n, callback: i, options: r } = this._eventStack[t]; this.off(e, n, i, r) } this._eventStack = [] } } function Ug(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Og(Ng, "selector", null), Og(Ng, "isSingleton", !1); class zg extends Ng { constructor(t) { super(t), Ug(this, "setHeight", (() => { this.el.style.height = "auto", requestAnimationFrame((() => { this.el.style.height = this.el.getBoundingClientRect().height + "px" })) })), Ug(this, "mouseEnter", (() => { ec.emit("buttonHover"), mg.delayedCall(.1, this.delayAnim = () => { this.noScramble || this.scrambleTl.play(0), this.flicker.play(0), this.dom.image && this.image.playAnimateIn(), this.dom.link && mg.to(this.dom.link, { color: "white", duration: this.config.duration }) }) })), Ug(this, "mouseLeave", (() => { mg.killTweensOf(this.delayAnim), this.dom.link && mg.to(this.dom.link, { color: "#A1A1A1", duration: this.config.duration }) })), Ug(this, "resize", (() => { this.el.style.width = "max-content", this.text && (this.text.style.width = this.el.style.width = "max-content"), this.el.dataset.fixedHeight && this.setHeight(), requestAnimationFrame((() => { this.el.style.width = this.el.getBoundingClientRect().width + 1 + "px", this.text && (this.text.style.width = this.text.getBoundingClientRect().width + "px") })) })), this.populateDom(), this.el._component = this, this.el.style.width = Math.round(this.el.getBoundingClientRect().width) + 1 + "px", this.text = Sh("p, span, a", this.el), this.noScramble = this.el.classList.contains("no-scramble"), this.el.dataset.fixedHeight && this.setHeight(), this.config = { opacity: 1, duration: .4, specialChars: !0 }, this.text && (this.text.style.width = this.text.getBoundingClientRect().width + "px", this.setScramble()), this.flicker = mg.timeline().set(this.el, { opacity: 1, delay: .05 }).set(this.el, { opacity: 0, delay: .05 }).set(this.el, { opacity: 1, delay: .06 }).set(this.el, { opacity: 0, delay: .08 }).set(this.el, { opacity: 1, delay: .09 }), this.on("mouseenter", this.el, (() => { this.text || (this.flicker.restart(), this.flicker.play()) })), ec.on("buttonHover", (() => { this.delayAnim && mg.killTweensOf(this.delayAnim) })), this.on(ic.RESIZE, this.resize) } setScramble() { this.text.style.opacity = this.config.opacity, this.scrambleTl = mg.timeline({ paused: !0 }), this.scrambleTl.scramble(this.text, { duration: this.config.duration, animationChars: '!$}{"?><][+=-_EZXCVBN' }), mg.set(this.text, { x: 0 }), Fh.mq.touch.matches || (this.on("mouseenter", this.el, this.mouseEnter), this.on("mouseleave", this.el, this.mouseLeave)) } } function Vg(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Ug(zg, "selector", ".js-button"); class Qg extends Ng { constructor(t) { super(t), Vg(this, "buildSplitAnimation", (() => { this.splitAnimationTl = mg.timeline({ paused: !0, defaults: { ease: "expo.inOut", duration: .6 } }).to(this.el, { yPercent: 0 }, 0).to(this.maskContainer, { yPercent: 0, opacity: 1 }, 0).to(this.masks, { yPercent: 0 }, 0) })), Vg(this, "playAnimateIn", (() => { this.splitAnimationTl.play() })), Vg(this, "playAnimateOut", (() => { this.splitAnimationTl.reverse() })), mg.set(this.el, { clearProps: "all" }), this.image = Sh("img", t), this.src = this.image.currentSrc ? this.image.currentSrc : this.image.src, this.outCompleted = !1, this.isPostPartialImg = t.closest(".js-post-partial"), this.maskContainer = document.createElement("div"), this.maskContainer.classList.add("split-image__mask-container"), this.config = { numOfSplits: 6 }, this.positions = [-5, 9, -20, -45, 10, -13, 20]; for (let t = 0; t < this.config.numOfSplits; t++)this.createSplit(t); this.el.append(this.maskContainer), this.masks = Mh(".js-split-image-mask", this.el), !this.isPostPartialImg || this.isPostPartialImg && !Fh.mq.touch.matches ? (this.buildSplitAnimation(), this.setInitialPositions()) : mg.set(this.el, { opacity: .3 }) } setInitialPositions() { mg.set(this.el, { yPercent: 100 }), mg.set(this.maskContainer, { yPercent: -100, opacity: 0 }) } createSplit(t) { const e = document.createElement("div"); e.classList.add("split-image__mask", "js-split-image-mask"), (!this.isPostPartialImg || this.isPostPartialImg && !Fh.mq.touch.matches) && mg.set(e, { yPercent: this.positions[t] }); const n = document.createElement("div"); n.style.backgroundImage = `url('${this.src}')`, e.append(n), this.maskContainer.append(e) } transitionOut() { this.outCompleted = new Promise((t => { this.outTl = mg.timeline({ defaults: { ease: "expo.inOut", duration: .86 } }).to(this.el, { yPercent: 100 }, 0).to(this.maskContainer, { yPercent: -100, opacity: 1 }, 0).to(this.masks, { yPercent: t => this.positions[t] }, 0).call((() => { t() })) })) } destroy() { var t; null === (t = this.outTl) || void 0 === t || t.kill(), super.destroy() } } Vg(Qg, "selector", ".js-split-image"); let Gg = /(?:^\s+|\s+$)/g; const Hg = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/; function jg(t) { let e = t.nodeType, n = ""; if (1 === e || 9 === e || 11 === e) { if ("string" == typeof t.textContent) return t.textContent; for (t = t.firstChild; t; t = t.nextSibling)n += jg(t) } else if (3 === e || 4 === e) return t.nodeValue; return n } function Wg(t, e, n, i) { if (t += "", n && (t = t.trim ? t.trim() : t.replace(Gg, "")), e && "" !== e) return t.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(e); let r, s, o = [], a = t.length, l = 0; for (; l < a; l++)s = t.charAt(l), (s.charCodeAt(0) >= 55296 && s.charCodeAt(0) <= 56319 || t.charCodeAt(l + 1) >= 65024 && t.charCodeAt(l + 1) <= 65039) && (r = ((t.substr(l, 12).split(Hg) || [])[1] || "").length || 2, s = t.substr(l, r), o.emoji = 1, l += r - 1), o.push(">" === s ? "&gt;" : "<" === s ? "&lt;" : !i || " " !== s || " " !== t.charAt(l - 1) && " " !== t.charAt(l + 1) ? s : "&nbsp;"); return o } let qg, Yg, Xg, Kg = /(?:\r|\n|\t\t)/g, Jg = /(?:\s\s+)/g, Zg = t => Yg.getComputedStyle(t), $g = Array.isArray, tv = [].slice, ev = (t, e) => { let n; return $g(t) ? t : "string" == (n = typeof t) && !e && t ? tv.call(qg.querySelectorAll(t), 0) : t && "object" === n && "length" in t ? tv.call(t, 0) : t ? [t] : [] }, nv = t => "absolute" === t.position || !0 === t.absolute, iv = (t, e) => { let n, i = e.length; for (; --i > -1;)if (n = e[i], t.substr(0, n.length) === n) return n.length }, rv = " style='position:relative;display:inline-block;'", sv = function () { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0, n = ~t.indexOf("++"), i = 1; return n && (t = t.split("++").join("")), () => "<" + e + rv + (t ? " class='" + t + (n ? i++ : "") + "'>" : ">") }, ov = (t, e, n) => { let i = t.nodeType; if (1 === i || 9 === i || 11 === i) for (t = t.firstChild; t; t = t.nextSibling)ov(t, e, n); else 3 !== i && 4 !== i || (t.nodeValue = t.nodeValue.split(e).join(n)) }, av = (t, e) => { let n = e.length; for (; --n > -1;)t.push(e[n]) }, lv = (t, e, n) => { let i; for (; t && t !== e;) { if (i = t._next || t.nextSibling, i) return i.textContent.charAt(0) === n; t = t.parentNode || t._parent } }, hv = t => { let e, n, i = ev(t.childNodes), r = i.length; for (e = 0; e < r; e++)n = i[e], n._isSplit ? hv(n) : e && n.previousSibling && 3 === n.previousSibling.nodeType ? (n.previousSibling.nodeValue += 3 === n.nodeType ? n.nodeValue : n.firstChild.nodeValue, t.removeChild(n)) : 3 !== n.nodeType && (t.insertBefore(n.firstChild, n), t.removeChild(n)) }, cv = (t, e) => parseFloat(e[t]) || 0, uv = (t, e, n, i, r, s, o) => { let a, l, h, c, u, d, p, f, m, g, v, A, b = Zg(t), y = cv("paddingLeft", b), x = -999, _ = cv("borderBottomWidth", b) + cv("borderTopWidth", b), w = cv("borderLeftWidth", b) + cv("borderRightWidth", b), E = cv("paddingTop", b) + cv("paddingBottom", b), C = cv("paddingLeft", b) + cv("paddingRight", b), S = cv("fontSize", b) * (e.lineThreshold || .2), M = b.textAlign, P = [], I = [], T = [], D = e.wordDelimiter || " ", B = e.tag ? e.tag : e.span ? "span" : "div", L = e.type || e.split || "chars,words,lines", F = r && ~L.indexOf("lines") ? [] : null, k = ~L.indexOf("words"), R = ~L.indexOf("chars"), O = nv(e), N = e.linesClass, U = ~(N || "").indexOf("++"), z = [], V = "flex" === b.display, Q = t.style.display; for (U && (N = N.split("++").join("")), V && (t.style.display = "block"), l = t.getElementsByTagName("*"), h = l.length, u = [], a = 0; a < h; a++)u[a] = l[a]; if (F || O) for (a = 0; a < h; a++)c = u[a], d = c.parentNode === t, (d || O || R && !k) && (A = c.offsetTop, F && d && Math.abs(A - x) > S && ("BR" !== c.nodeName || 0 === a) && (p = [], F.push(p), x = A), O && (c._x = c.offsetLeft, c._y = A, c._w = c.offsetWidth, c._h = c.offsetHeight), F && ((c._isSplit && d || !R && d || k && d || !k && c.parentNode.parentNode === t && !c.parentNode._isSplit) && (p.push(c), c._x -= y, lv(c, t, D) && (c._wordEnd = !0)), "BR" === c.nodeName && (c.nextSibling && "BR" === c.nextSibling.nodeName || 0 === a) && F.push([]))); for (a = 0; a < h; a++)if (c = u[a], d = c.parentNode === t, "BR" !== c.nodeName) if (O && (m = c.style, k || d || (c._x += c.parentNode._x, c._y += c.parentNode._y), m.left = c._x + "px", m.top = c._y + "px", m.position = "absolute", m.display = "block", m.width = c._w + 1 + "px", m.height = c._h + "px"), !k && R) if (c._isSplit) for (c._next = l = c.nextSibling, c.parentNode.appendChild(c); l && 3 === l.nodeType && " " === l.textContent;)c._next = l.nextSibling, c.parentNode.appendChild(l), l = l.nextSibling; else c.parentNode._isSplit ? (c._parent = c.parentNode, !c.previousSibling && c.firstChild && (c.firstChild._isFirst = !0), c.nextSibling && " " === c.nextSibling.textContent && !c.nextSibling.nextSibling && z.push(c.nextSibling), c._next = c.nextSibling && c.nextSibling._isFirst ? null : c.nextSibling, c.parentNode.removeChild(c), u.splice(a--, 1), h--) : d || (A = !c.nextSibling && lv(c.parentNode, t, D), c.parentNode._parent && c.parentNode._parent.appendChild(c), A && c.parentNode.appendChild(qg.createTextNode(" ")), "span" === B && (c.style.display = "inline"), P.push(c)); else c.parentNode._isSplit && !c._isSplit && "" !== c.innerHTML ? I.push(c) : R && !c._isSplit && ("span" === B && (c.style.display = "inline"), P.push(c)); else F || O ? (c.parentNode && c.parentNode.removeChild(c), u.splice(a--, 1), h--) : k || t.appendChild(c); for (a = z.length; --a > -1;)z[a].parentNode.removeChild(z[a]); if (F) { for (O && (g = qg.createElement(B), t.appendChild(g), v = g.offsetWidth + "px", A = g.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(g)), m = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;)t.removeChild(t.firstChild); for (f = " " === D && (!O || !k && !R), a = 0; a < F.length; a++) { for (p = F[a], g = qg.createElement(B), g.style.cssText = "display:block;text-align:" + M + ";position:" + (O ? "absolute;" : "relative;"), N && (g.className = N + (U ? a + 1 : "")), T.push(g), h = p.length, l = 0; l < h; l++)"BR" !== p[l].nodeName && (c = p[l], g.appendChild(c), f && c._wordEnd && g.appendChild(qg.createTextNode(" ")), O && (0 === l && (g.style.top = c._y + "px", g.style.left = y + A + "px"), c.style.top = "0px", A && (c.style.left = c._x - A + "px"))); 0 === h ? g.innerHTML = "&nbsp;" : k || R || (hv(g), ov(g, String.fromCharCode(160), " ")), O && (g.style.width = v, g.style.height = c._h + "px"), t.appendChild(g) } t.style.cssText = m } O && (o > t.clientHeight && (t.style.height = o - E + "px", t.clientHeight < o && (t.style.height = o + _ + "px")), s > t.clientWidth && (t.style.width = s - C + "px", t.clientWidth < s && (t.style.width = s + w + "px"))), V && (Q ? t.style.display = Q : t.style.removeProperty("display")), av(n, P), k && av(i, I), av(r, T) }, dv = (t, e, n, i) => { let r, s, o = ev(t.childNodes), a = o.length, l = nv(e); if (3 !== t.nodeType || a > 1) { for (e.absolute = !1, r = 0; r < a; r++)s = o[r], s._next = s._isFirst = s._parent = s._wordEnd = null, (3 !== s.nodeType || /\S+/.test(s.nodeValue)) && (l && 3 !== s.nodeType && "inline" === Zg(s).display && (s.style.display = "inline-block", s.style.position = "relative"), s._isSplit = !0, dv(s, e, n, i)); return e.absolute = l, void (t._isSplit = !0) } ((t, e, n, i) => { let r, s, o, a, l, h, c, u, d = e.tag ? e.tag : e.span ? "span" : "div", p = ~(e.type || e.split || "chars,words,lines").indexOf("chars"), f = nv(e), m = e.wordDelimiter || " ", g = " " !== m ? "" : f ? "&#173; " : " ", v = "</" + d + ">", A = 1, b = e.specialChars ? "function" == typeof e.specialChars ? e.specialChars : iv : null, y = qg.createElement("div"), x = t.parentNode; for (x.insertBefore(y, t), y.textContent = t.nodeValue, x.removeChild(t), r = jg(t = y), c = -1 !== r.indexOf("<"), !1 !== e.reduceWhiteSpace && (r = r.replace(Jg, " ").replace(Kg, "")), c && (r = r.split("<").join("{{LT}}")), l = r.length, s = (" " === r.charAt(0) ? g : "") + n(), o = 0; o < l; o++)if (h = r.charAt(o), b && (u = b(r.substr(o), e.specialChars))) h = r.substr(o, u || 1), s += p && " " !== h ? i() + h + "</" + d + ">" : h, o += u - 1; else if (h === m && r.charAt(o - 1) !== m && o) { for (s += A ? v : "", A = 0; r.charAt(o + 1) === m;)s += g, o++; o === l - 1 ? s += g : ")" !== r.charAt(o + 1) && (s += g + n(), A = 1) } else "{" === h && "{{LT}}" === r.substr(o, 6) ? (s += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}", o += 5) : h.charCodeAt(0) >= 55296 && h.charCodeAt(0) <= 56319 || r.charCodeAt(o + 1) >= 65024 && r.charCodeAt(o + 1) <= 65039 ? (a = ((r.substr(o, 12).split(Hg) || [])[1] || "").length || 2, s += p && " " !== h ? i() + r.substr(o, a) + "</" + d + ">" : r.substr(o, a), o += a - 1) : s += p && " " !== h ? i() + h + "</" + d + ">" : h; t.outerHTML = s + (A ? v : ""), c && ov(x, "{{LT}}", "<") })(t, e, n, i) }; class pv { constructor(t, e) { Xg || (qg = document, Yg = window, Xg = 1), this.elements = ev(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e) } split(t) { this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0; let e, n, i, r = this.elements.length, s = t.tag ? t.tag : t.span ? "span" : "div", o = sv(t.wordsClass, s), a = sv(t.charsClass, s); for (; --r > -1;)i = this.elements[r], this._originals[r] = i.innerHTML, e = i.clientHeight, n = i.clientWidth, dv(i, t, o, a), uv(i, t, this.chars, this.words, this.lines, n, e); return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this } revert() { let t = this._originals; if (!t) throw "revert() call wasn't scoped properly."; return this.elements.forEach(((e, n) => e.innerHTML = t[n])), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this } static create(t, e) { return new pv(t, e) } } function fv(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function mv(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? fv(Object(n), !0).forEach((function (e) { gv(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : fv(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function gv(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } pv.version = "3.11.3"; class vv extends Ng { constructor(t) { super(t), gv(this, "createScramble", (() => { var t; const e = { duration: this.config.duration, useSpecialChars: this.config.specialChars }; null === (t = this.titleSplit) || void 0 === t || t.revert(), this.titleSplit = new pv(this.dom.title, { type: "words", wordsClass: "break-word overflow-hidden" }), this.titleScrambleTl = mg.timeline({ paused: !0 }).scramble(this.dom.title, mv(mv({}, e), {}, { words: this.titleSplit.words, animationChars: "<>?=;!@@AZERTYUIOPQSDFGHJKLXCVBN", whiteSpace: "normal", wordFixedHeight: !0 })), this.subtitleScrambleTl = mg.timeline({ paused: !0 }).scramble(this.dom.subtitle, e), this.linkScrambleTl = mg.timeline({ paused: !0 }).scramble(this.dom.link, e) })), gv(this, "mouseEnter", (() => { this.titleScrambleTl.play(0), this.subtitleScrambleTl.play(0), this.linkScrambleTl.play(0), this.dom.image && this.image.playAnimateIn(), mg.to(this.dom.link, { color: "white", duration: this.config.duration }) })), gv(this, "mouseLeave", (() => { this.dom.image && this.image.playAnimateOut(), mg.to(this.dom.link, { color: "#A1A1A1", duration: this.config.duration }) })), gv(this, "onClick", (() => { this.outSequenceCompleted = new Promise((t => { this.dom.image ? (this.image.transitionOut(), this.titleScrambleTl.play(), this.subtitleScrambleTl.play(), this.linkScrambleTl.play(), this.image.outCompleted.then((() => { t() }))) : t() })) })), this.populateDom(); const e = Sh(".split-image__mask-container", t); e && e.remove(), this.outSequenceCompleted = !1, this.isClicked = !0, this.dom.image && (this.image = new Qg(this.dom.image)), this.config = { opacity: 1, duration: .4, specialChars: !0 }, this.createScramble(), mg.set([this.dom.title, this.dom.subtitle, this.dom.link], { opacity: this.config.opacity }), Fh.mq.touch.matches || (this.on("mouseenter", t, this.mouseEnter), this.on("mouseleave", t, this.mouseLeave)), this.on("click", this.dom.title, this.onClick), this.on(ic.RESIZE, this.createScramble) } removeMouseLeave() { this.off("mouseleave", this.el, this.mouseLeave) } destroy() { super.destroy() } } function Av(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function bv(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Av(Object(n), !0).forEach((function (e) { yv(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Av(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function yv(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } gv(vv, "selector", ".js-post-partial"); class xv extends Ng { constructor(t) { super(t), yv(this, "createScramble", (() => { var t; null === (t = this.lineSplit) || void 0 === t || t.revert(), this.lineSplit = new pv(this.text, { type: "words" }), this.textScramble = mg.timeline({ paused: !0 }).scramble(this.text, bv(bv({}, { duration: .6, useSpecialChars: !0 }), {}, { words: this.lineSplit.words, animationChars: "<>?=;!@@AZERTYUIOPQSDFGHJKLXCVBN" })) })), yv(this, "onMouseEnter", (() => { this.textScramble.play(0) })), yv(this, "onResize", (() => { const t = this.text.clientWidth; this.text.style.width = t + "px" })), this.text = Sh("span", t), this.createScramble(), this.on("click", t, this.scrollToTop), this.on("mouseenter", t, this.onMouseEnter), this.on(ic.RESIZE, this.createScramble) } scrollToTop() { Fh.Lenis.scrollTo(0, { immediate: !0 }) } destroy() { super.destroy() } } yv(xv, "selector", ".js-scroll-top"); n(7727); function _v(t, e, n) { const i = (e, n) => { "style" !== e ? "classList" !== e ? t.setAttribute(e, !0 === n ? e : n) : wv(t, n) : Object.assign(t.style, n) }; if ("object" == typeof e) for (const n in e) !1 !== e[n] ? i(n, e[n]) : t.removeAttribute(n); else { if (void 0 === n) return t.getAttribute(e); if (!1 === n) return void t.removeAttribute(e); i(e, n) } } function wv(t, e) { Array.isArray(e) ? t.classList.add(...e) : "string" != typeof e ? (e.add && wv(t, e.add), e.remove && function (t, e) { if (Array.isArray(e)) return void t.classList.remove(...e); "string" == typeof e && t.classList.remove(...e.split(" ")) }(t, e.remove)) : t.classList.add(...e.split(" ")) } function Ev(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Cv extends Ng { constructor(t) { super(t), Ev(this, "onLinkClick", (t => { t.preventDefault(); const e = t.currentTarget, n = _v(e, "data-href"), i = e.dataset.almondFrom || ".js-almond-from", r = e.dataset.almondTo || ".js-almond-to"; if (void 0 !== n) { if (null === Sh(r)) return console.warn(`Almond: Could not find ${r} on the current page. Gracefully degrading to normal link behaviour`, e), void this.navigationFallback(n); this.currentLink = e, this.load(n, i, r) } })), this.currentLink = null, this.delegate("click", this.constructor.selector, this.onLinkClick) } onClick(t, e) { t.disabled = !0, t.style.pointerEvents = "none" } onComplete(t, e, n) { } modifyFragment(t, e) { return t } load(t, e, n) { this.currentLink && this.onClick(this.currentLink, t), fetch(t).then((e => { if (e.ok) return e.text(); this.navigationFallback(t) })).then((i => { const r = Sh(n), s = (new DOMParser).parseFromString(i, "text/html"), o = Sh(e, s), a = document.createDocumentFragment(); if (null === o) return void this.navigationFallback(t); for (let t = 0; t < o.childNodes.length; t++)a.appendChild(o.childNodes[t].cloneNode(!0)); const l = r.parentElement; l.replaceChild(this.modifyFragment(a, t), r), this.onComplete(s, l, t), this.emit(Cv.COMPLETED, l, t) })).catch((e => { console.error(e, t), this.navigationFallback(t) })).finally((() => { this.clickedLink = null })) } navigationFallback(t) { window.location.href = t } } function Sv(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Ev(Cv, "selector", ".js-almond"), Ev(Cv, "isSingleton", !0), Ev(Cv, "COMPLETED", "almond:completed"); class Mv extends Cv { constructor(t) { super(t), Sv(this, "onAlmondComplete", (() => { Mh(".js-post-partial.js-needs-loading", Sh(".js-almond-from", Fh.body)).forEach((t => { this.existingIDs.includes(t.dataset.id) || Fh.components.get(vv).make(t), t.classList.remove("js-needs-loading") })) })), this.pagination = Fh.body.classList.contains("paged"), this.pagination ? Sh(".js-almond", Fh.body).style.display = "none" : Sh(".js-pagination-links", Fh.body).style.display = "none", this.loadingIndicator = Sh(".js-loading-indicator", Fh.body), this.ellipses = Mh("span", this.loadingIndicator), this.buildEllipsesAnimation(), mg.set([this.loadingIndicator, this.ellipses], { opacity: 0 }), this.on(Cv.COMPLETED, this.onAlmondComplete) } buildEllipsesAnimation() { this.ellipsesTl = mg.timeline({ repeat: -1, paused: !0, defaults: { duration: .25, ease: "expo.out" } }).to(this.ellipses[0], { opacity: 1 }).to(this.ellipses[1], { opacity: 1 }).to(this.ellipses[2], { opacity: 1 }).to(this.ellipses, { opacity: 0 }) } onClick(t, e) { this.existingIDs = []; Mh(".js-post-partial").forEach((t => { this.existingIDs.push(t.dataset.id) })); return mg.timeline({ defaults: { duration: .25, ease: "linear" } }).to(".js-load-below", { opacity: 0, overwrite: !0 }).to(this.loadingIndicator, { opacity: 1 }).then((() => { this.ellipsesTl.play() })) } modifyFragment(t, e) { return Mh(".js-post-partial", t).forEach((t => { t.classList.add("js-needs-loading") })), t } onComplete(t, e, n) { super.onComplete(t, e, n); const i = Sh(".js-scroll-top", e); this.scrollTop = new xv(i); const r = Sh(".js-view-more-btn", e); r ? Fh.components.get(zg).make(r) : Fh.body.classList.add("all-posts-loaded"), Fh.Taxi.updateCache(), this.tl = mg.timeline().to(this.loadingIndicator, { opacity: 0 }, 0) } destroy() { super.destroy() } } function Pv(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } var Iv, Tv, Dv, Bv, Lv, Fv, kv, Rv, Ov, Nv, Uv, zv, Vv, Qv = function () { return Iv || "undefined" != typeof window && (Iv = window.gsap) && Iv.registerPlugin && Iv }, Gv = 1, Hv = [], jv = [], Wv = [], qv = Date.now, Yv = function (t, e) { return e }, Xv = function (t, e) { return ~Wv.indexOf(t) && Wv[Wv.indexOf(t) + 1][e] }, Kv = function (t) { return !!~Nv.indexOf(t) }, Jv = function (t, e, n, i, r) { return t.addEventListener(e, n, { passive: !i, capture: !!r }) }, Zv = function (t, e, n, i) { return t.removeEventListener(e, n, !!i) }, $v = "scrollLeft", tA = "scrollTop", eA = function () { return Uv && Uv.isPressed || jv.cache++ }, nA = function (t, e) { var n = function n(i) { if (i || 0 === i) { Gv && (Dv.history.scrollRestoration = "manual"); var r = Uv && Uv.isPressed; i = n.v = Math.round(i) || (Uv && Uv.iOS ? 1 : 0), t(i), n.cacheID = jv.cache, r && Yv("ss", i) } else (e || jv.cache !== n.cacheID || Yv("ref")) && (n.cacheID = jv.cache, n.v = t()); return n.v + n.offset }; return n.offset = 0, t && n }, iA = { s: $v, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: nA((function (t) { return arguments.length ? Dv.scrollTo(t, rA.sc()) : Dv.pageXOffset || Bv[$v] || Lv[$v] || Fv[$v] || 0 })) }, rA = { s: tA, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: iA, sc: nA((function (t) { return arguments.length ? Dv.scrollTo(iA.sc(), t) : Dv.pageYOffset || Bv[tA] || Lv[tA] || Fv[tA] || 0 })) }, sA = function (t) { return Iv.utils.toArray(t)[0] || ("string" == typeof t && !1 !== Iv.config().nullTargetWarn ? console.warn("Element not found:", t) : null) }, oA = function (t, e) { var n = e.s, i = e.sc; Kv(t) && (t = Bv.scrollingElement || Lv); var r = jv.indexOf(t), s = i === rA.sc ? 1 : 2; !~r && (r = jv.push(t) - 1), jv[r + s] || t.addEventListener("scroll", eA); var o = jv[r + s], a = o || (jv[r + s] = nA(Xv(t, n), !0) || (Kv(t) ? i : nA((function (e) { return arguments.length ? t[n] = e : t[n] })))); return a.target = t, o || (a.smooth = "smooth" === Iv.getProperty(t, "scrollBehavior")), a }, aA = function (t, e, n) { var i = t, r = t, s = qv(), o = s, a = e || 50, l = Math.max(500, 3 * a), h = function (t, e) { var l = qv(); e || l - s > a ? (r = i, i = t, o = s, s = l) : n ? i += t : i = r + (t - r) / (l - o) * (s - o) }; return { update: h, reset: function () { r = i = n ? 0 : i, o = s = 0 }, getVelocity: function (t) { var e = o, a = r, c = qv(); return (t || 0 === t) && t !== i && h(t), s === o || c - o > l ? 0 : (i + (n ? a : -a)) / ((n ? c : s) - e) * 1e3 } } }, lA = function (t, e) { return e && !t._gsapAllow && t.preventDefault(), t.changedTouches ? t.changedTouches[0] : t }, hA = function (t) { var e = Math.max.apply(Math, t), n = Math.min.apply(Math, t); return Math.abs(e) >= Math.abs(n) ? e : n }, cA = function () { var t, e, n, i; (Ov = Iv.core.globals().ScrollTrigger) && Ov.core && (t = Ov.core, e = t.bridge || {}, n = t._scrollers, i = t._proxies, n.push.apply(n, jv), i.push.apply(i, Wv), jv = n, Wv = i, Yv = function (t, n) { return e[t](n) }) }, uA = function (t) { return (Iv = t || Qv()) && "undefined" != typeof document && document.body && (Dv = window, Bv = document, Lv = Bv.documentElement, Fv = Bv.body, Nv = [Dv, Bv, Lv, Fv], Iv.utils.clamp, Vv = Iv.core.context || function () { }, Rv = "onpointerenter" in Fv ? "pointer" : "mouse", kv = dA.isTouch = Dv.matchMedia && Dv.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Dv || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, zv = dA.eventTypes = ("ontouchstart" in Lv ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Lv ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function () { return Gv = 0 }), 500), cA(), Tv = 1), Tv }; iA.op = rA, jv.cache = 0; var dA = function () { function t(t) { this.init(t) } var e, n, i; return t.prototype.init = function (t) { Tv || uA(Iv) || console.warn("Please gsap.registerPlugin(Observer)"), Ov || cA(); var e = t.tolerance, n = t.dragMinimum, i = t.type, r = t.target, s = t.lineHeight, o = t.debounce, a = t.preventDefault, l = t.onStop, h = t.onStopDelay, c = t.ignore, u = t.wheelSpeed, d = t.event, p = t.onDragStart, f = t.onDragEnd, m = t.onDrag, g = t.onPress, v = t.onRelease, A = t.onRight, b = t.onLeft, y = t.onUp, x = t.onDown, _ = t.onChangeX, w = t.onChangeY, E = t.onChange, C = t.onToggleX, S = t.onToggleY, M = t.onHover, P = t.onHoverEnd, I = t.onMove, T = t.ignoreCheck, D = t.isNormalizer, B = t.onGestureStart, L = t.onGestureEnd, F = t.onWheel, k = t.onEnable, R = t.onDisable, O = t.onClick, N = t.scrollSpeed, U = t.capture, z = t.allowClicks, V = t.lockAxis, Q = t.onLockAxis; this.target = r = sA(r) || Lv, this.vars = t, c && (c = Iv.utils.toArray(c)), e = e || 1e-9, n = n || 0, u = u || 1, N = N || 1, i = i || "wheel,touch,pointer", o = !1 !== o, s || (s = parseFloat(Dv.getComputedStyle(Fv).lineHeight) || 22); var G, H, j, W, q, Y, X, K = this, J = 0, Z = 0, $ = oA(r, iA), tt = oA(r, rA), et = $(), nt = tt(), it = ~i.indexOf("touch") && !~i.indexOf("pointer") && "pointerdown" === zv[0], rt = Kv(r), st = r.ownerDocument || Bv, ot = [0, 0, 0], at = [0, 0, 0], lt = 0, ht = function () { return lt = qv() }, ct = function (t, e) { return (K.event = t) && c && ~c.indexOf(t.target) || e && it && "touch" !== t.pointerType || T && T(t, e) }, ut = function () { var t = K.deltaX = hA(ot), n = K.deltaY = hA(at), i = Math.abs(t) >= e, r = Math.abs(n) >= e; E && (i || r) && E(K, t, n, ot, at), i && (A && K.deltaX > 0 && A(K), b && K.deltaX < 0 && b(K), _ && _(K), C && K.deltaX < 0 != J < 0 && C(K), J = K.deltaX, ot[0] = ot[1] = ot[2] = 0), r && (x && K.deltaY > 0 && x(K), y && K.deltaY < 0 && y(K), w && w(K), S && K.deltaY < 0 != Z < 0 && S(K), Z = K.deltaY, at[0] = at[1] = at[2] = 0), (W || j) && (I && I(K), j && (m(K), j = !1), W = !1), Y && !(Y = !1) && Q && Q(K), q && (F(K), q = !1), G = 0 }, dt = function (t, e, n) { ot[n] += t, at[n] += e, K._vx.update(t), K._vy.update(e), o ? G || (G = requestAnimationFrame(ut)) : ut() }, pt = function (t, e) { V && !X && (K.axis = X = Math.abs(t) > Math.abs(e) ? "x" : "y", Y = !0), "y" !== X && (ot[2] += t, K._vx.update(t, !0)), "x" !== X && (at[2] += e, K._vy.update(e, !0)), o ? G || (G = requestAnimationFrame(ut)) : ut() }, ft = function (t) { if (!ct(t, 1)) { var e = (t = lA(t, a)).clientX, i = t.clientY, r = e - K.x, s = i - K.y, o = K.isDragging; K.x = e, K.y = i, (o || Math.abs(K.startX - e) >= n || Math.abs(K.startY - i) >= n) && (m && (j = !0), o || (K.isDragging = !0), pt(r, s), o || p && p(K)) } }, mt = K.onPress = function (t) { ct(t, 1) || (K.axis = X = null, H.pause(), K.isPressed = !0, t = lA(t), J = Z = 0, K.startX = K.x = t.clientX, K.startY = K.y = t.clientY, K._vx.reset(), K._vy.reset(), Jv(D ? r : st, zv[1], ft, a, !0), K.deltaX = K.deltaY = 0, g && g(K)) }, gt = function (t) { if (!ct(t, 1)) { Zv(D ? r : st, zv[1], ft, !0); var e = !isNaN(K.y - K.startY), n = K.isDragging && (Math.abs(K.x - K.startX) > 3 || Math.abs(K.y - K.startY) > 3), i = lA(t); !n && e && (K._vx.reset(), K._vy.reset(), a && z && Iv.delayedCall(.08, (function () { if (qv() - lt > 300 && !t.defaultPrevented) if (t.target.click) t.target.click(); else if (st.createEvent) { var e = st.createEvent("MouseEvents"); e.initMouseEvent("click", !0, !0, Dv, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e) } }))), K.isDragging = K.isGesturing = K.isPressed = !1, l && !D && H.restart(!0), f && n && f(K), v && v(K, n) } }, vt = function (t) { return t.touches && t.touches.length > 1 && (K.isGesturing = !0) && B(t, K.isDragging) }, At = function () { return (K.isGesturing = !1) || L(K) }, bt = function (t) { if (!ct(t)) { var e = $(), n = tt(); dt((e - et) * N, (n - nt) * N, 1), et = e, nt = n, l && H.restart(!0) } }, yt = function (t) { if (!ct(t)) { t = lA(t, a), F && (q = !0); var e = (1 === t.deltaMode ? s : 2 === t.deltaMode ? Dv.innerHeight : 1) * u; dt(t.deltaX * e, t.deltaY * e, 0), l && !D && H.restart(!0) } }, xt = function (t) { if (!ct(t)) { var e = t.clientX, n = t.clientY, i = e - K.x, r = n - K.y; K.x = e, K.y = n, W = !0, (i || r) && pt(i, r) } }, _t = function (t) { K.event = t, M(K) }, wt = function (t) { K.event = t, P(K) }, Et = function (t) { return ct(t) || lA(t, a) && O(K) }; H = K._dc = Iv.delayedCall(h || .25, (function () { K._vx.reset(), K._vy.reset(), H.pause(), l && l(K) })).pause(), K.deltaX = K.deltaY = 0, K._vx = aA(0, 50, !0), K._vy = aA(0, 50, !0), K.scrollX = $, K.scrollY = tt, K.isDragging = K.isGesturing = K.isPressed = !1, Vv(this), K.enable = function (t) { return K.isEnabled || (Jv(rt ? st : r, "scroll", eA), i.indexOf("scroll") >= 0 && Jv(rt ? st : r, "scroll", bt, a, U), i.indexOf("wheel") >= 0 && Jv(r, "wheel", yt, a, U), (i.indexOf("touch") >= 0 && kv || i.indexOf("pointer") >= 0) && (Jv(r, zv[0], mt, a, U), Jv(st, zv[2], gt), Jv(st, zv[3], gt), z && Jv(r, "click", ht, !1, !0), O && Jv(r, "click", Et), B && Jv(st, "gesturestart", vt), L && Jv(st, "gestureend", At), M && Jv(r, Rv + "enter", _t), P && Jv(r, Rv + "leave", wt), I && Jv(r, Rv + "move", xt)), K.isEnabled = !0, t && t.type && mt(t), k && k(K)), K }, K.disable = function () { K.isEnabled && (Hv.filter((function (t) { return t !== K && Kv(t.target) })).length || Zv(rt ? st : r, "scroll", eA), K.isPressed && (K._vx.reset(), K._vy.reset(), Zv(D ? r : st, zv[1], ft, !0)), Zv(rt ? st : r, "scroll", bt, U), Zv(r, "wheel", yt, U), Zv(r, zv[0], mt, U), Zv(st, zv[2], gt), Zv(st, zv[3], gt), Zv(r, "click", ht, !0), Zv(r, "click", Et), Zv(st, "gesturestart", vt), Zv(st, "gestureend", At), Zv(r, Rv + "enter", _t), Zv(r, Rv + "leave", wt), Zv(r, Rv + "move", xt), K.isEnabled = K.isPressed = K.isDragging = !1, R && R(K)) }, K.kill = K.revert = function () { K.disable(); var t = Hv.indexOf(K); t >= 0 && Hv.splice(t, 1), Uv === K && (Uv = 0) }, Hv.push(K), D && Kv(r) && (Uv = K), K.enable(d) }, e = t, (n = [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]) && Pv(e.prototype, n), i && Pv(e, i), t }(); dA.version = "3.11.4", dA.create = function (t) { return new dA(t) }, dA.register = uA, dA.getAll = function () { return Hv.slice() }, dA.getById = function (t) { return Hv.filter((function (e) { return e.vars.id === t }))[0] }, Qv() && Iv.registerPlugin(dA); var pA, fA, mA, gA, vA, AA, bA, yA, xA, _A, wA, EA, CA, SA, MA, PA, IA, TA, DA, BA, LA, FA, kA, RA, OA, NA, UA, zA, VA, QA, GA, HA, jA, WA, qA = 1, YA = Date.now, XA = YA(), KA = 0, JA = 0, ZA = function () { return SA = 1 }, $A = function () { return SA = 0 }, tb = function (t) { return t }, eb = function (t) { return Math.round(1e5 * t) / 1e5 || 0 }, nb = function () { return "undefined" != typeof window }, ib = function () { return pA || nb() && (pA = window.gsap) && pA.registerPlugin && pA }, rb = function (t) { return !!~bA.indexOf(t) }, sb = function (t) { return Xv(t, "getBoundingClientRect") || (rb(t) ? function () { return gy.width = mA.innerWidth, gy.height = mA.innerHeight, gy } : function () { return Db(t) }) }, ob = function (t, e) { var n = e.s, i = e.d2, r = e.d, s = e.a; return (n = "scroll" + i) && (s = Xv(t, n)) ? s() - sb(t)()[r] : rb(t) ? (vA[n] || AA[n]) - (mA["inner" + i] || vA["client" + i] || AA["client" + i]) : t[n] - t["offset" + i] }, ab = function (t, e) { for (var n = 0; n < DA.length; n += 3)(!e || ~e.indexOf(DA[n + 1])) && t(DA[n], DA[n + 1], DA[n + 2]) }, lb = function (t) { return "string" == typeof t }, hb = function (t) { return "function" == typeof t }, cb = function (t) { return "number" == typeof t }, ub = function (t) { return "object" == typeof t }, db = function (t, e, n) { return t && t.progress(e ? 0 : 1) && n && t.pause() }, pb = function (t, e) { if (t.enabled) { var n = e(t); n && n.totalTime && (t.callbackAnimation = n) } }, fb = Math.abs, mb = "left", gb = "right", vb = "bottom", Ab = "width", bb = "height", yb = "Right", xb = "Left", _b = "Top", wb = "Bottom", Eb = "padding", Cb = "margin", Sb = "Width", Mb = "Height", Pb = "px", Ib = function (t) { return mA.getComputedStyle(t) }, Tb = function (t, e) { for (var n in e) n in t || (t[n] = e[n]); return t }, Db = function (t, e) { var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== Ib(t)[MA] && pA.to(t, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), i = t.getBoundingClientRect(); return n && n.progress(0).kill(), i }, Bb = function (t, e) { var n = e.d2; return t["offset" + n] || t["client" + n] || 0 }, Lb = function (t) { var e, n = [], i = t.labels, r = t.duration(); for (e in i) n.push(i[e] / r); return n }, Fb = function (t) { var e = pA.utils.snap(t), n = Array.isArray(t) && t.slice(0).sort((function (t, e) { return t - e })); return n ? function (t, i, r) { var s; if (void 0 === r && (r = .001), !i) return e(t); if (i > 0) { for (t -= r, s = 0; s < n.length; s++)if (n[s] >= t) return n[s]; return n[s - 1] } for (s = n.length, t += r; s--;)if (n[s] <= t) return n[s]; return n[0] } : function (n, i, r) { void 0 === r && (r = .001); var s = e(n); return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : e(i < 0 ? n - t : n + t) } }, kb = function (t, e, n, i) { return n.split(",").forEach((function (n) { return t(e, n, i) })) }, Rb = function (t, e, n, i, r) { return t.addEventListener(e, n, { passive: !i, capture: !!r }) }, Ob = function (t, e, n, i) { return t.removeEventListener(e, n, !!i) }, Nb = function (t, e, n) { return n && n.wheelHandler && t(e, "wheel", n) }, Ub = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, zb = { toggleActions: "play", anticipatePin: 0 }, Vb = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Qb = function (t, e) { if (lb(t)) { var n = t.indexOf("="), i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0; ~n && (t.indexOf("%") > n && (i *= e / 100), t = t.substr(0, n - 1)), t = i + (t in Vb ? Vb[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0) } return t }, Gb = function (t, e, n, i, r, s, o, a) { var l = r.startColor, h = r.endColor, c = r.fontSize, u = r.indent, d = r.fontWeight, p = gA.createElement("div"), f = rb(n) || "fixed" === Xv(n, "pinType"), m = -1 !== t.indexOf("scroller"), g = f ? AA : n, v = -1 !== t.indexOf("start"), A = v ? l : h, b = "border-color:" + A + ";font-size:" + c + ";color:" + A + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return b += "position:" + ((m || a) && f ? "fixed;" : "absolute;"), (m || a || !f) && (b += (i === rA ? gb : vb) + ":" + (s + parseFloat(u)) + "px;"), o && (b += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), p._isStart = v, p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")), p.style.cssText = b, p.innerText = e || 0 === e ? t + "-" + e : t, g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p), p._offset = p["offset" + i.op.d2], Hb(p, 0, i, v), p }, Hb = function (t, e, n, i) { var r = { display: "block" }, s = n[i ? "os2" : "p2"], o = n[i ? "p2" : "os2"]; t._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + s + Sb] = 1, r["border" + o + Sb] = 0, r[n.p] = e + "px", pA.set(t, r) }, jb = [], Wb = {}, qb = function () { return YA() - KA > 34 && (GA || (GA = requestAnimationFrame(hy))) }, Yb = function () { (!kA || !kA.isPressed || kA.startX > AA.clientWidth) && (jv.cache++, kA ? GA || (GA = requestAnimationFrame(hy)) : hy(), KA || ty("scrollStart"), KA = YA()) }, Xb = function () { NA = mA.innerWidth, OA = mA.innerHeight }, Kb = function () { jv.cache++, !CA && !FA && !gA.fullscreenElement && !gA.webkitFullscreenElement && (!RA || NA !== mA.innerWidth || Math.abs(mA.innerHeight - OA) > .25 * mA.innerHeight) && yA.restart(!0) }, Jb = {}, Zb = [], $b = function t() { return Ob(xy, "scrollEnd", t) || oy(!0) }, ty = function (t) { return Jb[t] && Jb[t].map((function (t) { return t() })) || Zb }, ey = [], ny = function (t) { for (var e = 0; e < ey.length; e += 5)(!t || ey[e + 4] && ey[e + 4].query === t) && (ey[e].style.cssText = ey[e + 1], ey[e].getBBox && ey[e].setAttribute("transform", ey[e + 2] || ""), ey[e + 3].uncache = 1) }, iy = function (t, e) { var n; for (PA = 0; PA < jb.length; PA++)!(n = jb[PA]) || e && n._ctx !== e || (t ? n.kill(1) : n.revert(!0, !0)); e && ny(e), e || ty("revert") }, ry = function (t, e) { jv.cache++, (e || !HA) && jv.forEach((function (t) { return hb(t) && t.cacheID++ && (t.rec = 0) })), lb(t) && (mA.history.scrollRestoration = VA = t) }, sy = 0, oy = function (t, e) { if (!KA || t) { HA = xy.isRefreshing = !0, jv.forEach((function (t) { return hb(t) && t.cacheID++ && (t.rec = t()) })); var n = ty("refreshInit"); BA && xy.sort(), e || iy(), jv.forEach((function (t) { hb(t) && (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0)) })), jb.slice(0).forEach((function (t) { return t.refresh() })), jb.forEach((function (t, e) { if (t._subPinOffset && t.pin) { var n = t.vars.horizontal ? "offsetWidth" : "offsetHeight", i = t.pin[n]; t.revert(!0, 1), t.adjustPinSpacing(t.pin[n] - i), t.revert(!1, 1) } })), jb.forEach((function (t) { return "max" === t.vars.end && t.setPositions(t.start, Math.max(t.start + 1, ob(t.scroller, t._dir))) })), n.forEach((function (t) { return t && t.render && t.render(-1) })), jv.forEach((function (t) { hb(t) && (t.smooth && requestAnimationFrame((function () { return t.target.style.scrollBehavior = "smooth" })), t.rec && t(t.rec)) })), ry(VA, 1), yA.pause(), sy++, hy(2), jb.forEach((function (t) { return hb(t.vars.onRefresh) && t.vars.onRefresh(t) })), HA = xy.isRefreshing = !1, ty("refresh") } else Rb(xy, "scrollEnd", $b) }, ay = 0, ly = 1, hy = function (t) { if (!HA || 2 === t) { xy.isUpdating = !0, WA && WA.update(0); var e = jb.length, n = YA(), i = n - XA >= 50, r = e && jb[0].scroll(); if (ly = ay > r ? -1 : 1, ay = r, i && (KA && !SA && n - KA > 200 && (KA = 0, ty("scrollEnd")), wA = XA, XA = n), ly < 0) { for (PA = e; PA-- > 0;)jb[PA] && jb[PA].update(0, i); ly = 1 } else for (PA = 0; PA < e; PA++)jb[PA] && jb[PA].update(0, i); xy.isUpdating = !1 } GA = 0 }, cy = [mb, "top", vb, gb, Cb + wb, Cb + yb, Cb + _b, Cb + xb, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], uy = cy.concat([Ab, bb, "boxSizing", "max" + Sb, "max" + Mb, "position", Cb, Eb, Eb + _b, Eb + yb, Eb + wb, Eb + xb]), dy = function (t, e, n, i) { if (!t._gsap.swappedIn) { for (var r, s = cy.length, o = e.style, a = t.style; s--;)o[r = cy[s]] = n[r]; o.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (o.display = "inline-block"), a[vb] = a[gb] = "auto", o.flexBasis = n.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[Ab] = Bb(t, iA) + Pb, o[bb] = Bb(t, rA) + Pb, o[Eb] = a[Cb] = a.top = a[mb] = "0", fy(i), a[Ab] = a["max" + Sb] = n[Ab], a[bb] = a["max" + Mb] = n[bb], a[Eb] = n[Eb], t.parentNode !== e && (t.parentNode.insertBefore(e, t), e.appendChild(t)), t._gsap.swappedIn = !0 } }, py = /([A-Z])/g, fy = function (t) { if (t) { var e, n, i = t.t.style, r = t.length, s = 0; for ((t.t._gsap || pA.core.getCache(t.t)).uncache = 1; s < r; s += 2)n = t[s + 1], e = t[s], n ? i[e] = n : i[e] && i.removeProperty(e.replace(py, "-$1").toLowerCase()) } }, my = function (t) { for (var e = uy.length, n = t.style, i = [], r = 0; r < e; r++)i.push(uy[r], n[uy[r]]); return i.t = t, i }, gy = { left: 0, top: 0 }, vy = function (t, e, n, i, r, s, o, a, l, h, c, u, d) { hb(t) && (t = t(a)), lb(t) && "max" === t.substr(0, 3) && (t = u + ("=" === t.charAt(4) ? Qb("0" + t.substr(3), n) : 0)); var p, f, m, g = d ? d.time() : 0; if (d && d.seek(0), cb(t)) o && Hb(o, n, i, !0); else { hb(e) && (e = e(a)); var v, A, b, y, x = (t || "0").split(" "); m = sA(e) || AA, (v = Db(m) || {}) && (v.left || v.top) || "none" !== Ib(m).display || (y = m.style.display, m.style.display = "block", v = Db(m), y ? m.style.display = y : m.style.removeProperty("display")), A = Qb(x[0], v[i.d]), b = Qb(x[1] || "0", n), t = v[i.p] - l[i.p] - h + A + r - b, o && Hb(o, b, i, n - b < 20 || o._isStart && b > 20), n -= n - b } if (s) { var _ = t + n, w = s._isStart; p = "scroll" + i.d2, Hb(s, _, i, w && _ > 20 || !w && (c ? Math.max(AA[p], vA[p]) : s.parentNode[p]) <= _ + 1), c && (l = Db(o), c && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + Pb)) } return d && m && (p = Db(m), d.seek(u), f = Db(m), d._caScrollDist = p[i.p] - f[i.p], t = t / d._caScrollDist * u), d && d.seek(g), d ? t : Math.round(t) }, Ay = /(webkit|moz|length|cssText|inset)/i, by = function (t, e, n, i) { if (t.parentNode !== e) { var r, s, o = t.style; if (e === AA) { for (r in t._stOrig = o.cssText, s = Ib(t)) +r || Ay.test(r) || !s[r] || "string" != typeof o[r] || "0" === r || (o[r] = s[r]); o.top = n, o.left = i } else o.cssText = t._stOrig; pA.core.getCache(t).uncache = 1, e.appendChild(t) } }, yy = function (t, e) { var n, i, r = oA(t, e), s = "_scroll" + e.p2, o = function e(o, a, l, h, c) { var u = e.tween, d = a.onComplete, p = {}; return l = l || r(), c = h && c || 0, h = h || o - l, u && u.kill(), n = Math.round(l), a[s] = o, a.modifiers = p, p[s] = function (t) { return (t = Math.round(r())) !== n && t !== i && Math.abs(t - n) > 3 && Math.abs(t - i) > 3 ? (u.kill(), e.tween = 0) : t = l + h * u.ratio + c * u.ratio * u.ratio, i = n, n = Math.round(t) }, a.onUpdate = function () { jv.cache++, hy() }, a.onComplete = function () { e.tween = 0, d && d.call(u) }, u = e.tween = pA.to(t, a) }; return t[s] = r, r.wheelHandler = function () { return o.tween && o.tween.kill() && (o.tween = 0) }, Rb(t, "wheel", r.wheelHandler), o }, xy = function () { function t(e, n) { fA || t.register(pA) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(e, n) } return t.prototype.init = function (e, n) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), JA) { var i, r, s, o, a, l, h, c, u, d, p, f, m, g, v, A, b, y, x, _, w, E, C, S, M, P, I, T, D, B, L, F, k, R, O, N, U, z, V, Q, G, H, j = e = Tb(lb(e) || cb(e) || e.nodeType ? { trigger: e } : e, zb), W = j.onUpdate, q = j.toggleClass, Y = j.id, X = j.onToggle, K = j.onRefresh, J = j.scrub, Z = j.trigger, $ = j.pin, tt = j.pinSpacing, et = j.invalidateOnRefresh, nt = j.anticipatePin, it = j.onScrubComplete, rt = j.onSnapComplete, st = j.once, ot = j.snap, at = j.pinReparent, lt = j.pinSpacer, ht = j.containerAnimation, ct = j.fastScrollEnd, ut = j.preventOverlaps, dt = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? iA : rA, pt = !J && 0 !== J, ft = sA(e.scroller || mA), mt = pA.core.getCache(ft), gt = rb(ft), vt = "fixed" === ("pinType" in e ? e.pinType : Xv(ft, "pinType") || gt && "fixed"), At = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack], bt = pt && e.toggleActions.split(" "), yt = "markers" in e ? e.markers : zb.markers, xt = gt ? 0 : parseFloat(Ib(ft)["border" + dt.p2 + Sb]) || 0, _t = this, wt = e.onRefreshInit && function () { return e.onRefreshInit(_t) }, Et = function (t, e, n) { var i = n.d, r = n.d2, s = n.a; return (s = Xv(t, "getBoundingClientRect")) ? function () { return s()[i] } : function () { return (e ? mA["inner" + r] : t["client" + r]) || 0 } }(ft, gt, dt), Ct = function (t, e) { return !e || ~Wv.indexOf(t) ? sb(t) : function () { return gy } }(ft, gt), St = 0, Mt = 0, Pt = oA(ft, dt); if (zA(_t), _t._dir = dt, nt *= 45, _t.scroller = ft, _t.scroll = ht ? ht.time.bind(ht) : Pt, o = Pt(), _t.vars = e, n = n || e.animation, "refreshPriority" in e && (BA = 1, -9999 === e.refreshPriority && (WA = _t)), mt.tweenScroll = mt.tweenScroll || { top: yy(ft, rA), left: yy(ft, iA) }, _t.tweenTo = i = mt.tweenScroll[dt.p], _t.scrubDuration = function (t) { (F = cb(t) && t) ? L ? L.duration(t) : L = pA.to(n, { ease: "expo", totalProgress: "+=0.001", duration: F, paused: !0, onComplete: function () { return it && it(_t) } }) : (L && L.progress(1).kill(), L = 0) }, n && (n.vars.lazy = !1, n._initted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.duration() && n.render(0, !0, !0), _t.animation = n.pause(), n.scrollTrigger = _t, _t.scrubDuration(J), D = 0, Y || (Y = n.vars.id)), jb.push(_t), ot && (ub(ot) && !ot.push || (ot = { snapTo: ot }), "scrollBehavior" in AA.style && pA.set(gt ? [AA, vA] : ft, { scrollBehavior: "auto" }), jv.forEach((function (t) { return hb(t) && t.target === (gt ? gA.scrollingElement || vA : ft) && (t.smooth = !1) })), s = hb(ot.snapTo) ? ot.snapTo : "labels" === ot.snapTo ? function (t) { return function (e) { return pA.utils.snap(Lb(t), e) } }(n) : "labelsDirectional" === ot.snapTo ? (Q = n, function (t, e) { return Fb(Lb(Q))(t, e.direction) }) : !1 !== ot.directional ? function (t, e) { return Fb(ot.snapTo)(t, YA() - Mt < 500 ? 0 : e.direction) } : pA.utils.snap(ot.snapTo), k = ot.duration || { min: .1, max: 2 }, k = ub(k) ? _A(k.min, k.max) : _A(k, k), R = pA.delayedCall(ot.delay || F / 2 || .1, (function () { var t = Pt(), e = YA() - Mt < 500, r = i.tween; if (!(e || Math.abs(_t.getVelocity()) < 10) || r || SA || St === t) _t.isActive && St !== t && R.restart(!0); else { var o = (t - l) / m, a = n && !pt ? n.totalProgress() : o, c = e ? 0 : (a - B) / (YA() - wA) * 1e3 || 0, u = pA.utils.clamp(-o, 1 - o, fb(c / 2) * c / .185), d = o + (!1 === ot.inertia ? 0 : u), p = _A(0, 1, s(d, _t)), f = Math.round(l + p * m), g = ot, v = g.onStart, A = g.onInterrupt, b = g.onComplete; if (t <= h && t >= l && f !== t) { if (r && !r._initted && r.data <= fb(f - t)) return; !1 === ot.inertia && (u = p - o), i(f, { duration: k(fb(.185 * Math.max(fb(d - a), fb(p - a)) / c / .05 || 0)), ease: ot.ease || "power3", data: fb(f - t), onInterrupt: function () { return R.restart(!0) && A && A(_t) }, onComplete: function () { _t.update(), St = Pt(), D = B = n && !pt ? n.totalProgress() : _t.progress, rt && rt(_t), b && b(_t) } }, t, u * m, f - t - u * m), v && v(_t, i.tween) } } })).pause()), Y && (Wb[Y] = _t), (V = (Z = _t.trigger = sA(Z || $)) && Z._gsap && Z._gsap.stRevert) && (V = V(_t)), $ = !0 === $ ? Z : sA($), lb(q) && (q = { targets: Z, className: q }), $ && (!1 === tt || tt === Cb || (tt = !(!tt && $.parentNode && $.parentNode.style && "flex" === Ib($.parentNode).display) && Eb), _t.pin = $, (r = pA.core.getCache($)).spacer ? g = r.pinState : (lt && ((lt = sA(lt)) && !lt.nodeType && (lt = lt.current || lt.nativeElement), r.spacerIsNative = !!lt, lt && (r.spacerState = my(lt))), r.spacer = b = lt || gA.createElement("div"), b.classList.add("pin-spacer"), Y && b.classList.add("pin-spacer-" + Y), r.pinState = g = my($)), !1 !== e.force3D && pA.set($, { force3D: !0 }), _t.spacer = b = r.spacer, T = Ib($), C = T[tt + dt.os2], x = pA.getProperty($), _ = pA.quickSetter($, dt.a, Pb), dy($, b, T), A = my($)), yt) { f = ub(yt) ? Tb(yt, Ub) : Ub, d = Gb("scroller-start", Y, ft, dt, f, 0), p = Gb("scroller-end", Y, ft, dt, f, 0, d), y = d["offset" + dt.op.d2]; var It = sA(Xv(ft, "content") || ft); c = this.markerStart = Gb("start", Y, It, dt, f, y, 0, ht), u = this.markerEnd = Gb("end", Y, It, dt, f, y, 0, ht), ht && (z = pA.quickSetter([c, u], dt.a, Pb)), vt || Wv.length && !0 === Xv(ft, "fixedMarkers") || (H = Ib(G = gt ? AA : ft).position, G.style.position = "absolute" === H || "fixed" === H ? H : "relative", pA.set([d, p], { force3D: !0 }), M = pA.quickSetter(d, dt.a, Pb), I = pA.quickSetter(p, dt.a, Pb)) } if (ht) { var Tt = ht.vars.onUpdate, Dt = ht.vars.onUpdateParams; ht.eventCallback("onUpdate", (function () { _t.update(0, 0, 1), Tt && Tt.apply(Dt || []) })) } _t.previous = function () { return jb[jb.indexOf(_t) - 1] }, _t.next = function () { return jb[jb.indexOf(_t) + 1] }, _t.revert = function (t, e) { if (!e) return _t.kill(!0); var i = !1 !== t || !_t.enabled, r = CA; i !== _t.isReverted && (i && (N = Math.max(Pt(), _t.scroll.rec || 0), O = _t.progress, U = n && n.progress()), c && [c, u, d, p].forEach((function (t) { return t.style.display = i ? "none" : "block" })), i && (CA = 1, _t.update(i)), !$ || at && _t.isActive || (i ? function (t, e, n) { fy(n); var i = t._gsap; if (i.spacerIsNative) fy(i.spacerState); else if (t._gsap.swappedIn) { var r = e.parentNode; r && (r.insertBefore(t, e), r.removeChild(e)) } t._gsap.swappedIn = !1 }($, b, g) : dy($, b, Ib($), S)), i || _t.update(i), CA = r, _t.isReverted = i) }, _t.refresh = function (r, s) { if (!CA && _t.enabled || s) if ($ && r && KA) Rb(t, "scrollEnd", $b); else { !HA && wt && wt(_t), CA = 1, Mt = YA(), i.tween && (i.tween.kill(), i.tween = 0), L && L.pause(), et && n && n.revert({ kill: !1 }).invalidate(), _t.isReverted || _t.revert(!0, !0), _t._subPinOffset = !1; for (var f, y, _, C, M, I, T, D, B, F, k, z = Et(), V = Ct(), Q = ht ? ht.duration() : ob(ft, dt), G = 0, H = 0, j = e.end, W = e.endTrigger || Z, q = e.start || (0 !== e.start && Z ? $ ? "0 0" : "0 100%" : 0), Y = _t.pinnedContainer = e.pinnedContainer && sA(e.pinnedContainer), X = Z && Math.max(0, jb.indexOf(_t)) || 0, J = X; J--;)(I = jb[J]).end || I.refresh(0, 1) || (CA = 1), !(T = I.pin) || T !== Z && T !== $ || I.isReverted || (F || (F = []), F.unshift(I), I.revert(!0, !0)), I !== jb[J] && (X--, J--); for (hb(q) && (q = q(_t)), l = vy(q, Z, z, dt, Pt(), c, d, _t, V, xt, vt, Q, ht) || ($ ? -.001 : 0), hb(j) && (j = j(_t)), lb(j) && !j.indexOf("+=") && (~j.indexOf(" ") ? j = (lb(q) ? q.split(" ")[0] : "") + j : (G = Qb(j.substr(2), z), j = lb(q) ? q : l + G, W = Z)), h = Math.max(l, vy(j || (W ? "100% 0" : Q), W, z, dt, Pt() + G, u, p, _t, V, xt, vt, Q, ht)) || -.001, m = h - l || (l -= .01) && .001, G = 0, J = X; J--;)(T = (I = jb[J]).pin) && I.start - I._pinPush <= l && !ht && I.end > 0 && (f = I.end - I.start, (T === Z && I.start - I._pinPush < l || T === Y) && !cb(q) && (G += f * (1 - I.progress)), T === $ && (H += f)); if (l += G, h += G, _t._pinPush = H, c && G && ((f = {})[dt.a] = "+=" + G, Y && (f[dt.p] = "-=" + Pt()), pA.set([c, u], f)), $) f = Ib($), C = dt === rA, _ = Pt(), w = parseFloat(x(dt.a)) + H, !Q && h > 1 && ((k = { style: k = (gt ? gA.scrollingElement || vA : ft).style, value: k["overflow" + dt.a.toUpperCase()] })["overflow" + dt.a.toUpperCase()] = "scroll"), dy($, b, f), A = my($), y = Db($, !0), D = vt && oA(ft, C ? iA : rA)(), tt && ((S = [tt + dt.os2, m + H + Pb]).t = b, (J = tt === Eb ? Bb($, dt) + m + H : 0) && S.push(dt.d, J + Pb), fy(S), Y && jb.forEach((function (t) { t.pin === Y && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0) })), vt && Pt(N)), vt && ((M = { top: y.top + (C ? _ - l : D) + Pb, left: y.left + (C ? D : _ - l) + Pb, boxSizing: "border-box", position: "fixed" })[Ab] = M["max" + Sb] = Math.ceil(y.width) + Pb, M[bb] = M["max" + Mb] = Math.ceil(y.height) + Pb, M[Cb] = M[Cb + _b] = M[Cb + yb] = M[Cb + wb] = M[Cb + xb] = "0", M[Eb] = f[Eb], M[Eb + _b] = f[Eb + _b], M[Eb + yb] = f[Eb + yb], M[Eb + wb] = f[Eb + wb], M[Eb + xb] = f[Eb + xb], v = function (t, e, n) { for (var i, r = [], s = t.length, o = n ? 8 : 0; o < s; o += 2)i = t[o], r.push(i, i in e ? e[i] : t[o + 1]); return r.t = t.t, r }(g, M, at), HA && Pt(0)), n ? (B = n._initted, LA(1), n.render(n.duration(), !0, !0), E = x(dt.a) - w + m + H, P = Math.abs(m - E) > 1, vt && P && v.splice(v.length - 2, 2), n.render(0, !0, !0), B || n.invalidate(!0), n.parent || n.totalTime(n.totalTime()), LA(0)) : E = m, k && (k.value ? k.style["overflow" + dt.a.toUpperCase()] = k.value : k.style.removeProperty("overflow-" + dt.a)); else if (Z && Pt() && !ht) for (y = Z.parentNode; y && y !== AA;)y._pinOffset && (l -= y._pinOffset, h -= y._pinOffset), y = y.parentNode; F && F.forEach((function (t) { return t.revert(!1, !0) })), _t.start = l, _t.end = h, o = a = HA ? N : Pt(), ht || HA || (o < N && Pt(N), _t.scroll.rec = 0), _t.revert(!1, !0), R && (St = -1, _t.isActive && Pt(l + m * O), R.restart(!0)), CA = 0, n && pt && (n._initted || U) && n.progress() !== U && n.progress(U, !0).render(n.time(), !0, !0), (O !== _t.progress || ht) && (n && !pt && n.totalProgress(O, !0), _t.progress = (o - l) / m === O ? 0 : O), $ && tt && (b._pinOffset = Math.round(_t.progress * E)), K && !HA && K(_t) } }, _t.getVelocity = function () { return (Pt() - a) / (YA() - wA) * 1e3 || 0 }, _t.endAnimation = function () { db(_t.callbackAnimation), n && (L ? L.progress(1) : n.paused() ? pt || db(n, _t.direction < 0, 1) : db(n, n.reversed())) }, _t.labelToScroll = function (t) { return n && n.labels && (l || _t.refresh() || l) + n.labels[t] / n.duration() * m || 0 }, _t.getTrailing = function (t) { var e = jb.indexOf(_t), n = _t.direction > 0 ? jb.slice(0, e).reverse() : jb.slice(e + 1); return (lb(t) ? n.filter((function (e) { return e.vars.preventOverlaps === t })) : n).filter((function (t) { return _t.direction > 0 ? t.end <= l : t.start >= h })) }, _t.update = function (t, e, r) { if (!ht || r || t) { var s, c, u, p, f, g, y, x = HA ? N : _t.scroll(), S = t ? 0 : (x - l) / m, T = S < 0 ? 0 : S > 1 ? 1 : S || 0, F = _t.progress; if (e && (a = o, o = ht ? Pt() : x, ot && (B = D, D = n && !pt ? n.totalProgress() : T)), nt && !T && $ && !CA && !qA && KA && l < x + (x - a) / (YA() - wA) * nt && (T = 1e-4), T !== F && _t.enabled) { if (p = (f = (s = _t.isActive = !!T && T < 1) !== (!!F && F < 1)) || !!T != !!F, _t.direction = T > F ? 1 : -1, _t.progress = T, p && !CA && (c = T && !F ? 0 : 1 === T ? 1 : 1 === F ? 2 : 3, pt && (u = !f && "none" !== bt[c + 1] && bt[c + 1] || bt[c], y = n && ("complete" === u || "reset" === u || u in n))), ut && (f || y) && (y || J || !n) && (hb(ut) ? ut(_t) : _t.getTrailing(ut).forEach((function (t) { return t.endAnimation() }))), pt || (!L || CA || qA ? n && n.totalProgress(T, !!CA) : (L._dp._time - L._start !== L._time && L.render(L._dp._time - L._start), L.resetTo ? L.resetTo("totalProgress", T, n._tTime / n._tDur) : (L.vars.totalProgress = T, L.invalidate().restart()))), $) if (t && tt && (b.style[tt + dt.os2] = C), vt) { if (p) { if (g = !t && T > F && h + 1 > x && x + 1 >= ob(ft, dt), at) if (t || !s && !g) by($, b); else { var k = Db($, !0), O = x - l; by($, AA, k.top + (dt === rA ? O : 0) + Pb, k.left + (dt === rA ? 0 : O) + Pb) } fy(s || g ? v : A), P && T < 1 && s || _(w + (1 !== T || g ? 0 : E)) } } else _(eb(w + E * T)); ot && !i.tween && !CA && !qA && R.restart(!0), q && (f || st && T && (T < 1 || !QA)) && xA(q.targets).forEach((function (t) { return t.classList[s || st ? "add" : "remove"](q.className) })), W && !pt && !t && W(_t), p && !CA ? (pt && (y && ("complete" === u ? n.pause().totalProgress(1) : "reset" === u ? n.restart(!0).pause() : "restart" === u ? n.restart(!0) : n[u]()), W && W(_t)), !f && QA || (X && f && pb(_t, X), At[c] && pb(_t, At[c]), st && (1 === T ? _t.kill(!1, 1) : At[c] = 0), f || At[c = 1 === T ? 1 : 3] && pb(_t, At[c])), ct && !s && Math.abs(_t.getVelocity()) > (cb(ct) ? ct : 2500) && (db(_t.callbackAnimation), L ? L.progress(1) : db(n, "reverse" === u ? 1 : !T, 1))) : pt && W && !CA && W(_t) } if (I) { var U = ht ? x / ht.duration() * (ht._caScrollDist || 0) : x; M(U + (d._isFlipped ? 1 : 0)), I(U) } z && z(-x / ht.duration() * (ht._caScrollDist || 0)) } }, _t.enable = function (e, n) { _t.enabled || (_t.enabled = !0, Rb(ft, "resize", Kb), Rb(gt ? gA : ft, "scroll", Yb), wt && Rb(t, "refreshInit", wt), !1 !== e && (_t.progress = O = 0, o = a = St = Pt()), !1 !== n && _t.refresh()) }, _t.getTween = function (t) { return t && i ? i.tween : L }, _t.setPositions = function (t, e) { $ && (w += t - l, E += e - t - m, tt === Eb && _t.adjustPinSpacing(e - t - m)), _t.start = l = t, _t.end = h = e, m = e - t, _t.update() }, _t.adjustPinSpacing = function (t) { if (S) { var e = S.indexOf(dt.d) + 1; S[e] = parseFloat(S[e]) + t + Pb, S[1] = parseFloat(S[1]) + t + Pb, fy(S) } }, _t.disable = function (e, n) { if (_t.enabled && (!1 !== e && _t.revert(!0, !0), _t.enabled = _t.isActive = !1, n || L && L.pause(), N = 0, r && (r.uncache = 1), wt && Ob(t, "refreshInit", wt), R && (R.pause(), i.tween && i.tween.kill() && (i.tween = 0)), !gt)) { for (var s = jb.length; s--;)if (jb[s].scroller === ft && jb[s] !== _t) return; Ob(ft, "resize", Kb), Ob(ft, "scroll", Yb) } }, _t.kill = function (t, i) { _t.disable(t, i), L && !i && L.kill(), Y && delete Wb[Y]; var s = jb.indexOf(_t); s >= 0 && jb.splice(s, 1), s === PA && ly > 0 && PA--, s = 0, jb.forEach((function (t) { return t.scroller === _t.scroller && (s = 1) })), s || HA || (_t.scroll.rec = 0), n && (n.scrollTrigger = null, t && n.revert({ kill: !1 }), i || n.kill()), c && [c, u, d, p].forEach((function (t) { return t.parentNode && t.parentNode.removeChild(t) })), WA === _t && (WA = 0), $ && (r && (r.uncache = 1), s = 0, jb.forEach((function (t) { return t.pin === $ && s++ })), s || (r.spacer = 0)), e.onKill && e.onKill(_t) }, _t.enable(!1, !1), V && V(_t), n && n.add && !m ? pA.delayedCall(.01, (function () { return l || h || _t.refresh() })) && (m = .01) && (l = h = 0) : _t.refresh(), $ && function () { if (jA !== sy) { var t = jA = sy; requestAnimationFrame((function () { return t === sy && oy(!0) })) } }() } else this.update = this.refresh = this.kill = tb }, t.register = function (e) { return fA || (pA = e || ib(), nb() && window.document && t.enable(), fA = JA), fA }, t.defaults = function (t) { if (t) for (var e in t) zb[e] = t[e]; return zb }, t.disable = function (t, e) { JA = 0, jb.forEach((function (n) { return n[e ? "kill" : "disable"](t) })), Ob(mA, "wheel", Yb), Ob(gA, "scroll", Yb), clearInterval(EA), Ob(gA, "touchcancel", tb), Ob(AA, "touchstart", tb), kb(Ob, gA, "pointerdown,touchstart,mousedown", ZA), kb(Ob, gA, "pointerup,touchend,mouseup", $A), yA.kill(), ab(Ob); for (var n = 0; n < jv.length; n += 3)Nb(Ob, jv[n], jv[n + 1]), Nb(Ob, jv[n], jv[n + 2]) }, t.enable = function () { if (mA = window, gA = document, vA = gA.documentElement, AA = gA.body, pA && (xA = pA.utils.toArray, _A = pA.utils.clamp, zA = pA.core.context || tb, LA = pA.core.suppressOverwrites || tb, VA = mA.history.scrollRestoration || "auto", pA.core.globals("ScrollTrigger", t), AA)) { JA = 1, dA.register(pA), t.isTouch = dA.isTouch, UA = dA.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Rb(mA, "wheel", Yb), bA = [mA, gA, vA, AA], pA.matchMedia ? (t.matchMedia = function (t) { var e, n = pA.matchMedia(); for (e in t) n.add(e, t[e]); return n }, pA.addEventListener("matchMediaInit", (function () { return iy() })), pA.addEventListener("matchMediaRevert", (function () { return ny() })), pA.addEventListener("matchMedia", (function () { oy(0, 1), ty("matchMedia") })), pA.matchMedia("(orientation: portrait)", (function () { return Xb(), Xb }))) : console.warn("Requires GSAP 3.11.0 or later"), Xb(), Rb(gA, "scroll", Yb); var e, n, i = AA.style, r = i.borderTopStyle, s = pA.core.Animation.prototype; for (s.revert || Object.defineProperty(s, "revert", { value: function () { return this.time(-.01, !0) } }), i.borderTopStyle = "solid", e = Db(AA), rA.m = Math.round(e.top + rA.sc()) || 0, iA.m = Math.round(e.left + iA.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), EA = setInterval(qb, 250), pA.delayedCall(.5, (function () { return qA = 0 })), Rb(gA, "touchcancel", tb), Rb(AA, "touchstart", tb), kb(Rb, gA, "pointerdown,touchstart,mousedown", ZA), kb(Rb, gA, "pointerup,touchend,mouseup", $A), MA = pA.utils.checkPrefix("transform"), uy.push(MA), fA = YA(), yA = pA.delayedCall(.2, oy).pause(), DA = [gA, "visibilitychange", function () { var t = mA.innerWidth, e = mA.innerHeight; gA.hidden ? (IA = t, TA = e) : IA === t && TA === e || Kb() }, gA, "DOMContentLoaded", oy, mA, "load", oy, mA, "resize", Kb], ab(Rb), jb.forEach((function (t) { return t.enable(0, 1) })), n = 0; n < jv.length; n += 3)Nb(Ob, jv[n], jv[n + 1]), Nb(Ob, jv[n], jv[n + 2]) } }, t.config = function (e) { "limitCallbacks" in e && (QA = !!e.limitCallbacks); var n = e.syncInterval; n && clearInterval(EA) || (EA = n) && setInterval(qb, n), "ignoreMobileResize" in e && (RA = 1 === t.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (ab(Ob) || ab(Rb, e.autoRefreshEvents || "none"), FA = -1 === (e.autoRefreshEvents + "").indexOf("resize")) }, t.scrollerProxy = function (t, e) { var n = sA(t), i = jv.indexOf(n), r = rb(n); ~i && jv.splice(i, r ? 6 : 2), e && (r ? Wv.unshift(mA, e, AA, e, vA, e) : Wv.unshift(n, e)) }, t.clearMatchMedia = function (t) { jb.forEach((function (e) { return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0) })) }, t.isInViewport = function (t, e, n) { var i = (lb(t) ? sA(t) : t).getBoundingClientRect(), r = i[n ? Ab : bb] * e || 0; return n ? i.right - r > 0 && i.left + r < mA.innerWidth : i.bottom - r > 0 && i.top + r < mA.innerHeight }, t.positionInViewport = function (t, e, n) { lb(t) && (t = sA(t)); var i = t.getBoundingClientRect(), r = i[n ? Ab : bb], s = null == e ? r / 2 : e in Vb ? Vb[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0; return n ? (i.left + s) / mA.innerWidth : (i.top + s) / mA.innerHeight }, t.killAll = function (t) { if (jb.slice(0).forEach((function (t) { return "ScrollSmoother" !== t.vars.id && t.kill() })), !0 !== t) { var e = Jb.killAll || []; Jb = {}, e.forEach((function (t) { return t() })) } }, t }(); xy.version = "3.11.4", xy.saveStyles = function (t) { return t ? xA(t).forEach((function (t) { if (t && t.style) { var e = ey.indexOf(t); e >= 0 && ey.splice(e, 5), ey.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), pA.core.getCache(t), zA()) } })) : ey }, xy.revert = function (t, e) { return iy(!t, e) }, xy.create = function (t, e) { return new xy(t, e) }, xy.refresh = function (t) { return t ? Kb() : (fA || xy.register()) && oy(!0) }, xy.update = function (t) { return ++jv.cache && hy(!0 === t ? 2 : 0) }, xy.clearScrollMemory = ry, xy.maxScroll = function (t, e) { return ob(t, e ? iA : rA) }, xy.getScrollFunc = function (t, e) { return oA(sA(t), e ? iA : rA) }, xy.getById = function (t) { return Wb[t] }, xy.getAll = function () { return jb.filter((function (t) { return "ScrollSmoother" !== t.vars.id })) }, xy.isScrolling = function () { return !!KA }, xy.snapDirectional = Fb, xy.addEventListener = function (t, e) { var n = Jb[t] || (Jb[t] = []); ~n.indexOf(e) || n.push(e) }, xy.removeEventListener = function (t, e) { var n = Jb[t], i = n && n.indexOf(e); i >= 0 && n.splice(i, 1) }, xy.batch = function (t, e) { var n, i = [], r = {}, s = e.interval || .016, o = e.batchMax || 1e9, a = function (t, e) { var n = [], i = [], r = pA.delayedCall(s, (function () { e(n, i), n = [], i = [] })).pause(); return function (t) { n.length || r.restart(!0), n.push(t.trigger), i.push(t), o <= n.length && r.progress(1) } }; for (n in e) r[n] = "on" === n.substr(0, 2) && hb(e[n]) && "onRefreshInit" !== n ? a(0, e[n]) : e[n]; return hb(o) && (o = o(), Rb(xy, "refresh", (function () { return o = e.batchMax() }))), xA(t).forEach((function (t) { var e = {}; for (n in r) e[n] = r[n]; e.trigger = t, i.push(xy.create(e)) })), i }; var _y, wy = function (t, e, n, i) { return e > i ? t(i) : e < 0 && t(0), n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1 }, Ey = function t(e, n) { !0 === n ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (dA.isTouch ? " pinch-zoom" : "") : "none", e === vA && t(AA, n) }, Cy = { auto: 1, scroll: 1 }, Sy = function (t) { var e, n = t.event, i = t.target, r = t.axis, s = (n.changedTouches ? n.changedTouches[0] : n).target, o = s._gsap || pA.core.getCache(s), a = YA(); if (!o._isScrollT || a - o._isScrollT > 2e3) { for (; s && s !== AA && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !Cy[(e = Ib(s)).overflowY] && !Cy[e.overflowX]);)s = s.parentNode; o._isScroll = s && s !== i && !rb(s) && (Cy[(e = Ib(s)).overflowY] || Cy[e.overflowX]), o._isScrollT = a } (o._isScroll || "x" === r) && (n.stopPropagation(), n._gsapAllow = !0) }, My = function (t, e, n, i) { return dA.create({ target: t, capture: !0, debounce: !1, lockAxis: !0, type: e, onWheel: i = i && Sy, onPress: i, onDrag: i, onScroll: i, onEnable: function () { return n && Rb(gA, dA.eventTypes[0], Iy, !1, !0) }, onDisable: function () { return Ob(gA, dA.eventTypes[0], Iy, !0) } }) }, Py = /(input|label|select|textarea)/i, Iy = function (t) { var e = Py.test(t.target.tagName); (e || _y) && (t._gsapAllow = !0, _y = e) }, Ty = function (t) { ub(t) || (t = {}), t.preventDefault = t.isNormalizer = t.allowClicks = !0, t.type || (t.type = "wheel,touch"), t.debounce = !!t.debounce, t.id = t.id || "normalizer"; var e, n, i, r, s, o, a, l, h = t, c = h.normalizeScrollX, u = h.momentum, d = h.allowNestedScroll, p = sA(t.target) || vA, f = pA.core.globals().ScrollSmoother, m = f && f.get(), g = UA && (t.content && sA(t.content) || m && !1 !== t.content && !m.smooth() && m.content()), v = oA(p, rA), A = oA(p, iA), b = 1, y = (dA.isTouch && mA.visualViewport ? mA.visualViewport.scale * mA.visualViewport.width : mA.outerWidth) / mA.innerWidth, x = 0, _ = hb(u) ? function () { return u(e) } : function () { return u || 2.8 }, w = My(p, t.type, !0, d), E = function () { return r = !1 }, C = tb, S = tb, M = function () { n = ob(p, rA), S = _A(UA ? 1 : 0, n), c && (C = _A(0, ob(p, iA))), i = sy }, P = function () { g._gsap.y = eb(parseFloat(g._gsap.y) + v.offset) + "px", g.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(g._gsap.y) + ", 0, 1)", v.offset = v.cacheID = 0 }, I = function () { M(), s.isActive() && s.vars.scrollY > n && (v() > n ? s.progress(1) && v(n) : s.resetTo("scrollY", n)) }; return g && pA.set(g, { y: "+=0" }), t.ignoreCheck = function (t) { return UA && "touchmove" === t.type && function () { if (r) { requestAnimationFrame(E); var t = eb(e.deltaY / 2), n = S(v.v - t); if (g && n !== v.v + v.offset) { v.offset = n - v.v; var i = eb((parseFloat(g && g._gsap.y) || 0) - v.offset); g.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + i + ", 0, 1)", g._gsap.y = i + "px", v.cacheID = jv.cache, hy() } return !0 } v.offset && P(), r = !0 }() || b > 1.05 && "touchstart" !== t.type || e.isGesturing || t.touches && t.touches.length > 1 }, t.onPress = function () { var t = b; b = eb((mA.visualViewport && mA.visualViewport.scale || 1) / y), s.pause(), t !== b && Ey(p, b > 1.01 || !c && "x"), o = A(), a = v(), M(), i = sy }, t.onRelease = t.onGestureStart = function (t, e) { if (v.offset && P(), e) { jv.cache++; var i, r, o = _(); c && (r = (i = A()) + .05 * o * -t.velocityX / .227, o *= wy(A, i, r, ob(p, iA)), s.vars.scrollX = C(r)), r = (i = v()) + .05 * o * -t.velocityY / .227, o *= wy(v, i, r, ob(p, rA)), s.vars.scrollY = S(r), s.invalidate().duration(o).play(.01), (UA && s.vars.scrollY >= n || i >= n - 1) && pA.to({}, { onUpdate: I, duration: o }) } else l.restart(!0) }, t.onWheel = function () { s._ts && s.pause(), YA() - x > 1e3 && (i = 0, x = YA()) }, t.onChange = function (t, e, n, r, s) { if (sy !== i && M(), e && c && A(C(r[2] === e ? o + (t.startX - t.x) : A() + e - r[1])), n) { v.offset && P(); var l = s[2] === n, h = l ? a + t.startY - t.y : v() + n - s[1], u = S(h); l && h !== u && (a += u - h), v(u) } (n || e) && hy() }, t.onEnable = function () { Ey(p, !c && "x"), xy.addEventListener("refresh", I), Rb(mA, "resize", I), v.smooth && (v.target.style.scrollBehavior = "auto", v.smooth = A.smooth = !1), w.enable() }, t.onDisable = function () { Ey(p, !0), Ob(mA, "resize", I), xy.removeEventListener("refresh", I), w.kill() }, t.lockAxis = !1 !== t.lockAxis, (e = new dA(t)).iOS = UA, UA && !v() && v(1), UA && pA.ticker.add(tb), l = e._dc, s = pA.to(e, { ease: "power4", paused: !0, scrollX: c ? "+=0.1" : "+=0", scrollY: "+=0.1", onComplete: l.vars.onComplete }), e }; function Dy(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } xy.sort = function (t) { return jb.sort(t || function (t, e) { return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0)) }) }, xy.observe = function (t) { return new dA(t) }, xy.normalizeScroll = function (t) { if (void 0 === t) return kA; if (!0 === t && kA) return kA.enable(); if (!1 === t) return kA && kA.kill(); var e = t instanceof dA ? t : Ty(t); return kA && kA.target === e.target && kA.kill(), rb(e.target) && (kA = e), e }, xy.core = { _getVelocityProp: aA, _inputObserver: My, _scrollers: jv, _proxies: Wv, bridge: { ss: function () { KA || ty("scrollStart"), KA = YA() }, ref: function () { return CA } } }, ib() && pA.registerPlugin(xy); class By extends Ng { constructor(t) { super(t), Dy(this, "animate", (() => { this.animRuning && (this.time++, this.time % 100 == 0 && (this.noiseValTemp = this.noiseVal - Math.random(2)), this.noiseVal = this.noiseVal + .005 * (this.noiseValTemp - this.noiseVal), mg.set(this.dom.outer1, { x: .5 * this.size.width * (1 + Math.sin(10 * this.noiseVal)), y: .5 * this.size.height * (1 + Math.cos(10 * this.noiseVal)), rotate: 10 * -this.noiseVal + "rad" }), mg.set(this.dom.outer2, { x: .5 * this.size.width * (1 + Math.sin(10 * this.noiseVal + Math.PI)), y: .5 * this.size.height * (1 + Math.cos(10 * this.noiseVal + Math.PI)), rotate: -(10 * this.noiseVal + Math.PI) + "rad" }), mg.set(this.dom.inner1, { x: .5 * this.size.width * (1 + .62 * Math.sin(10 * this.noiseVal + 4 * this.noiseVal)), y: .5 * this.size.height * (1 + .62 * Math.cos(10 * this.noiseVal + 4 * this.noiseVal)), rotate: -(10 * this.noiseVal + 4 * this.noiseVal) + "rad" }), mg.set(this.dom.inner2, { x: .5 * this.size.width * (1 + .62 * Math.sin(10 * this.noiseVal + Math.PI + 5 * this.noiseVal)), y: .5 * this.size.height * (1 + .62 * Math.cos(10 * this.noiseVal + Math.PI + 5 * this.noiseVal)), rotate: -(10 * this.noiseVal + Math.PI + 5 * this.noiseVal) + "rad" })) })), Dy(this, "resize", (() => { })), this.time = 0, this.progress = 0, this.animRuning = !1, this.noiseValTemp = -Math.random(2), this.noiseVal = -Math.random(2), this.loaderPersisting = Sh(".loader__persisting-elements"), this.loader = Sh(".js-loader"), this.animationPos = ["0", " ", "&", "*", " ", "/", " ", "%", "$", "€"], this.populateDom(), this.size = this.dom.icon.getBoundingClientRect(), this.launchAnim(), this.transitionStarted = !1, this.on(ic.RAF, this.animate), this.on(ic.RESIZE, this.resize), ec.on("Launch-transition", (() => { this.flicker(1), this.animRuning = !0 })), ec.on("End-transition", (() => { this.isHome = Fh.body.classList.contains("home"), this.animRuning = !1; const t = document.URL.split("#")[1]; this.isHome && !t ? this.loaderPersisting.style.opacity = 1 : this.loaderPersisting.style.opacity = 0, mg.fromTo(this.el, { opacity: 1, duration: .5, ease: "linear", delay: Fh.body.classList.contains("home") && window.location.hash ? 2 : 0 }, { opacity: 0 }) })), ec.on("Home:EndTransition", (() => { this.isHome = Fh.body.classList.contains("home"), this.animRuning = !1; const t = document.URL.split("#")[1]; this.isHome && !t ? this.loaderPersisting.style.opacity = 1 : this.loaderPersisting.style.opacity = 0, mg.fromTo(this.el, { opacity: 1, duration: .5, ease: "linear", delay: Fh.body.classList.contains("home") && window.location.hash ? 2 : 0 }, { opacity: 0 }) })) } updateAnim(t) { for (let e = 0; e < t.animationText.length; e++)" " === t.original[e] ? t.animationText[e] = t.original[e] : t.animationText[e] = t.animationPos[Math.floor(Math.random() * t.animationPos.length)] } flicker(t) { 1 === t ? this.isTransition = !0 : this.transition = !1, this.transitionStarted = new Promise((e => mg.timeline({ onComplete: () => { e(), this.transitionStarted = !1 } }).set(this.el, { opacity: 1, delay: .05 }).set(this.el, { opacity: 0, delay: .05 }).set(this.el, { opacity: 0, delay: .1 }).set(this.el, { opacity: 1, delay: .1 }).set(this.el, { opacity: 0, delay: .08 }).set(this.el, { opacity: 1, delay: .05 }).set(this.el, { opacity: t, delay: .05 }))) } textAnim() { mg.set(this.dom.blockTextArray, { y: "100%" }); mg.timeline().to(this.dom.blockTextArray[0], { y: "-90%", duration: 1, ease: "steps(10)" }).to(this.dom.blockTextArray[1], { y: "-90%", duration: 1, ease: "steps(10)" }, "-=0.75") } launchAnim() { mg.set(this.dom.outer1, { x: .5 * this.size.width * (1 + Math.sin(10)), y: .5 * this.size.height * (1 + Math.cos(10)) }), mg.set(this.dom.outer2, { x: .5 * this.size.width * (1 + Math.sin(30)), y: .5 * this.size.height * (1 + Math.cos(30)) }), mg.set(this.dom.inner1, { x: .5 * this.size.width * (1 + .62 * Math.sin(10)), y: .5 * this.size.height * (1 + .62 * Math.cos(10)) }), mg.set(this.dom.inner2, { x: .5 * this.size.width * (1 + .62 * Math.sin(30)), y: .5 * this.size.height * (1 + .62 * Math.cos(30)) }) } destroy() { super.destroy() } } Dy(By, "selector", ".js-transition"); var Ly = n(1248), Fy = n.n(Ly); function ky(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Ry extends Ng { constructor(t) { super(t), ky(this, "updateProgress", (t => { let { percent: e } = t; mg.to(this, { progress: e, duration: 1, ease: "power2.out", overwrite: !0, onUpdate: () => { this.dom.indicator.textContent = Math.round(this.progress) + "%", this.dom.mainTextArray[2].textContent = "/ " + Math.round(this.progress) + "%_COMPLETE" } }) })), ky(this, "onAssetsLoaded", (() => { this.isHome = Fh.body.classList.contains("home"), requestIdleCallback((() => { this.updateProgress({ percent: 100 }), this.animation.play(), this.animation.onComplete = () => { this.emit("Loader:Complete"), this.isHome || this.el.style.setProperty("--text-opacity", 0), !Fh.urlParams.has("noui") && this.isHome && this.loadHomeSection && Fh.components.get(Ny).first().scrollToOnLoad(), this.switchText(this.dom.mainTextArray[2], "/ LOADED"), mg.to(this.dom.inner, { delay: this.isHome && this.loadHomeSection ? .5 : 0, autoAlpha: 0, onStart: () => { this.el.style.zIndex = 1, this.el.classList.add("complete"), mg.delayedCall(1, (() => { this.switchText(this.dom.mainTextArray[2], "/ SCROLL_TO_COMMENCE_BUILD"), setTimeout((() => { this.switchText(this.dom.mainTextArray[1], "/ SEQUENCE_INITIATED") }), 100) })) }, onComplete: () => { this.isLoaded = !0 } }) } }), { timeout: 2e3 }) })), ky(this, "animate", (() => { this.isLoaded || (this.time++, this.time % 100 == 0 && (this.noiseValTemp = this.noiseVal - Math.random(2)), this.noiseVal = this.noiseVal + .005 * (this.noiseValTemp - this.noiseVal), mg.set(this.dom.outer1, { x: .5 * this.size.width * (1 + Math.sin(10 * this.noiseVal)), y: .5 * this.size.height * (1 + Math.cos(10 * this.noiseVal)), rotate: 10 * -this.noiseVal + "rad" }), mg.set(this.dom.outer2, { x: .5 * this.size.width * (1 + Math.sin(10 * this.noiseVal + Math.PI)), y: .5 * this.size.height * (1 + Math.cos(10 * this.noiseVal + Math.PI)), rotate: -(10 * this.noiseVal + Math.PI) + "rad" }), mg.set(this.dom.inner1, { x: .5 * this.size.width * (1 + .62 * Math.sin(10 * this.noiseVal + 4 * this.noiseVal)), y: .5 * this.size.height * (1 + .62 * Math.cos(10 * this.noiseVal + 4 * this.noiseVal)), rotate: -(10 * this.noiseVal + 4 * this.noiseVal) + "rad" }), mg.set(this.dom.inner2, { x: .5 * this.size.width * (1 + .62 * Math.sin(10 * this.noiseVal + Math.PI + 5 * this.noiseVal)), y: .5 * this.size.height * (1 + .62 * Math.cos(10 * this.noiseVal + Math.PI + 5 * this.noiseVal)), rotate: -(10 * this.noiseVal + Math.PI + 5 * this.noiseVal) + "rad" }), this.animation.currentFrame / this.animation.totalFrames > .3 && this.animation.currentFrame / this.animation.totalFrames < .6 ? Math.floor(2 * this.animation.currentFrame) % 20 == 0 && mg.to(this, { iconOpacity: 0, duration: .2, onUpdate: () => { this.el.style.setProperty("--icon-opacity", this.iconOpacity) } }) : this.animation.currentFrame / this.animation.totalFrames > .4 ? this.el.style.setProperty("--icon-opacity", 0) : this.el.style.setProperty("--icon-opacity", 1)) })), ky(this, "resize", (() => { this.isHome && (Fh.mq.sm.matches ? this.el.style.setProperty("--text-opacity", 1) : this.el.style.setProperty("--text-opacity", 0)), setTimeout((() => { const t = this.dom.globe.getBoundingClientRect(), e = this.dom.mainTextContainer.getBoundingClientRect(), n = t.top + .5 * t.height - (e.top + .5 * e.height), i = e.left - t.left - t.width; this.dom.mainTextArray.forEach((t => { t.style.transform = `translate(${-i}px, ${n}px)` })) }), 100) })), this.time = 0, this.iconOpacity = 0, this.el.style.setProperty("--icon-opacity", this.iconOpacity), this.el.style.setProperty("--text-opacity", this.iconOpacity), this.progress = 0, this.noiseValTemp = -Math.random(2), this.noiseVal = -Math.random(2), this.animationPos = ["0", " ", "&", "*", " ", "/", " ", "%", "$", "€"], this.loadHomeSection = window.location.hash, this.populateDom(), this.size = this.dom.icon.getBoundingClientRect(); const e = new Image; requestAnimationFrame((() => { this.mainTextAnim() })), e.src = "/wp-content/themes/quai/public/images/globe_loader.png", e.onload = () => { this.globeLoaded = !0 }, this.textAnim(), this.launchAnim(), this.on(ic.RAF, this.animate), this.on(ic.RESIZE, this.resize), this.throttledProgressFunc = this.throttle(this.updateProgress, 50), this.on("AssetsProgress", this.throttledProgressFunc), this.on("AssetsLoaded", this.onAssetsLoaded) } switchText(t, e) { t.progress = 1, t.style.height = t.getBoundingClientRect().height + "px", t.original = t.innerText.split(""), t.target = [], t.target.length = t.original.length, mg.to(t, { progress: 0, duration: .02 * t.original.length, onUpdate: () => { const e = Math.floor(t.original.length * t.progress); t.textContent = t.original.slice(0, e).join("") }, onComplete: () => { t.target = e.split(""), t.original = [], t.original.length = t.target.length, mg.to(t, { progress: 1, duration: .02 * t.target.length, onUpdate: () => { const e = Math.floor(t.original.length * t.progress); t.textContent = t.target.slice(0, e).join("") } }) } }) } mainTextAnim() { const t = this.dom.mainTextContainer.getBoundingClientRect(); this.textPosition = t, this.dom.mainTextContainer.style.width = t.width + "px", this.textTimeline = mg.timeline({ paused: !0 }), this.el.style.setProperty("--text-opacity", 1), this.dom.mainTextArray.forEach(((t, e) => { t.progress = 0, t.original = t.innerText.split(""), t.animationText = [], t.animationText.length = t.original.length; for (let e = 0; e < t.animationText.length; e++)" " === t.original[e] ? t.animationText[e] = t.original[e] : t.animationText[e] = this.animationPos[Math.floor(Math.random() * this.animationPos.length)]; t.textContent = "//", t.style.opacity = 0, this.textTimeline.to(t, { progress: 1, duration: .05 * t.original.length, onStart: () => { t.style.opacity = 1 }, onUpdate: () => { t.iteration++; const e = Math.floor(t.original.length * t.progress); t.textContent = t.original.slice(0, e).join("") + t.animationText.slice(e, e + 2).join(""), t.iteration % 10 == 0 && this.updateAnim(t) }, onComplete: () => { if (this.textTimeline.addLabel("beforeTranslate"), this.globeLoaded && 2 === e) this.playNextAnim(); else if (!this.globeLoaded && 2 === e) { const t = new Image; t.src = "/wp-content/themes/quai/public/images/globe_loader.png", t.onload = () => { this.playNextAnim() } } } }) })), this.textTimeline.duration(2), this.textTimeline.play() } playNextAnim() { const t = this.dom.globe.getBoundingClientRect(), e = t.top + .5 * t.height - (this.textPosition.top + .5 * this.textPosition.height), n = this.textPosition.left - t.left - t.width; for (let t = this.dom.mainTextArray.length - 1; t >= 0; t--) { const i = this.dom.mainTextArray[t]; this.textTimeline.addLabel(`translate-${t}`, "-=" + .3 * (this.dom.mainTextArray.length - 1 - t)), this.textTimeline.to(i, { y: `+=${e}`, onUpdate: function () { Math.floor(100 * this.progress()) % 10 == 0 && (this._targets[0].progress *= -1, this._targets[0].style.opacity = this._targets[0].progress) }, onComplete: function () { this._targets[0].style.opacity = 1 } }, `translate-${t}`), this.textTimeline.to(i, { x: `-=${n}` }, `translate-${t}+=0.5`) } } updateAnim(t) { for (let e = 0; e < t.animationText.length; e++)" " === t.original[e] ? t.animationText[e] = t.original[e] : t.animationText[e] = t.animationPos[Math.floor(Math.random() * t.animationPos.length)] } textAnim() { mg.set(this.dom.blockTextArray, { y: "350vh" }); mg.timeline().to(this.dom.blockTextArray[0], { y: 1.5 * -Fh.window.h, duration: 1.5, ease: "steps(30)" }).to(this.dom.blockTextArray[1], { y: 1.5 * -Fh.window.h, duration: 1.5, ease: "steps(30)" }, "-=1") } launchAnim() { mg.set(this.dom.outer1, { x: .5 * this.size.width * (1 + Math.sin(10)), y: .5 * this.size.height * (1 + Math.cos(10)), top: 0 }), mg.set(this.dom.outer2, { x: .5 * this.size.width * (1 + Math.sin(30)), y: .5 * this.size.height * (1 + Math.cos(30)), top: 0 }), mg.set(this.dom.inner1, { x: .5 * this.size.width * (1 + .62 * Math.sin(10)), y: .5 * this.size.height * (1 + .62 * Math.cos(10)), top: 0 }), mg.set(this.dom.inner2, { x: .5 * this.size.width * (1 + .62 * Math.sin(30)), y: .5 * this.size.height * (1 + .62 * Math.cos(30)), top: 0 }), this.animation = Fy().loadAnimation({ container: this.dom.icon, renderer: "svg", loop: !1, autoplay: !1, path: "/wp-content/themes/quai/public/anim/Loader_7.json" }), this.iconOpacity = 1, this.el.style.setProperty("--icon-opacity", this.iconOpacity), this.animation.addEventListener("enterFrame", (() => { 100 === Math.ceil(this.animation.currentFrame) && (this.reachFrame || (this.reachFrame = !0, mg.timeline().to(this.dom.icon, { x: 20, y: 20, duration: .4, ease: "back.in" }).to(this.dom.icon, { x: 0, y: 0, duration: .4, ease: "back.out" }))) })) } destroy() { super.destroy() } throttle(t, e) { let n = !1; return function () { n || (t.apply(this, arguments), n = !0, setTimeout((function () { n = !1 }), e)) } } } function Oy(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } ky(Ry, "selector", ".js-loader"); class Ny extends Ng { constructor(t) { super(t), Oy(this, "scrollToOnLoad", (() => { if ("" !== window.location.hash) { const t = this.urls.indexOf("/" + window.location.hash), e = this.sections[t], n = Fh.Lenis.scroll + e.getBoundingClientRect().top + this.sectionOffset[t]; Fh.Lenis.wrapperNode.scrollTo(0, n), Fh.Lenis.scrollTo(n, { immediate: !0 }) } })), Oy(this, "onClick", (t => { Fh.body.classList.contains("home") && (t.preventDefault(), ec.emit("Launch-transition"), Fh.staticComponents.get(By).first().transitionStarted.then((() => { Sh(".js-navigation").classList.add("hide"), Sh(".js-toggle-menu").classList.add("closed"), Fh.Header.isOpen = !1; const e = _v(t.target, "href"), n = this.urls.indexOf(e), i = this.sections[n], r = this.sectionOffset[n], s = Fh.Lenis.scroll + i.getBoundingClientRect().top + r; Fh.Lenis.scrollTo(s, { immediate: !0 }), setTimeout((() => { ec.emit("Home:EndTransition"), Fh.Header.animateInBack() }), 500) }))) })), Oy(this, "scrollToTop", (t => { Fh.body.classList.contains("home") && (t.preventDefault(), window.history.replaceState(null, null, window.location.origin), ec.emit("Launch-transition"), Fh.staticComponents.get(By).first().transitionStarted.then((() => { Fh.Lenis.scrollTo(0, { immediate: !0 }), setTimeout((() => { ec.emit("Home:EndTransition"), Fh.Header.animateInBack() }), 500) }))) })), Oy(this, "resize", (() => { this.createCanvas() })), this.populateDom(), this.loaderPersisting = Fh.staticComponents.get(Ry).first().dom.persisting; const e = Mh("[data-section-url]", Fh.body); this.resources = Sh(".js-resources", Fh.body), this.homeBtn = Sh(".js-home-btn", Fh.body), this.urls = [], this.sections = [], this.resourceSections = [], this.scrollTriggers = [], e.forEach((t => { const e = _v(t, "data-section-url"); "null" !== e && (this.urls.push(e), this.sections.push(t), this.buildST(t)) })), this.sectionOffset = [10, 10, 10, -50, -50, -50, -50], this.createCanvas(), this.on("click", this.dom.mainNavLinkArray, this.onClick), this.on("click", Mh(".js-main-nav-link"), this.onClick), this.on("click", this.homeBtn, this.scrollToTop), this.on(ic.RESIZE, this.resize) } createCanvas() { this.dpr = window.devicePixelRatio || 1, this.dom.canvas.size = this.dom.canvas.getBoundingClientRect(), this.dom.canvas.width = this.dom.canvas.size.width, this.dom.canvas.height = this.dom.canvas.size.height, this.legalPosition = this.dom.legal.getBoundingClientRect().x + this.dom.legal.getBoundingClientRect().width + 100, this.socialPosition = this.dom.social.getBoundingClientRect().x, this.offset = [30, 40], this.ctx = this.dom.canvas.getContext("2d"), this.points = [], this.curve = 35, this.lineWidth = 1.5, this.pointTension = Fh.mq.smallDesk.matches ? .5 : .3, this.points = [{ x: this.lineWidth, y: this.lineWidth, tension: this.pointTension }, { x: this.dom.canvas.width - .5 * this.lineWidth, y: this.lineWidth, tension: this.pointTension }, { x: this.dom.canvas.width - .5 * this.lineWidth, y: this.dom.canvas.height - this.curve, tension: this.pointTension }, { x: this.dom.canvas.width - this.curve, y: this.dom.canvas.height - this.lineWidth, tension: this.pointTension }, { x: this.dom.canvas.width - this.curve - 100, y: this.dom.canvas.height - this.lineWidth, tension: this.pointTension }, { x: this.legalPosition + this.offset[0] + 200, y: this.dom.canvas.height - this.lineWidth, tension: .2 }, { x: this.legalPosition + this.offset[0] + .5 * this.curve, y: this.dom.canvas.height - this.lineWidth, tension: this.pointTension }, { x: this.legalPosition - .5 * this.curve, y: this.dom.canvas.height - this.lineWidth - this.offset[1], tension: this.pointTension, color: "green" }, { x: this.curve, y: this.dom.canvas.height - this.lineWidth - this.offset[1], tension: this.pointTension }, { x: .5 * this.lineWidth, y: this.dom.canvas.height - this.lineWidth - this.offset[1] - this.curve, tension: this.pointTension }, { x: .5 * this.lineWidth, y: this.lineWidth, tension: this.pointTension }], this.border = [{ x: this.socialPosition - 0, y: this.dom.canvas.height - this.lineWidth - 30, tension: .2 }, { x: this.legalPosition + this.offset[0] + 2 * this.curve, y: this.dom.canvas.height - this.lineWidth - 30, tension: .2 }, { x: this.legalPosition + this.offset[0] + .75 * this.curve, y: this.dom.canvas.height - this.lineWidth - 30, tension: .2 }, { x: this.legalPosition, y: this.dom.canvas.height - this.lineWidth - this.offset[1] - 30, tension: 1, color: "green" }, { x: this.legalPosition - 70, y: this.dom.canvas.height - this.lineWidth - this.offset[1] - 30, tension: .2, color: "green" }], this.set() } drawCurve(t, e, n, i, r) { this.ctx.beginPath(), this.ctx.setLineDash([1e5, 1e5]), this.ctx.moveTo(t[0].x, t[0].y); for (let e = 0; e < t.length - 1; e++) { const n = null != t[e].tension ? t[e].tension : 1, i = e > 0 ? t[e - 1] : t[0], r = t[e], s = t[e + 1], o = e !== t.length - 2 ? t[e + 2] : s, a = r.x + (s.x - i.x) / 6 * n, l = r.y + (s.y - i.y) / 6 * n, h = s.x - (o.x - r.x) / 6 * n, c = s.y - (o.y - r.y) / 6 * n; r.x === s.x || r.y === s.y ? this.ctx.lineTo(s.x, s.y) : this.ctx.bezierCurveTo(Math.round(a), Math.round(l), Math.round(h), Math.round(c), Math.round(s.x), Math.round(s.y)) } this.ctx.strokeStyle = r || "white", this.ctx.fillStyle = i, this.ctx.strokeWidth = 10, this.ctx.stroke(), this.ctx.fill(), this.ctx.closePath() } set() { this.progress = 2e3, this.ctx.clearRect(0, 0, this.dom.canvas.width, this.dom.canvas.height), this.drawCurve(this.points, -.5, !1, "rgba(0, 0, 0, 0.9", "#646464"), this.drawCurve(this.border, -.5, !1, "transparent", "rgba(100, 100, 100, 0.5)") } buildST(t) { const e = xy.create({ trigger: t, start: "top top+=50%", end: "bottom top", onEnter: () => { window.history.replaceState(null, null, _v(t, "data-section-url")), mg.set(".js-hero", { display: "none" }) }, onEnterBack: () => { window.history.replaceState(null, null, _v(t, "data-section-url")) }, onLeaveBack: () => { "/#what-can-you-build" === _v(t, "data-section-url") && window.history.replaceState(null, null, "/#crosschain"), "/#trilemma" === _v(t, "data-section-url") && (window.history.replaceState(null, null, window.location.origin), mg.set(".js-hero", { display: "block" })) } }); this.scrollTriggers.push(e) } destroy() { super.destroy(), this.scrollTriggers.forEach((t => { null == t || t.kill() })) } } Oy(Ny, "selector", ".js-navigation"); var Uy = n(6498), zy = n(6041); n(285); const Vy = "tp"; function Qy(t) { return e => n => { if (!e && void 0 === n) return { succeeded: !1, value: void 0 }; if (e && void 0 === n) return { succeeded: !0, value: void 0 }; const i = t(n); return void 0 !== i ? { succeeded: !0, value: i } : { succeeded: !1, value: void 0 } } } function Gy(t) { return { custom: e => Qy(e)(t), boolean: Qy((t => "boolean" == typeof t ? t : void 0))(t), number: Qy((t => "number" == typeof t ? t : void 0))(t), string: Qy((t => "string" == typeof t ? t : void 0))(t), function: Qy((t => "function" == typeof t ? t : void 0))(t), constant: e => Qy((t => t === e ? e : void 0))(t), raw: Qy((t => t))(t), object: e => Qy((t => { var n; if (null !== (n = t) && "object" == typeof n) return function (t, e) { const n = Object.keys(e).reduce(((n, i) => { if (void 0 === n) return; const r = (0, e[i])(t[i]); return r.succeeded ? Object.assign(Object.assign({}, n), { [i]: r.value }) : void 0 }), {}); return n }(t, e) }))(t), array: e => Qy((t => { var n; if (Array.isArray(t)) return n = e, t.reduce(((t, e) => { if (void 0 === t) return; const i = n(e); return i.succeeded && void 0 !== i.value ? [...t, i.value] : void 0 }), []) }))(t) } } const Hy = { optional: Gy(!0), required: Gy(!1) }; function jy(t, e, n, i) { return new (n || (n = Promise))((function (r, s) { function o(t) { try { l(i.next(t)) } catch (t) { s(t) } } function a(t) { try { l(i.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) { t(e) }))).then(o, a) } l((i = i.apply(t, e || [])).next()) })) } function Wy(t) { return jy(this, void 0, void 0, (function* () { const e = new Image; return e.crossOrigin = "anonymous", new Promise((n => { e.src = t, e.decode().then((() => { n(e) })) })) })) } function qy(t) { return new Promise((e => { e(t) })) } const Yy = (Xy = "img", (t, e) => [Vy, "-", Xy, "v", t ? `_${t}` : "", e ? `-${e}` : ""].join("")); var Xy; class Ky { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(Yy()), e.viewProps.bindClassModifiers(this.element), this.input = t.createElement("input"), this.input.classList.add(Yy("input")), this.input.setAttribute("type", "file"), this.input.setAttribute("accept", e.extensions.join(",")), this.element.appendChild(this.input), this.image_ = t.createElement("img"), this.image_.classList.add(Yy("image")), this.image_.classList.add(Yy(`image_${e.imageFit}`)), this.element.classList.add(Yy("area_root")), this.element.appendChild(this.image_) } changeImage(t) { this.image_.src = t } changeDraggingState(t) { const e = this.element; t ? null == e || e.classList.add(Yy("area_dragging")) : null == e || e.classList.remove(Yy("area_dragging")) } } class Jy { constructor(t, e) { this.placeholderImage = null, this.value = e.value, this.viewProps = e.viewProps, this.view = new Ky(t, { viewProps: this.viewProps, extensions: e.extensions, imageFit: e.imageFit }), this.onFile = this.onFile.bind(this), this.onDrop = this.onDrop.bind(this), this.onDragOver = this.onDragOver.bind(this), this.onDragLeave = this.onDragLeave.bind(this), this.view.input.addEventListener("change", this.onFile), this.view.element.addEventListener("drop", this.onDrop), this.view.element.addEventListener("dragover", this.onDragOver), this.view.element.addEventListener("dragleave", this.onDragLeave), this.viewProps.handleDispose((() => { this.view.input.removeEventListener("change", this.onFile), this.view.input.removeEventListener("drop", this.onDrop), this.view.input.removeEventListener("dragover", this.onDragOver), this.view.input.removeEventListener("dragleave", this.onDragLeave) })), this.value.emitter.on("change", this.handleValueChange.bind(this)), this.handleValueChange() } onFile(t) { const e = (null == t ? void 0 : t.target).files; if (!e || !e.length) return; const n = e[0], i = URL.createObjectURL(n); this.setValue(i), this.updateImage(i) } onDrop(t) { return jy(this, void 0, void 0, (function* () { t.preventDefault(); try { const { dataTransfer: e } = t, n = null == e ? void 0 : e.files[0]; if (n) { const t = URL.createObjectURL(n); this.updateImage(t), this.setValue(t) } else { const t = null == e ? void 0 : e.getData("url"); if (!t) throw new Error("No url"); Wy(t).then((t => jy(this, void 0, void 0, (function* () { const e = yield qy(t); this.updateImage(e.src), this.setValue(e) })))) } } catch (t) { console.error("Could not parse the dropped image", t) } finally { this.view.changeDraggingState(!1) } })) } onDragOver(t) { t.preventDefault(), this.view.changeDraggingState(!0) } onDragLeave() { this.view.changeDraggingState(!1) } handleImage(t) { return jy(this, void 0, void 0, (function* () { if (t instanceof HTMLImageElement) qy(t).then((t => { this.updateImage(t.src) })); else if ("string" == typeof t) { let e = ""; try { if ("placeholder" === t) throw new Error("placeholder"); new URL(t); e = (yield Wy(t)).src } catch (t) { e = (yield this.handlePlaceholderImage()).src } finally { this.updateImage(e), this.setValue(e) } } })) } updateImage(t) { this.view.changeImage(t) } setValue(t) { return jy(this, void 0, void 0, (function* () { t instanceof HTMLImageElement ? this.value.setRawValue(t) : t ? this.value.setRawValue(yield Wy(t)) : this.value.setRawValue(yield this.handlePlaceholderImage()) })) } handleValueChange() { this.handleImage(this.value.rawValue) } handlePlaceholderImage() { return jy(this, void 0, void 0, (function* () { return this.placeholderImage || (this.placeholderImage = yield function () { const t = document.createElement("canvas"); t.width = 128, t.height = 64; const e = t.getContext("2d"); return e.fillStyle = "#222", e.fillRect(0, 0, t.width, t.height), e.fillStyle = "#ddd", e.font = "monospaced", e.textAlign = "center", e.textBaseline = "middle", e.fillText("No image", .5 * t.width, .5 * t.height), new Promise((e => { t.toBlob((t => { const n = new Image; n.src = URL.createObjectURL(t), n.onload = () => { e(n) } })) })) }()), this.placeholderImage })) } } const Zy = [".jpg", ".png", ".gif"], $y = { id: "input-image", type: "input", css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:0.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:grid;height:calc(var(--bld-us) * 3);overflow:hidden;position:relative}.tp-imgv.tp-v-disabled{opacity:0.5}.tp-imgv_input{width:100%;height:100%;opacity:0}.tp-imgv_image{width:100%;height:100%;position:absolute;pointer-events:none;border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity 0.16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:6px;opacity:0.6}", accept(t, e) { if (!(t instanceof HTMLImageElement || "string" == typeof t)) return null; const n = Hy, i = function (t, e) { const n = Hy.required.object(e)(t); return n.succeeded ? n.value : void 0 }(e, { view: n.required.constant("input-image"), acceptUrl: n.optional.boolean, imageFit: n.optional.custom((t => "contain" === t || "cover" === t ? t : void 0)), extensions: n.optional.array(n.required.string) }); return i ? { initialValue: t, params: i } : null }, binding: { reader(t) { return t => t instanceof HTMLImageElement ? "" === t.src ? "placeholder" : t.src : "string" == typeof t ? t : "placeholder" }, writer(t) { return (t, e) => { t.write(e) } } }, controller(t) { let e, n; return new Jy(t.document, { value: t.value, imageFit: null !== (e = t.params.imageFit) && void 0 !== e ? e : "cover", viewProps: t.viewProps, extensions: null !== (n = t.params.extensions) && void 0 !== n ? n : Zy }) } }, tx = $y; function ex(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class nx extends Uy.Pane { constructor() { super({ title: "Options" }), ex(this, "rebuildParticles", (() => { Fh.MainScene.components.shape.removeShapes(), Fh.MainScene.components.shape.build(Fh.MainScene.objectData) })), this.containerElem_.style.width = "350px", this.containerElem_.style.position = "fixed", this.containerElem_.style.maxHeight = "98vh", this.containerElem_.style.overflowY = "auto", this.containerElem_.style.zIndex = "9999999", this.containerElem_.firstChild.style.overflow = "hidden", this.containerElem_.addEventListener("wheel", (t => { t.stopPropagation() })), this.registerPlugin(zy), this.registerPlugin(i), this.fireChange = !0, this.options = { syncGuiValues: !0 }, this.addFps(), this.addSceneStats(), this.addInput(this.options, "syncGuiValues"), this.addMisc(), this.addCamera(), this.addPostFX(), this.addFog(), this.addMainTower(), this.addPeople(), this.addLogo(), this.addShapes(), this.addReflectiveFloors(), this.addTowers(), this.addBridges(), this.addSignsPipes(), this.addCars(), this.addTextures(), this.addPaths() } addSceneStats() { const t = { count: Fh.WebGL.renderer.info.programs.length }; setInterval((() => { t.count = Fh.WebGL.renderer.info.programs.length }), 1e3); const e = this.addFolder({ title: "Scene Stats", expanded: !1 }); e.addMonitor(Fh.WebGL.renderer.info.render, "calls", { label: "draw calls", interval: 500 }), e.addMonitor(Fh.WebGL.renderer.info.render, "triangles", { interval: 500 }), e.addMonitor(Fh.WebGL.renderer.info.memory, "geometries", { interval: 1e4 }), e.addMonitor(Fh.WebGL.renderer.info.memory, "textures", { interval: 1e4 }), e.addMonitor(t, "count", { label: "materials", interval: 1e3 }) } addMisc() { const t = this.addFolder({ title: "misc", expanded: !0 }); t.addInput(Fh.MainScene.options, "scrollPosition", { min: 0, max: 1, step: 1e-5 }), t.addInput(Fh.MainScene.options, "scrollSpeed", { min: .01, max: 2, step: .001 }) } addCamera() { const t = this.addFolder({ title: "camera", expanded: !0 }); t.addInput(Fh.MainScene.controls, "enabled", { label: "orbit camera" }), t.addInput(Fh.MainScene.cameraHelper, "visible", { label: "camera helper" }), t.addInput(Fh.MainScene.brownianMotion, "positionAmplitude", { min: 0, max: .1, step: .001 }), t.addInput(Fh.MainScene.brownianMotion, "rotationAmplitude", { min: 0, max: .1, step: .001 }), t.addInput(Fh.MainScene.brownianMotion, "positionFrequency", { min: 0, max: 1, step: .01 }), t.addInput(Fh.MainScene.brownianMotion, "rotationFrequency", { min: 0, max: 1, step: .01 }) } addPostFX() { const t = this.addFolder({ title: "post fx", expanded: !1 }); t.addInput(Fh.WebGL.renderer, "toneMappingExposure", { min: 0, max: 5, step: .001 }), t.addInput(Fh.WebGL.renderer, "toneMapping", { options: { None: K, Linear: J, Reinhard: Z, Cineon: $, ACESFilmic: tt, Custom: et }, label: "tone mapping" }); const e = t.addFolder({ title: "bloom", expanded: !0 }); e.addInput(Fh.MainScene.bloomPass, "enabled"), e.addInput(Fh.MainScene.bloomPass, "threshold", { min: 0, max: 1, step: .001 }), e.addInput(Fh.MainScene.bloomPass, "strength", { min: 0, max: 5, step: .001 }), e.addInput(Fh.MainScene.bloomPass, "radius", { min: 0, max: 2, step: .001 }); const n = t.addFolder({ title: "chromatric aberration", expanded: !0 }); n.addInput(Fh.MainScene.screenFxPass, "enabled"), n.addInput(Fh.MainScene.screenFxPass.uniforms.uMaxDistort, "value", { label: "max distort", min: 0, max: 4, step: .001 }), n.addInput(Fh.MainScene.screenFxPass.uniforms.uBendAmount, "value", { label: "bend amount", min: -1, max: 0, step: .001 }) } addFog() { const t = this.addFolder({ title: "fog", expanded: !1 }); t.addInput(Fh.MainScene.components.fog.globalUniforms.uEnableFog, "value", { label: "enable fog" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uDebugFog, "value", { label: "uDebugFog (non volumetric)" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uFogNear_D, "value", { min: 0, max: 500, step: .01, label: "uFogNear_D" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uFogFar_D, "value", { min: 0, max: 1e3, step: .01, label: "uFogFar_D" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uFogStrength_D, "value", { min: 0, max: 1, step: 1e-4, label: "uFogStrength_D" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uFogNear_H, "value", { min: -200, max: 300, step: .1, label: "uFogNear_H" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uFogFar_H, "value", { min: -200, max: 300, step: .1, label: "uFogFar_H" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uFogStrength_H, "value", { min: 0, max: 1, step: 1e-4, label: "uFogStrength_H" }), this.addColor(t, Fh.MainScene.components.fog.globalUniforms.uWorldFogColor, "value", "uWorldFogColor overlay", !0), t.addInput(Fh.MainScene.components.fog.globalUniforms.uWorldFogColorMix, "value", { min: 0, max: 1, step: 1e-4, label: "uWorldFogColorMix" }), t.addInput(Fh.MainScene.components.fog.globalUniforms.uFogStrength, "value", { min: 0, max: 1, step: 1e-4, label: "uFogStrength_Combined" }), t.addInput(Fh.MainScene.options, "lightHelpersEnabled").on("change", (t => { Fh.MainScene.helpers.visible = t.value })); const e = []; for (let n = 0; n < Fh.MainScene.components.fog.globalUniforms.volumetricLights.value.length; ++n) { const i = t.addFolder({ title: `light ${n}`, expanded: !1 }); e.push(i) } for (let t = 0; t < e.length; ++t)this.addColor(e[t], Fh.MainScene.components.fog.globalUniforms.volumetricLights.value[t], "color", "color", !1, [Fh.MainScene.components.fog.helpers.children[t].material, Fh.MainScene.components.fog.helpers.children[t].children[0].material]), e[t].addInput(Fh.MainScene.components.fog.globalUniforms.volumetricLights.value[t], "near", { min: 0, max: 300, step: .1 }), e[t].addInput(Fh.MainScene.components.fog.globalUniforms.volumetricLights.value[t], "far", { min: 0, max: 1e3, step: .1 }), e[t].addInput(Fh.MainScene.components.fog.globalUniforms.volumetricLights.value[t], "strength", { min: 0, max: 2, step: .001 }), e[t].addInput(Fh.MainScene.components.fog.globalUniforms.volumetricLights.value[t], "position").on("change", (e => { Fh.MainScene.components.fog.helpers.children[t].position.set(e.value.x, e.value.y, e.value.z) })) } addMainTower() { const t = this.addFolder({ title: "main tower", expanded: !1 }), e = t.addFolder({ title: "Reveal shader", expanded: !0 }); e.addInput(Fh.MainScene.components.mainTower.globalUniforms.uAnimate, "value", { label: "uAnimate" }), e.addInput(Fh.MainScene.components.mainTower.globalUniforms.uAnimateUpFlag, "value", { label: "uAnimateUp" }).on("change", (t => { t.value ? Fh.MainScene.components.mainTower.globalUniforms.uAnimateUp.value = 1 : Fh.MainScene.components.mainTower.globalUniforms.uAnimateUp.value = -1 })), e.addInput(Fh.MainScene.components.mainTower.globalUniforms.uGroundFloorBegin, "value", { label: "uGroundFloorBegin", min: -1, max: 1, step: .001 }), e.addInput(Fh.MainScene.components.mainTower.globalUniforms.uHexTexScale, "value", { label: "uHexTextScale" }), e.addInput(Fh.MainScene.components.mainTower.globalUniforms.uRecTexScale, "value", { label: "uRecTexScale" }); const n = e.addFolder({ title: "Fragment", expanded: !0 }), i = e.addFolder({ title: "Vertex", expanded: !0 }); this.addColor(n, Fh.MainScene.components.mainTower.globalUniforms.uFlameTopColor, "value", "uFlameTopColor", !0), this.addColor(n, Fh.MainScene.components.mainTower.globalUniforms.uFlameBottomColor, "value", "uFlameBottomColor", !0), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uFlameBandWidth, "value", { label: "uFlameBandWidth", min: .01, max: 1, step: .001 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uOverallGradientSpread, "value", { label: "uOverallGradientSpread", min: 0, max: 1, step: 1e-4 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uEdgeTextureSubtractStrength, "value", { label: "uEdgeTextureSubtractStrength", min: .01, max: 1, step: .001 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uFlameColorGradientSpread, "value", { label: "uFlameColorGradientSpread", min: .01, max: 1, step: .001 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uFlameColorChangeOffset, "value", { label: "uFlameColorChangeOffset", min: -1, max: 1, step: .001 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uFlameStrength, "value", { label: "uFlameStrength", min: 0, max: 5, step: .001 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uFragNoiseSpeed, "value", { label: "uFragNoiseSpeed", min: 0, max: 10, step: .001 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uFragNoiseStrength, "value", { label: "uFragNoiseStrength", min: 0, max: .5, step: 1e-4 }), n.addInput(Fh.MainScene.components.mainTower.globalUniforms.uFragNoiseScale, "value", { label: "uFragNoiseScale", min: 0, max: 50, step: .001 }), i.addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertDispType, "value", { options: { movingGradient: 0, smoothStep: 1 }, label: "uVertDispType" }); const r = i.addTab({ pages: [{ title: "Gradient" }, { title: "Smoothstep" }] }); i.addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertDispMult, "value", { label: "uVertDispMult", min: .1, max: 50, step: .1 }), i.addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertNoiseScale, "value", { label: "uVertNoiseScale", min: 0, max: 5, step: .001 }), i.addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertNoiseSpeed, "value", { label: "uVertNoiseSpeed", min: 0, max: 10, step: .001 }), i.addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertNoiseStrength, "value", { label: "uVertNoiseStrength", min: 0, max: 1, step: 1e-4 }), r.pages[0].addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertGradientSpread, "value", { label: "uVertGradientSpread", min: 0, max: 2, step: 1e-4 }), r.pages[1].addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertFalloffStart, "value", { label: "uVertFalloffStart", min: -5, max: 2, step: 1e-4 }), r.pages[1].addInput(Fh.MainScene.components.mainTower.globalUniforms.uVertFalloffEnd, "value", { label: "uVertFalloffEnd", min: 0, max: 2, step: 1e-4 }); const s = t.addFolder({ title: "Balconies", expanded: !0 }); this.addColor(s, Fh.MainScene.components.mainTower.globalUniforms.uBalconyBaseColorTop, "value", "uBalconyBaseColorTop", !0), this.addColor(s, Fh.MainScene.components.mainTower.globalUniforms.uBalconyBaseColorBottom, "value", "uBalconyBaseColorBottom", !0), s.addInput(Fh.MainScene.components.mainTower.globalUniforms.uBalconyScanLinesBlendMode, "value", { options: { blendOverlay: 0, blendSoftLight: 1, blendColorDodge: 2, add: 3, subtract: 4 }, label: "uBalconyScanLinesBlendMode" }), s.addInput(Fh.MainScene.components.mainTower.globalUniforms.uBalconyScanLinesDensity, "value", { label: "uBalconyScanLinesDensity", min: 0, max: 100, step: .01 }), s.addInput(Fh.MainScene.components.mainTower.globalUniforms.uBalconyScanLinesSpeed, "value", { label: "uBalconyScanLinesSpeed", min: 0, max: 3, step: .001 }), s.addInput(Fh.MainScene.components.mainTower.globalUniforms.uBalconyScanLinesStrength, "value", { label: "uBalconyScanLinesStrength", min: 0, max: 1, step: .001 }), s.addInput(Fh.MainScene.components.mainTower.globalUniforms.uBalconyScanLinesMaxDistance, "value", { label: "uBalconyScanLinesMaxDistance", min: 0, max: 200, step: .01 }); const o = t.addFolder({ title: "Textures" }); this.addImage(o, Fh.MainScene.components.reflectiveFloors.children[0].material.uniforms.uDiffuse, "value", "base lightmap", { flipY: !1, encoding: be }, (t => { Fh.MainScene.components.mainTower.baseSides.material.map = t })); for (const t in Fh.MainScene.components.mainTower.meshes) for (const e in Fh.MainScene.components.mainTower.meshes[t]) { const n = Fh.MainScene.components.mainTower.meshes[t][e], i = Object.keys(Fh.MainScene.components.mainTower.meshes[t]).indexOf(e); "walls" === t && (this.addImage(o, n.material.uniforms.tWallsTex, "value", "walls" + i, { flipY: !1, encoding: be }, (t => { Fh.MainScene.components.reflectiveFloors.children[i + 1] && (Fh.MainScene.components.reflectiveFloors.children[i + 1].material.uniforms.uDiffuse.value = t) })), this.addImage(o, n.material.uniforms.tWindowsTex, "value", "windows" + i, { flipY: !1, encoding: be }), this.addImage(o, n.material.uniforms.tPillarsTex, "value", "pillars" + i, { flipY: !1, encoding: be })) } } addPeople() { const t = this.addFolder({ title: "people", expanded: !1 }).addFolder({ title: "Textures" }); Fh.MainScene.components.people.meshes.forEach(((e, n) => { this.addImage(t, e.material.uniforms.uColorTexture, "value", "p" + n, { flipY: !1, encoding: be }) })) } addLogo() { const t = this.addFolder({ title: "logo", expanded: !1 }); t.addInput(Fh.MainScene.components.logo.options, "animateInDuration", { label: "Duration" }).on("change", (() => { Fh.MainScene.components.logo.animateIn() })), t.addInput(Fh.MainScene.components.logo.options.revealEasing, "amplitude", { label: "Ease amplitude", min: 0, max: 2, step: .01 }).on("change", (() => { Fh.MainScene.components.logo.animateIn() })), t.addInput(Fh.MainScene.components.logo.options.revealEasing, "period", { label: "Ease period", min: 0, max: 1, step: .01 }).on("change", (() => { Fh.MainScene.components.logo.animateIn() })), t.addInput(Fh.MainScene.components.logo.options, "additiveBlending").on("change", (t => { Fh.MainScene.components.logo.material.blending = t.value ? b : A })), t.addButton({ title: "Play", label: "Animate logo" }).on("click", (() => { const t = Fh.MainScene.components.logo.timeline; t ? 1 === t.progress() ? t.play(0) : t.play() : Fh.MainScene.components.logo.animateIn() })), t.addButton({ title: "Pause", label: "Pause animation" }).on("click", (() => { var t, e; null === (t = Fh.MainScene.components.logo) || void 0 === t || null === (e = t.timeline) || void 0 === e || e.pause() })), t.addButton({ title: "Reset", label: "Reset animation" }).on("click", (() => { var t, e; null === (t = Fh.MainScene.components.logo) || void 0 === t || null === (e = t.timeline) || void 0 === e || e.play(0) })), t.addInput(Fh.MainScene.components.logo.material.uniforms.uProgress, "value", { label: "uProgress", min: 0, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.logo.material.uniforms.uRadius, "value", { label: "Mouse radius", min: .05, max: 2.5, step: .05 }), t.addInput(Fh.MainScene.components.logo.material.uniforms.uDistortion, "value", { label: "uDistortion", min: 0, max: 1.5, step: .01 }), this.addColor(t, Fh.MainScene.components.logo.material.uniforms.uColor1, "value", "uColor1", !1), this.addColor(t, Fh.MainScene.components.logo.material.uniforms.uColor2, "value", "uColor2", !1), this.addColor(t, Fh.MainScene.components.logo.material.uniforms.uColorHover, "value", "uColorHover", !1), t.addInput(Fh.MainScene.components.logo.material.uniforms.uColorStrength, "value", { label: "uColorStrength", min: 0, max: 1, step: .01 }), t.addInput(Fh.MainScene.components.logo.material.uniforms.uColorSpeed, "value", { label: "uColorSpeed", min: 0, max: 10, step: .1 }), t.addInput(Fh.MainScene.components.logo.material.uniforms.uColorAmplitude, "value", { label: "uColorAmplitude", min: 0, max: 1, step: .01 }), t.addInput(Fh.MainScene.components.logo.material.uniforms.uTexScale, "value", { label: "Texture scale", min: .1, max: 100, step: .01 }); const e = t.addFolder({ title: "glow", expanded: !1 }); e.addInput(Fh.MainScene.components.logo.glowPlane.material.uniforms.uOpacity, "value", { label: "opacity", min: 0, max: 1, step: .01 }), this.addColor(e, Fh.MainScene.components.logo.glowPlane.material.uniforms.uColor, "value", "color", !0), e.addInput(Fh.MainScene.components.logo.glowPlane.material.uniforms.uInnerRadius, "value", { label: "inner radius", step: .01 }), e.addInput(Fh.MainScene.components.logo.glowPlane.material.uniforms.uOuterRadius, "value", { label: "outer radius", step: .01 }), e.addInput(Fh.MainScene.components.logo.glowPlane.material.uniforms.uScale, "value", { label: "inner scale", step: .01 }); const n = { scale: Fh.MainScene.components.logo.glowPlane.scale.x }; e.addInput(n, "scale", { step: .01 }).on("change", (t => { Fh.MainScene.components.logo.glowPlane.scale.setScalar(t.value) })) } addShapes() { const t = this.addFolder({ title: "shapes", expanded: !1 }); t.addInput(Fh.MainScene.components.shape.globalUniforms.uParticleStrength, "value", { label: "Particle strength", step: .01, min: .01, max: 1 }), t.addInput(Fh.MainScene.components.shape.globalOptions, "mouseLerp", { label: "mouseLerp", step: .01, min: .01, max: .7 }), t.addBlade({ view: "list", label: "Blending", options: [{ text: "AdditiveBlending", value: b }, { text: "NormalBlending", value: A }], value: b }).on("change", (t => { Fh.MainScene.components.shape.children.forEach((e => { e.children.forEach((e => { e.material.blending = t.value })) })) })); const e = t.addFolder({ title: "Shape 1", expanded: !1 }), n = t.addFolder({ title: "Shape 2", expanded: !1 }), i = t.addFolder({ title: "Shape 3", expanded: !1 }); e.addInput(Fh.MainScene.components.shape.options.k0, "particlesCount", { label: "Particles count", step: 5, min: 10, max: 150 }).on("change", this.rebuildParticles), this.addColor(e, Fh.MainScene.components.shape.uniforms.particles.k0.uParticlesColor, "value", "Particles color", !0), this.addColor(e, Fh.MainScene.components.shape.uniforms.lines.k0.uLinesColor1, "value", "Lines color 1", !0), this.addColor(e, Fh.MainScene.components.shape.uniforms.lines.k0.uLinesColor2, "value", "Lines color 2", !0), e.addInput(Fh.MainScene.components.shape.uniforms.lines.k0.uBlendFrequency, "value", { label: "Lines gradient - uBlendFrequency", step: .1, min: .1, max: 10 }), e.addInput(Fh.MainScene.components.shape.uniforms.lines.k0.uBlendSpeed, "value", { label: "Lines gradient - uBlendSpeed", step: .01, min: .01, max: 6 }), e.addInput(Fh.MainScene.components.shape.options.k0, "planeParticleSize", { label: "Particle size", step: .01, min: .1, max: .8 }).on("change", this.rebuildParticles), e.addInput(Fh.MainScene.components.shape.options.k0, "randomSpread", { label: "Particles random spread", step: .001, min: .001, max: .3 }).on("change", this.rebuildParticles), e.addInput(Fh.MainScene.components.shape.uniforms.particles.k0.uDisplace, "value", { label: "uDisplace", step: .01, min: 0, max: .5 }), e.addInput(Fh.MainScene.components.shape.uniforms.particles.k0.uMouseSize, "value", { label: "uMouseSize", step: .01, min: .5, max: 5 }), e.addInput(Fh.MainScene.components.shape.uniforms.particles.k0.uMouseStrength, "value", { label: "uMouseStrength", step: .01, min: .5, max: 5 }), e.addInput(Fh.MainScene.components.shape.uniforms.lines.k0.linewidth, "value", { label: "Line width", step: .001, min: .001, max: .06 }).on("change", (t => { Fh.MainScene.components.shape.children[0].children[0].material.linewidth = t.value })), n.addInput(Fh.MainScene.components.shape.options.k1, "particlesCount", { label: "Particles count", step: 5, min: 10, max: 150 }).on("change", this.rebuildParticles), this.addColor(n, Fh.MainScene.components.shape.uniforms.particles.k1.uParticlesColor, "value", "Particles color", !0), this.addColor(n, Fh.MainScene.components.shape.uniforms.lines.k1.uLinesColor1, "value", "Lines color 1", !0), this.addColor(n, Fh.MainScene.components.shape.uniforms.lines.k1.uLinesColor2, "value", "Lines color 2", !0), n.addInput(Fh.MainScene.components.shape.uniforms.lines.k1.uBlendFrequency, "value", { label: "Lines gradient - uBlendFrequency", step: .1, min: .1, max: 10 }), n.addInput(Fh.MainScene.components.shape.uniforms.lines.k1.uBlendSpeed, "value", { label: "Lines gradient - uBlendSpeed", step: .01, min: .01, max: 6 }), n.addInput(Fh.MainScene.components.shape.options.k1, "planeParticleSize", { label: "Particle size", step: .01, min: .1, max: .8 }).on("change", this.rebuildParticles), n.addInput(Fh.MainScene.components.shape.options.k1, "randomSpread", { label: "Particles random spread", step: .001, min: .001, max: .3 }).on("change", this.rebuildParticles), n.addInput(Fh.MainScene.components.shape.uniforms.particles.k1.uDisplace, "value", { label: "uDisplace", step: .01, min: 0, max: .5 }), n.addInput(Fh.MainScene.components.shape.uniforms.particles.k1.uMouseSize, "value", { label: "uMouseSize", step: .01, min: .5, max: 5 }), n.addInput(Fh.MainScene.components.shape.uniforms.particles.k1.uMouseStrength, "value", { label: "uMouseStrength", step: .01, min: .5, max: 5 }), n.addInput(Fh.MainScene.components.shape.uniforms.lines.k1.linewidth, "value", { label: "Line width", step: .001, min: .001, max: .06 }).on("change", (t => { Fh.MainScene.components.shape.children[1].children[0].material.linewidth = t.value })), i.addInput(Fh.MainScene.components.shape.options.k2, "particlesCount", { label: "Particles count", step: 5, min: 10, max: 150 }).on("change", this.rebuildParticles), this.addColor(i, Fh.MainScene.components.shape.uniforms.particles.k2.uParticlesColor, "value", "Particles color", !0), this.addColor(i, Fh.MainScene.components.shape.uniforms.lines.k2.uLinesColor1, "value", "Lines color 1", !0), this.addColor(i, Fh.MainScene.components.shape.uniforms.lines.k2.uLinesColor2, "value", "Lines color 2", !0), i.addInput(Fh.MainScene.components.shape.uniforms.lines.k2.uBlendFrequency, "value", { label: "Lines gradient - uBlendFrequency", step: .1, min: .1, max: 10 }), i.addInput(Fh.MainScene.components.shape.uniforms.lines.k2.uBlendSpeed, "value", { label: "Lines gradient - uBlendSpeed", step: .01, min: .01, max: 6 }), i.addInput(Fh.MainScene.components.shape.options.k2, "planeParticleSize", { label: "Particle size", step: .01, min: .1, max: .8 }).on("change", this.rebuildParticles), i.addInput(Fh.MainScene.components.shape.options.k2, "randomSpread", { label: "Particles random spread", step: .001, min: .001, max: .3 }).on("change", this.rebuildParticles), i.addInput(Fh.MainScene.components.shape.uniforms.particles.k2.uDisplace, "value", { label: "uDisplace", step: .01, min: 0, max: .5 }), i.addInput(Fh.MainScene.components.shape.uniforms.particles.k2.uMouseSize, "value", { label: "uMouseSize", step: .01, min: .5, max: 5 }), i.addInput(Fh.MainScene.components.shape.uniforms.particles.k2.uMouseStrength, "value", { label: "uMouseStrength", step: .01, min: .5, max: 5 }), i.addInput(Fh.MainScene.components.shape.uniforms.lines.k2.linewidth, "value", { label: "Line width", step: .001, min: .001, max: .06 }).on("change", (t => { Fh.MainScene.components.shape.children[2].children[0].material.linewidth = t.value })) } addReflectiveFloors() { const t = this.addFolder({ title: "reflective floors", expanded: !1 }); for (const e in Fh.MainScene.components.reflectiveFloors.floors) { const n = Fh.MainScene.components.reflectiveFloors.floors[e], i = t.addFolder({ title: e, expanded: !1 }); i.addInput(n.material.uniforms.uBaseLod, "value", { label: "blur strength", min: 0, max: 5, step: .001 }), i.addInput(n.material.uniforms.uDistortionAmount, "value", { label: "distortion", min: 0, max: .5, step: 1e-4 }), i.addInput(n.material.uniforms.uReflectionOpacity, "value", { label: "reflection opacity", min: 0, max: 1, step: .001 }), i.addInput(n.material.uniforms.uReflectionLighten, "value", { label: "reflection blend intensity", min: 0, max: 1, step: .001 }), i.addInput(n.material.uniforms.uRoughnessScale, "value", { label: "roughness tex scale", min: .01, max: 100, step: .01 }), this.addImage(i, n.material.uniforms.uRoughnessTexture, "value", "roughness texture", { wrapping: at }), this.addImage(i, n.material.uniforms.uNormalTexture, "value", "normal texture", { wrapping: at }), i.addInput(n.material.uniforms.uConcreteScale, "value", { label: "concrete tex scale", min: .01, max: 100, step: .01 }) } } addTowers() { const t = this.addFolder({ title: "backgroud towers", expanded: !1 }), e = t.addFolder({ title: "Balconies", expanded: !0 }); e.addInput(Fh.MainScene.components.towers.globalUniforms.uBalconiesBlendMode, "value", { options: { blendSoftLight: 0, blendLinearLight: 1 }, label: "uBalconiesBlendMode" }), this.addColor(e, Fh.MainScene.components.towers.globalUniforms.uBalconyBaseColorTop, "value", "uBalconyBaseColorTop", !0), this.addColor(e, Fh.MainScene.components.towers.globalUniforms.uBalconyBaseColorBottom, "value", "uBalconyBaseColorBottom", !0), e.addInput(Fh.MainScene.components.towers.globalUniforms.uBalconiesBlendAlpha, "value", { label: "uBalconiesBlendAlpha", min: 0, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uAnimate, "value", { label: "uAnimate" }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uAnimateUpFlag, "value", { label: "uAnimateUp" }).on("change", (t => { t.value ? Fh.MainScene.components.towers.globalUniforms.uAnimateUp.value = 1 : Fh.MainScene.components.towers.globalUniforms.uAnimateUp.value = -1 })), t.addInput(Fh.MainScene.components.towers.globalUniforms.uFragNoiseSpeed, "value", { label: "uFragNoiseSpeed", min: 0, max: 10, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uFragNoiseStrength, "value", { label: "uFragNoiseStrength", min: 0, max: .5, step: 1e-4 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uFragNoiseScale, "value", { label: "uFragNoiseScale", min: 0, max: 50, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uGroundFloorBegin, "value", { label: "uGroundFloorBegin", min: -50, max: 0, step: .1 }), this.addColor(t, Fh.MainScene.components.towers.globalUniforms.uFlameTopColor, "value", "uFlameTopColor", !0), this.addColor(t, Fh.MainScene.components.towers.globalUniforms.uFlameBottomColor, "value", "uFlameBottomColor", !0), t.addInput(Fh.MainScene.components.towers.globalUniforms.uFlameBandWidth, "value", { label: "uFlameBandWidth", min: .01, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uOverallGradientSpread, "value", { label: "uOverallGradientSpread", min: .01, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uEdgeTextureSubtractStrength, "value", { label: "uEdgeTextureSubtractStrength", min: .01, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uFlameColorGradientSpread, "value", { label: "uFlameColorGradientSpread", min: .01, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uFlameColorChangeOffset, "value", { label: "uFlameColorChangeOffset", min: -1, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uFlameStrength, "value", { label: "uFlameStrength", min: 0, max: 5, step: .001 }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uHexTexScale, "value", { label: "uHexTextScale" }), t.addInput(Fh.MainScene.components.towers.globalUniforms.uRecTexScale, "value", { label: "uRecTexScale" }), t.addInput(Fh.MainScene.components.cityPipes.globalUniforms.linewidth, "value", { label: "uPipesLineWidth", min: 0, max: .3, step: 1e-4 }) } addBridges() { const t = this.addFolder({ title: "bridges", expanded: !1 }); this.addColor(t, Fh.MainScene.components.bridges.globalUniforms.uColor1, "value", "uColor1", !0), this.addColor(t, Fh.MainScene.components.bridges.globalUniforms.uColor2, "value", "uColor2", !0), t.addInput(Fh.MainScene.components.bridges.globalUniforms.uTextureNum, "value", { options: { recursive2: 2, recursive3: 3 }, label: "uTextureNum" }).on("change", (t => { Fh.MainScene.components.bridges.meshes.bridges.material.uniforms.uTextureRecursive.value = Fh.MainScene.assets.textures[`recursiveMask${t.value}`] })), t.addInput(Fh.MainScene.components.bridges.meshes.bridges.material.uniforms.uUvScale, "value", { label: "uUvScale" }), t.addInput(Fh.MainScene.components.bridges.meshes.bridges.material.uniforms.uBakeBlend, "value", { label: "uBakeBlend", min: 0, max: 1, step: 1e-4 }), t.addInput(Fh.MainScene.components.bridges.meshes.bridges.material.uniforms.uBlendAlpha, "value", { label: "uBlendAlpha", min: 0, max: 1, step: 1e-4 }), t.addInput(Fh.MainScene.components.bridges.meshes.bridges.material.uniforms.uAlphaMin, "value", { label: "uAlphaMin", min: 0, max: 1, step: 1e-4 }), t.addInput(Fh.MainScene.components.bridges.meshes.bridges.material.uniforms.uAlphaMax, "value", { label: "uAlphaMax", min: 0, max: 1, step: 1e-4 }) } addSignsPipes() { const t = this.addFolder({ title: "signs and pipes", expanded: !1 }); this.addColor(t, Fh.MainScene.options.signs.uColor1, "value", "signs uColor1", !0), this.addColor(t, Fh.MainScene.options.signs.uColor2, "value", "signs uColor2", !0), t.addInput(Fh.MainScene.components.signs.globalUniforms.uBlendSpeed, "value", { label: "signs uBlendSpeed", min: -5, max: 5, step: .001 }), t.addInput(Fh.MainScene.components.signs.globalUniforms.uBlendFrequency, "value", { label: "signs uBlendFrequency", min: 0, max: 10, step: .001 }), this.addColor(t, Fh.MainScene.options.pipes.uColor1, "value", "pipes uColor1", !0), this.addColor(t, Fh.MainScene.options.pipes.uColor2, "value", "pipes uColor2", !0) } addCars() { const t = this.addFolder({ title: "cars", expanded: !1 }); this.addColor(t, Fh.MainScene.components.cars.carOptions.shared.trailColorBegin, "value", "car begin trail color", !0), this.addColor(t, Fh.MainScene.components.cars.carOptions.shared.trailColorEnd, "value", "car end trail color", !0), t.addInput(Fh.MainScene.components.cars.carOptions.shared.uColorOffset, "value", { label: "uColorOffset", min: 0, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.cars.carOptions.shared.uColorFallOff, "value", { label: "uColorFallOff", min: 0, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.cars.carOptions.shared.uTrailLength, "value", { label: "uTrailLength", min: 0, max: 1, step: .001 }), t.addInput(Fh.MainScene.components.cars.carOptions.shared.uTrailFallOffEnd, "value", { label: "uTrailFallOffEnd", min: 0, max: 5, step: .001 }) } addTextures() { const t = this.addFolder({ title: "textures", expanded: !1 }); this.addImage(t, Fh.MainScene.assets.textures, "hexTexture", "reveal hex texture", { wrapping: at, encoding: be }, (t => { for (const e in Fh.MainScene.components.mainTower.meshes.walls) Fh.MainScene.components.mainTower.meshes.walls[e].material.uniforms.tHexText.value = t, Fh.MainScene.components.mainTower.meshes.walls[e].material.uniforms.tHexText.value.needsUpdate = !0; for (const e in Fh.MainScene.components.mainTower.meshes.floors) Fh.MainScene.components.mainTower.meshes.floors[e].material.uniforms.tHexText.value = t, Fh.MainScene.components.mainTower.meshes.floors[e].material.uniforms.tHexText.value.needsUpdate = !0; for (const e in Fh.MainScene.components.towers.meshes) Fh.MainScene.components.towers.meshes[e].material.uniforms.tHexText.value = t, Fh.MainScene.components.towers.meshes[e].material.uniforms.tHexText.value.needsUpdate = !0; Fh.MainScene.components.people.meshes.forEach((e => { e.material.uniforms.tHexText.value = t, e.material.uniforms.tHexText.value.needsUpdate = !0 })) })), this.addImage(t, Fh.MainScene.components.logo.assets.textures, "hex", "logo hex texture", { wrapping: at }, (t => { Fh.MainScene.components.logo.material.uniforms.uDiffuse.value = t, Fh.MainScene.components.logo.material.uniforms.uDiffuse.value.needsUpdate = !0 })) } addPaths() { Fh.MainScene.debugPaths = {}; const t = [16711680, 65280, 255, 65535, 16711935, 16776960, 15790320, 986895]; let e = 0; for (const n in Fh.MainScene.paths) if (Fh.MainScene.paths[n] instanceof sl) { const i = Fh.MainScene.paths[n].getPoints(500); Fh.MainScene.debugPaths[n] = new Ua((new qi).setFromPoints(i), new La({ color: t[e % t.length] })), Fh.MainScene.debugPaths[n].visible = !1, Fh.MainScene.add(Fh.MainScene.debugPaths[n]), e++ } else for (const i in Fh.MainScene.paths[n]) { const r = Fh.MainScene.paths[n][i].getPoints(500); Fh.MainScene.debugPaths[i] = new Ua((new qi).setFromPoints(r), new La({ color: t[e % t.length] })), Fh.MainScene.debugPaths[i].visible = !1, Fh.MainScene.add(Fh.MainScene.debugPaths[i]), e++ } const n = this.addFolder({ title: "paths", expanded: !1 }); n.addButton({ title: "Toggle All Paths" }).on("click", (() => { for (const t in Fh.MainScene.debugPaths) Fh.MainScene.debugPaths[t].visible = !Fh.MainScene.debugPaths[t].visible; n.children.forEach((t => { t.refresh && t.refresh() })) })); for (const t in Fh.MainScene.debugPaths) { const e = Fh.MainScene.debugPaths[t]; n.addInput(e, "visible", { label: t }) } } refresh() { let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.options.syncGuiValues && (this.fireChange = t, super.refresh(), this.fireChange = !0) } addColor(t, e, n, i, r) { let s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : []; return r ? this.setupColorUniform(e) : e.guiValue = "#" + e[`${n}`].getHexString(), t.addInput(e, "guiValue", { label: i, picker: "inline" }).on("change", (() => { if (this.fireChange && (e[n].set(e.guiValue), s && s.length > 0)) for (const t of s) t[n].set(e.guiValue) })) } setupColorUniform(t) { t.guiValue = "#" + t.value.getHexString() } addImage(t, e, n, i) { } addFps() { this.fps = this.addBlade({ view: "fpsgraph" }), mg.ticker.fps(999); const t = document.createElement("div"); t.classList.add("force-unlocked-fps"), this.containerElem_.appendChild(t); const e = document.createElement("style"); e.innerHTML = "\n\t\t.force-unlocked-fps {\n\t\t\tanimation-name: forceUnlockedFps;\n\t\t\tanimation-duration: 4s;\n\t\t\tanimation-iteration-count: infinite;\n\t\t}\n\n\t\t@keyframes forceUnlockedFps {\n\t\t\tfrom { transform: translateX(-1%) }\n\t\t\tto { transform: translateX(0%) }\n\t\t}\n\t\t", this.containerElem_.appendChild(e) } } class ix extends Lg { initialLoad() { this.onEnter(), this.isFirstLoad = !0, Fh.AssetLoader.loaded.then((() => { Fh.urlParams.has("nowebgl") || (Fh.WebGL.build(), Fh.MainScene.build(), Fh.urlParams.has("gui") && (Fh.Gui = new nx)), this.onEnterCompleted() })), this.isFirstLoad && ec.on("Loader:Complete", this.introSequence) } onEnter() { this.isFirstLoad || ec.on("End-transition", this.introSequence), Fh.body.classList.contains("home") ? (Sh(".scroll-container").classList.remove("bg-black"), Sh(".js-hero", Fh.body).style.display = "block") : (Sh(".scroll-container").classList.add("bg-black"), Sh(".js-hero", Fh.body).style.display = "none"), Fh.ScrollAnimations.build(this.content), Fh.AssetLoader.load({ element: this.content }).then((() => { Fh.urlParams.has("noui") || Fh.components.add(zg, Mv, vv, xv, Ny) })) } onEnterCompleted() { Fh.ScrollAnimations.enable(), this.isFirstLoad = !1 } onLeave() { Sh(".js-navigation").classList.add("hide"), Sh(".js-toggle-menu").classList.add("closed"), Fh.ScrollAnimations.destroy(), ec.off("Loader:Complete", this.introSequence), ec.off("End-transition", this.introSequence) } onLeaveCompleted() { Fh.Header.reset(), Fh.Lenis.scrollTo(0, { immediate: !0 }), Fh.Lenis.stop(); for (const t of Fh.components) t.destroy() } introSequence() { Fh.Header.animateIn().then((() => { Fh.Lenis.start() })) } } class rx extends Bg { onLeave(t) { let { from: e, trigger: n, done: i } = t; this.from = e.dataset.taxiView, ec.emit("Launch-transition"), setTimeout((() => { i() }), 1500) } onEnter(t) { let { to: e, trigger: n, done: i } = t; this.to = e.dataset.taxiView, Fh.restoreBlogScroll = "post" === this.from && "blog" === this.to, Fh.AssetLoader.loaded.then((() => { Fh.body.classList.contains("home") && window.location.hash || ec.emit("End-transition"), i() })) } } function sx(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class ox extends ix { constructor() { super(...arguments), sx(this, "blogIntroSequence", (() => { const t = Mh(".js-almond-from > *", Fh.body), e = []; t.forEach((t => { xy.isInViewport(t) && e.push(t) })); const n = mg.timeline({ defaults: { duration: .6, ease: "customOut" } }).call((() => { this.textScrambleTl.play() }), null, 0); if (!Fh.restoreBlogScroll || Fh.blogArchiveScrollPos < 10) for (let t = 0; t < e.length; t++)n.flicker(e[t], .05 * t).from(e[t], { yPercent: 50 }, .05 * t); return n })) } initialLoad() { super.initialLoad(), this.isFirstLoad && ec.on("Loader:Complete", this.blogIntroSequence) } onEnter() { super.onEnter(), this.isFirstLoad || ec.on("End-transition", this.blogIntroSequence); const t = Sh(".js-blog-title", Fh.body), e = new pv(t, { type: "words" }); this.textScrambleTl = mg.timeline({ paused: !0 }).scramble(t, { words: e.words }) } onEnterCompleted() { super.onEnterCompleted(), Fh.restoreBlogScroll && Fh.blogArchiveScrollPos && (Fh.Lenis.start(), Fh.Lenis.scrollTo(Fh.blogArchiveScrollPos, { immediate: !0 })) } onLeave() { super.onLeave(), ec.off("Loader:Complete", this.blogIntroSequence), ec.off("End-transition", this.blogIntroSequence) } } function ax(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } const lx = "#e20101"; class hx extends Ng { constructor(t) { super(t), ax(this, "updateFloorProgress", (t => { this.currentFloor = parseInt(t), mg.to(this.floors, { fillOpacity: t => t === this.currentFloor ? .4 : 0, opacity: t => { const e = Math.abs(this.currentFloor - t); return 0 === e ? 1 : 1 - (.5 + .1 * e) }, stroke: t => t === this.currentFloor ? lx : "#fff" }) })), this.currentFloor = 0, Fh.mq.xsm.matches && !Fh.mq.sm.matches ? this.dom = { hero: Sh(".js-hero"), section0: Sh(".js-section-0"), heroInner: Sh(".js-hero-inner"), sections: Mh(".js-section"), ctaSection: Sh(".js-cta-section"), resources: Sh(".js-resources"), floorProgress: Sh(".js-floor-progress"), loaderText: Sh(".js-loader-text"), loaderGlobe: Sh(".js-loader-globe"), loaderPersisting: Sh(".loader__persisting-elements") } : this.dom = { hero: Sh(".js-hero"), section0: Sh(".js-section-0"), heroInner: Sh(".js-hero-inner"), loaderText: Sh(".js-loader-text"), loaderGlobe: Sh(".js-loader-globe"), loaderPersisting: Sh(".loader__persisting-elements"), sections: Mh(".js-section"), ctaSection: Sh(".js-cta-section"), resources: Sh(".js-resources"), floorProgress: Sh(".js-floor-progress") }, this.buildFloorProgress(), this.buildHeroST(), this.buildWebGLToggleST(), this.buildEnter(), this.on("HomeTitle:AnimateBack", this.animateTitleBack), this.on("HomeTitle:AnimateOut", this.animateTitleOut) } buildFloorProgress() { this.floors = Mh(".js-floor-el"), this.floors.sort(((t, e) => t.dataset.level - e.dataset.level)), mg.to(this.floors, { fill: lx }), this.updateFloorProgress(this.currentFloor) } buildHeroST() { const t = this.dom.section0.dataset.floorProgress; this.tl = mg.timeline({ scrollTrigger: { trigger: this.dom.section0, start: "bottom 99%", end: "bottom 98%", onEnter: () => { this.emit("Logo:hide"), this.emit("HomeTitle:AnimateOut"), this.enterTl.restart(); return mg.timeline().set([this.dom.hero, this.dom.loaderPersisting], { opacity: 0, delay: .04 }, .2).set([this.dom.hero, this.dom.loaderPersisting], { opacity: 1, delay: .04 }).set([this.dom.hero, this.dom.loaderPersisting], { opacity: 0, delay: .04 }) }, onEnterBack: () => { this.emit("Logo:show"), this.emit("HomeTitle:AnimateBack"), this.enterTl.reverse(), this.updateFloorProgress(t); return mg.timeline().set([this.dom.hero, this.dom.loaderPersisting], { opacity: 1, delay: .04 }, .2).set([this.dom.hero, this.dom.loaderPersisting], { opacity: 0, delay: .04 }).set([this.dom.hero, this.dom.loaderPersisting], { opacity: 1, delay: .04 }) }, onLeave: () => { if (this.enterTl.reversed()) { this.enterTl.restart(), this.emit("HomeTitle:AnimateOut"); return mg.timeline().set([this.dom.hero, this.dom.loaderPersisting], { opacity: 0, delay: .04 }, .2).set([this.dom.hero, this.dom.loaderPersisting], { opacity: 1, delay: .04 }).set([this.dom.hero, this.dom.loaderPersisting], { opacity: 0, delay: .04 }) } } } }) } animateTitleOut() { return mg.timeline().fromTo(Fh.HomeTitle.leftSlices, { xPercent: 0 }, { xPercent: 100, stagger: .02, ease: "expo.inOut", duration: .6, overwrite: !1 }, 0).fromTo(Fh.HomeTitle.rightSlices, { xPercent: 0 }, { xPercent: -100, stagger: .02, ease: "expo.inOut", duration: .6, overwrite: !1 }, 0) } animateTitleBack() { return mg.timeline().fromTo(Fh.HomeTitle.leftSlices, { xPercent: 100 }, { xPercent: 0, stagger: -.02, ease: "expo.inOut", duration: .6, overwrite: !1 }, 0).fromTo(Fh.HomeTitle.rightSlices, { xPercent: -100 }, { xPercent: 0, stagger: -.02, ease: "expo.inOut", duration: .6, overwrite: !1 }, 0) } buildEnter() { this.heroLines = Mh(".js-hero-line", Fh.body), this.heroLinesInner = Mh(".js-hero-line div", Fh.body), this.heroText = Mh(".js-hero-text", Fh.body), this.heroSubtitle = Mh(".js-hero-subtitle", Fh.body), this.enterTl = mg.timeline({ defaults: { ease: "expo.inOut" } }).fromTo([this.heroLines[0], this.heroLinesInner[1]], { xPercent: 0 }, { xPercent: 100 }, 0).fromTo([this.heroLinesInner[0], this.heroLines[1]], { xPercent: 0 }, { xPercent: -100 }, 0).fromTo(this.heroText[0], { x: 0 }, { x: "35vw" }, 0).fromTo(this.heroText[1], { x: 0 }, { x: "-35vw" }, 0) } buildWebGLToggleST() { this.webGLToggleST = xy.create({ trigger: this.dom.resources, start: "top top", end: "top top+=1px", onEnter: () => { Fh.MainScene.disable() }, onEnterBack: () => { Fh.MainScene.enable() } }) } destroy() { var t, e; super.destroy(), null === (t = this.tl) || void 0 === t || t.kill(), null === (e = this.webGLToggleST) || void 0 === e || e.kill() } } function cx(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } ax(hx, "selector", ".js-home"); class ux extends Ng { constructor(t) { super(t), cx(this, "setCountHeight", (() => { this.dom.count.style.height = this.dom.currentNumber.offsetHeight / 2 + "px" })), cx(this, "showLabels", (() => { var t; this.enableLabels && (this.arePointsDisplayed = !0, null === (t = this.labelsTl) || void 0 === t || t.kill(), this.labelsTl = mg.timeline().call((() => { this.labels.forEach((t => t.classList.remove("d-none"))) })).set(this.labels, { autoAlpha: 1 }).set(this.labels, { autoAlpha: 0, delay: .03 }).set(this.labels, { autoAlpha: 1, delay: .03 })) })), cx(this, "hideLabels", (() => { var t; this.enableLabels && (this.arePointsDisplayed = !1, null === (t = this.labelsTl) || void 0 === t || t.kill(), this.labelsTl = mg.timeline().set(this.labels, { autoAlpha: 0 }).set(this.labels, { autoAlpha: 1, delay: .03 }).set(this.labels, { autoAlpha: 0, delay: .03 }).call((() => { this.labels.forEach((t => t.classList.add("d-none"))) }))) })), cx(this, "onSectionEnter", (() => { var t; this.isSectionActive = !0, this.home.updateFloorProgress(this.el.dataset.floorProgress), null === (t = this.leaveTl) || void 0 === t || t.pause(), this.tl.play(), this.showLabels() })), cx(this, "onSectionLeave", (() => { this.hideLabels(), this.tl.pause(), this.isSectionActive = !1; const t = [...this.titleSplit.words].reverse(); this.leaveTl = mg.timeline({ defaults: { ease: "power2.in" }, onComplete: () => { var t; null === (t = this.tl) || void 0 === t || t.kill(), this.buildTl(), this.dom.subtitle.innerText = this.dom.subtitle.original } }).to(t[t.length - 1], { x: 20, duration: .3 }).to(t, { opacity: 0, duration: 0, stagger: { amount: .3 } }, 0).scramble(this.dom.subtitle, { replacingText: "&", duration: .3 }, 0).set(this.dom.subtitle, { opacity: 0 }).to(this.dom.count, { x: "25%", duration: .2 }, 0).set([this.dom.subtitleText, this.dom.description, this.dom.countText, this.dom.count], { opacity: 0 }, .2).set(this.el, { autoAlpha: 0 }) })), cx(this, "onSectionLeaveBack", (() => { this.onSectionLeave() })), cx(this, "onResize", (() => { this.setCountHeight(), this.createSplitText(), this.enableLabels = !Fh.isTouch && Fh.mq.md.matches, this.enableLabels && this.isSectionActive ? (this.labels.forEach((t => t.classList.remove("d-none"))), mg.set(this.labels, { opacity: 1 })) : (mg.set(this.labels, { opacity: 0 }), this.labels.forEach((t => t.classList.add("d-none")))) })), this.populateDom(), this.labels = Fh.labels[this.el.dataset.index], this.labels.forEach((t => t.classList.add("d-none"))), this.enableLabels = !Fh.isTouch && Fh.mq.md.matches, this.isSectionActive = !1, this.arePointsDisplayed = !1, this.setCountHeight(), this.on(ic.RESIZE, this.onResize), this.home = Fh.components.get(hx).first(), this.isFeaturesSection = "/#features" === _v(t, "data-section-url"), this.createSplitText(), this.on("HomeRenderer:onLeaveCompleted", (() => { this.labels.forEach((t => t.classList.add("d-none"))) })), window.setTimeout((() => { mg.set(this.el, { autoAlpha: 1 }), this.buildTl(), this.buildScrollTrigger(), mg.set([this.el, this.labels], { autoAlpha: 0 }), mg.set(this.dom.count, { opacity: 0 }) }), 200) } createSplitText() { var t, e; window.clearTimeout(this.splitTextTimeout), null === (t = this.titleSplit) || void 0 === t || t.revert(), null === (e = this.descriptionSplit) || void 0 === e || e.revert(), this.splitTextTimeout = window.setTimeout((() => { this.titleSplit = new pv(this.dom.title, { type: "words" }), this.descriptionSplit = new pv(this.dom.description, { type: "lines" }) }), 200) } buildTl() { const t = .7; this.tl = mg.timeline({ paused: !0, defaults: { ease: "power2.out" } }).set(this.el, { autoAlpha: 1 }).set(this.dom.count, { opacity: 1 }, 0).title(this.titleSplit.words, { duration: t }, 0).flicker(this.dom.subtitleText, 0).set(this.dom.subtitle, { opacity: 1 }, 0).scramble(this.dom.subtitle, { duration: t, revealDelay: .2 }, 0).fromTo(this.dom.subtitle, { x: 50 }, { x: 0, duration: 1 }, 0).swipeLines({ el: this.dom.description, lines: this.descriptionSplit.lines }, null, 0).flicker(this.dom.countText, 0).addLabel("count", 0).fromTo(this.dom.count, { x: "25%" }, { x: "0%", duration: .6, ease: "power2.inOut" }, "count").fromTo(this.dom.currentNumber, { yPercent: 0 }, { duration: .6, yPercent: -50 }, "count").fromTo(this.dom.totalNumber, { yPercent: 0 }, { duration: .6, yPercent: -75 }, "count") } buildScrollTrigger() { this.st = xy.create({ trigger: this.el, start: "top top", end: "top+=100% top", onEnter: this.onSectionEnter, onEnterBack: this.onSectionEnter, onLeave: this.onSectionLeave, onLeaveBack: this.onSectionLeaveBack }) } destroy() { var t, e; super.destroy(), null === (t = this.tl) || void 0 === t || t.kill(), null === (e = this.st) || void 0 === e || e.kill() } } cx(ux, "selector", ".js-section"); class dx extends Ng { constructor(t) { super(t), this.populateDom(), this.home = Fh.components.get(hx).first(), this.buildScrollTrigger() } buildScrollTrigger() { const t = this.el.dataset.floorProgress; this.st = xy.create({ trigger: this.el, start: "0% 50%", end: "100% 50%", onEnter: () => { this.home.updateFloorProgress(t) }, onEnterBack: () => { this.home.updateFloorProgress(t) } }), this.parallaxTween = mg.to(this.dom.inner, { y: Fh.window.h, ease: "linear", scrollTrigger: { trigger: this.el, start: "top top", end: "bottom top", scrub: !0 } }) } destroy() { var t, e; super.destroy(), null === (t = this.st) || void 0 === t || t.kill(), null === (e = this.parallaxTween) || void 0 === e || e.kill() } } var px, fx, mx; px = dx, mx = ".js-cta-section", (fx = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(fx = "selector")) in px ? Object.defineProperty(px, fx, { value: mx, enumerable: !0, configurable: !0, writable: !0 }) : px[fx] = mx; class gx extends Ng { constructor(t) { super(t), this.originalText = t.innerText, this.config = { numOfSplits: 8, cssClass: "sliced-text" }, this.maskLeft = document.createElement("div"), this.maskLeft.classList.add(`${this.config.cssClass}__mask`, `${this.config.cssClass}__mask--left`), this.maskRight = document.createElement("div"), this.maskRight.classList.add(`${this.config.cssClass}__mask`, `${this.config.cssClass}__mask--right`), this.el.append(this.maskLeft), this.el.append(this.maskRight), this.leftSlices = [], this.rightSlices = []; for (let t = 0; t < this.config.numOfSplits; t++)this.createSplit(t); this.positions = [-1, -10, -16, -22], this.setInitialPositions() } createSplit(t) { const e = document.createElement("div"); e.classList.add(`${this.config.cssClass}__slice-mask`); const n = document.createElement("div"); n.innerText = this.originalText, e.append(n), t < 4 ? (this.maskLeft.append(e), this.leftSlices.push(e)) : (this.maskRight.append(e), this.rightSlices.push(e)) } setInitialPositions() { return mg.timeline().set(this.leftSlices, { xPercent: 50 }).set(this.rightSlices, { xPercent: -50 }) } buildSequence() { this.inTl = mg.timeline({ defaults: { ease: "customOut", duration: .8 }, paused: !0, immediateRender: !0 }).fromTo(this.leftSlices, { xPercent: 100 }, { xPercent: 0, stagger: .02 }, 0).fromTo(this.rightSlices, { xPercent: -100 }, { xPercent: 0, stagger: .02 }, 0) } } function vx(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } !function (t, e, n) { (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n }(gx, "selector", ".js-sliced-text"); class Ax extends Ng { constructor(t) { super(t), vx(this, "animate", (t => { if (this.isResizing) return; const e = this.isMobile ? Math.min(Fh.Lenis.scroll - this.activeScroll, 50) : Math.min(.1 * (Fh.Lenis.scroll - Fh.Lenis.targetScroll), 50); this.time++, this.dom.listArray.forEach(((t, n) => { 0 === n ? t.items.forEach(((n, i) => { n.transform = n.transform + Math.min(.001 * Fh.window.w, .5) + Math.abs(.1 * e); n.pos.x + n.pos.width + n.transform > t.pos.width && (n.transform = n.transform - t.pos.width), n.style.transform = `translate3D(${n.transform}px, 0, 0)`, Math.abs(n.transform - n.center + .3 * Fh.window.w) < .1 * Fh.window.w && i !== this.center[0] && (this.center[0] = i, this.titleSwitch()) })) : t.items.forEach(((n, i) => { n.transform = n.transform - Math.min(.001 * Fh.window.w, .5) - Math.abs(.1 * e); n.pos.x + n.pos.width + n.transform < 0 && (n.transform = n.transform + t.pos.width), n.style.transform = `translate3D(${n.transform}px, 0, 0)`, Math.abs(n.transform - n.center - .3 * Fh.window.w) < .1 * Fh.window.w && i !== this.center[1] && i && (this.center[1] = i, this.titleSwitch()) })) })), this.activeScroll = Fh.Lenis.scroll })), vx(this, "resize", (() => { this.isResizing = !0, requestAnimationFrame((() => { this.dom.listArray.forEach((t => { t.pos = t.getBoundingClientRect(), t.progress = 0, t.items = Mh("li", t), t.items.forEach((t => { t.transform = 0, t.style.transform = `translate3D(${t.transform}px, 0, 0)`, t.pos = t.getBoundingClientRect(), t.center = -t.pos.x - .5 * t.pos.width + .5 * Fh.window.w })) })) })), this.isResizing = !1 })), this.populateDom(), this.time = 0, this.activeIndex = 0, this.activeScroll = 0, this.isMobile = Fh.mq.touch.matches, this.center = [0, 0], this.dom.listArray.forEach((t => { t.pos = t.getBoundingClientRect(), t.progress = 0, t.items = Mh("li", t), t.items.forEach((t => { t.transform = 0, t.pos = t.getBoundingClientRect(), t.center = -t.pos.x - .5 * t.pos.width + .5 * Fh.window.w })) })), this.on(ic.RAF, this.animate), this.on(ic.RESIZE, this.resize) } titleSwitch() { this.dom.listArray.forEach((t => { t.items.forEach((t => { t.classList.remove("active") })) })), this.activeIndex++, this.activePart = this.center[this.activeIndex % 2], this.dom.listArray[this.activeIndex % 2].items[this.activePart].classList.add("active"), this.dom.listArray[this.activeIndex % 2].items[this.activePart]._component.mouseEnter() } destroy() { super.destroy() } } vx(Ax, "selector", ".js-marquee"); class bx extends Ng { constructor(t) { super(t), this.populateDom(), this.dom.video.currentTime = 0, this.on("mouseenter", this.el, (() => { this.dom.video.play() })) } } function yx(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } !function (t, e, n) { (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n }(bx, "selector", ".js-dev-resources"); class xx extends Ng { constructor(t) { super(t), yx(this, "splitInChars", (() => { this.titleSplit = new pv(this.el, { type: "chars words" }), this.chars = this.titleSplit.chars, this.length = this.chars.length, mg.set(this.chars, { height: t => this.chars[t].offsetHeight, width: t => this.chars[t].offsetWidth, overflow: "hidden" }); for (let t = 0; t < this.chars.length; t++) { const e = this.chars[t]; e.original = e.innerText, e.innerText = "" } })), yx(this, "animate", (() => { const t = Math.ceil(this.progress.reveal), e = Math.ceil(this.progress.scramble); if (!this.animCompleted) { if (e > t && this.totalFrames % 2 == 0) { const n = e - t; for (let e = 0; e < n; e++)this.chars[t + e].innerText = this.specialChars[Math.floor(Math.random() * this.specialChars.length)] } for (let e = 0; e < t; e++)this.chars[e].innerText = this.chars[e].original; this.totalFrames++, t === this.length && (this.animCompleted = !0), window.requestAnimationFrame((() => this.animate())) } })), yx(this, "onResize", (() => { var t; null === (t = this.titleSplit) || void 0 === t || t.revert(), this.animCompleted || this.splitInChars() })), this.animCompleted = !1, this.totalFrames = 0, this.specialChars = '!@£$%&}{":;?><][+=-_QWEZXCVBNM'.split(""), this.progress = { scramble: 0, reveal: 0 }, this.splitInChars(), this.on(ic.RESIZE, this.onResize), this.titleTl = mg.timeline({ paused: !0, scrollTrigger: { trigger: this.el, start: "0% 70%", onEnter: () => !this.animCompleted && window.requestAnimationFrame(this.animate) } }), this.titleTl.to(this.progress, { reveal: this.length, duration: .7, ease: "power1.in" }, .1).to(this.progress, { scramble: this.length, duration: .8, ease: "linear" }, 0) } destroy() { var t; super.destroy(), null === (t = this.titleTl) || void 0 === t || t.kill() } } function _x(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } yx(xx, "selector", ".js-glitch"); class wx extends ix { constructor() { super(...arguments), _x(this, "homeIntroSequence", (() => { !Fh.urlParams.has("nowebgl") && this.urlHasHash && (Fh.MainScene.options.cameraYTranslate = 0, Fh.MainScene.options.cameraZTranslate = 0), Fh.urlParams.has("noui") || this.urlHasHash || (Fh.urlParams.has("nowebgl") || Fh.MainScene.playIntro(), this.tl = mg.timeline({ immediateRender: !0, defaults: { ease: "customOut", duration: .45 } }).fromTo(Fh.HomeTitle.leftSlices, { xPercent: 100 }, { xPercent: 0, stagger: .02 }, 0).fromTo(Fh.HomeTitle.rightSlices, { xPercent: -100 }, { xPercent: 0, stagger: .02 }, 0).to([".js-hero", Fh.staticComponents.get(Ry).first().dom.persisting], { opacity: 1 }, 0).fromTo([this.heroLines[0], this.heroLinesInner[1]], { xPercent: 100 }, { xPercent: 0 }, 0).fromTo([this.heroLinesInner[0], this.heroLines[1]], { xPercent: -100 }, { xPercent: 0 }, 0).fromTo(this.heroText[0], { x: "35vw" }, { x: 0 }, 0).fromTo(this.heroText[1], { x: "-35vw" }, { x: 0 }, 0).fromTo([".js-home-title", ".js-hero-title-line"], { y: "8vh" }, { y: 0 }, 0).flicker(this.heroSubtitle, 0)) })) } initialLoad() { super.initialLoad(), this.isFirstLoad && ec.on("Loader:Complete", this.homeIntroSequence) } onEnter() { super.onEnter(), this.urlHasHash = !1, this.isFirstLoad || ec.on("End-transition", this.homeIntroSequence), "" !== window.location.hash && (this.urlHasHash = !0); const t = Sh(".js-home-title", Fh.body); Fh.HomeTitle || (Fh.HomeTitle = new Dh(gx).make(t)), this.heroLines = Mh(".js-hero-line", Fh.body), this.heroLinesInner = Mh(".js-hero-line div", Fh.body), this.heroText = Mh(".js-hero-text", Fh.body), this.heroSubtitle = Mh(".js-hero-subtitle", Fh.body), this.floorProgress = Sh(".js-floor-progress", Fh.body), this.floorProgress.classList.remove("d-none"), Fh.MainScene.labelRendererEnabled = !0, Fh.WebGL.labelRenderer.domElement.classList.remove("d-none") } onEnterCompleted() { Fh.AssetLoader.loaded.then((() => { Fh.urlParams.has("noui") || Fh.components.add(hx, ux, dx, zg, Ax, bx, xx), Fh.urlParams.has("nowebgl") || (Fh.WebGL.initialise(), Fh.MainScene.initialise()), this.isFirstLoad || requestAnimationFrame((() => { Fh.components.get(Ny).first().scrollToOnLoad(), ec.emit("End-transition") })), super.onEnterCompleted(), ec.emit("CheckFPS") })) } onLeaveCompleted() { var t; super.onLeaveCompleted(), null === (t = this.tl) || void 0 === t || t.progress(1), ec.emit("HomeRenderer:onLeaveCompleted"), Fh.MainScene.labelRendererEnabled = !1, Fh.WebGL.labelRenderer.domElement.classList.add("d-none"), this.floorProgress.classList.add("d-none"), Fh.urlParams.has("nowebgl") || (Fh.WebGL.destroy(), Fh.MainScene.destroy()) } onLeave() { super.onLeave(), this.urlHasHash = !1, ec.off("End-transition", this.homeIntroSequence), ec.off("Loader:Complete", this.homeIntroSequence) } } function Ex(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Cx extends Ng { constructor(t) { super(t), Ex(this, "onResize", (() => { var t; null === (t = this.st) || void 0 === t || t.kill(), Fh.mq.md.matches && (this.startSpacing = window.getComputedStyle(this.dom.mainContainer).getPropertyValue("padding-top").replace("px", ""), this.endSpacing = Fh.headerHeight, this.createPin()) })), this.populateDom(), this.dom.assContainerEl = Sh("[asscroll]", Fh.body), this.dom.mainContainer = Sh(".js-sticky-main", Fh.body), this.onResize(), this.on(ic.RESIZE, this.onResize) } createPin() { this.st = xy.create({ trigger: this.el, endTrigger: ".js-main", pin: this.dom.pin, pinType: Fh.pinType, start: () => `top +=${this.startSpacing}px`, end: () => "bottom bottom" }) } destroy() { var t; super.destroy(), null === (t = this.st) || void 0 === t || t.kill() } } function Sx(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Ex(Cx, "selector", ".js-sticky"); class Mx extends ix { constructor() { super(...arguments), Sx(this, "titleAnimTotalDuration", 1), Sx(this, "postIntroSequence", (() => { const t = Mh(".js-post-content > *", Fh.body), e = []; t.forEach((t => { !t.classList.contains("js-post-image") && xy.isInViewport(t) && e.push(t) })); const n = mg.timeline().flicker(Sh(".js-post-btns", Fh.body), 0).flicker(Sh(".js-post-date-flicker", Fh.body), 0).call((() => { this.img && this.image.playAnimateIn(), this.dateScrambleTl.play(), this.titleScrambleTl.play() }), null, 0); return e.length > 0 && n.from(e, { y: 200, opacity: 0, stagger: .06, duration: .6, ease: "customOut" }, .2), n })), Sx(this, "createScrambleText", (() => { this.titleSplit = new pv(this.postTitle, { type: "words" }), this.dateScrambleTl = mg.timeline({ paused: !0 }).scramble(this.postDate, { duration: .6 }), this.titleScrambleTl = mg.timeline({ paused: !0 }).scramble(this.postTitle, { duration: 1, words: this.titleSplit.words, animationChars: "<>?=;!@@AZERTYUIOPQSDFGHJKLXCVBN", onComplete: () => { this.titleSplit.revert() } }) })), Sx(this, "onResize", (() => { this.postTitle.style.height = "auto" })) } initialLoad() { super.initialLoad(), this.isFirstLoad && ec.on("Loader:Complete", this.postIntroSequence) } onEnter() { super.onEnter(), this.isFirstLoad || ec.on("End-transition", this.postIntroSequence), Fh.AssetLoader.loaded.then((() => { this.img = Sh(".js-post-image", Fh.body), this.img && (this.image = new Dh(Qg).make(this.img)) })), this.postDate = Sh(".js-post-date", Fh.body), this.postTitle = Sh(".js-post-title", Fh.body); const t = Mh(".js-button", Sh(".js-post-content", Fh.body)); t.length > 0 && mg.set(t, { className: e => `${t[e].className} t-nowrap` }); const e = this.postTitle.clientHeight; this.postTitle.style.height = e + "px", this.postTitle.style.minheight = e + "px", this.createScrambleText(), ec.on(ic.RESIZE, this.onResize) } onEnterCompleted() { super.onEnterCompleted(), Fh.components.add(Cx) } onLeave() { super.onLeave(), ec.off(ic.RESIZE, this.onResize), ec.off("Loader:Complete", this.postIntroSequence), ec.off("End-transition", this.postIntroSequence) } } class Px extends Bg { onLeave(t) { let { from: e, trigger: n, done: i } = t; const r = Mh(".js-post-partial", Fh.body); Fh.blogArchiveScrollPos = Fh.Lenis.scroll; for (let t = 0; t < r.length; t++)r[t] === n.closest(".js-post-partial") && (this.clickedPost = Fh.components.get(vv).get(t), this.clickedPost.removeMouseLeave()); this.clickedPost.outSequenceCompleted.then((() => { ec.emit("Launch-transition"), setTimeout((() => { i() }), 1500) })) } onEnter(t) { let { to: e, trigger: n, done: i } = t; Fh.AssetLoader.loaded.then((() => { ec.emit("End-transition"), i() })) } } class Ix extends Rg { constructor() { super({ links: "a:not([target]):not([href^=\\#]):not([download]):not([data-router-disabled]):not(.sf-dump-toggle):not(.sf-dump-str-toggle):not(#wpadminbar a)", renderers: { default: ix, post: Mx, home: wx, blog: ox }, transitions: { default: rx, archiveToPost: Px } }), this.setDefaultRenderer("default"), this.setDefaultTransition("default"), this.on("NAVIGATE_IN", this.onNavigateIn), this.on("NAVIGATE_END", this.onNavigateEnd) } onNavigateIn(t) { let { to: e } = t; e && (document.body.className = e.page.body.className) } onNavigateEnd(t) { let { from: e, to: n } = t } } var Tx = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, Dx = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi, Bx = Math.PI / 180, Lx = (Math.PI, Math.sin), Fx = Math.cos, kx = Math.abs, Rx = Math.sqrt, Ox = (Math.atan2, function (t) { return "number" == typeof t }), Nx = 1e5, Ux = function (t) { return Math.round(t * Nx) / Nx || 0 }; function zx(t, e, n, i, r, s, o, a, l) { if (t !== a || e !== l) { n = kx(n), i = kx(i); var h = r % 360 * Bx, c = Fx(h), u = Lx(h), d = Math.PI, p = 2 * d, f = (t - a) / 2, m = (e - l) / 2, g = c * f + u * m, v = -u * f + c * m, A = g * g, b = v * v, y = A / (n * n) + b / (i * i); y > 1 && (n = Rx(y) * n, i = Rx(y) * i); var x = n * n, _ = i * i, w = (x * _ - x * b - _ * A) / (x * b + _ * A); w < 0 && (w = 0); var E = (s === o ? -1 : 1) * Rx(w), C = E * (n * v / i), S = E * (-i * g / n), M = (t + a) / 2 + (c * C - u * S), P = (e + l) / 2 + (u * C + c * S), I = (g - C) / n, T = (v - S) / i, D = (-g - C) / n, B = (-v - S) / i, L = I * I + T * T, F = (T < 0 ? -1 : 1) * Math.acos(I / Rx(L)), k = (I * B - T * D < 0 ? -1 : 1) * Math.acos((I * D + T * B) / Rx(L * (D * D + B * B))); isNaN(k) && (k = d), !o && k > 0 ? k -= p : o && k < 0 && (k += p), F %= p, k %= p; var R, O = Math.ceil(kx(k) / (p / 4)), N = [], U = k / O, z = 4 / 3 * Lx(U / 2) / (1 + Fx(U / 2)), V = c * n, Q = u * n, G = u * -i, H = c * i; for (R = 0; R < O; R++)g = Fx(r = F + R * U), v = Lx(r), I = Fx(r += U), T = Lx(r), N.push(g - z * v, v + z * g, I + z * T, T - z * I, I, T); for (R = 0; R < N.length; R += 2)g = N[R], v = N[R + 1], N[R] = g * V + v * G + M, N[R + 1] = g * Q + v * H + P; return N[R - 2] = a, N[R - 1] = l, N } } function Vx(t) { var e, n, i, r, s, o, a, l, h, c, u, d, p, f, m, g = (t + "").replace(Dx, (function (t) { var e = +t; return e < 1e-4 && e > -1e-4 ? 0 : e })).match(Tx) || [], v = [], A = 0, b = 0, y = 2 / 3, x = g.length, _ = 0, w = "ERROR: malformed path: " + t, E = function (t, e, n, i) { c = (n - t) / 3, u = (i - e) / 3, a.push(t + c, e + u, n - c, i - u, n, i) }; if (!t || !isNaN(g[0]) || isNaN(g[1])) return console.log(w), v; for (e = 0; e < x; e++)if (p = s, isNaN(g[e]) ? o = (s = g[e].toUpperCase()) !== g[e] : e--, i = +g[e + 1], r = +g[e + 2], o && (i += A, r += b), e || (l = i, h = r), "M" === s) a && (a.length < 8 ? v.length -= 1 : _ += a.length), A = l = i, b = h = r, a = [i, r], v.push(a), e += 2, s = "L"; else if ("C" === s) a || (a = [0, 0]), o || (A = b = 0), a.push(i, r, A + 1 * g[e + 3], b + 1 * g[e + 4], A += 1 * g[e + 5], b += 1 * g[e + 6]), e += 6; else if ("S" === s) c = A, u = b, "C" !== p && "S" !== p || (c += A - a[a.length - 4], u += b - a[a.length - 3]), o || (A = b = 0), a.push(c, u, i, r, A += 1 * g[e + 3], b += 1 * g[e + 4]), e += 4; else if ("Q" === s) c = A + (i - A) * y, u = b + (r - b) * y, o || (A = b = 0), A += 1 * g[e + 3], b += 1 * g[e + 4], a.push(c, u, A + (i - A) * y, b + (r - b) * y, A, b), e += 4; else if ("T" === s) c = A - a[a.length - 4], u = b - a[a.length - 3], a.push(A + c, b + u, i + (A + 1.5 * c - i) * y, r + (b + 1.5 * u - r) * y, A = i, b = r), e += 2; else if ("H" === s) E(A, b, A = i, b), e += 1; else if ("V" === s) E(A, b, A, b = i + (o ? b - A : 0)), e += 1; else if ("L" === s || "Z" === s) "Z" === s && (i = l, r = h, a.closed = !0), ("L" === s || kx(A - i) > .5 || kx(b - r) > .5) && (E(A, b, i, r), "L" === s && (e += 2)), A = i, b = r; else if ("A" === s) { if (f = g[e + 4], m = g[e + 5], c = g[e + 6], u = g[e + 7], n = 7, f.length > 1 && (f.length < 3 ? (u = c, c = m, n--) : (u = m, c = f.substr(2), n -= 2), m = f.charAt(1), f = f.charAt(0)), d = zx(A, b, +g[e + 1], +g[e + 2], +g[e + 3], +f, +m, (o ? A : 0) + 1 * c, (o ? b : 0) + 1 * u), e += n, d) for (n = 0; n < d.length; n++)a.push(d[n]); A = a[a.length - 2], b = a[a.length - 1] } else console.log(w); return (e = a.length) < 6 ? (v.pop(), e = 0) : a[0] === a[e - 2] && a[1] === a[e - 1] && (a.closed = !0), v.totalPoints = _ + e, v } function Qx(t) { Ox(t[0]) && (t = [t]); var e, n, i, r, s = "", o = t.length; for (n = 0; n < o; n++) { for (r = t[n], s += "M" + Ux(r[0]) + "," + Ux(r[1]) + " C", e = r.length, i = 2; i < e; i++)s += Ux(r[i++]) + "," + Ux(r[i++]) + " " + Ux(r[i++]) + "," + Ux(r[i++]) + " " + Ux(r[i++]) + "," + Ux(r[i]) + " "; r.closed && (s += "z") } return s } var Gx, Hx, jx = function () { return Gx || "undefined" != typeof window && (Gx = window.gsap) && Gx.registerPlugin && Gx }, Wx = function () { (Gx = jx()) ? (Gx.registerEase("_CE", Zx.create), Hx = 1) : console.warn("Please gsap.registerPlugin(CustomEase)") }, qx = function (t) { return ~~(1e3 * t + (t < 0 ? -.5 : .5)) / 1e3 }, Yx = 1, Xx = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, Kx = /[cLlsSaAhHvVtTqQ]/g, Jx = function t(e, n, i, r, s, o, a, l, h, c, u) { var d, p = (e + i) / 2, f = (n + r) / 2, m = (i + s) / 2, g = (r + o) / 2, v = (s + a) / 2, A = (o + l) / 2, b = (p + m) / 2, y = (f + g) / 2, x = (m + v) / 2, _ = (g + A) / 2, w = (b + x) / 2, E = (y + _) / 2, C = a - e, S = l - n, M = Math.abs((i - a) * S - (r - l) * C), P = Math.abs((s - a) * S - (o - l) * C); return c || (c = [{ x: e, y: n }, { x: a, y: l }], u = 1), c.splice(u || c.length - 1, 0, { x: w, y: E }), (M + P) * (M + P) > h * (C * C + S * S) && (d = c.length, t(e, n, p, f, b, y, w, E, h, c, u), t(w, E, x, _, v, A, a, l, h, c, u + 1 + (c.length - d))), c }, Zx = function () { function t(t, e, n) { Hx || Wx(), this.id = t, Yx && this.setData(e, n) } var e = t.prototype; return e.setData = function (t, e) { e = e || {}; var n, i, r, s, o, a, l, h, c, u = (t = t || "0,0,1,1").match(Xx), d = 1, p = [], f = [], m = e.precision || 1, g = m <= 1; if (this.data = t, (Kx.test(t) || ~t.indexOf("M") && t.indexOf("C") < 0) && (u = Vx(t)[0]), 4 === (n = u.length)) u.unshift(0, 0), u.push(1, 1), n = 8; else if ((n - 2) % 6) throw "Invalid CustomEase"; for (0 == +u[0] && 1 == +u[n - 2] || function (t, e, n) { n || 0 === n || (n = Math.max(+t[t.length - 1], +t[1])); var i, r = -1 * +t[0], s = -n, o = t.length, a = 1 / (+t[o - 2] + r), l = -e || (Math.abs(+t[o - 1] - +t[1]) < .01 * (+t[o - 2] - +t[0]) ? function (t) { var e, n = t.length, i = 1e20; for (e = 1; e < n; e += 6)+t[e] < i && (i = +t[e]); return i }(t) + s : +t[o - 1] + s); for (l = l ? 1 / l : -a, i = 0; i < o; i += 2)t[i] = (+t[i] + r) * a, t[i + 1] = (+t[i + 1] + s) * l }(u, e.height, e.originY), this.segment = u, s = 2; s < n; s += 6)i = { x: +u[s - 2], y: +u[s - 1] }, r = { x: +u[s + 4], y: +u[s + 5] }, p.push(i, r), Jx(i.x, i.y, +u[s], +u[s + 1], +u[s + 2], +u[s + 3], r.x, r.y, 1 / (2e5 * m), p, p.length - 1); for (n = p.length, s = 0; s < n; s++)l = p[s], h = p[s - 1] || l, (l.x > h.x || h.y !== l.y && h.x === l.x || l === h) && l.x <= 1 ? (h.cx = l.x - h.x, h.cy = l.y - h.y, h.n = l, h.nx = l.x, g && s > 1 && Math.abs(h.cy / h.cx - p[s - 2].cy / p[s - 2].cx) > 2 && (g = 0), h.cx < d && (h.cx ? d = h.cx : (h.cx = .001, s === n - 1 && (h.x -= .001, d = Math.min(d, .001), g = 0)))) : (p.splice(s--, 1), n--); if (o = 1 / (n = 1 / d + 1 | 0), a = 0, l = p[0], g) { for (s = 0; s < n; s++)c = s * o, l.nx < c && (l = p[++a]), i = l.y + (c - l.x) / l.cx * l.cy, f[s] = { x: c, cx: o, y: i, cy: 0, nx: 9 }, s && (f[s - 1].cy = i - f[s - 1].y); f[n - 1].cy = p[p.length - 1].y - i } else { for (s = 0; s < n; s++)l.nx < s * o && (l = p[++a]), f[s] = l; a < p.length - 1 && (f[s - 1] = p[p.length - 2]) } return this.ease = function (t) { var e = f[t * n | 0] || f[n - 1]; return e.nx < t && (e = e.n), e.y + (t - e.x) / e.cx * e.cy }, this.ease.custom = this, this.id && Gx && Gx.registerEase(this.id, this.ease), this }, e.getSVGData = function (e) { return t.getSVGData(this, e) }, t.create = function (e, n, i) { return new t(e, n, i).ease }, t.register = function (t) { Gx = t, Wx() }, t.get = function (t) { return Gx.parseEase(t) }, t.getSVGData = function (e, n) { var i, r, s, o, a, l, h, c, u, d, p = (n = n || {}).width || 100, f = n.height || 100, m = n.x || 0, g = (n.y || 0) + f, v = Gx.utils.toArray(n.path)[0]; if (n.invert && (f = -f, g = 0), "string" == typeof e && (e = Gx.parseEase(e)), e.custom && (e = e.custom), e instanceof t) i = Qx(function (t, e, n, i, r, s, o) { for (var a, l, h, c, u, d = t.length; --d > -1;)for (l = (a = t[d]).length, h = 0; h < l; h += 2)c = a[h], u = a[h + 1], a[h] = c * e + u * i + s, a[h + 1] = c * n + u * r + o; return t._dirty = 1, t }([e.segment], p, 0, 0, -f, m, g)); else { for (i = [m, g], o = 1 / (h = Math.max(5, 200 * (n.precision || 1))), c = 5 / (h += 2), u = qx(m + o * p), r = ((d = qx(g + e(o) * -f)) - g) / (u - m), s = 2; s < h; s++)a = qx(m + s * o * p), l = qx(g + e(s * o) * -f), (Math.abs((l - d) / (a - u) - r) > c || s === h - 1) && (i.push(u, d), r = (l - d) / (a - u)), u = a, d = l; i = "M" + i.join(",") } return v && v.setAttribute("d", i), i }, t }(); jx() && Gx.registerPlugin(Zx), Zx.version = "3.11.4"; class $x { constructor(t) { this.chars = Wg(t), this.sets = [], this.length = 50; for (let t = 0; t < 20; t++)this.sets[t] = r_(80, this.chars) } grow(t) { for (let e = 0; e < 20; e++)this.sets[e] += r_(t - this.length, this.chars); this.length = t } } let t_, e_, n_ = () => t_ || "undefined" != typeof window && (t_ = window.gsap) && t_.registerPlugin && t_, i_ = /\s+/g, r_ = (t, e) => { let n = e.length, i = ""; for (; --t > -1;)i += e[~~(Math.random() * n)]; return i }, s_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", o_ = s_.toLowerCase(), a_ = { upperCase: new $x(s_), lowerCase: new $x(o_), upperAndLowerCase: new $x(s_ + o_) }, l_ = () => { e_ = t_ = n_() }; const h_ = { version: "3.11.3", name: "scrambleText", register(t, e, n) { t_ = t, l_() }, init(t, e, n, i, r) { if (e_ || l_(), this.prop = "innerHTML" in t ? "innerHTML" : "textContent" in t ? "textContent" : 0, !this.prop) return; this.target = t, "object" != typeof e && (e = { text: e }); let s, o, a, l, h = e.text || e.value || "", c = !1 !== e.trim, u = this; return u.delimiter = s = e.delimiter || "", u.original = Wg(jg(t).replace(i_, " ").split("&nbsp;").join(""), s, c), "{original}" !== h && !0 !== h && null != h || (h = u.original.join(s)), u.text = Wg((h || "").replace(i_, " "), s, c), u.hasClass = !(!e.newClass && !e.oldClass), u.newClass = e.newClass, u.oldClass = e.oldClass, l = "" === s, u.textHasEmoji = l && !!u.text.emoji, u.charsHaveEmoji = !!e.chars && !!Wg(e.chars).emoji, u.length = l ? u.original.length : u.original.join(s).length, u.lengthDif = (l ? u.text.length : u.text.join(s).length) - u.length, u.fillChar = e.fillChar || e.chars && ~e.chars.indexOf(" ") ? "&nbsp;" : "", u.charSet = a = a_[e.chars || "upperCase"] || new $x(e.chars), u.speed = .05 / (e.speed || 1), u.prevScrambleTime = 0, u.setIndex = 20 * Math.random() | 0, o = u.length + Math.max(u.lengthDif, 0), o > a.length && a.grow(o), u.chars = a.sets[u.setIndex], u.revealDelay = e.revealDelay || 0, u.tweenLength = !1 !== e.tweenLength, u.tween = n, u.rightToLeft = !!e.rightToLeft, u._props.push("scrambleText", "text"), 1 }, render(t, e) { let n, i, r, s, o, a, l, h, c, u, d, { target: p, prop: f, text: m, delimiter: g, tween: v, prevScrambleTime: A, revealDelay: b, setIndex: y, chars: x, charSet: _, length: w, textHasEmoji: E, charsHaveEmoji: C, lengthDif: S, tweenLength: M, oldClass: P, newClass: I, rightToLeft: T, fillChar: D, speed: B, original: L, hasClass: F } = e, k = m.length, R = v._time, O = R - A; b && (v._from && (R = v._dur - R), t = 0 === R ? 0 : R < b ? 1e-6 : R === v._dur ? 1 : v._ease((R - b) / (v._dur - b))), t < 0 ? t = 0 : t > 1 && (t = 1), T && (t = 1 - t), n = ~~(t * k + .5), t ? ((O > B || O < -B) && (e.setIndex = y = (y + (19 * Math.random() | 0)) % 20, e.chars = _.sets[y], e.prevScrambleTime += O), s = x) : s = L.join(g), d = v._from ? t : 1 - t, u = w + (M ? v._from ? d * d * d : 1 - d * d * d : 1) * S, T ? 1 !== t || !v._from && "isFromStart" !== v.data ? (l = m.slice(n).join(g), r = C ? Wg(s).slice(0, u - (E ? Wg(l) : l).length + .5 | 0).join("") : s.substr(0, u - (E ? Wg(l) : l).length + .5 | 0), s = l) : (r = "", s = L.join(g)) : (r = m.slice(0, n).join(g), i = (E ? Wg(r) : r).length, s = C ? Wg(s).slice(i, u + .5 | 0).join("") : s.substr(i, u - i + .5 | 0)), F ? (h = T ? P : I, c = T ? I : P, o = h && 0 !== n, a = c && n !== k, l = (o ? "<span class='" + h + "'>" : "") + r + (o ? "</span>" : "") + (a ? "<span class='" + c + "'>" : "") + g + s + (a ? "</span>" : "")) : l = r + g + s, p[f] = "&nbsp;" === D && ~l.indexOf("  ") ? l.split("  ").join("&nbsp;&nbsp;") : l } }; h_.emojiSafeSplit = Wg, h_.getText = jg, n_() && t_.registerPlugin(h_); var c_ = n(4279), u_ = n(9389); function d_() { return d_ = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, d_.apply(this, arguments) } function p_(t, e) { let n = t % e; return (e > 0 && n < 0 || e < 0 && n > 0) && (n += e), n } const f_ = ["duration", "easing"]; class m_ { to(t, e = {}) { let { duration: n = 1, easing: i = (t => t) } = e, r = function (t, e) { if (null == t) return {}; var n, i, r = {}, s = Object.keys(t); for (i = 0; i < s.length; i++)e.indexOf(n = s[i]) >= 0 || (r[n] = t[n]); return r }(e, f_); this.target = t, this.fromKeys = d_({}, r), this.toKeys = d_({}, r), this.keys = Object.keys(d_({}, r)), this.keys.forEach((e => { this.fromKeys[e] = t[e] })), this.duration = n, this.easing = i, this.currentTime = 0, this.isRunning = !0 } stop() { this.isRunning = !1 } raf(t) { if (!this.isRunning) return; this.currentTime = Math.min(this.currentTime + t, this.duration); const e = this.progress >= 1 ? 1 : this.easing(this.progress); this.keys.forEach((t => { const n = this.fromKeys[t]; this.target[t] = n + (this.toKeys[t] - n) * e })), 1 === e && this.stop() } get progress() { return this.currentTime / this.duration } } class g_ extends c_.TinyEmitter { constructor({ duration: t = 1.2, easing: e = (t => Math.min(1, 1.001 - Math.pow(2, -10 * t))), smooth: n = !0, mouseMultiplier: i = 1, smoothTouch: r = !1, touchMultiplier: s = 2, direction: o = "vertical", gestureDirection: a = "vertical", infinite: l = !1, wrapper: h = window, content: c = document.body } = {}) { var u, d, p; super(), this.onWindowResize = () => { this.wrapperWidth = window.innerWidth, this.wrapperHeight = window.innerHeight }, this.onWrapperResize = ([t]) => { if (t) { const e = t.contentRect; this.wrapperWidth = e.width, this.wrapperHeight = e.height } }, this.onContentResize = ([t]) => { if (t) { const e = t.contentRect; this.contentWidth = e.width, this.contentHeight = e.height } }, this.onVirtualScroll = ({ deltaY: t, deltaX: e, originalEvent: n }) => { if ("vertical" === this.gestureDirection && 0 === t || "horizontal" === this.gestureDirection && 0 === e) return; const i = !!n.composedPath().find((t => t.hasAttribute && t.hasAttribute("data-lenis-prevent"))); if (n.ctrlKey || i) return; if (this.smooth = n.changedTouches ? this.smoothTouch : this.options.smooth, this.stopped) return void n.preventDefault(); if (!this.smooth) return; if (4 === n.buttons) return; this.smooth && n.preventDefault(); let r = 0; r = "both" === this.gestureDirection ? e + t : "horizontal" === this.gestureDirection ? e : t, this.targetScroll -= r, this.scrollTo(this.targetScroll) }, this.onScroll = t => { this.isScrolling && this.smooth || (this.targetScroll = this.scroll = this.lastScroll = this.wrapperNode[this.scrollProperty], this.notify()) }, window.lenisVersion = "0.2.28", this.options = { duration: t, easing: e, smooth: n, mouseMultiplier: i, smoothTouch: r, touchMultiplier: s, direction: o, gestureDirection: a, infinite: l, wrapper: h, content: c }, this.duration = t, this.easing = e, this.smooth = n, this.mouseMultiplier = i, this.smoothTouch = r, this.touchMultiplier = s, this.direction = o, this.gestureDirection = a, this.infinite = l, this.wrapperNode = h, this.contentNode = c, this.wrapperNode.addEventListener("scroll", this.onScroll), this.wrapperNode === window ? (this.wrapperNode.addEventListener("resize", this.onWindowResize), this.onWindowResize()) : (this.wrapperHeight = this.wrapperNode.offsetHeight, this.wrapperWidth = this.wrapperNode.offsetWidth, this.wrapperObserver = new ResizeObserver(this.onWrapperResize), this.wrapperObserver.observe(this.wrapperNode)), this.contentHeight = this.contentNode.offsetHeight, this.contentWidth = this.contentNode.offsetWidth, this.contentObserver = new ResizeObserver(this.onContentResize), this.contentObserver.observe(this.contentNode), this.targetScroll = this.scroll = this.lastScroll = this.wrapperNode[this.scrollProperty], this.animate = new m_; const f = (null == (u = navigator) || null == (d = u.userAgentData) ? void 0 : d.platform) || (null == (p = navigator) ? void 0 : p.platform) || "unknown"; this.virtualScroll = new u_({ el: this.wrapperNode, firefoxMultiplier: 50, mouseMultiplier: this.mouseMultiplier * (f.includes("Win") || f.includes("Linux") ? .84 : .4), touchMultiplier: this.touchMultiplier, passive: !1, useKeyboard: !1, useTouch: !0 }), this.virtualScroll.on(this.onVirtualScroll) } get scrollProperty() { let t; return t = this.wrapperNode === window ? "horizontal" === this.direction ? "scrollX" : "scrollY" : "horizontal" === this.direction ? "scrollLeft" : "scrollTop", t } start() { let t = this.wrapperNode; this.wrapperNode === window && (t = document.documentElement), t.classList.remove("lenis-stopped"), this.stopped = !1 } stop() { let t = this.wrapperNode; this.wrapperNode === window && (t = document.documentElement), t.classList.add("lenis-stopped"), this.stopped = !0, this.animate.stop() } destroy() { var t; this.wrapperNode === window && this.wrapperNode.removeEventListener("resize", this.onWindowResize), this.wrapperNode.removeEventListener("scroll", this.onScroll), this.virtualScroll.destroy(), null == (t = this.wrapperObserver) || t.disconnect(), this.contentObserver.disconnect() } get limit() { return "horizontal" === this.direction ? this.contentWidth - this.wrapperWidth : this.contentHeight - this.wrapperHeight } raf(t) { const e = t - (this.now || 0); this.now = t, !this.stopped && this.smooth && (this.lastScroll = this.scroll, this.animate.raf(.001 * e), this.scroll === this.targetScroll && (this.lastScroll = this.scroll), this.isScrolling && (this.setScroll(this.scroll), this.notify()), this.isScrolling = this.scroll !== this.targetScroll) } get velocity() { return this.scroll - this.lastScroll } setScroll(t) { let e = this.infinite ? p_(t, this.limit) : t; "horizontal" === this.direction ? this.wrapperNode.scrollTo(e, 0) : this.wrapperNode.scrollTo(0, e) } notify() { let t = this.infinite ? p_(this.scroll, this.limit) : this.scroll; this.emit("scroll", { scroll: t, limit: this.limit, velocity: this.velocity, direction: 0 === this.velocity ? 0 : this.velocity > 0 ? 1 : -1, progress: t / this.limit }) } scrollTo(t, { offset: e = 0, immediate: n = !1, duration: i = this.duration, easing: r = this.easing } = {}) { if (null == t || this.stopped) return; let s; if ("number" == typeof t) s = t; else if ("top" === t || "#top" === t) s = 0; else if ("bottom" === t) s = this.limit; else { let e; if ("string" == typeof t) e = document.querySelector(t); else { if (null == t || !t.nodeType) return; e = t } if (!e) return; let n = 0; if (this.wrapperNode !== window) { const t = this.wrapperNode.getBoundingClientRect(); n = "horizontal" === this.direction ? t.left : t.top } const i = e.getBoundingClientRect(); s = ("horizontal" === this.direction ? i.left : i.top) + this.scroll - n } s += e, this.targetScroll = this.infinite ? s : Math.max(0, Math.min(s, this.limit)), !this.smooth || n ? (this.animate.stop(), this.scroll = this.lastScroll = this.targetScroll, this.setScroll(this.targetScroll)) : this.animate.to(this, { duration: i, easing: r, scroll: this.targetScroll }) } } function v_(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class A_ extends Ng { constructor(t) { super(t), v_(this, "hostname", null), v_(this, "includeSubDomains", !1), v_(this, "toggleBtn", null), v_(this, "onClick", (() => { const t = new Date; t.setMonth(t.getMonth() + 1); let e = `cookie_notice_accepted=true;expires=${t.toUTCString()};path=/`; !0 === this.includeSubDomains && (e += `;domain=${this.hostname}`), document.cookie = e, this.updateStore(), this.hide() })), null === this.hostname && (this.hostname = window.location.hostname), this.toggleBtn = Sh(".js-cookie-notice-toggle", this.el), this.updateStore(), !1 === Fh.cookieNoticeAccepted ? (this.on("click", this.toggleBtn, this.onClick), this.show()) : this.hide() } hide() { this.el.classList.remove("is-open"), this.el.style.display = "none" } show() { this.el.classList.add("is-open"), this.el.classList.remove("d-none") } updateStore() { Fh.cookieNoticeAccepted = document.cookie.split(";").some((t => t.includes("cookie_notice_accepted=true"))), !0 === Fh.cookieNoticeAccepted && this.emit("cookienotice:accepted") } } function b_(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } v_(A_, "selector", ".js-cookie-notice"); class y_ extends Ng { constructor(t) { super(t), b_(this, "animate", (() => { if (this.isOpen) { Math.abs(this.currentScroll - Fh.Lenis.scroll) > 200 && (this.isOpen = !this.isOpen, this.navigation.classList.add("hide"), this.menuButton.classList.add("closed"), Fh.Header.animateInBack()) } })), this.populateDom(), this.logoWidth = this.dom.logo.clientWidth, this.logoTextWidth = this.dom.logoText.clientWidth, this.menuToggle = Sh(".js-toggle-menu", t), this.headerLinks = [...this.dom.linkArray, this.menuToggle], this.isOpen = !1, this.menuButton = Sh(".js-toggle-menu"), this.navigation = Sh(".js-navigation"), this.on(ic.RAF, this.animate), this.reset(), ec.on("End-transition", (() => { this.isOpen = !1 })), this.on("click", this.menuButton, (() => { this.isOpen = !this.isOpen, this.isOpen ? (this.navigation.classList.remove("hide"), this.menuButton.classList.remove("closed"), Fh.Header.animateOut(), this.currentScroll = Fh.Lenis.scroll) : (this.navigation.classList.add("hide"), this.menuButton.classList.add("closed"), Fh.Header.animateInBack()) })) } reset() { const t = mg.timeline(); return Fh.mq.sm.matches && t.set(this.dom.logo, { xPercent: 600 }).set(this.dom.logoMask, { xPercent: 100 }).set(this.dom.logoText, { xPercent: -100 }), Fh.mq.md.matches && t.set(this.headerLinks, { xPercent: 800 }), t } animateIn() { const t = mg.timeline({ defaults: { ease: "customOut", duration: .6 } }).flicker(this.dom.logo, 0); if (Fh.mq.sm.matches && t.to(this.dom.logo, { xPercent: 0, ease: "power1.inOut" }, .25).to([this.dom.logoMask, this.dom.logoText], { xPercent: 0, ease: "power1.inOut" }, .3), Fh.mq.md.matches) for (let e = 0; e < this.headerLinks.length; e++) { const n = .6 / this.headerLinks.length; t.flicker(this.headerLinks[e], n * e).to(this.headerLinks[e], { xPercent: 0 }, n * e) } else t.flicker(this.menuToggle, 0); return t } animateOut() { const t = mg.timeline({ defaults: { ease: "customOut", duration: .6 } }); if (Fh.mq.md.matches) for (let e = 0; e < this.dom.linkArray.length; e++) { mg.killTweensOf(this.dom.linkArray[e]); const n = .6 / this.dom.linkArray.length; t.flickerOut(this.dom.linkArray[e], n * e) } } animateInBack() { const t = mg.timeline({ defaults: { ease: "customOut", duration: .6 } }); if (Fh.mq.md.matches) for (let e = this.dom.linkArray.length - 1; e >= 0; e--) { mg.killTweensOf(this.dom.linkArray[e]); const n = .6 / this.dom.linkArray.length; t.flicker(this.dom.linkArray[e], n * (this.dom.linkArray.length - e)) } } } b_(y_, "selector", ".js-header"); const x_ = new An, __ = new vn, w_ = new An; class E_ extends bi { constructor(t = document.createElement("div")) { super(), this.isCSS3DObject = !0, this.element = t, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", (function () { this.traverse((function (t) { t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element) })) })) } copy(t, e) { return super.copy(t, e), this.element = t.element.cloneNode(!0), this } } class C_ extends E_ { constructor(t) { super(t), this.isCSS3DSprite = !0, this.rotation2D = 0 } copy(t, e) { return super.copy(t, e), this.rotation2D = t.rotation2D, this } } const S_ = new Yn, M_ = new Yn; class P_ { constructor(t = {}) { const e = this; let n, i, r, s; const o = { camera: { fov: 0, style: "" }, objects: new WeakMap }, a = void 0 !== t.element ? t.element : document.createElement("div"); a.style.overflow = "hidden", this.domElement = a; const l = document.createElement("div"); function h(t) { return Math.abs(t) < 1e-10 ? 0 : t } function c(t) { const e = t.elements; return "matrix3d(" + h(e[0]) + "," + h(-e[1]) + "," + h(e[2]) + "," + h(e[3]) + "," + h(e[4]) + "," + h(-e[5]) + "," + h(e[6]) + "," + h(e[7]) + "," + h(e[8]) + "," + h(-e[9]) + "," + h(e[10]) + "," + h(e[11]) + "," + h(e[12]) + "," + h(-e[13]) + "," + h(e[14]) + "," + h(e[15]) + ")" } function u(t) { const e = t.elements; return "translate(-50%,-50%)" + ("matrix3d(" + h(e[0]) + "," + h(e[1]) + "," + h(e[2]) + "," + h(e[3]) + "," + h(-e[4]) + "," + h(-e[5]) + "," + h(-e[6]) + "," + h(-e[7]) + "," + h(e[8]) + "," + h(e[9]) + "," + h(e[10]) + "," + h(e[11]) + "," + h(e[12]) + "," + h(e[13]) + "," + h(e[14]) + "," + h(e[15]) + ")") } function d(t, n, i, r) { if (t.isCSS3DObject) { const r = !0 === t.visible && !0 === t.layers.test(i.layers); if (t.element.style.display = !0 === r ? "" : "none", !0 === r) { let r; t.onBeforeRender(e, n, i), t.isCSS3DSprite ? (S_.copy(i.matrixWorldInverse), S_.transpose(), 0 !== t.rotation2D && S_.multiply(M_.makeRotationZ(t.rotation2D)), t.matrixWorld.decompose(x_, __, w_), S_.setPosition(x_), S_.scale(w_), S_.elements[3] = 0, S_.elements[7] = 0, S_.elements[11] = 0, S_.elements[15] = 1, r = u(S_)) : r = u(t.matrixWorld); const s = t.element, a = o.objects.get(t); if (void 0 === a || a.style !== r) { s.style.transform = r; const e = { style: r }; o.objects.set(t, e) } s.parentNode !== l && l.appendChild(s), t.onAfterRender(e, n, i) } } for (let e = 0, s = t.children.length; e < s; e++)d(t.children[e], n, i, r) } l.style.transformStyle = "preserve-3d", l.style.pointerEvents = "none", a.appendChild(l), this.getSize = function () { return { width: n, height: i } }, this.render = function (t, e) { const n = e.projectionMatrix.elements[5] * s; let i, u; o.camera.fov !== n && (a.style.perspective = e.isPerspectiveCamera ? n + "px" : "", o.camera.fov = n), !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), e.isOrthographicCamera && (i = -(e.right + e.left) / 2, u = (e.top + e.bottom) / 2); const p = e.isOrthographicCamera ? "scale(" + n + ")translate(" + h(i) + "px," + h(u) + "px)" + c(e.matrixWorldInverse) : "translateZ(" + n + "px)" + c(e.matrixWorldInverse), f = p + "translate(" + r + "px," + s + "px)"; o.camera.style !== f && (l.style.transform = f, o.camera.style = f), d(t, t, e, p) }, this.setSize = function (t, e) { n = t, i = e, r = n / 2, s = i / 2, a.style.width = t + "px", a.style.height = e + "px", l.style.width = t + "px", l.style.height = e + "px" } } } function I_(t) { return t.replace(/#define\sGLSLIFY\s./, "") } var T_ = "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec4 color;", D_ = "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n", B_ = "#define GLSLIFY 1\nvec3 objectNormal = vec3( normal );\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n    mat3 m = mat3( instanceMatrix );\n    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    transformedNormal = m * transformedNormal;\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\nvNormal = normalize( transformedNormal );", L_ = "#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying float vFogDepth;\nvarying float vFogHeight;", F_ = "#define GLSLIFY 1\nvec4 worldPosition = vec4(transformedPosition, 1.0); // global coordinates\n#ifdef USE_INSTANCING\n    worldPosition = instanceMatrix * worldPosition;\n#endif\nworldPosition = modelMatrix * worldPosition;\nvWorldPosition = worldPosition.xyz;\nvFogDepth = -mvPosition.z;\nvFogHeight = -mvPosition.y;", k_ = '#define GLSLIFY 1\n// float depth = 1. - gl_FragCoord.z / gl_FragCoord.w;\n\nvec3 fogColor = gl_FragColor.rgb; \nvec4 debugColorOriginal = vec4(gl_FragColor.rgb, 1.0);\n\nif (uEnableFog) {\n\tfor ( int i = 0; i < NUM_V_LIGHTS; i++ ) {\n\t\tVolumetricLight light = volumetricLights[i];\n\n\t\tfloat fogOriginDistance = distance(vWorldPosition, light.position);\n\t\tfloat fogFactor = smoothstep(light.near, light.far, fogOriginDistance) * light.strength;\n\n\t\tfogColor = mix(light.color, fogColor, fogFactor + (1.0 - light.strength)); // Volumetric "fog"\n\t}\n\t// World fog\n\t// Depth fog\n\tfloat worldDepthFogFactor = smoothstep( uFogNear_D, uFogFar_D, vFogDepth );\n\t// gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, worldDepthFogFactor);\n\t// gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0, 1.0, 1.0), worldDepthFogFactor); // debug\n\n\t// Height fog\n\t// float worldHeightFogFactor = smoothstep(-uFogFar_H, -uFogNear_H, vFogHeight ); // Turned around\n\tfloat worldHeightFogFactor = smoothstep(uFogNear_H, uFogFar_H, vWorldPosition.y - cameraPosition.y ); // based on distance from camera Y\n\t// gl_FragColor.rgb = mix(fogColor, gl_FragColor.rgb, worldDepthFogFactor);\n\t// gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0, 1.0, 1.0), worldHeightFogFactor); // debug\n\n\t// World Fog overlay\n\tfogColor = mix(fogColor, uWorldFogColor, uWorldFogColorMix);\n\n\t// Combine depth and height fog\n\t// gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, clamp(worldHeightFogFactor*uFogStrength_H+worldDepthFogFactor*uFogStrength_D, 0.0, 1.0));\n\tgl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, clamp(worldDepthFogFactor*uFogStrength_D, 0.0, 1.0));\n\tgl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, clamp(worldHeightFogFactor*uFogStrength_H, 0.0, 1.0));\n\n\tif(uDebugFog) {\n\t\t// gl_FragColor.rgb = mix(debugColorOriginal.rgb, vec3(0.0, 1.0, 1.0), clamp(worldDepthFogFactor*worldHeightFogFactor+worldHeightFogFactor*worldDepthFogFactor, 0.0, 1.0)); // debug\n\t\tgl_FragColor.rgb = mix(debugColorOriginal.rgb, vec3(0.9, 0.38, 0.27), clamp(worldHeightFogFactor*uFogStrength_H+worldDepthFogFactor*uFogStrength_D, 0.0, 1.0) * uFogStrength); // debug\n\t}\n}', R_ = "#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying float vFogDepth;\nvarying float vFogHeight;\n\nuniform float uFogNear_D;\nuniform float uFogFar_D;\nuniform float uFogStrength_D;\nuniform float uFogNear_H;\nuniform float uFogFar_H;\nuniform float uFogStrength_H;\nuniform float uFogStrength;\nuniform bool uEnableFog;\nuniform vec3 uWorldFogColor;\nuniform float uWorldFogColorMix;\n\nuniform bool uDebugFog;\n\nstruct VolumetricLight {\n    float near;\n    float far;\n    float strength;\n    vec3 color;\n    vec3 position;\n};\n\nuniform VolumetricLight volumetricLights[ NUM_V_LIGHTS ];"; function O_(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class N_ { constructor() { O_(this, "onRaf", (t => { this.clockDelta = Math.round(1e3 * this.clock.getDelta()) / 1e3, this.clockDelta = Ge.clamp(this.clockDelta, 0, .016), this.normalizeDelta = this.clockDelta / .016, this.globalUniforms.uDelta.value = this.clockDelta, this.globalUniforms.uTime.value = t, this.renderer.info.reset() })), O_(this, "onResize", (() => { this.renderer.setSize(Fh.window.w, Fh.window.fullHeight), this.renderer.setViewport(0, 0, Fh.window.w, Fh.window.fullHeight), this.renderer.setScissor(0, 0, Fh.window.w, Fh.window.fullHeight), this.labelRenderer.setSize(Fh.window.w % 2 == 0 ? Fh.window.w : Fh.window.w - 1, Fh.window.h % 2 == 0 ? Fh.window.h : Fh.window.h - 1), this.globalUniforms.uResolution.value.set(Fh.window.w * this.renderer.getPixelRatio(), Fh.window.fullHeight * this.renderer.getPixelRatio()) })), this.dom = { canvas: Sh("canvas#gl") }, this.setup() } setup() { this.renderer = new ca({ alpha: !1, antialias: !1, canvas: this.dom.canvas, powerPreference: "high-performance", stencil: !1 }); let t = Fh.window.dpr >= 2 ? 2 : Fh.window.dpr; Fh.isTouch && !Fh.mq.sm.matches && (t = Fh.window.dpr >= 1.5 ? 1.5 : Fh.window.dpr), this.renderer.setPixelRatio(t), this.renderer.setSize(Fh.window.w, Fh.window.fullHeight), this.renderer.info.autoReset = !1, this.renderer.toneMapping = K, Fh.AssetLoader.ktxLoader.detectSupport(this.renderer), this.labelRenderer = new P_, this.labelRenderer.setSize(Fh.window.w % 2 == 0 ? Fh.window.w : Fh.window.w - 1, Fh.window.h % 2 == 0 ? Fh.window.h : Fh.window.h - 1), this.labelRenderer.domElement.style.position = "fixed", this.labelRenderer.domElement.style.top = "0px", document.body.appendChild(this.labelRenderer.domElement), this.labelRenderer.domElement.classList.add("pointer-events-none", "d-none"), this.clock = new hh, this.clockDelta = 0, this.normalizeDelta = 0, this.globalUniforms = { uDelta: { value: 0 }, uTime: { value: 0 }, uResolution: { value: new He(Fh.window.w * this.renderer.getPixelRatio(), Fh.window.fullHeight * this.renderer.getPixelRatio()) }, uPixelRatio: { value: this.renderer.getPixelRatio() / Fh.window.dpr } }, Dr.defaultVert = I_(T_), Dr.defaultFrag = I_(D_), Dr.normalsVert = I_(B_), Dr.fogParamsVert = I_(L_), Dr.fogOutputVert = I_(F_), Dr.fogParamsFrag = I_(R_), Dr.fogOutputFrag = I_(k_), ec.on(ic.RESIZE, this.onResize) } build() { } initialise() { this.addEvents() } addEvents() { Fh.RAFCollection.add(this.onRaf, 0) } generateTexture(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return t instanceof HTMLImageElement && (t = new dn(t)), t.minFilter = e.minFilter || mt, t.magFilter = e.magFilter || pt, t.wrapS = t.wrapT = e.wrapping || lt, t.flipY = void 0 === e.flipY || e.flipY, t.encoding = e.encoding || Ae, this.renderer.initTexture(t), t } destroy() { Fh.RAFCollection.remove(this.onRaf) } } const U_ = { type: "change" }, z_ = { type: "start" }, V_ = { type: "end" }; class Q_ extends Ie { constructor(t, e) { super(), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new An, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: s.ROTATE, MIDDLE: s.DOLLY, RIGHT: s.PAN }, this.touches = { ONE: o.ROTATE, TWO: o.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return l.phi }, this.getAzimuthalAngle = function () { return l.theta }, this.getDistance = function () { return this.object.position.distanceTo(this.target) }, this.listenToKeyEvents = function (t) { t.addEventListener("keydown", j), this._domElementKeyEvents = t }, this.saveState = function () { n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom }, this.reset = function () { n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(U_), n.update(), r = i.NONE }, this.update = function () { const e = new An, s = (new vn).setFromUnitVectors(t.up, new An(0, 1, 0)), o = s.clone().invert(), p = new An, f = new vn, m = 2 * Math.PI; return function () { const t = n.object.position; e.copy(t).sub(n.target), e.applyQuaternion(s), l.setFromVector3(e), n.autoRotate && r === i.NONE && C(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (l.theta += h.theta * n.dampingFactor, l.phi += h.phi * n.dampingFactor) : (l.theta += h.theta, l.phi += h.phi); let g = n.minAzimuthAngle, v = n.maxAzimuthAngle; return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += m : g > Math.PI && (g -= m), v < -Math.PI ? v += m : v > Math.PI && (v -= m), l.theta = g <= v ? Math.max(g, Math.min(v, l.theta)) : l.theta > (g + v) / 2 ? Math.max(g, l.theta) : Math.min(v, l.theta)), l.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, l.phi)), l.makeSafe(), l.radius *= c, l.radius = Math.max(n.minDistance, Math.min(n.maxDistance, l.radius)), !0 === n.enableDamping ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), e.setFromSpherical(l), e.applyQuaternion(o), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), u.set(0, 0, 0)), c = 1, !!(d || p.distanceToSquared(n.object.position) > a || 8 * (1 - f.dot(n.object.quaternion)) > a) && (n.dispatchEvent(U_), p.copy(n.object.position), f.copy(n.object.quaternion), d = !1, !0) } }(), this.dispose = function () { n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", z), n.domElement.removeEventListener("pointercancel", G), n.domElement.removeEventListener("wheel", H), n.domElement.removeEventListener("pointermove", V), n.domElement.removeEventListener("pointerup", Q), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", j) }; const n = this, i = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let r = i.NONE; const a = 1e-6, l = new bh, h = new bh; let c = 1; const u = new An; let d = !1; const p = new He, f = new He, m = new He, g = new He, v = new He, A = new He, b = new He, y = new He, x = new He, _ = [], w = {}; function E() { return Math.pow(.95, n.zoomSpeed) } function C(t) { h.theta -= t } function S(t) { h.phi -= t } const M = function () { const t = new An; return function (e, n) { t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), u.add(t) } }(), P = function () { const t = new An; return function (e, i) { !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), u.add(t) } }(), I = function () { const t = new An; return function (e, i) { const r = n.domElement; if (n.object.isPerspectiveCamera) { const s = n.object.position; t.copy(s).sub(n.target); let o = t.length(); o *= Math.tan(n.object.fov / 2 * Math.PI / 180), M(2 * e * o / r.clientHeight, n.object.matrix), P(2 * i * o / r.clientHeight, n.object.matrix) } else n.object.isOrthographicCamera ? (M(e * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix), P(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1) } }(); function T(t) { n.object.isPerspectiveCamera ? c /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function D(t) { n.object.isPerspectiveCamera ? c *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function B(t) { p.set(t.clientX, t.clientY) } function L(t) { g.set(t.clientX, t.clientY) } function F() { if (1 === _.length) p.set(_[0].pageX, _[0].pageY); else { const t = .5 * (_[0].pageX + _[1].pageX), e = .5 * (_[0].pageY + _[1].pageY); p.set(t, e) } } function k() { if (1 === _.length) g.set(_[0].pageX, _[0].pageY); else { const t = .5 * (_[0].pageX + _[1].pageX), e = .5 * (_[0].pageY + _[1].pageY); g.set(t, e) } } function R() { const t = _[0].pageX - _[1].pageX, e = _[0].pageY - _[1].pageY, n = Math.sqrt(t * t + e * e); b.set(0, n) } function O(t) { if (1 == _.length) f.set(t.pageX, t.pageY); else { const e = X(t), n = .5 * (t.pageX + e.x), i = .5 * (t.pageY + e.y); f.set(n, i) } m.subVectors(f, p).multiplyScalar(n.rotateSpeed); const e = n.domElement; C(2 * Math.PI * m.x / e.clientHeight), S(2 * Math.PI * m.y / e.clientHeight), p.copy(f) } function N(t) { if (1 === _.length) v.set(t.pageX, t.pageY); else { const e = X(t), n = .5 * (t.pageX + e.x), i = .5 * (t.pageY + e.y); v.set(n, i) } A.subVectors(v, g).multiplyScalar(n.panSpeed), I(A.x, A.y), g.copy(v) } function U(t) { const e = X(t), i = t.pageX - e.x, r = t.pageY - e.y, s = Math.sqrt(i * i + r * r); y.set(0, s), x.set(0, Math.pow(y.y / b.y, n.zoomSpeed)), T(x.y), b.copy(y) } function z(t) { !1 !== n.enabled && (0 === _.length && (n.domElement.setPointerCapture(t.pointerId), n.domElement.addEventListener("pointermove", V), n.domElement.addEventListener("pointerup", Q)), function (t) { _.push(t) }(t), "touch" === t.pointerType ? function (t) { switch (Y(t), _.length) { case 1: switch (n.touches.ONE) { case o.ROTATE: if (!1 === n.enableRotate) return; F(), r = i.TOUCH_ROTATE; break; case o.PAN: if (!1 === n.enablePan) return; k(), r = i.TOUCH_PAN; break; default: r = i.NONE }break; case 2: switch (n.touches.TWO) { case o.DOLLY_PAN: if (!1 === n.enableZoom && !1 === n.enablePan) return; n.enableZoom && R(), n.enablePan && k(), r = i.TOUCH_DOLLY_PAN; break; case o.DOLLY_ROTATE: if (!1 === n.enableZoom && !1 === n.enableRotate) return; n.enableZoom && R(), n.enableRotate && F(), r = i.TOUCH_DOLLY_ROTATE; break; default: r = i.NONE }break; default: r = i.NONE }r !== i.NONE && n.dispatchEvent(z_) }(t) : function (t) { let e; switch (t.button) { case 0: e = n.mouseButtons.LEFT; break; case 1: e = n.mouseButtons.MIDDLE; break; case 2: e = n.mouseButtons.RIGHT; break; default: e = -1 }switch (e) { case s.DOLLY: if (!1 === n.enableZoom) return; !function (t) { b.set(t.clientX, t.clientY) }(t), r = i.DOLLY; break; case s.ROTATE: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === n.enablePan) return; L(t), r = i.PAN } else { if (!1 === n.enableRotate) return; B(t), r = i.ROTATE } break; case s.PAN: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === n.enableRotate) return; B(t), r = i.ROTATE } else { if (!1 === n.enablePan) return; L(t), r = i.PAN } break; default: r = i.NONE }r !== i.NONE && n.dispatchEvent(z_) }(t)) } function V(t) { !1 !== n.enabled && ("touch" === t.pointerType ? function (t) { switch (Y(t), r) { case i.TOUCH_ROTATE: if (!1 === n.enableRotate) return; O(t), n.update(); break; case i.TOUCH_PAN: if (!1 === n.enablePan) return; N(t), n.update(); break; case i.TOUCH_DOLLY_PAN: if (!1 === n.enableZoom && !1 === n.enablePan) return; !function (t) { n.enableZoom && U(t), n.enablePan && N(t) }(t), n.update(); break; case i.TOUCH_DOLLY_ROTATE: if (!1 === n.enableZoom && !1 === n.enableRotate) return; !function (t) { n.enableZoom && U(t), n.enableRotate && O(t) }(t), n.update(); break; default: r = i.NONE } }(t) : function (t) { switch (r) { case i.ROTATE: if (!1 === n.enableRotate) return; !function (t) { f.set(t.clientX, t.clientY), m.subVectors(f, p).multiplyScalar(n.rotateSpeed); const e = n.domElement; C(2 * Math.PI * m.x / e.clientHeight), S(2 * Math.PI * m.y / e.clientHeight), p.copy(f), n.update() }(t); break; case i.DOLLY: if (!1 === n.enableZoom) return; !function (t) { y.set(t.clientX, t.clientY), x.subVectors(y, b), x.y > 0 ? T(E()) : x.y < 0 && D(E()), b.copy(y), n.update() }(t); break; case i.PAN: if (!1 === n.enablePan) return; !function (t) { v.set(t.clientX, t.clientY), A.subVectors(v, g).multiplyScalar(n.panSpeed), I(A.x, A.y), g.copy(v), n.update() }(t) } }(t)) } function Q(t) { q(t), 0 === _.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", V), n.domElement.removeEventListener("pointerup", Q)), n.dispatchEvent(V_), r = i.NONE } function G(t) { q(t) } function H(t) { !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (t.preventDefault(), n.dispatchEvent(z_), function (t) { t.deltaY < 0 ? D(E()) : t.deltaY > 0 && T(E()), n.update() }(t), n.dispatchEvent(V_)) } function j(t) { !1 !== n.enabled && !1 !== n.enablePan && function (t) { let e = !1; switch (t.code) { case n.keys.UP: t.ctrlKey || t.metaKey || t.shiftKey ? S(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(0, n.keyPanSpeed), e = !0; break; case n.keys.BOTTOM: t.ctrlKey || t.metaKey || t.shiftKey ? S(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(0, -n.keyPanSpeed), e = !0; break; case n.keys.LEFT: t.ctrlKey || t.metaKey || t.shiftKey ? C(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(n.keyPanSpeed, 0), e = !0; break; case n.keys.RIGHT: t.ctrlKey || t.metaKey || t.shiftKey ? C(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(-n.keyPanSpeed, 0), e = !0 }e && (t.preventDefault(), n.update()) }(t) } function W(t) { !1 !== n.enabled && t.preventDefault() } function q(t) { delete w[t.pointerId]; for (let e = 0; e < _.length; e++)if (_[e].pointerId == t.pointerId) return void _.splice(e, 1) } function Y(t) { let e = w[t.pointerId]; void 0 === e && (e = new He, w[t.pointerId] = e), e.set(t.pageX, t.pageY) } function X(t) { const e = t.pointerId === _[0].pointerId ? _[1] : _[0]; return w[e.pointerId] } n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", z), n.domElement.addEventListener("pointercancel", G), n.domElement.addEventListener("wheel", H, { passive: !1 }), this.update() } } n(4197), n(3105), n(3462), n(3824); class G_ { constructor() { this.CHANNELS = 4, this.TEXTURE_WIDTH = 2048, this.TEXTURE_HEIGHT = 4, this.texture = this.initSplineTexture(1) } initSplineTexture() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; const e = new Float32Array(this.TEXTURE_WIDTH * this.TEXTURE_HEIGHT * t * this.CHANNELS), n = new _a(e, this.TEXTURE_WIDTH, this.TEXTURE_HEIGHT * t, It, _t); return n.wrapS = at, n.wrapY = at, n.magFilter = ct, n.needsUpdate = !0, n } updateSplineTexture(t, e) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const i = Math.floor(this.TEXTURE_WIDTH * (this.TEXTURE_HEIGHT / 4)); e.arcLengthDivisions = i / 2, e.updateArcLengths(); const r = e.getSpacedPoints(i), s = e.computeFrenetFrames(i, !0); for (let e = 0; e < i; e++) { const i = Math.floor(e / this.TEXTURE_WIDTH), o = e % this.TEXTURE_WIDTH; let a = r[e]; this.setTextureValue(t, o, a.x, a.y, a.z, 0 + i + this.TEXTURE_HEIGHT * n), a = s.tangents[e], this.setTextureValue(t, o, a.x, a.y, a.z, 1 + i + this.TEXTURE_HEIGHT * n), a = s.normals[e].negate(), this.setTextureValue(t, o, a.x, a.y, a.z, 2 + i + this.TEXTURE_HEIGHT * n), a = s.binormals[e].negate(), this.setTextureValue(t, o, a.x, a.y, a.z, 3 + i + this.TEXTURE_HEIGHT * n) } t.needsUpdate = !0 } setTextureValue(t, e, n, i, r, s) { const o = t.image, { data: a } = o, l = this.CHANNELS * this.TEXTURE_WIDTH * s; a[e * this.CHANNELS + l + 0] = n, a[e * this.CHANNELS + l + 1] = i, a[e * this.CHANNELS + l + 2] = r, a[e * this.CHANNELS + l + 3] = 1 } getUniforms(t) { return { spineTexture: { value: t }, pathOffset: { type: "f", value: 0 }, pathSegment: { type: "f", value: 1 }, spineOffset: { type: "f", value: 13 }, spineLength: { type: "f", value: 13 }, flow: { type: "i", value: 1 } } } } function H_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function j_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? H_(Object(n), !0).forEach((function (e) { W_(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : H_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function W_(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class q_ extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; super({ vertexShader: "#define GLSLIFY 1\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\nvarying vec3 testCol;\n\nuniform float uStartOffset; // Start offset for the whole car component\nuniform float uPartStartOffset; // Start offset for only the part of the component (trail or car mesh)\n\nuniform sampler2D spineTexture;\nuniform float pathOffset;\nuniform float pathSegment;\nuniform float spineOffset;\nuniform float spineLength;\nuniform int flow;\n\nuniform float uTime;\nuniform float uJitterAmplitude;\nuniform float uJitterFrequency;\nuniform float uNumberOfCurves;\nuniform float uTextureHeight;\n\n#include <fogParamsVert>\n\nvoid main() {\n\n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    #ifdef USE_INSTANCING\n        mat3 m = mat3( instanceMatrix );\n        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n        transformedNormal = m * transformedNormal;\n    #endif\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n\n    vUv = uv;\n\n    vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n    float textureLayers = uTextureHeight * uNumberOfCurves;\n    float textureStacks = uTextureHeight / 4.;\n    \n    bool bend = flow > 0;\n    float xWeight = bend ? 0. : 1.;\n\n    #ifdef USE_INSTANCING\n    float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n    float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n    float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n    float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix + uStartOffset)*textureStacks;\n    #else\n    float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n    float mt = (spinePortion * pathSegment + pathOffset + uStartOffset + uPartStartOffset)*textureStacks;\n    #endif\n\n    mt = mod(mt, textureStacks);\n    float rowOffset = floor(mt);\n\n    #ifdef USE_INSTANCING\n    rowOffset += instanceMatrix[3][1] * uTextureHeight;\n    #endif\n\n    vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n    vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz; // tangent\n    vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz; // normal (y direction)\n    vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz; // binormal\n    mat3 basis = mat3(a, b, c);\n\n    vec3 transformedPosition = basis\n        * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n        + spinePos;\n\n    // Additional displacement along the curve binormal (side to side) and normal (up and down)\n    float amplitude = uJitterAmplitude;\n    float frequency = uJitterFrequency;\n    float verticalDisplacement = sin(TWO_PI * uTime * frequency) * sin(TWO_PI * uTime * frequency * 1.5) * amplitude;\n    float horizontalDisplacement = cos(TWO_PI * uTime * frequency/0.33) * sin(TWO_PI * uTime * frequency * 0.75) * amplitude * 0.25;\n\n    transformedPosition += c * verticalDisplacement + b * horizontalDisplacement;\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );    \n    #ifdef USE_INSTANCING\n        mvPosition = instanceMatrix * mvPosition;\n    #endif\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n\n    vViewPosition = -mvPosition.xyz;\n    \n    #include <fogOutputVert>\n}", fragmentShader: "#define GLSLIFY 1\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nuniform sampler2D uMatcapTexture;\nuniform sampler2D uDiffuseTexture;\n\n#include <fogParamsFrag>\n\nvoid main() {\n\tvec3 diffuseColor = texture2D(uDiffuseTexture, vUv).rgb;\n\n    // matcap UVs\n    vec3 normal = normalize( vNormal );\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\n    vec3 matcapColor = texture2D(uMatcapTexture, uv).rgb;\n\tvec3 finalColor = blendSoftLight(diffuseColor, matcapColor, 1.);\n\n    gl_FragColor = vec4(finalColor, 1.);\n\n\t#include <tonemapping_fragment>\n\t#include <fogOutputFrag>\n\n}", uniforms: j_(j_({ uTime: Fh.WebGL.globalUniforms.uTime }, Fh.MainScene.components.fog.globalUniforms), t.uniforms), defines: j_({}, Fh.MainScene.components.fog.fogDefines), side: m }) } } function Y_(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function X_(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Y_(Object(n), !0).forEach((function (e) { K_(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Y_(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function K_(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class J_ extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; super({ vertexShader: "#define GLSLIFY 1\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nuniform float uStartOffset; // Start offset for the whole car component\nuniform float uPartStartOffset; // Start offset for only the part of the component (trail or car mesh)\n\nuniform sampler2D spineTexture;\nuniform float pathOffset;\nuniform float pathSegment;\nuniform float spineOffset;\nuniform float spineLength;\nuniform int flow;\n\nuniform float uTime;\nuniform float uJitterAmplitude;\nuniform float uJitterFrequency;\nuniform float uJitterFollow;\nuniform float uNumberOfCurves;\nuniform float uTextureHeight;\n\n#include <fogParamsVert>\n\nvoid main() {\n\n    #include <beginnormal_vertex>\n\n    vUv = uv;\n    vNormal = normal;\n\n    // vec4 mvPosition = vec4( position, 1.0 );\n    // #ifdef USE_INSTANCING\n    //     mvPosition = instanceMatrix * mvPosition;\n    // #endif\n    // mvPosition = modelViewMatrix * mvPosition;\n\n    vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n    float textureLayers = uTextureHeight * uNumberOfCurves;\n    float textureStacks = uTextureHeight / 4.;\n    \n    bool bend = flow > 0;\n    float xWeight = bend ? 0. : 1.;\n\n    #ifdef USE_INSTANCING\n    float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n    float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n    float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n    float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix + uStartOffset)*textureStacks;\n    #else\n    float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n    float mt = (spinePortion * pathSegment + pathOffset + uStartOffset + uPartStartOffset )*textureStacks;\n    #endif\n\n    mt = mod(mt, textureStacks);\n    float rowOffset = floor(mt);\n\n    #ifdef USE_INSTANCING\n    rowOffset += instanceMatrix[3][1] * uTextureHeight;\n    #endif\n\n    vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n    vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz; // tangent\n    vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz; // normal (y)\n    vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz; // binormal\n    mat3 basis = mat3(a, b, c);\n\n    vec3 transformedPosition = basis\n        * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n        + spinePos;\n\n    // Additional displacement along the curve binormal (side to side) and normal (up and down)\n    float amplitude = uJitterAmplitude;\n    float frequency = uJitterFrequency;\n    float verticalDisplacement = sin(TWO_PI * uTime * frequency + uJitterFollow) * sin(TWO_PI * uTime * frequency * 1.5 + uJitterFollow) * amplitude;\n    float horizontalDisplacement = cos(TWO_PI * uTime * frequency/0.33 + uJitterFollow) * sin(TWO_PI * uTime * frequency * 0.75 + uJitterFollow) * amplitude * 0.25;\n\n    transformedPosition += c * verticalDisplacement + b * horizontalDisplacement;\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );    \n    #ifdef USE_INSTANCING\n        mvPosition = instanceMatrix * mvPosition;\n    #endif\n    mvPosition = modelViewMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( transformedPosition, 1.0 );  \n\n    #include <fogOutputVert>\n\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nuniform vec3 uColorBegin;\nuniform vec3 uColorEnd;\nuniform float uColorFallOff;\nuniform float uColorOffset;\nuniform float uTrailLength;\nuniform float uTrailFallOffEnd;\n\n#include <fogParamsFrag>\n\nvoid main() {\n\n    vec3 beginColor = uColorBegin;\n    vec3 endColor = uColorEnd;\n    float trailLength = uTrailLength;\n\n    float triX = vUv.x;\n    // triX /= trailLength;\n    triX -= 0.08 / trailLength;\n    \n    float maskBack = smoothstep(0., uTrailFallOffEnd, triX);\n    maskBack = clamp(maskBack, 0.0, 1.0);\n    float mask = maskBack;\n\n    float colX = 1.0 - triX; // reverse so 1.0 is closes to the car\n    colX -= uColorOffset; // Move the beginning point of the gradient\n    float gradientMask = colX / uColorFallOff; // Make the color gradient steeper or more gradual\n    gradientMask = clamp(gradientMask, 0.0, 1.0);\n\n    vec3 colorGradient = mix(beginColor, endColor, gradientMask);\n\n    // Side masks\n    float sideWidths = 0.05;\n    float left = 1.0 - step(sideWidths, vUv.y);\n    float right = step(1.0-sideWidths, vUv.y);\n    float leftPlusRight = left + right;\n\n    float middleWidth = 0.7;\n    float middle = step((1.0 - middleWidth)/2., 0.5 - abs(vUv.y - 0.5) );\n    float middlePlusSides = middle + leftPlusRight;\n    middlePlusSides = clamp(middlePlusSides, 0., 1.);\n\n    mask *= middlePlusSides;\n\n    gl_FragColor = vec4(mix(vec3(0., 0., 0.), colorGradient, middlePlusSides), mask);\n\n    #include <tonemapping_fragment>\n\n    #include <fogOutputFrag>\n}", uniforms: X_(X_({ uTime: Fh.WebGL.globalUniforms.uTime }, Fh.MainScene.components.fog.globalUniforms), t.uniforms), defines: X_({}, Fh.MainScene.components.fog.fogDefines), side: m, transparent: !1, blending: _, blendEquation: w, blendSrc: B, blendDst: L }) } } class Z_ { constructor(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0; this.trailColorBegin = e.trailColorBegin, this.trailColorEnd = e.trailColorEnd, this.carMeshColor = e.bodyColor, this.uTrailLength = e.uTrailLength, this.uTrailFallOffEnd = e.uTrailFallOffEnd, this.uColorFallOff = e.uColorFallOff, this.uColorOffset = e.uColorOffset, this.jitter = { uJitterAmplitude: e.uJitterAmplitude, uJitterFrequency: e.uJitterFrequency, uJitterFollow: e.uJitterFollow }, this.pathPoints = t, this.startOffset = e.startOffset, this.trailOffset = 0, this.carMeshOffset = 0, this.speed = e.speed, this.curveArray = new Array(1), this.curveLengthArray = new Array(1), this.buildCurve(), this.initDataTexture(), this.buildCarMesh(n, i), this.buildTrail(), this.updateCurve(0, this.curve) } buildCurve() { this.curve = new sl(this.pathPoints, !1); this.carMeshOffset = 30 / this.curve.getLength() } initDataTexture() { this.dataTextHelper = new G_, this.dataTexture = this.dataTextHelper.texture, this.dataTextureOptions = { uTextureHeight: { value: this.dataTextHelper.TEXTURE_HEIGHT }, uNumberOfCurves: { value: 1 }, textureHeight: { value: this.dataTextHelper.TEXTURE_HEIGHT }, pathOffset: { type: "f", value: 0 }, pathSegment: { type: "f", value: 1 }, spineOffset: { type: "f", value: 15 }, spineLength: { type: "f", value: 13 } } } updateCurve(t, e) { if (t >= this.curveArray.length) throw Error("Index out of range for Flow"); const n = this.curve.getLength(); this.dataTextureOptions.spineLength.value = n, this.curveLengthArray[t] = n, this.curveArray[t] = e, this.dataTextHelper.updateSplineTexture(this.dataTexture, e, t) } buildCarMesh(t, e) { const n = { uTime: Fh.WebGL.globalUniforms.uTime, uDiffuseTexture: { value: e }, uMatcapTexture: { value: Fh.MainScene.assets.textures.matcap }, uPartStartOffset: { value: this.carMeshOffset }, uStartOffset: { value: this.startOffset }, spineTexture: { value: this.dataTexture }, flow: { type: "i", value: 0 } }; Object.assign(n, this.jitter), Object.assign(n, this.dataTextureOptions); const i = t.clone(); i.rotateY(Ge.degToRad(-90)), this.carMesh = new ar(i, new q_({ uniforms: n })), this.carMesh.geometry.computeBoundingBox(), this.carMesh.geometry.boundingBox.makeEmpty(), this.carMesh.geometry.boundingBox.setFromPoints(this.pathPoints), this.carMesh.geometry.boundingSphere = new Un, this.carMesh.geometry.boundingBox.getBoundingSphere(this.carMesh.geometry.boundingSphere), this.carMesh.geometry.boundingSphere.radius *= 1.5 } buildTrail() { const t = { uColorBegin: this.trailColorBegin, uColorEnd: this.trailColorEnd, uPartStartOffset: { value: this.trailOffset }, uStartOffset: { value: this.startOffset }, spineTexture: { value: this.dataTexture }, uTrailLength: this.uTrailLength, uTrailFallOffEnd: this.uTrailFallOffEnd, uColorFallOff: this.uColorFallOff, uColorOffset: this.uColorOffset, flow: { type: "i", value: 1 } }; Object.assign(t, this.jitter), Object.assign(t, this.dataTextureOptions), this.trail = new ar(new Tr(25, 2, 10, 1).rotateX(Ge.degToRad(90)), new J_({ uniforms: t })), this.trail.geometry.computeBoundingBox(), this.trail.geometry.boundingBox.makeEmpty(), this.trail.geometry.boundingBox.setFromPoints(this.pathPoints), this.trail.geometry.boundingSphere = new Un, this.trail.geometry.boundingBox.getBoundingSphere(this.trail.geometry.boundingSphere), this.trail.geometry.boundingSphere.radius *= 1.5 } animateCar() { this.trail.material.uniforms.pathOffset.value + 1e-4 >= .97 - this.startOffset - this.carMeshOffset && (this.trail.material.uniforms.pathOffset.value = -this.startOffset), this.trail.material.uniforms.pathOffset.value += this.speed * Fh.WebGL.normalizeDelta } pauseCar() { this.animating = !1 } splineHelperVisibility(t) { this.splineHelperLine.visible = t } } function $_(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class tw extends ia { constructor() { super(), $_(this, "onRaf", (() => { if (this.enabled) for (const t in this.paths.cars) this.paths.cars[t].animateCar() })), this.enabled = !1, this.load() } build(t) { this.paths = { cars: {} }, this.carOptions = { gui: { progress: 0, splineHelperVisible: !0, currCar: "" }, shared: { uJitterAmplitude: { value: .4 }, uJitterFrequency: { value: .2 }, uJitterFollow: { value: 0 }, trailColorBegin: { value: new on(16764332) }, trailColorEnd: { value: new on(15097924) }, uTrailLength: { value: .9 }, uTrailFallOffEnd: { value: .9 }, uColorOffset: { value: .163 }, uColorFallOff: { value: .28 } } }; const e = Object.keys(t.paths).filter((t => t.startsWith("car"))); for (const n in t.paths) { const i = []; for (let e = 0; e < t.paths[n][0].length; e++) { const r = t.paths[n][0][e]; i.push(new An(r[0], r[1], r[2])) } if (n.startsWith("car")) { const t = e.indexOf(n), r = { startOffset: Number(((0 + .32 * t) % .9).toFixed(2)), speed: 897e-6 }; Object.assign(r, this.carOptions.shared), this.paths.cars[n] = new Z_(i, r, t % 2 ? this.assets.models.car0.geometry : this.assets.models.car1.geometry, t % 2 ? this.assets.textures.car0 : this.assets.textures.car1), this.add(this.paths.cars[n].carMesh), this.add(this.paths.cars[n].trail) } } this.addEvents() } addEvents() { Fh.RAFCollection.add(this.onRaf, 5) } load() { this.assets = { models: {}, textures: {} }, Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/car0.glb").then((t => { this.assets.models.car0 = t.scene.children[0] })), Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/car1.glb").then((t => { this.assets.models.car1 = t.scene.children[0] })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/car0.ktx2", { flipY: !1 }).then((t => { this.assets.textures.car0 = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/car1.ktx2", { flipY: !1 }).then((t => { this.assets.textures.car1 = t })) } destroy() { this.enabled = !1 } } function ew() { const t = t => t && "object" == typeof t; for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)n[i] = arguments[i]; return n.reduce(((e, n) => (Object.keys(n).forEach((i => { const r = e[i], s = n[i]; Array.isArray(r) && Array.isArray(s) ? e[i] = r.concat(...s) : t(r) && t(s) ? e[i] = ew(r, s) : e[i] = s })), e)), {}) } class nw extends fr { constructor(t) { super({ vertexShader: "#define GLSLIFY 1\nattribute vec4 color;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\nvarying float vDistance;\nvarying vec3 vWorldPosition;\n\nuniform float uTime;\nuniform float uProgress;\nuniform float uRadius;\nuniform float uDistortion;\nuniform vec3 uMousePos;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main()    {\n    vUv = uv;\n    vColor = color;\n\n    vec3 startPos = vec3(0., 0., 0.);\n    vec3 finalPos = position;\n    float delay = color.r;\n\n    // Map tween progress\n    float mapProgress = map(uProgress, 0., 1., 0., 2.);\n\n    // Stagger using a color channel\n    float stag = mapProgress - color.r;\n    float am = uProgress * clamp(stag, 0., 1.);\n\n    vec3 interactPos = (modelMatrix * vec4(position.xyz, 1.0)).xyz;\n\n    // Mouse interaction (magic here)\n    vec3 mouseDir = normalize(uMousePos - cameraPosition);\n    vec3 camToWorld = interactPos - cameraPosition;\n    float distFromCam = dot(camToWorld, mouseDir);\n    vec3 p = interactPos - (cameraPosition + distFromCam * mouseDir);\n    float dist = length(p);\n    vec3 dir = p / dist;\n\n    // Create the mouse radius\n    dist = clamp(dist, 0., uRadius);\n    vDistance = dist;\n    vWorldPosition = (modelMatrix * vec4(position, 1.)).xyz;\n\n    // Mouse distortion\n    float distortion = map(dist, 0., uRadius, uDistortion, 0.);\n\n    // Create value to mix between start and finish\n    float value = am;\n\n    // Animate using value\n    vec3 transformedPosition = mix(startPos, finalPos, am);\n\n    // Overlay with mouse interaction\n    transformedPosition += dir * distortion;\n    // transformedPosition += (1. - smoothstep(-0.75, 0.75, d + 0.1)) * dir;\n\n    float pulse = map(cos(uTime + color.r * 2.), -1., 1., 0., 1.);\n    transformedPosition.xy = mix(transformedPosition.xy, transformedPosition.xy * 1.07, pulse);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformedPosition, 1.0);\n}\n", fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec4 vColor;\nvarying float vDistance;\nvarying vec3 vWorldPosition;\n\nuniform float uTime;\nuniform float uProgress;\nuniform sampler2D uDiffuse;\nuniform float uTexScale;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColorHover;\nuniform float uColorStrength;\nuniform float uColorSpeed;\nuniform float uColorAmplitude;\n\n//\tClassic Perlin 3D Noise\n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){ return mod(((x*34.0)+1.0)*x, 289.0); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec3 P){\n\tvec3 Pi0 = floor(P);// Integer part for indexing\n\tvec3 Pi1 = Pi0 + vec3(1.0);// Integer part + 1\n\tPi0 = mod(Pi0, 289.0);\n\tPi1 = mod(Pi1, 289.0);\n\tvec3 Pf0 = fract(P);// Fractional part for interpolation\n\tvec3 Pf1 = Pf0 - vec3(1.0);// Fractional part - 1.0\n\tvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\tvec4 iy = vec4(Pi0.yy, Pi1.yy);\n\tvec4 iz0 = Pi0.zzzz;\n\tvec4 iz1 = Pi1.zzzz;\n\n\tvec4 ixy = permute(permute(ix) + iy);\n\tvec4 ixy0 = permute(ixy + iz0);\n\tvec4 ixy1 = permute(ixy + iz1);\n\n\tvec4 gx0 = ixy0 / 7.0;\n\tvec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n\tgx0 = fract(gx0);\n\tvec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\tvec4 sz0 = step(gz0, vec4(0.0));\n\tgx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\tgy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\tvec4 gx1 = ixy1 / 7.0;\n\tvec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n\tgx1 = fract(gx1);\n\tvec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\tvec4 sz1 = step(gz1, vec4(0.0));\n\tgx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\tgy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n\tvec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n\tvec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n\tvec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n\tvec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n\tvec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n\tvec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n\tvec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n\tvec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n\tvec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\tg000 *= norm0.x;\n\tg010 *= norm0.y;\n\tg100 *= norm0.z;\n\tg110 *= norm0.w;\n\tvec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\tg001 *= norm1.x;\n\tg011 *= norm1.y;\n\tg101 *= norm1.z;\n\tg111 *= norm1.w;\n\n\tfloat n000 = dot(g000, Pf0);\n\tfloat n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\tfloat n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\tfloat n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\tfloat n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\tfloat n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\tfloat n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\tfloat n111 = dot(g111, Pf1);\n\n\tvec3 fade_xyz = fade(Pf0);\n\tvec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\tvec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\tfloat n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n\treturn 2.2 * n_xyz;\n}\n\nvoid main() {\n\tvec4 texture = texture2D(uDiffuse, vUv * uTexScale);\n\n\tvec3 finalColor = mix(uColor1, uColor2, vColor.r) + uColorStrength;\n\ttexture.rgb += cos(uTime * finalColor.r * uColorSpeed) * uColorAmplitude;\n\n\tfloat noise = cnoise(vec3(vWorldPosition.xy * 8., uTime * 0.5));\n\tnoise = clamp(0.6 + noise * .3, 0., 1.);\n\tfloat circle = smoothstep(noise, noise + 0.3, vDistance);\n\tfinalColor = mix(uColorHover, finalColor, circle);\n\tfloat alpha = mix(1., texture.r, circle);\n\n\t// Avoid having some fragments staying after we revert the progress (because of mouse distortion)\n\tfloat transparency = step(0.1, uProgress);\n\n\tgl_FragColor = vec4(finalColor, alpha * transparency);\n}\n", uniforms: (t = ew({ uniforms: { uTime: Fh.WebGL.globalUniforms.uTime, uProgress: { value: 0 }, uDiffuse: { value: null }, uTexScale: { value: 9 }, uMousePos: { value: new An(10, 10, 0) }, uRadius: { value: 1.5 }, uDistortion: { value: .07 }, uColor1: { value: new on(11279104) }, uColor2: { value: new on(16505975) }, uColorHover: { value: new on(11512639) }, uColorStrength: { value: 0 }, uColorSpeed: { value: 2 }, uColorAmplitude: { value: .2 } }, defines: {} }, t)).uniforms, transparent: !0, blending: t.additiveBlending ? b : A }) } } function iw(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function rw(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? iw(Object(n), !0).forEach((function (e) { sw(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : iw(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function sw(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class ow extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: rw({ uTime: Fh.WebGL.globalUniforms.uTime, uColor: { value: new on(16716800) }, uOpacity: { value: .53 }, uInnerRadius: { value: 1.99 }, uOuterRadius: { value: 1.67 }, uScale: { value: .36 } }, Fh.MainScene.components.fog.globalUniforms), defines: rw({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\n#include <fogParamsVert>\n\nvoid main() {\n    \n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n    vUv = uv;\n    \n    vec3 transformedPosition = position;\n    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz; // global coordinates\n    vLocalPos = position; // Local position\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    #include <fogOutputVert>\n\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\nuniform float uTime;\nuniform vec3 uColor;\nuniform float uOpacity;\nuniform float uInnerRadius;\nuniform float uOuterRadius;\nuniform float uScale;\n\n#include <fogParamsFrag>\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*uInnerRadius),\n                         _radius+(_radius*uOuterRadius),\n                         dot(dist,dist)*4.);\n}\n\nvoid main() {\n  // gl_FragColor = vec4(uColor, (1. - distance(vec2(0.5), vUv) * 2.) * uOpacity);\n  gl_FragColor = vec4(uColor, circle(vUv, uScale) * uOpacity);\n\n  #include <tonemapping_fragment>\n  \n  // Add fog\n  #include <fogOutputFrag>\n}", uniforms: t.uniforms, defines: t.defines, transparent: !0, blending: b, depthTest: !1 }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } const aw = new vn; function lw(t, e) { e ? t.isBufferGeometry ? (e[1] && t.applyQuaternion(aw.set(e[1][0], e[1][1], e[1][2], e[1][3])), e[0] && t.translate(e[0][0], e[0][1], e[0][2]), e[2] && t.scale(e[2][0], e[2][1], e[2][2])) : (e[0] && t.position.set(e[0][0], e[0][1], e[0][2]), e[1] && t.rotation.setFromQuaternion(aw.set(e[1][0], e[1][1], e[1][2], e[1][3])), e[2] && t.scale.set(e[2][0], e[2][1], e[2][2])) : console.error(`Data not found for object: ${t}`) } function hw(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class cw extends ar { constructor() { super(), hw(this, "updateMouse", (t => { this.current.lerp(Fh.pointer.glNormalized, this.options.mouseLerp * Fh.WebGL.normalizeDelta), this.mouseVector.set(this.current.x, this.current.y, .5), this.mouseVector.unproject(Fh.MainScene.camera), this.mouseVector.sub(Fh.MainScene.camera.position).normalize(); const e = this._vec3.copy(t.position).sub(Fh.MainScene.camera.position).dot(this.mouseVector); t.material.uniforms.uMousePos.value.copy(Fh.MainScene.camera.position).add(this.mouseVector.multiplyScalar(e)) })), hw(this, "show", (() => { var t; this.isHidden && (this.isHidden = !1, null === (t = this.toggleTl) || void 0 === t || t.kill(), this.toggleTl = mg.timeline({ defaults: { duration: this.options.animateInDuration, ease: tm.easeOut.config(this.options.revealEasing.amplitude, this.options.revealEasing.period), overwrite: !0 } }).to(this.material.uniforms.uProgress, { value: 1 }, 0).to(this.glowPlane.scale, { x: this.glowPlane.origScale, y: this.glowPlane.origScale, z: this.glowPlane.origScale }, 0).to(this.glowPlane.material.uniforms.uOpacity, { value: this.glowPlane.origOpacity }, 0).to(Fh.MainScene.components.reflectiveFloors.floors["base-top"].material.uniforms.uDiffuseRedAmount, { value: 1 }, 0)) })), hw(this, "hide", (() => { var t; this.isHidden || (this.isHidden = !0, null === (t = this.toggleTl) || void 0 === t || t.kill(), this.toggleTl = mg.timeline({ defaults: { duration: this.options.animateOutDuration, ease: tm.easeOut.config(this.options.revealEasing.amplitude, this.options.revealEasing.period), overwrite: !0 } }).to(this.material.uniforms.uProgress, { value: 0 }, 0).to(this.glowPlane.scale, { x: 0, y: 0, z: 0 }, 0).to(this.glowPlane.material.uniforms.uOpacity, { value: 0 }, 0).to(Fh.MainScene.components.reflectiveFloors.floors["base-top"].material.uniforms.uDiffuseRedAmount, { value: 0 }, 0)) })), hw(this, "onBeforeRender", (() => { this.isHidden || this.updateMouse(this) })), this.options = { mouseLerp: .1, animateInDuration: 5, animateOutDuration: 4, additiveBlending: !0, revealEasing: { amplitude: .57, period: .4 } }, this.isHidden = !1, this.mouseVector = new An, this.current = new He, this._vec3 = new An, ec.on("Logo:show", this.show), ec.on("Logo:hide", this.hide), this.load() } build(t) { this.geometry = this.assets.models.logo.geometry, this.material = new nw({ uniforms: { uDiffuse: { value: this.assets.textures.hex } }, additiveBlending: this.options.additiveBlending }), lw(this, t.objects.logo[0]), this.glowPlane = new ar(new Tr, new ow), this.glowPlane.scale.setScalar(9.68), this.glowPlane.origScale = this.glowPlane.scale.x, this.glowPlane.origOpacity = this.glowPlane.material.uniforms.uOpacity.value, this.glowPlane.position.y = .25, this.add(this.glowPlane) } animateIn() { this.timeline = mg.timeline().fromTo(this.material.uniforms.uProgress, { value: 0 }, { value: 1, duration: this.options.animateInDuration, ease: tm.easeOut.config(this.options.revealEasing.amplitude, this.options.revealEasing.period) }).fromTo(this.glowPlane.scale, { x: 0, y: 0, z: 0 }, { x: this.glowPlane.origScale, y: this.glowPlane.origScale, z: this.glowPlane.origScale, duration: this.options.animateInDuration, ease: tm.easeOut.config(this.options.revealEasing.amplitude, this.options.revealEasing.period) }, 0).fromTo(this.glowPlane.material.uniforms.uOpacity, { value: 0 }, { value: this.glowPlane.origOpacity, duration: this.options.animateInDuration, ease: tm.easeOut.config(this.options.revealEasing.amplitude, this.options.revealEasing.period) }, 0).fromTo(Fh.MainScene.components.reflectiveFloors.floors["base-top"].material.uniforms.uDiffuseRedAmount, { value: 0 }, { value: 1, duration: this.options.animateInDuration, ease: tm.easeOut.config(this.options.revealEasing.amplitude, this.options.revealEasing.period) }, 0) } load() { this.assets = { models: {}, textures: {} }, Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/logo.glb").then((t => { this.assets.models.logo = t.scene.children[0] })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/logo/logo-hex.ktx2", { wrapping: at }).then((t => { this.assets.textures.hex = t })) } } function uw(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function dw(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? uw(Object(n), !0).forEach((function (e) { pw(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : uw(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function pw(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class fw extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: dw({ uTime: Fh.WebGL.globalUniforms.uTime, uAnimate: { value: null }, uAnimateUp: { value: null }, uUseNoise: { value: !0 }, tRecText: { value: null }, tHexText: { value: null }, tMatCap: { value: null }, tWallsTex: { value: null }, tRailsTex: { value: null }, tRailsMaskTex: { value: null }, tWindowsTex: { value: null }, tPillarsTex: { value: null }, tRepeatedTexWalls: { value: null }, tRepeatedTexRails: { value: null }, tRepeatedTexWindows: { value: null }, tRepeatedTexPillars: { value: null }, uFloorIndex: { value: null } }, Fh.MainScene.components.fog.globalUniforms), defines: dw({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\n// All color attributes for each material\nattribute vec4 color;\nattribute vec4 color_1;\nattribute vec4 color_2;\nattribute vec4 color_3;\nattribute vec4 color_4;\n\n// Additional UV maps\nattribute vec2 uv2;\nattribute vec2 texcoord_2;\nattribute vec2 texcoord_3;\nattribute vec2 texcoord_4;\n\n// Values to be passed to fragment shader\nvarying vec3 vNormal;\nvarying vec3 vObjectNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\nvarying float vNoise;\n// UVs\nvarying vec2 vUv;\nvarying vec2 vUv1;\nvarying vec2 vUv2;\nvarying vec2 vUv3;\nvarying vec2 vUv4; // All UVs\n// Color attributes\nvarying vec4 c0_wall;\nvarying vec4 c1_rails;\nvarying vec4 c2_windows;\nvarying vec4 c3_pillars;\n\nuniform float uTime;\nuniform bool uAnimate;\nuniform float uProgress;\nuniform float uFloorIndex;\nuniform float uGroundFloorBegin;\nuniform float uOverallGradientSpread;\n\nuniform sampler2D tRecText;\nuniform float uRecTexScale;\n\nuniform int uVertDispType;\nuniform float uVertGradientSpread;\nuniform float uVertDispMult;\nuniform float uVertFalloffStart;\nuniform float uVertFalloffEnd;\nuniform float uVertNoiseSpeed;\nuniform float uVertNoiseScale;\nuniform float uVertNoiseStrength;\n\n// Fog params\n#include <fogParamsVert>\n\nvoid main()\t{\n    \n    vec3 objectNormal = vec3(normal);\n    vObjectNormal = objectNormal;\n    vec3 transformedNormal = objectNormal;\n    #ifdef USE_INSTANCING\n        mat3 m = mat3( instanceMatrix );\n        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n        transformedNormal = m * transformedNormal;\n    #endif\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n    \n    vUv = uv;\n    \n    vec3 transformedPosition = position;\n    vec4 pos = modelMatrix * vec4(position, 1.0);\n    vWorldPos = pos.xyz; // global coordinates\n    vLocalPos = position; // Local position\n\n    //Time\n    float time;\n    if (uAnimate) time = uTime;\n    else time = 0.0;\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    #ifdef USE_INSTANCING\n        mvPosition = instanceMatrix * mvPosition;\n    #endif\n\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    // Pass through\n    vUv1 = uv2;\n    vUv2 = texcoord_2;\n    vUv3 = texcoord_3;\n    vUv4 = texcoord_4;\n    c0_wall = color_2;\n    c1_rails = color_3; \n    c2_windows = color_4; \n    c3_pillars = color;\n\n    #include <fogOutputVert>\n\n}", fragmentShader: '#define GLSLIFY 1\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Passed through the vertex shader\n// UVs\nvarying vec2 vUv;\nvarying vec2 vUv1;\nvarying vec2 vUv2;\nvarying vec2 vUv3;\nvarying vec2 vUv4;\n// Color attributes\nvarying vec4 c0_wall;\nvarying vec4 c1_rails;\nvarying vec4 c2_windows;\nvarying vec4 c3_pillars;\n\nvarying vec3 vNormal;\nvarying vec3 vObjectNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos; // Global vertex position\nvarying vec3 vLocalPos; // Local vertex position\nvarying float vNoise;\n\n// Uniforms\nuniform float uTime;\nuniform bool uAnimate;\nuniform float uAnimateUp;\nuniform bool uUseNoise;\nuniform float uProgress; // Animation progress variable\nuniform float uFloorIndex;\nuniform float uGroundFloorBegin;\n\n// Baked Textures\nuniform sampler2D tMatCap;\nuniform sampler2D tWallsTex;\nuniform sampler2D tWindowsTex;\nuniform sampler2D tPillarsTex;\n// Detail textures\nuniform sampler2D tRepeatedTexWalls;\n// uniform sampler2D tRepeatedTexRails;\nuniform sampler2D tRailsMaskTex;\nuniform sampler2D tRepeatedTexWindows;\nuniform sampler2D tRepeatedTexPillars;\n\n// Masking textures\nuniform sampler2D tHexText; // Hex grid texture\nuniform sampler2D tRecText; // Recursive texture\nuniform float uHexTexScale;\nuniform float uRecTexScale;\n\n// Effect fine tuning uniforms\nuniform float uOverallGradientSpread;\nuniform float uEdgeTextureSubtractStrength; // Controls how much of the texture we subtract from the edge\nuniform float uFlameBandWidth; // How "thick" the flame is\nuniform float uFlameColorChangeOffset; // Where the flame colours change in the gradient\nuniform float uFlameColorGradientSpread; // How steeply or smoothly to interpolate between the flame colours\nuniform float uFlameStrength; // How bright the flame colour is\n\nuniform vec3 uFlameTopColor;\nuniform vec3 uFlameBottomColor;\n\nuniform float uFragNoiseSpeed;\nuniform float uFragNoiseScale;\nuniform float uFragNoiseStrength;\n\n// Balconies\nuniform int uBalconyBlendMode;\nuniform vec3 uBalconyBaseColorTop;\nuniform vec3 uBalconyBaseColorBottom;\nuniform float uBalconyAlphaBlend;\nuniform float uBalconyMaskAlphaMin;\nuniform float uBalconyMaskAlphaMax;\nuniform int uBalconyScanLinesBlendMode;\nuniform float uBalconyScanLinesSpeed;\nuniform float uBalconyScanLinesDensity;\nuniform float uBalconyScanLinesStrength;\nuniform float uBalconyScanLinesMaxDistance;\n\n#include <fogParamsFrag>\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvoid main() {\n\n  //Time\n  float time;\n  if (uAnimate) time = uTime * 1.;\n  else time = 0.0;\n\n  // matcap UVs\n  vec3 normal = normalize( vNormal );\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\n  float noise = 1.;\n  if (uUseNoise) {\n    noise = cnoise( vec3(vWorldPos.x * uFragNoiseScale, vWorldPos.y * uFragNoiseScale - time * uFragNoiseSpeed * uAnimateUp, vWorldPos.z * uFragNoiseScale) );\n  }\n\n  // Textures for masking\n  #ifdef IS_WALL\n\n    vec4 tHex = texture2D(tHexText, vUv4 * vec2(uHexTexScale)); // hex texture\n\n    // vec4 tHex = texture2D(tHexText, (vUv4+vec2(0.0, .0)) * vec2(uHexTexScale)); // hex texture\n    // vec4 tRecursive = texture2D(tRecText, (vUv4+vec2(0.0, time)) * vec2(uRecTexScale)); // Recursive subdivision texture\n  #else\n    vec4 tHex = texture2D(tHexText, vUv * vec2(uHexTexScale)); // hex texture\n  #endif\n\n  // Clamp to make it a bit brighter\n  float tHexClamped = clamp(tHex.r, 0.2, 1.0);\n\n  // Noise\n  // float sine = sin(2.5 * time + uv.y + vWorldPos.y - vWorldPos.x) * 0.15;\n\n  vec4 baseColor;\n  if (c0_wall.r > 0.0) {\n    // Sample walls\n    baseColor = vec4(blendSoftLight(texture2D(tWallsTex, vUv).rgb, texture2D(tRepeatedTexWalls, vUv * 35.).rgb, 1.), 1.0 );\n  } else if (c1_rails.r > 0.0) {\n    // Sample rails (balconies)\n\n    /**\n      Balconies material\n    */\n    // Mask alpha with the texture\n    // float balconyMask = clamp(texture2D(tRepeatedTexRails, vUv1 * 12.).r, uBalconyMaskAlphaMin, uBalconyMaskAlphaMax);\n    // Blend mask with gradient\n    float balconyGradient = texture2D(tRailsMaskTex, vUv1).r;\n    \n    // float alphaMask;\n    // if(uBalconyBlendMode == 0) {\n    //   alphaMask = vec4(blendOverlay( vec3(balconyGradient), vec3(balconyMask), uBalconyAlphaBlend ), 1.0).r;\n    // } else if(uBalconyBlendMode == 1) {\n    //   alphaMask = vec4(blendSoftLight( vec3(balconyGradient), vec3(balconyMask), uBalconyAlphaBlend ), 1.0).r;\n    // } else {\n    //   alphaMask = vec4(blendColorDodge( vec3(balconyGradient), vec3(balconyMask), uBalconyAlphaBlend ), 1.0).r;\n    // }\n    \n    //Base colour blend\n    // baseColor.rgb = mix(uBalconyBaseColorBottom, uBalconyBaseColorTop, balconyGradient);\n\n    vec3 scanLines = vec3( sin( ( fract(0.99) * uBalconyScanLinesDensity * vWorldPos.y + uTime * uBalconyScanLinesSpeed ) * 10. ));\n    scanLines *= (1.0 - smoothstep( 5., uBalconyScanLinesMaxDistance, distance(cameraPosition, vWorldPos) ) * 0.7 );\n    \n    vec3 scanCol;\n    if(uBalconyScanLinesBlendMode == 0) {\n      scanCol = blendOverlay(vec3(balconyGradient), scanLines, uBalconyScanLinesStrength);\n    } else if(uBalconyScanLinesBlendMode == 1) {\n      scanCol = blendSoftLight(vec3(balconyGradient), scanLines, uBalconyScanLinesStrength);\n    } else if(uBalconyScanLinesBlendMode == 2){\n      scanCol = blendColorDodge(vec3(balconyGradient), scanLines, uBalconyScanLinesStrength);\n    } else if(uBalconyScanLinesBlendMode == 3){\n      scanCol = vec3(balconyGradient) + scanLines * uBalconyScanLinesStrength;\n    } else {\n      scanCol = vec3(balconyGradient) - scanLines * uBalconyScanLinesStrength;\n    }\n\n    baseColor.rgb = mix(uBalconyBaseColorBottom, uBalconyBaseColorTop, scanCol.r);\n    baseColor = vec4(baseColor.rgb, balconyGradient);\n\n  } else if (c2_windows.r > 0.0) {\n    // Sample windows\n    baseColor = vec4( blendMultiply(texture2D(tWindowsTex, vUv2).rgb, texture2D(tRepeatedTexWindows, vUv2 * 4.).rgb, 0.1), 1.0 );\n    float windowMask = clamp(texture2D(tRepeatedTexWindows, vUv2 * 4.).r, 0.5, 0.7);\n    baseColor = vec4(baseColor.rgb, windowMask);\n  } else if (c3_pillars.r > 0.0) {\n    // Sample pillars\n    // baseColor = vec4(texture2D(tPillarsTex, vUv3).rgb, 1.0);\n    baseColor = vec4(blendSoftLight(texture2D(tPillarsTex, vUv3).rgb, texture2D(tRepeatedTexPillars, vUv3 * 9.).rgb, 1.), 1.0 );\n  } \n\n  float objectSize = 26.0 * 4.;\n  float initialRaiseInScene = 3.0;\n\n  float mappedY = map(vWorldPos.y, initialRaiseInScene, objectSize + initialRaiseInScene, 0.0, 1.0); // + 5.90779 because this is where the reveal box begins in the scene world coords.\n  float uProgressMapped = map(uProgress, 0.0, 1.0, 0.0, 1.0 + abs(uGroundFloorBegin));\n  float progress = uProgressMapped + uGroundFloorBegin;\n\n  float bottomEdge = mappedY - progress;\n  bottomEdge /= uOverallGradientSpread;\n  float topEdge = bottomEdge - uFlameBandWidth; // Top edge\n\n  // Gradient edge where the flame colours will change\n  // float colorChangeEdge = bottomEdge - uFlameColorChangeOffset - sin(vNoise + time * 10. + vWorldPos.x * 0.2) * 0.05; // Offset to control where the middle point is of the change\n  float colorChangeEdge = bottomEdge - uFlameColorChangeOffset - noise * uFragNoiseStrength;\n  float colorChangeEdgeSteepness = colorChangeEdge/uFlameColorGradientSpread;\n  float clampedColorChangeEdgeGradient = clamp(colorChangeEdgeSteepness, 0.0, 1.0); // Make sure to clamp the range before using it for colours\n\n  /** \n    Edge effects\n  */\n  // Bottom edge: flamed + sharp (no gradient) edge\n  // float flameBottomEdge = bottomEdge - tHex.r * uEdgeTextureSubtractStrength - sin(2. * uTime - (vWorldPos.y - vWorldPos.x) * 2.) * 0.01; // "flame" the edge line to add detail, this essentially flames it UP because it subtracts more\n  float flameBottomEdge = bottomEdge - tHex.r * uEdgeTextureSubtractStrength + noise * uFragNoiseStrength;\n  float flamedSharpEdge = step(0.0, flameBottomEdge); // make a sharp edge line instead of gradient, flamed; top part white, bottom black\n\n  // Top edge : flamed + sharp (no gradient) edge\n  float flameTopEdge = topEdge - tHex.r * uEdgeTextureSubtractStrength + noise * uFragNoiseStrength;\n  float flamedSharpTopEdge = step(0.0, flameTopEdge);\n\n  // Alpha masking\n  // Mask the desired top bit with textures\n  float texturedEdgeMask = flamedSharpEdge * (1.0 - tHexClamped * uFlameStrength); \n  // float texturedEdgeMask = flamedSharpEdge; \n  // Invert it so we can add another mask (the top edge mask)\n  float invertedTexturedEdgeMask = 1.0 - texturedEdgeMask;\n  // Mask layer 2: add mask width (aka top edge mask)\n  float texturedAlphaMask = invertedTexturedEdgeMask * (1.0 - flamedSharpTopEdge); // Use this for alpha ! // Flamed\n\n  // Apply final colours\n  vec4 layer1flameColor = vec4(mix(uFlameBottomColor, uFlameTopColor, clampedColorChangeEdgeGradient), 1.0);\n  vec4 overallColor = mix(baseColor, layer1flameColor, flamedSharpEdge); // Mask it with the base\n\n  // Apply matcaps\n  #ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( tMatCap, uv );\n\t#else\n\t  vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\t// vec3 outgoingLight = overallColor.rgb * matcapColor.rgb; \n\tvec4 outgoingLight = overallColor; // ignore matcaps for now\n\n  if (texturedAlphaMask * overallColor.a <= 0.) {\n    discard;\n  }\n\n  // Apply alpha mask\n  gl_FragColor = vec4(outgoingLight.rgb, texturedAlphaMask * overallColor.a);\n  // gl_FragColor = vec4(vec3(c.rgb), 1.0);\n\n  #include <tonemapping_fragment>\n  // Add fog\n  #include <fogOutputFrag>\n\n}', uniforms: t.uniforms, defines: t.defines, transparent: !1, side: m, blending: _, blendEquation: w, blendSrc: B, blendDst: L }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } function mw(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function gw(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? mw(Object(n), !0).forEach((function (e) { vw(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : mw(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function vw(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Aw extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: gw({ uProgress: { value: null }, uColor: { value: null }, uTexture: { value: null }, uRepeatTexture: { value: null } }, Fh.MainScene.components.fog.globalUniforms), defines: gw(gw({}, Fh.MainScene.components.fog.fogDefines), {}, { IS_PILLARS: !1 }) }, t), super({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n\nuniform float uProgress;\n\nattribute vec2 texcoord_3; // Pillars UV map\n\n#include <fogParamsVert>\n\nvoid main() {\n    \n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n    #ifdef IS_PILLARS\n        vUv = texcoord_3;\n    #else\n        vUv = uv;\n    #endif\n    \n    vec3 transformedPosition = position;\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    #include <fogOutputVert>\n\n}", fragmentShader: "#define GLSLIFY 1\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n\nuniform float uProgress;\nuniform vec3 uColor;\nuniform sampler2D uTexture; \nuniform sampler2D uRepeatTexture; \n\n#include <fogParamsFrag>\n\nvoid main() {\n\n    #ifdef USE_TEXTURE\n        #ifdef IS_PILLARS\n            vec4 diffuse = texture2D(uTexture, vUv);\n            gl_FragColor = vec4(blendSoftLight(diffuse.rgb, texture2D(uRepeatTexture, vUv * 15.).rgb, 1.), diffuse.a );\n        #else\n            gl_FragColor = texture2D(uTexture, vUv);\n        #endif\n    #else \n        gl_FragColor = vec4(uColor, 1.0);\n    #endif\n    \n    #include <tonemapping_fragment>\n    // Add fog\n    #include <fogOutputFrag>\n}", uniforms: t.uniforms, defines: t.defines, side: p }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } class bw extends ia { constructor() { super(), this.globalUniforms = { uProgress: { value: 0 }, uAnimate: { value: !0 }, uAnimateUpFlag: { value: !1 }, uUseNoise: { value: !0 }, uAnimateUp: { value: -1 }, uGroundFloorBegin: { value: -.076 }, uVertDispType: { value: 0 }, uVertDispMult: { value: 0 }, uVertGradientSpread: { value: .5 }, uVertFalloffStart: { value: .022 }, uVertFalloffEnd: { value: .609 }, uVertNoiseScale: { value: 2 }, uVertNoiseSpeed: { value: 2.5 }, uVertNoiseStrength: { value: .13 }, uHexTexScale: { value: 6 }, uRecTexScale: { value: .6 }, uOverallGradientSpread: { value: .13 }, uFlameBandWidth: { value: .462 }, uEdgeTextureSubtractStrength: { value: .253 }, uFlameColorGradientSpread: { value: .2 }, uFlameColorChangeOffset: { value: .2 }, uFlameStrength: { value: .75 }, uFlameTopColor: { value: new on(16765123) }, uFlameBottomColor: { value: new on(16752742) }, uFragNoiseScale: { value: 14.5 }, uFragNoiseSpeed: { value: 2.5 }, uFragNoiseStrength: { value: .04 }, uBalconyBaseColorTop: { value: new on(16764607) }, uBalconyBaseColorBottom: { value: new on(16743475) }, uBalconyScanLinesBlendMode: { value: 1 }, uBalconyScanLinesSpeed: { value: 1 }, uBalconyScanLinesDensity: { value: 10 }, uBalconyScanLinesStrength: { value: .25 }, uBalconyScanLinesMaxDistance: { value: 38 } }, this.load() } build(t) { this.meshes = { walls: {}, floors: {} }; for (const e in t.objects) e.startsWith("mb") && (this.meshes.walls[e] = this.assets.models.buildingWalls.clone(), this.meshes.walls[e].name = e.replace("mb", ""), this.add(this.meshes.walls[e])); this.meshes.floors.mb3 = this.assets.models.buildingFloor.clone(), this.meshes.floors.mb3.name = 3, this.add(this.meshes.floors.mb3), this.meshes.walls.mb0.renderOrder = 4, this.meshes.walls.mb1.renderOrder = 3, this.meshes.walls.mb2.renderOrder = 2, this.meshes.walls.mb3.renderOrder = 1; for (const e in this.meshes) for (const n in this.meshes[e]) { lw(this.meshes[e][n], t.objects[n][0]), "walls" !== e && (this.meshes[e][n].position.y -= .05); const i = this.meshes[e][n], r = this.meshes[e][n].name; i.material && (i.material = new fw({ uniforms: { tRecText: { value: Fh.MainScene.assets.textures.recursiveMask2 }, tHexText: { value: Fh.MainScene.assets.textures.hexTexture }, tMatCap: { value: Fh.MainScene.assets.textures.matcap }, tRepeatedTexWalls: { value: this.assets.textures.repeatWalls }, tRepeatedTexWindows: { value: this.assets.textures.repeatWindows }, tRepeatedTexPillars: { value: this.assets.textures.repeatPillars }, tWallsTex: { value: this.assets.textures[`wallsColor${r}`] || this.assets.textures.wallsColor0 }, tRailsMaskTex: { value: this.assets.textures.railsMask }, tWindowsTex: { value: this.assets.textures[`windowsColor${r}`] || this.assets.textures.windowsColor0 }, tPillarsTex: { value: this.assets.textures[`pillarsColor${r}`] || this.assets.textures.pillarsColor0 }, uFloorIndex: { value: r } }, globalUniforms: this.globalUniforms, defines: { USE_MATCAP: !0, IS_WALL: "walls" === e } })) } this.pillars = new ar(this.assets.models.pillars.geometry, new Aw({ uniforms: { uTexture: { value: this.assets.textures.pillarsColor0 }, uRepeatTexture: { value: this.assets.textures.repeatPillars } }, defines: { USE_TEXTURE: !0, IS_PILLARS: !0 } })), lw(this.pillars, t.objects.pilars[0]), this.add(this.pillars), this.baseSides = new ar(this.assets.models.baseSides.geometry, new Aw({ uniforms: { uTexture: { value: this.assets.textures.baseLightmap } }, defines: { USE_TEXTURE: !0 } })), lw(this.baseSides, t.objects["base-sides"][0]), this.add(this.baseSides) } hideFloors() { for (const t in this.meshes) for (const e in this.meshes[t]) { this.meshes[t][e].visible = !1 } } showFloors() { for (const t in this.meshes) for (const e in this.meshes[t]) { this.meshes[t][e].visible = !0 } } load() { this.assets = { models: {}, textures: {} }, Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/mb-walls.glb").then((t => { this.assets.models.buildingWalls = t.scene.children[0] })), Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/mb-topfloor.glb").then((t => { this.assets.models.buildingFloor = t.scene.children[0] })), Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/pilars.glb").then((t => { this.assets.models.pillars = t.scene.children[0] })), Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/base-sides.glb").then((t => { this.assets.models.baseSides = t.scene.children[0] })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/rails-mask.ktx2", { wrapping: at, flipY: !1 }).then((t => { this.assets.textures.railsMask = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/walls-2.ktx2", { wrapping: at }).then((t => { this.assets.textures.repeatWalls = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/windows.ktx2", { wrapping: at }).then((t => { this.assets.textures.repeatWindows = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/pilars.ktx2", { wrapping: at }).then((t => { this.assets.textures.repeatPillars = t })); for (let t = 0; t < 4; t++)Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + `webgl/images/mb${t}-walls-lightmap.ktx2`, { wrapping: at, flipY: !1, encoding: be }).then((e => { this.assets.textures[`wallsColor${t}`] = e })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + `webgl/images/mb${t}-windows-lightmap.ktx2`, { wrapping: at, flipY: !1, encoding: be }).then((e => { this.assets.textures[`windowsColor${t}`] = e })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + `webgl/images/mb${t}-pilars-lightmap.ktx2`, { wrapping: at, flipY: !1, encoding: be }).then((e => { this.assets.textures[`pillarsColor${t}`] = e })); Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/base-lightmap.ktx2", { flipY: !1, encoding: be }).then((t => { this.assets.textures.baseLightmap = t })) } } function yw(t, e = !1) { const n = null !== t[0].index, i = new Set(Object.keys(t[0].attributes)), r = new Set(Object.keys(t[0].morphAttributes)), s = {}, o = {}, a = t[0].morphTargetsRelative, l = new qi; let h = 0; for (let c = 0; c < t.length; ++c) { const u = t[c]; let d = 0; if (n !== (null !== u.index)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null; for (const t in u.attributes) { if (!i.has(t)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + '. All geometries must have compatible attributes; make sure "' + t + '" attribute exists among all geometries, or in none of them.'), null; void 0 === s[t] && (s[t] = []), s[t].push(u.attributes[t]), d++ } if (d !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". Make sure all geometries have the same number of attributes."), null; if (a !== u.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". .morphTargetsRelative must be consistent throughout all geometries."), null; for (const t in u.morphAttributes) { if (!r.has(t)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ".  .morphAttributes must be consistent throughout all geometries."), null; void 0 === o[t] && (o[t] = []), o[t].push(u.morphAttributes[t]) } if (e) { let t; if (n) t = u.index.count; else { if (void 0 === u.attributes.position) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". The geometry must have either an index or a position attribute"), null; t = u.attributes.position.count } l.addGroup(h, t, c), h += t } } if (n) { let e = 0; const n = []; for (let i = 0; i < t.length; ++i) { const r = t[i].index; for (let t = 0; t < r.count; ++t)n.push(r.getX(t) + e); e += t[i].attributes.position.count } l.setIndex(n) } for (const t in s) { const e = xw(s[t]); if (!e) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + t + " attribute."), null; l.setAttribute(t, e) } for (const t in o) { const e = o[t][0].length; if (0 === e) break; l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[t] = []; for (let n = 0; n < e; ++n) { const e = []; for (let i = 0; i < o[t].length; ++i)e.push(o[t][i][n]); const i = xw(e); if (!i) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + t + " morphAttribute."), null; l.morphAttributes[t].push(i) } } return l } function xw(t) { let e, n, i, r = 0; for (let s = 0; s < t.length; ++s) { const o = t[s]; if (o.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null; if (void 0 === e && (e = o.array.constructor), e !== o.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null; if (void 0 === n && (n = o.itemSize), n !== o.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null; if (void 0 === i && (i = o.normalized), i !== o.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null; r += o.array.length } const s = new e(r); let o = 0; for (let e = 0; e < t.length; ++e)s.set(t[e].array, o), o += t[e].array.length; return new Ri(s, n, i) } function _w(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function ww(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? _w(Object(n), !0).forEach((function (e) { Ew(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _w(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Ew(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Cw extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: ww({ uProgress: { value: 0 }, uGradientSpread: { value: .015 }, uGroundFloorBegin: { value: 1.74 }, uHexTexScale: { value: 16 }, uRecTexScale: { value: 4 } }, Fh.MainScene.components.fog.globalUniforms), defines: ww({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPos;\nvarying vec3 vViewPosition;\n\nuniform float uProgress;\n\n#include <fogParamsVert>\n\nvoid main()\t{\n\n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    #ifdef USE_INSTANCING\n        mat3 m = mat3( instanceMatrix );\n        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n        transformedNormal = m * transformedNormal;\n    #endif\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n    \n    vUv = uv;\n    \n    vec3 transformedPosition = position;\n    vWorldPos = vec4( modelMatrix * vec4(position, 1.0) ).xyz; // World coordinates to use for the reveal\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    #ifdef USE_INSTANCING\n        mvPosition = instanceMatrix * mvPosition;\n    #endif\n\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    #include <fogOutputVert>\n}", fragmentShader: "#define GLSLIFY 1\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPos;\nvarying vec3 vViewPosition;\n\nuniform float uProgress;\nuniform float uGradientSpread;\nuniform float uGroundFloorBegin;\n\nuniform sampler2D uColorTexture;\nuniform sampler2D uRepeatTexture;\n// Masking textures\nuniform sampler2D tHexText; // Hex grid texture\nuniform sampler2D tRecText; // Recursive texture\nuniform float uHexTexScale;\nuniform float uRecTexScale;\n\n#include <fogParamsFrag>\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n\n    vec4 baseColor = vec4(blendSoftLight(texture2D(uColorTexture, vUv).rgb, texture2D(uRepeatTexture, vUv * 15.).rgb, 1.), 1.0 );\n    vec4 tHex = texture2D(tHexText, vUv * vec2(uHexTexScale)); // hex texture\n    float tHexClamped = clamp(tHex.r, 0.2, 1.0);\n    vec4 tRecursive = texture2D(tRecText, vUv * vec2(uRecTexScale)); // Recursive subdivision texture\n    float tRecursiveClamped = clamp(tRecursive.r, 0.2, 1.0); // Multiply to make it a bit brighter\n\n    float mappedWorldY = map(vWorldPos.y, 3. + uGroundFloorBegin, 26. * 4., 0., 1.); // Map across the whole main building \n    float edge = mappedWorldY - uProgress; \n    edge /= uGradientSpread;\n\n    float flameEdge = edge - tHex.r * tRecursiveClamped;\n    float flamedSharpEdge = step(flameEdge, 0.0);\n\n    if (flamedSharpEdge < 1.) {\n      discard;\n    }\n\n    gl_FragColor = vec4(baseColor.rgb, 1.);\n\n    #include <tonemapping_fragment>\n\n    #include <fogOutputFrag>\n\n}", uniforms: t.uniforms, defines: t.defines }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } } class Sw extends ia { constructor() { super(), this.meshes = [], this.globalUniforms = { uProgress: { value: 0 } }, this.load() } build(t) { for (const e in this.assets.models) t[e].sort(((t, e) => t[0][1] - e[0][1])); for (let e = 0; e < 8; e++) { const n = []; for (const i in this.assets.models) { const r = this.assets.models[`${i}`].geometry.clone(); lw(r, t[i][e]), n.push(r) } this.meshes[e] = new ar(yw(n, !1), new Cw({ uniforms: { tRecText: { value: Fh.MainScene.assets.textures.recursiveMask2 }, tHexText: { value: Fh.MainScene.assets.textures.hexTexture }, uColorTexture: { value: this.assets.textures[`p${e}`] }, uRepeatTexture: { value: this.assets.textures.repeatTexture } }, globalUniforms: this.globalUniforms })), this.add(this.meshes[e]) } } load() { this.assets = { models: {}, textures: {} }; for (let t = 0; t < 8; t++)Fh.AssetLoader.loadGltf(Fh.publicUrl + `webgl/models/p${t}.glb`).then((e => { this.assets.models[`p${t}`] = e.scene.children[0] })); for (let t = 0; t < 8; t++)Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + `webgl/images/people-L${t}-lightmap.ktx2`, { wrapping: at, flipY: !1, encoding: be }).then((e => { this.assets.textures[`p${t}`] = e })); Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/people.ktx2", { wrapping: at, flipY: !1, encoding: be }).then((t => { this.assets.textures.repeatTexture = t })) } } const Mw = new xn, Pw = new An; class Iw extends ah { constructor() { super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry"; this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new Ui([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new Ui([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2)) } applyMatrix4(t) { const e = this.attributes.instanceStart, n = this.attributes.instanceEnd; return void 0 !== e && (e.applyMatrix4(t), n.applyMatrix4(t), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } setPositions(t) { let e; t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t)); const n = new Ah(e, 6, 1); return this.setAttribute("instanceStart", new fa(n, 3, 0)), this.setAttribute("instanceEnd", new fa(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this } setColors(t) { let e; t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t)); const n = new Ah(e, 6, 1); return this.setAttribute("instanceColorStart", new fa(n, 3, 0)), this.setAttribute("instanceColorEnd", new fa(n, 3, 3)), this } fromWireframeGeometry(t) { return this.setPositions(t.attributes.position.array), this } fromEdgesGeometry(t) { return this.setPositions(t.attributes.position.array), this } fromMesh(t) { return this.fromWireframeGeometry(new dl(t.geometry)), this } fromLineSegments(t) { const e = t.geometry; return this.setPositions(e.attributes.position.array), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new xn); const t = this.attributes.instanceStart, e = this.attributes.instanceEnd; void 0 !== t && void 0 !== e && (this.boundingBox.setFromBufferAttribute(t), Mw.setFromBufferAttribute(e), this.boundingBox.union(Mw)) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new Un), null === this.boundingBox && this.computeBoundingBox(); const t = this.attributes.instanceStart, e = this.attributes.instanceEnd; if (void 0 !== t && void 0 !== e) { const n = this.boundingSphere.center; this.boundingBox.getCenter(n); let i = 0; for (let r = 0, s = t.count; r < s; r++)Pw.fromBufferAttribute(t, r), i = Math.max(i, n.distanceToSquared(Pw)), Pw.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(Pw)); this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } } toJSON() { } applyMatrix(t) { return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(t) } } class Tw extends Iw { constructor() { super(), this.isLineGeometry = !0, this.type = "LineGeometry" } setPositions(t) { const e = t.length - 3, n = new Float32Array(2 * e); for (let i = 0; i < e; i += 3)n[2 * i] = t[i], n[2 * i + 1] = t[i + 1], n[2 * i + 2] = t[i + 2], n[2 * i + 3] = t[i + 3], n[2 * i + 4] = t[i + 4], n[2 * i + 5] = t[i + 5]; return super.setPositions(n), this } setColors(t) { const e = t.length - 3, n = new Float32Array(2 * e); for (let i = 0; i < e; i += 3)n[2 * i] = t[i], n[2 * i + 1] = t[i + 1], n[2 * i + 2] = t[i + 2], n[2 * i + 3] = t[i + 3], n[2 * i + 4] = t[i + 4], n[2 * i + 5] = t[i + 5]; return super.setColors(n), this } fromLine(t) { const e = t.geometry; return this.setPositions(e.attributes.position.array), this } } Br.line = { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new He(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, Lr.line = { uniforms: pr.merge([Br.common, Br.fog, Br.line]), vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t", fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t" }; class Dw extends fr { constructor(t) { super({ type: "LineMaterial", uniforms: pr.clone(Lr.line.uniforms), vertexShader: Lr.line.vertexShader, fragmentShader: Lr.line.fragmentShader, clipping: !0 }), this.isLineMaterial = !0, Object.defineProperties(this, { color: { enumerable: !0, get: function () { return this.uniforms.diffuse.value }, set: function (t) { this.uniforms.diffuse.value = t } }, worldUnits: { enumerable: !0, get: function () { return "WORLD_UNITS" in this.defines }, set: function (t) { !0 === t ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS } }, linewidth: { enumerable: !0, get: function () { return this.uniforms.linewidth.value }, set: function (t) { this.uniforms.linewidth.value = t } }, dashed: { enumerable: !0, get: function () { return Boolean("USE_DASH" in this.defines) }, set(t) { Boolean(t) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), !0 === t ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH } }, dashScale: { enumerable: !0, get: function () { return this.uniforms.dashScale.value }, set: function (t) { this.uniforms.dashScale.value = t } }, dashSize: { enumerable: !0, get: function () { return this.uniforms.dashSize.value }, set: function (t) { this.uniforms.dashSize.value = t } }, dashOffset: { enumerable: !0, get: function () { return this.uniforms.dashOffset.value }, set: function (t) { this.uniforms.dashOffset.value = t } }, gapSize: { enumerable: !0, get: function () { return this.uniforms.gapSize.value }, set: function (t) { this.uniforms.gapSize.value = t } }, opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (t) { this.uniforms.opacity.value = t } }, resolution: { enumerable: !0, get: function () { return this.uniforms.resolution.value }, set: function (t) { this.uniforms.resolution.value.copy(t) } }, alphaToCoverage: { enumerable: !0, get: function () { return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) }, set: function (t) { Boolean(t) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), !0 === t ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1) } } }), this.setValues(t) } } const Bw = new An, Lw = new An, Fw = new pn, kw = new pn, Rw = new pn, Ow = new An, Nw = new Yn, Uw = new class { constructor(t = new An, e = new An) { this.start = t, this.end = e } set(t, e) { return this.start.copy(t), this.end.copy(e), this } copy(t) { return this.start.copy(t.start), this.end.copy(t.end), this } getCenter(t) { return t.addVectors(this.start, this.end).multiplyScalar(.5) } delta(t) { return t.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(t, e) { return this.delta(e).multiplyScalar(t).add(this.start) } closestPointToPointParameter(t, e) { yh.subVectors(t, this.start), xh.subVectors(this.end, this.start); const n = xh.dot(xh); let i = xh.dot(yh) / n; return e && (i = ke(i, 0, 1)), i } closestPointToPoint(t, e, n) { const i = this.closestPointToPointParameter(t, e); return this.delta(n).multiplyScalar(i).add(this.start) } applyMatrix4(t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this } equals(t) { return t.start.equals(this.start) && t.end.equals(this.end) } clone() { return (new this.constructor).copy(this) } }, zw = new An, Vw = new xn, Qw = new Un, Gw = new pn; let Hw, jw; function Ww(t, e, n) { return Gw.set(0, 0, -e, 1).applyMatrix4(t.projectionMatrix), Gw.multiplyScalar(1 / Gw.w), Gw.x = jw / n.width, Gw.y = jw / n.height, Gw.applyMatrix4(t.projectionMatrixInverse), Gw.multiplyScalar(1 / Gw.w), Math.abs(Math.max(Gw.x, Gw.y)) } class qw extends ar { constructor(t = new Iw, e = new Dw({ color: 16777215 * Math.random() })) { super(t, e), this.isLineSegments2 = !0, this.type = "LineSegments2" } computeLineDistances() { const t = this.geometry, e = t.attributes.instanceStart, n = t.attributes.instanceEnd, i = new Float32Array(2 * e.count); for (let t = 0, r = 0, s = e.count; t < s; t++, r += 2)Bw.fromBufferAttribute(e, t), Lw.fromBufferAttribute(n, t), i[r] = 0 === r ? 0 : i[r - 1], i[r + 1] = i[r] + Bw.distanceTo(Lw); const r = new Ah(i, 2, 1); return t.setAttribute("instanceDistanceStart", new fa(r, 1, 0)), t.setAttribute("instanceDistanceEnd", new fa(r, 1, 1)), this } raycast(t, e) { const n = this.material.worldUnits, i = t.camera; null !== i || n || console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'); const r = void 0 !== t.params.Line2 && t.params.Line2.threshold || 0; Hw = t.ray; const s = this.matrixWorld, o = this.geometry, a = this.material; let l, h; if (jw = a.linewidth + r, null === o.boundingSphere && o.computeBoundingSphere(), Qw.copy(o.boundingSphere).applyMatrix4(s), n) l = .5 * jw; else { l = Ww(i, Math.max(i.near, Qw.distanceToPoint(Hw.origin)), a.resolution) } if (Qw.radius += l, !1 !== Hw.intersectsSphere(Qw)) { if (null === o.boundingBox && o.computeBoundingBox(), Vw.copy(o.boundingBox).applyMatrix4(s), n) h = .5 * jw; else { h = Ww(i, Math.max(i.near, Vw.distanceToPoint(Hw.origin)), a.resolution) } Vw.expandByScalar(h), !1 !== Hw.intersectsBox(Vw) && (n ? function (t, e) { const n = t.matrixWorld, i = t.geometry, r = i.attributes.instanceStart, s = i.attributes.instanceEnd; for (let o = 0, a = Math.min(i.instanceCount, r.count); o < a; o++) { Uw.start.fromBufferAttribute(r, o), Uw.end.fromBufferAttribute(s, o), Uw.applyMatrix4(n); const i = new An, a = new An; Hw.distanceSqToSegment(Uw.start, Uw.end, a, i), a.distanceTo(i) < .5 * jw && e.push({ point: a, pointOnLine: i, distance: Hw.origin.distanceTo(a), object: t, face: null, faceIndex: o, uv: null, uv2: null }) } }(this, e) : function (t, e, n) { const i = e.projectionMatrix, r = t.material.resolution, s = t.matrixWorld, o = t.geometry, a = o.attributes.instanceStart, l = o.attributes.instanceEnd, h = Math.min(o.instanceCount, a.count), c = -e.near; Hw.at(1, Rw), Rw.w = 1, Rw.applyMatrix4(e.matrixWorldInverse), Rw.applyMatrix4(i), Rw.multiplyScalar(1 / Rw.w), Rw.x *= r.x / 2, Rw.y *= r.y / 2, Rw.z = 0, Ow.copy(Rw), Nw.multiplyMatrices(e.matrixWorldInverse, s); for (let e = 0, o = h; e < o; e++) { if (Fw.fromBufferAttribute(a, e), kw.fromBufferAttribute(l, e), Fw.w = 1, kw.w = 1, Fw.applyMatrix4(Nw), kw.applyMatrix4(Nw), Fw.z > c && kw.z > c) continue; if (Fw.z > c) { const t = Fw.z - kw.z, e = (Fw.z - c) / t; Fw.lerp(kw, e) } else if (kw.z > c) { const t = kw.z - Fw.z, e = (kw.z - c) / t; kw.lerp(Fw, e) } Fw.applyMatrix4(i), kw.applyMatrix4(i), Fw.multiplyScalar(1 / Fw.w), kw.multiplyScalar(1 / kw.w), Fw.x *= r.x / 2, Fw.y *= r.y / 2, kw.x *= r.x / 2, kw.y *= r.y / 2, Uw.start.copy(Fw), Uw.start.z = 0, Uw.end.copy(kw), Uw.end.z = 0; const o = Uw.closestPointToPointParameter(Ow, !0); Uw.at(o, zw); const h = Ge.lerp(Fw.z, kw.z, o), u = h >= -1 && h <= 1, d = Ow.distanceTo(zw) < .5 * jw; if (u && d) { Uw.start.fromBufferAttribute(a, e), Uw.end.fromBufferAttribute(l, e), Uw.start.applyMatrix4(s), Uw.end.applyMatrix4(s); const i = new An, r = new An; Hw.distanceSqToSegment(Uw.start, Uw.end, r, i), n.push({ point: r, pointOnLine: i, distance: Hw.origin.distanceTo(r), object: t, face: null, faceIndex: e, uv: null, uv2: null }) } } }(this, i, e)) } } } class Yw extends qw { constructor(t = new Tw, e = new Dw({ color: 16777215 * Math.random() })) { super(t, e), this.isLine2 = !0, this.type = "Line2" } } function Xw(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function Kw(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? Xw(Object(n), !0).forEach((function (e) { Jw(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Xw(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function Jw(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class Zw extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: Kw({ uProgress: { value: null }, uTime: Fh.WebGL.globalUniforms.uTime, uColor1: { value: null }, uColor2: { value: null }, uFloorIndex: { value: null }, vertexColors: { value: !1 }, worldUnits: { value: !0 }, resolution: { value: null }, dashed: { value: !1 }, dashScale: { value: 1 }, dashSize: { value: 1 }, dashOffset: { value: 0 }, gapSize: { value: 1 }, opacity: { value: 1 } }, Fh.MainScene.components.fog.globalUniforms), defines: Kw({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vFakeUv;\nvarying float vAlpha;\n// Reveal\nuniform float uProgress;\nuniform float uGradientSpread;\n\n#include <fogParamsVert>\n\n// Line material\n#include <common>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nuniform float linewidth;\nuniform vec2 resolution;\nattribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nvarying vec4 worldPos;\nvarying vec3 worldStart;\nvarying vec3 worldEnd;\n#ifdef USE_DASH\n    uniform float dashScale;\n    attribute float instanceDistanceStart;\n    attribute float instanceDistanceEnd;\n    varying float vLineDistance;\n#endif\n\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\n    // trim end segment so it terminates between the camera plane and the near plane\n    // conservative estimate of the near plane\n    float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n    float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n    float nearEstimate = - 0.5 * b / a;\n    float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n    end.xyz = mix( start.xyz, end.xyz, alpha );\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nmat4 inverseMat4(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main() {\n    \n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    \n    #ifdef USE_COLOR\n        vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n    #endif\n    #ifdef USE_DASH\n        vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n    #endif\n    float aspect = resolution.x / resolution.y;\n    vUv = uv;\n    // camera space\n    vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n    vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n    worldStart = start.xyz;\n    worldEnd = end.xyz;\n    // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n    // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n    // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n    // perhaps there is a more elegant solution -- WestLangley\n    bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n    if ( perspective ) {\n        if ( start.z < 0.0 && end.z >= 0.0 ) {\n            trimSegment( start, end );\n        } else if ( end.z < 0.0 && start.z >= 0.0 ) {\n            trimSegment( end, start );\n        }\n    }\n    // clip space\n    vec4 clipStart = projectionMatrix * start;\n    vec4 clipEnd = projectionMatrix * end;\n    // ndc space\n    vec3 ndcStart = clipStart.xyz / clipStart.w;\n    vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n    // direction\n    vec2 dir = ndcEnd.xy - ndcStart.xy;\n    // account for clip-space aspect ratio\n    dir.x *= aspect;\n    dir = normalize( dir );\n\n    #ifdef WORLD_UNITS\n        // get the offset direction as perpendicular to the view vector\n        vec3 worldDir = normalize( end.xyz - start.xyz );\n        vec3 offset;\n        if ( position.y < 0.5 ) {\n            offset = normalize( cross( start.xyz, worldDir ) );\n        } else {\n            offset = normalize( cross( end.xyz, worldDir ) );\n        }\n        // sign flip\n        if ( position.x < 0.0 ) offset *= - 1.0;\n        float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        #ifndef USE_DASH\n            // extend the line bounds to encompass  endcaps\n            start.xyz += - worldDir * linewidth * 0.5;\n            end.xyz += worldDir * linewidth * 0.5;\n            // shift the position of the quad so it hugs the forward edge of the line\n            offset.xy -= dir * forwardOffset;\n            offset.z += 0.5;\n        #endif\n        // endcaps\n        if ( position.y > 1.0 || position.y < 0.0 ) {\n            offset.xy += dir * 2.0 * forwardOffset;\n        }\n        // adjust for linewidth\n        offset *= linewidth * 0.5;\n        // set the world position\n        worldPos = ( position.y < 0.5 ) ? start : end;\n        worldPos.xyz += offset;\n        // project the worldpos\n        vec4 clip = projectionMatrix * worldPos;\n        // shift the depth of the projected points so the line\n        // segements overlap neatly\n        vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n        clip.z = clipPose.z * clip.w;\n    #else\n    vec2 offset = vec2( dir.y, - dir.x );\n    // undo aspect ratio adjustment\n    dir.x /= aspect;\n    offset.x /= aspect;\n    // sign flip\n    if ( position.x < 0.0 ) offset *= - 1.0;\n    // endcaps\n    if ( position.y < 0.0 ) {\n        offset += - dir;\n    } else if ( position.y > 1.0 ) {\n        offset += dir;\n    }\n    // adjust for linewidth\n    offset *= linewidth;\n    // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n    offset /= resolution.y;\n    // select end\n    vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n    // back to clip space\n    offset *= clip.w;\n    clip.xy += offset;\n    #endif\n    gl_Position = clip;\n    vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n    // Reveal\n    vec3 myWorldPos = (inverseMat4(viewMatrix) * worldPos).xyz;\n    vec3 myLocalPos = (inverseMat4(modelViewMatrix) * worldPos).xyz;\n    vec3 transformedPosition = position;\n\n    float objectSize = 26.0 * 4.;\n    float mappedY = map(myWorldPos.y, 0.0, objectSize, 0.0, 1.0);\n    float mappedX = map(myWorldPos.x, -11.5, 11.5, 0.0, 1.0);\n    float mappedZ = map(myWorldPos.z, -11.5, 11.5, 0.0, 1.0);\n\n    float bottomEdge = mappedY - uProgress;\n    bottomEdge /= uGradientSpread;\n    bottomEdge = clamp(bottomEdge,0.0, 1.0);\n    bottomEdge = 1.0 - bottomEdge;\n\n    vAlpha = bottomEdge; // Send the alpha to the fragment to be nicely interpolated\n    vFakeUv = vec3(mappedX, mappedY, mappedZ); // Send a \"UV\" to the fragment to get a gradient between 0 and 1 on XY\n\n    // #include <logdepthbuf_vertex>\n    // #include <clipping_planes_vertex>\n    #include <fogOutputVert>\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec3 vFakeUv;\nvarying float vAlpha;\n\n// Animated colour gradient\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform float uTime;\nuniform float uFloorIndex;\nuniform float uBlendFrequency;\nuniform float uBlendSpeed;\n\n#include <fogParamsFrag>\n\n// Line material\nuniform float opacity;\nuniform float linewidth;\n\n#ifdef USE_DASH\n  uniform float dashOffset;\n  uniform float dashSize;\n  uniform float gapSize;\n#endif\nvarying float vLineDistance;\n#ifdef WORLD_UNITS\n  varying vec4 worldPos;\n  varying vec3 worldStart;\n  varying vec3 worldEnd;\n  #ifdef USE_DASH\n    varying vec2 vUv;\n  #endif\n#else\n  varying vec2 vUv;\n#endif\n#include <common>\n// #include <color_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nfloat randomOffset(vec3 value, float index) {\n  return (0.5 + 0.5 * cos(value.x) + fract(value.z)) * abs(value.x) * (index + 1.0);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  float mua;\n  float mub;\n  vec3 p13 = p1 - p3;\n  vec3 p43 = p4 - p3;\n  vec3 p21 = p2 - p1;\n  float d1343 = dot( p13, p43 );\n  float d4321 = dot( p43, p21 );\n  float d1321 = dot( p13, p21 );\n  float d4343 = dot( p43, p43 );\n  float d2121 = dot( p21, p21 );\n  float denom = d2121 * d4343 - d4321 * d4321;\n  float numer = d1343 * d4321 - d1321 * d4343;\n  mua = numer / denom;\n  mua = clamp( mua, 0.0, 1.0 );\n  mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n  mub = clamp( mub, 0.0, 1.0 );\n  return vec2( mua, mub );\n}\n\nvoid main() {\n  // #include <clipping_planes_fragment>\n  #ifdef USE_DASH\n    if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n    if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n  #endif\n  float alpha = opacity;\n  #ifdef WORLD_UNITS\n    // Find the closest points on the view ray and the line segment\n    vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n    vec3 lineDir = worldEnd - worldStart;\n    vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n    vec3 p1 = worldStart + lineDir * params.x;\n    vec3 p2 = rayEnd * params.y;\n    vec3 delta = p1 - p2;\n    float len = length( delta );\n    float norm = len / linewidth;\n    #ifndef USE_DASH\n      #ifdef USE_ALPHA_TO_COVERAGE\n        float dnorm = fwidth( norm );\n        alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n      #else\n        if ( norm > 0.5 ) {\n          discard;\n        }\n      #endif\n    #endif\n  #else\n    #ifdef USE_ALPHA_TO_COVERAGE\n      // artifacts appear on some hardware if a derivative is taken within a conditional\n      float a = vUv.x;\n      float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n      float len2 = a * a + b * b;\n      float dlen = fwidth( len2 );\n      if ( abs( vUv.y ) > 1.0 ) {\n        alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n      }\n    #else\n      if ( abs( vUv.y ) > 1.0 ) {\n        float a = vUv.x;\n        float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n        float len2 = a * a + b * b;\n        if ( len2 > 1.0 ) discard;\n      }\n    #endif\n  #endif\n  \n  // #include <logdepthbuf_fragment>\n\n  if (vAlpha < 0.05) {\n    discard;\n  }\n\n  float sinMix = 0.5 + 0.5 * sin(vFakeUv.y * uBlendFrequency + randomOffset(vFakeUv, uFloorIndex) - uTime * uBlendSpeed);\n  vec3 baseColor = mix(uColor1, uColor2, sinMix );\n  gl_FragColor = vec4( baseColor, alpha * vAlpha );\n\n  #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  // Add fog\n  #include <fogOutputFrag>\n  // #include <premultiplied_alpha_fragment>\n  \n}", uniforms: t.uniforms, defines: t.defines, transparent: !1, blending: _, blendEquation: w, blendSrc: B, blendDst: L }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } class $w extends ia { constructor() { super(), this._v = new An, this.globalUniforms = { uProgress: { value: 0 }, uGradientSpread: { value: .03 }, linewidth: { value: .06 }, uBlendFrequency: { value: 20 }, uBlendSpeed: { value: 1.8 } }, this.load() } build(t) { this.paths = { curves: {}, pipes: {} }; const e = Object.keys(t.paths).filter((t => t.startsWith("pip") && t.indexOf("city") < 0)).sort(((t, e) => t.replace("pip", "") - e.replace("pip", ""))).reduce(((e, n) => (e[n] = t.paths[n], e)), {}); for (const t in e) { const n = [], i = Math.floor(Object.keys(e).indexOf(t) / 4); for (let i = 0; i < e[t][0].length; i++) { const r = e[t][0][i]; n.push(r[0], r[1], r[2]) } const r = new Tw; r.setPositions(n); const s = new He; Fh.WebGL.renderer.getSize(s), this.paths.pipes[t] = new Yw(r, new Zw({ uniforms: { uColor1: Fh.MainScene.options.pipes.uColor1, uColor2: Fh.MainScene.options.pipes.uColor2, uFloorIndex: { value: i }, resolution: { value: s } }, globalUniforms: this.globalUniforms, defines: { WORLD_UNITS: "" } })), this.paths.pipes[t].computeLineDistances(), this.add(this.paths.pipes[t]) } } load() { this.assets = { models: {}, textures: {} } } } function tE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function eE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? tE(Object(n), !0).forEach((function (e) { nE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : tE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function nE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class iE extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: eE({ uDiffuse: { value: null }, uBaseLod: { value: 2 }, uDistortionAmount: { value: .02 }, uReflectionOpacity: { value: .587 }, uReflectionLighten: { value: .783 }, uRoughnessTexture: { value: null }, uNormalTexture: { value: null }, uRoughnessScale: { value: 7.18 }, uConcreteScale: { value: 7.18 }, uWallsTexture: { value: null }, uMaskTexture: { value: null }, uDiffuseRedAmount: { value: 1 } }, Fh.MainScene.components.fog.globalUniforms), defines: eE({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nattribute vec2 uv2;\n\nvarying vec4 vMirrorCoord;\nvarying vec2 vUv;\nvarying vec2 vUv2;\n\nuniform mat4 uTextureMatrix;\n\n#include <fogParamsVert>\n\nvoid main () {\n\tvec3 transformedPosition = position;\n\n\tvUv = uv;\n\tvUv2 = uv2;\n\n\tvMirrorCoord = uTextureMatrix * vec4( transformedPosition, 1.0 );\n\n\tvec4 mvPosition = vec4( transformedPosition, 1.0 );\n\tmvPosition = modelViewMatrix * mvPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <fogOutputVert>\n}", fragmentShader: '#define GLSLIFY 1\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvarying vec4 vMirrorCoord;\nvarying vec2 vUv;\nvarying vec2 vUv2;\n\nuniform sampler2D uDiffuse;\nuniform sampler2D uRoughnessTexture;\nuniform sampler2D uNormalTexture;\nuniform sampler2D uWallsTexture;\nuniform sampler2D uMaskTexture;\nuniform float uRoughnessScale;\nuniform float uConcreteScale;\nuniform sampler2D uTexture;\nuniform vec2 uMipmapTextureSize;\nuniform float uBaseLod;\nuniform float uDistortionAmount;\nuniform float uReflectionOpacity;\nuniform float uReflectionLighten;\nuniform float uDiffuseRedAmount;\n\n#include <fogParamsFrag>\n\nvec4 cubic(float v) {\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w);\n}\n\n// https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\nvec4 textureBicubic(sampler2D t, vec2 texCoords, vec2 textureSize) {\n   vec2 invTexSize = 1.0 / textureSize;\n   texCoords = texCoords * textureSize - 0.5;\n\n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2 (-0.5, 1.5).xyxy;\n\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\n    offset *= invTexSize.xxyy;\n\n    vec4 sample0 = texture2D(t, offset.xz);\n    vec4 sample1 = texture2D(t, offset.yz);\n    vec4 sample2 = texture2D(t, offset.xw);\n    vec4 sample3 = texture2D(t, offset.yw);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(\n       mix(sample3, sample2, sx), mix(sample1, sample0, sx)\n    , sy);\n}\n\n// With original size argument\nvec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level, vec2 originalPixelSize ) {\n    float floatLevel = float( level );\n    vec2 atlasSize;\n    atlasSize.x = floor( originalPixelSize.x * 1.5 );\n    atlasSize.y = originalPixelSize.y;\n    \n    // we stop making mip maps when one dimension == 1\n    \n    float maxLevel = min( floor( log2( originalPixelSize.x ) ), floor( log2( originalPixelSize.y ) ) );\n    floatLevel = min( floatLevel, maxLevel );\n    \n    // use inverse pow of 2 to simulate right bit shift operator\n    \n    vec2 currentPixelDimensions = floor( originalPixelSize / pow( 2.0, floatLevel ) );\n    vec2 pixelOffset = vec2(\n    floatLevel > 0.0 ? originalPixelSize.x : 0.0, floatLevel > 0.0 ? currentPixelDimensions.y : 0.0\n    );\n    \n    // "minPixel / atlasSize" samples the top left piece of the first pixel\n    // "maxPixel / atlasSize" samples the bottom right piece of the last pixel\n    vec2 minPixel = pixelOffset;\n    vec2 maxPixel = pixelOffset + currentPixelDimensions;\n    vec2 samplePoint = mix( minPixel, maxPixel, uv );\n    samplePoint /= atlasSize;\n    vec2 halfPixelSize = 1.0 / ( 2.0 * atlasSize );\n    samplePoint = min( samplePoint, maxPixel / atlasSize - halfPixelSize );\n    samplePoint = max( samplePoint, minPixel / atlasSize + halfPixelSize );\n    return textureBicubic( tex, samplePoint, originalPixelSize );\n}\n\nvec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level, vec2 originalPixelSize ) {\n    float ratio = mod( level, 1.0 );\n    int minLevel = int( floor( level ) );\n    int maxLevel = int( ceil( level ) );\n    vec4 minValue = packedTexture2DLOD( tex, uv, minLevel, originalPixelSize );\n    vec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel, originalPixelSize );\n    return mix( minValue, maxValue, ratio );\n}\n\nvoid main() {\n    vec3 floorDiffuse = texture2D(uDiffuse, vUv).rgb;\n    floorDiffuse.r *= uDiffuseRedAmount;\n\n    vec2 reflectionUv = vMirrorCoord.xy / vMirrorCoord.w;\n    float lod = uBaseLod;\n\n    vec2 roughnessUv = vUv * uRoughnessScale;\n    float roughness = texture2D(uRoughnessTexture, roughnessUv).r;\n\n    vec3 floorNormal = texture2D(uNormalTexture, vUv * uRoughnessScale).rgb * 2. - 1.;\n    floorNormal = normalize(floorNormal);\n\n    vec3 color = packedTexture2DLOD(uTexture, reflectionUv + floorNormal.xy * uDistortionAmount, roughness * uBaseLod, uMipmapTextureSize).rgb;\n\n    // mix with base texture color\n    color = blendLinearLight(color, floorDiffuse, uReflectionLighten);\n    color = blendSoftLight(color, texture2D(uWallsTexture, vUv * uConcreteScale).rgb, roughness);\n    color = mix(floorDiffuse, color, uReflectionOpacity);\n    \n    gl_FragColor = vec4(color, 1.0);\n    gl_FragColor.rgb = mix(floorDiffuse, gl_FragColor.rgb, texture2D(uMaskTexture, vUv2).r);\n\n    #include <tonemapping_fragment>\n\n    // Add fog\n    #include <fogOutputFrag>\n}', uniforms: t.uniforms, defines: t.defines }) } } class rE { get camera() { return this._camera } get material() { return this._mesh.material } set material(t) { this._mesh.material = t } constructor(t) { const e = new Vr(-1, 1, 1, -1, 0, 1), n = new Tr(2, 2); this._mesh = new ar(n, t), this._camera = e } dispose() { this._mesh.geometry.dispose() } render(t) { t.render(this._mesh, this._camera) } } class sE { constructor() { this.material = new fr({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n    #include <begin_vertex>\n    #include <project_vertex>\n    vUv = uv;\n}", fragmentShader: '#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform sampler2D map;\nuniform int parentLevel;\nuniform vec2 parentMapSize;\nuniform vec2 originalMapSize;\n\n// With original size argument\nvec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level, vec2 originalPixelSize ) {\n\n    float floatLevel = float( level );\n    vec2 atlasSize;\n    atlasSize.x = floor( originalPixelSize.x * 1.5 );\n    atlasSize.y = originalPixelSize.y;\n\n    // we stop making mip maps when one dimension == 1\n    float maxLevel = min( floor( log2( originalPixelSize.x ) ), floor( log2( originalPixelSize.y ) ) );\n    floatLevel = min( floatLevel, maxLevel );\n\n    // use inverse pow of 2 to simulate right bit shift operator\n    vec2 currentPixelDimensions = floor( originalPixelSize / pow( 2.0, floatLevel ) );\n    vec2 pixelOffset = vec2(\n        floatLevel > 0.0 ? originalPixelSize.x : 0.0,\n        floatLevel > 0.0 ? currentPixelDimensions.y : 0.0\n    );\n\n    // "minPixel / atlasSize" samples the top left piece of the first pixel\n    // "maxPixel / atlasSize" samples the bottom right piece of the last pixel\n    vec2 minPixel = pixelOffset;\n    vec2 maxPixel = pixelOffset + currentPixelDimensions;\n    vec2 samplePoint = mix( minPixel, maxPixel, uv );\n    samplePoint /= atlasSize;\n\n    vec2 halfPixelSize = 1.0 / ( 2.0 * atlasSize );\n    samplePoint = min( samplePoint, maxPixel / atlasSize - halfPixelSize );\n    samplePoint = max( samplePoint, minPixel / atlasSize + halfPixelSize );\n\n    return texture2D( tex, samplePoint );\n\n}\n\n#define SAMPLES 6\n\nvec4 sampleAt( vec2 uv ) {\n    return packedTexture2DLOD( map, uv, parentLevel, originalMapSize );\n}\n\nvoid main() {\n\n    vec2 childMapSize = parentMapSize / 2.0;\n    vec2 childPixelPos = floor( vUv * childMapSize );\n\n    vec2 parentPixelSize = 1.0 / parentMapSize;\n    vec2 halfParentPixelSize = parentPixelSize / 2.0;\n    vec2 parentPixelPos = childPixelPos * 2.0;\n\n    vec2 baseUv = ( parentPixelPos / parentMapSize ) + halfParentPixelSize;\n\n    vec4 samples[ SAMPLES ];\n    float weights[ SAMPLES ];\n\n    float xden = 2.0 * parentMapSize.x + 1.0;\n    float wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;\n    float wx1 = ( parentMapSize.x ) / xden;\n    float wx2 = ( parentPixelPos.x + 1.0 ) / xden;\n\n    float yden = 2.0 * parentMapSize.y + 1.0;\n    float wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;\n    float wy1 = ( parentMapSize.y ) / yden;\n    float wy2 = ( parentPixelPos.y + 1.0 ) / yden;\n\n    samples[ 0 ] = sampleAt( baseUv );\n    samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );\n    samples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );\n\n    samples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );\n    samples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );\n    samples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );\n\n    // samples[ 6 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );\n    // samples[ 7 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n    // samples[ 8 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 2.0 * parentPixelSize.y ) );\n\n    weights[ 0 ] = wx0 * wy0;\n    weights[ 1 ] = wx1 * wy0;\n    weights[ 2 ] = wx2 * wy0;\n\n    weights[ 3 ] = wx0 * wy1;\n    weights[ 4 ] = wx1 * wy1;\n    weights[ 5 ] = wx2 * wy1;\n\n    // weights[ 6 ] = wx0 * wy2;\n    // weights[ 7 ] = wx1 * wy2;\n    // weights[ 8 ] = wx2 * wy2;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < SAMPLES; i ++ ) {\n        gl_FragColor += samples[ i ] * weights[ i ];\n    }\n}', uniforms: { map: { value: null }, originalMapSize: { value: new He }, parentMapSize: { value: new He }, parentLevel: { value: 0 } } }), this.swapTarget = new fn, this.swapTarget.texture.minFilter = ct, this.swapTarget.texture.magFilter = ct, this.copyQuad = new rE(new fl({ vertexShader: "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0 );\n}", fragmentShader: "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nvarying vec2 vUv;\n\nvoid main () {\n    gl_FragColor = texture2D(uTexture, vUv);\n}\n", uniforms: { uTexture: { value: null } }, depthTest: !1, depthWrite: !1, blending: v })), this.mipQuad = new rE(this.material), this.size = new He, this.targetSize = new He, this.maxMipMapLevel = 1 } resize(t, e) { const n = Math.floor(t.x), i = Math.floor(t.y); this.size.set(n, i), this.targetSize.set(Math.floor(1.5 * this.size.x), this.size.y), e.setSize(this.targetSize.x, this.targetSize.y), this.swapTarget.setSize(this.targetSize.x, this.targetSize.y) } update(t, e, n) { const i = n.autoClear, r = n.getRenderTarget(); n.autoClear = !1, this.copyQuad.material.uniforms.uTexture.value = t, n.setRenderTarget(this.swapTarget), this.copyQuad.render(n); let s = this.size.x, o = this.size.y, a = 0; for (; s > this.maxMipMapLevel && o > this.maxMipMapLevel;) { this.material.uniforms.map.value = this.swapTarget.texture, this.material.uniforms.parentLevel.value = a, this.material.uniforms.parentMapSize.value.set(s, o), this.material.uniforms.originalMapSize.value.set(this.size.x, this.size.y), s = Math.floor(s / 2), o = Math.floor(o / 2); const t = this.targetSize.y - 2 * o; n.setRenderTarget(e), this.mipQuad.camera.setViewOffset(s, o, -this.size.x, -t, this.targetSize.x, this.targetSize.y), this.mipQuad.render(n), n.setRenderTarget(this.swapTarget), this.material.uniforms.map.value = e.texture, this.mipQuad.render(n), a++ } n.setRenderTarget(r), n.autoClear = i } dispose() { this.swapTarget.dispose(), this.mipQuad.dispose(), this.copyQuad.dispose() } } function oE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class aE extends ar { constructor(t, e, n) { super(t, e), oE(this, "onResize", (() => { this.textureSize.set(.5 * Fh.window.w, .5 * Fh.window.fullHeight), this.mipmapper.resize(this.textureSize, this.renderTarget) })), this.name = n, this.ignoreObjects = [], this.renderReflection = !0, this.camera = null, this.scene = null, this.sceneCamera = null, this.reflectorPlane = new Er, this.normal = new An, this.reflectorWorldPosition = new An, this.cameraWorldPosition = new An, this.rotationMatrix = new Yn, this.lookAtPosition = new An(0, 0, -1), this.clipPlane = new pn, this.view = new An, this.target = new An, this.q = new pn, this.textureSize = new He(.25 * Fh.window.w, .25 * Fh.window.fullHeight), this.textureMatrix = new Yn, this.renderTarget = new fn(this.textureSize.x, this.textureSize.y, { minFilter: pt }), this.mipmapper = new sE, this.mipmapper.resize(this.textureSize, this.renderTarget), this.material.uniforms.uTextureMatrix = { value: this.textureMatrix }, this.material.uniforms.uTexture = { value: this.renderTarget.texture }, this.material.uniforms.uMipmapTextureSize = { value: this.mipmapper.targetSize }, this.matrixAutoUpdate = !1, this.renderCount = 0, ec.on(ic.RESIZE, this.onResize) } onBeforeRender() { if (this.renderCount++, this.reflectorWorldPosition.setFromMatrixPosition(this.matrixWorld), this.cameraWorldPosition.setFromMatrixPosition(this.sceneCamera.matrixWorld), this.rotationMatrix.extractRotation(this.matrixWorld), this.rotationMatrix.makeRotationX(Ge.degToRad(-90)), this.normal.set(0, 0, 1), this.normal.applyMatrix4(this.rotationMatrix), this.view.subVectors(this.reflectorWorldPosition, this.cameraWorldPosition), this.view.dot(this.normal) > 0) return; this.view.reflect(this.normal).negate(), this.view.add(this.reflectorWorldPosition), this.rotationMatrix.extractRotation(this.sceneCamera.matrixWorld), this.lookAtPosition.set(0, 0, -1), this.lookAtPosition.applyMatrix4(this.rotationMatrix), this.lookAtPosition.add(this.cameraWorldPosition), this.target.subVectors(this.reflectorWorldPosition, this.lookAtPosition), this.target.reflect(this.normal).negate(), this.target.add(this.reflectorWorldPosition), this.camera.position.copy(this.view), this.camera.up.set(0, 1, 0), this.camera.up.applyMatrix4(this.rotationMatrix), this.camera.up.reflect(this.normal), this.camera.lookAt(this.target), this.camera.far = this.sceneCamera.far, this.camera.updateMatrixWorld(), this.camera.projectionMatrix.copy(this.sceneCamera.projectionMatrix), this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.camera.projectionMatrix), this.textureMatrix.multiply(this.camera.matrixWorldInverse), this.textureMatrix.multiply(this.matrixWorld), this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal, this.reflectorWorldPosition), this.reflectorPlane.applyMatrix4(this.camera.matrixWorldInverse), this.clipPlane.set(this.reflectorPlane.normal.x, this.reflectorPlane.normal.y, this.reflectorPlane.normal.z, this.reflectorPlane.constant); const t = this.camera.projectionMatrix; if (this.q.x = (Math.sign(this.clipPlane.x) + t.elements[8]) / t.elements[0], this.q.y = (Math.sign(this.clipPlane.y) + t.elements[9]) / t.elements[5], this.q.z = -1, this.q.w = (1 + t.elements[10]) / t.elements[14], this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(this.q)), t.elements[2] = this.clipPlane.x, t.elements[6] = this.clipPlane.y, t.elements[10] = this.clipPlane.z + 1 - .003, t.elements[14] = this.clipPlane.w, this.renderCount % 2 != 0) { this.visible = !1; for (let t = 0; t < this.ignoreObjects.length; t++)this.ignoreObjects[t].visible = !1; if (this.renderReflection) { const t = Fh.WebGL.renderer.getRenderTarget(); Fh.WebGL.renderer.setRenderTarget(this.renderTarget), Fh.WebGL.renderer.setViewport(0, 0, this.textureSize.x / Fh.WebGL.renderer.getPixelRatio(), this.textureSize.y / Fh.WebGL.renderer.getPixelRatio()), Fh.WebGL.renderer.setScissor(0, 0, this.textureSize.x, this.textureSize.y), Fh.WebGL.renderer.setScissorTest(!0), Fh.WebGL.renderer.clear(!0), Fh.WebGL.renderer.render(this.scene, this.camera), Fh.WebGL.renderer.setRenderTarget(null), Fh.WebGL.renderer.setViewport(0, 0, Fh.window.w, Fh.window.fullHeight), Fh.WebGL.renderer.setScissor(0, 0, Fh.window.w, Fh.window.fullHeight), Fh.WebGL.renderer.setRenderTarget(t), this.mipmapper.update(this.renderTarget.texture, this.renderTarget, Fh.WebGL.renderer) } this.visible = !0; for (let t = 0; t < this.ignoreObjects.length; t++)this.ignoreObjects[t].visible = !0 } } updateCameraScene(t, e) { this.sceneCamera = t, this.camera = t.clone(), this.scene = e } clearIgnoreObjects() { this.ignoreObjects = [] } destroy() { this.renderTarget.dispose(), this.geometry.dispose(), this.material.dispose(), ec.off(ic.RESIZE, this.onResize) } } class lE extends aE { constructor(t, e, n, i, r, s, o, a, l, h) { super(t.clone(), new iE(h), a), this.startPos = l.start, this.stopPos = l.stop, this.material.uniforms.uRoughnessTexture.value = n, this.material.uniforms.uNormalTexture.value = i, this.material.uniforms.uWallsTexture.value = r, this.material.uniforms.uDiffuse.value = e, s && (this.material.uniforms.uMaskTexture.value = s), this.geometry.computeBoundingBox(), this.geometry.computeBoundingSphere(), lw(this, o), this.updateMatrix(), this.updateMatrixWorld(), this.updateCameraScene(Fh.MainScene.camera, Fh.MainScene) } onBeforeRender() { Fh.MainScene.options.scrollPosition < this.startPos || Fh.MainScene.options.scrollPosition > this.stopPos || super.onBeforeRender() } } class hE extends ia { constructor() { super(), this.load() } build(t) { this.assets.models.baseTop.geometry.attributes.uv2 = this.assets.models.baseTop.geometry.getAttribute("uv"), this.floors = { "base-top": new lE(this.assets.models.baseTop.geometry, this.assets.textures.baseLightmap, this.assets.textures.wallsRoughness, this.assets.textures.wallsNormal, this.assets.textures.walls, this.assets.textures.baseMask, t.objects["base-top"][0], "base-top", { start: 0, stop: .14 }, { uniforms: { uBaseLod: { value: 3 }, uDistortionAmount: { value: .1 }, uReflectionOpacity: { value: .6 }, uReflectionLighten: { value: .15 }, uRoughnessScale: { value: 7.62 }, uConcreteScale: { value: 7.62 } } }), mb0: new lE(this.assets.models.buildingFloor.geometry, this.assets.textures.wallsColor0, this.assets.textures.wallsRoughness, this.assets.textures.wallsNormal, this.assets.textures.walls, this.assets.textures.mask, t.objects.mb0[0], "mb0", { start: .1401, stop: .372 }, { uniforms: { uBaseLod: { value: 5 }, uDistortionAmount: { value: .1522 }, uReflectionOpacity: { value: .5 }, uReflectionLighten: { value: .087 }, uRoughnessScale: { value: 18.49 }, uConcreteScale: { value: 23.92 } } }), mb1: new lE(this.assets.models.buildingFloor.geometry, this.assets.textures.wallsColor1, this.assets.textures.wallsRoughness, this.assets.textures.wallsNormal, this.assets.textures.walls, this.assets.textures.mask, t.objects.mb1[0], "mb1", { start: .3721, stop: .624 }, { uniforms: { uBaseLod: { value: 5 }, uDistortionAmount: { value: .1 }, uReflectionOpacity: { value: .739 }, uReflectionLighten: { value: .489 }, uRoughnessScale: { value: 33.7 }, uConcreteScale: { value: 32 } } }), mb2: new lE(this.assets.models.buildingFloor.geometry, this.assets.textures.wallsColor2, this.assets.textures.wallsRoughness, this.assets.textures.wallsNormal, this.assets.textures.walls, this.assets.textures.mask, t.objects.mb2[0], "mb2", { start: 0, stop: .92 }, { uniforms: { uBaseLod: { value: 5 }, uDistortionAmount: { value: .2174 }, uReflectionOpacity: { value: .457 }, uReflectionLighten: { value: .848 }, uRoughnessScale: { value: 46.74 }, uConcreteScale: { value: 32 } } }) }; for (const t in this.floors) this.floors[t].ignoreObjects.push(Fh.MainScene.components.towers), this.floors[t].ignoreObjects.push(Fh.MainScene.components.signs), this.floors[t].ignoreObjects.push(Fh.MainScene.components.bridges), this.floors[t].ignoreObjects.push(Fh.MainScene.components.pipes), this.floors[t].ignoreObjects.push(Fh.MainScene.components.cityPipes), this.floors[t].ignoreObjects.push(Fh.MainScene.components.cars), this.floors[t].ignoreObjects.push(Fh.MainScene.components.worldFloor), this.floors[t].ignoreObjects.push(Fh.MainScene.components.particles); this.floors["base-top"].ignoreObjects.push(this.floors.mb0, this.floors.mb1, this.floors.mb2), this.floors.mb0.ignoreObjects.push(this.floors["base-top"], this.floors.mb1, this.floors.mb2), this.floors.mb1.ignoreObjects.push(this.floors["base-top"], this.floors.mb0, this.floors.mb2), this.floors.mb2.ignoreObjects.push(this.floors["base-top"], this.floors.mb0, this.floors.mb1); for (const t in this.floors) this.add(this.floors[t]) } load() { this.assets = { models: {}, textures: {} }, Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/base-top.glb").then((t => { this.assets.models.baseTop = t.scene.children[0] })), Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/mb-topfloor.glb").then((t => { this.assets.models.buildingFloor = t.scene.children[0] })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/mb0-walls-lightmap.ktx2", { wrapping: at, flipY: !1, encoding: be }).then((t => { this.assets.textures.wallsColor0 = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/mb1-walls-lightmap.ktx2", { wrapping: at, flipY: !1, encoding: be }).then((t => { this.assets.textures.wallsColor1 = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/mb2-walls-lightmap.ktx2", { wrapping: at, flipY: !1, encoding: be }).then((t => { this.assets.textures.wallsColor2 = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/base-lightmap.ktx2", { flipY: !1, encoding: be }).then((t => { this.assets.textures.baseLightmap = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/base-top-mask.ktx2", { flipY: !1 }).then((t => { this.assets.textures.baseMask = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/mb-topfloor-mask.ktx2", { flipY: !1 }).then((t => { this.assets.textures.mask = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/walls-2.ktx2", { wrapping: at }).then((t => { this.assets.textures.walls = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/walls-2-Normal.ktx2", { wrapping: at }).then((t => { this.assets.textures.wallsNormal = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/walls-2-Roughness.ktx2", { wrapping: at }).then((t => { this.assets.textures.wallsRoughness = t })) } } class cE extends fr { constructor(t) { let { enableAdditiveBlending: e, distortion: n, uniforms: i, globalUniforms: r } = t; super({ uniforms: { uTime: Fh.WebGL.globalUniforms.uTime, uDistortion: { value: n }, uProgress: { value: 0 }, uMousePos: { value: new An(10, 10, 10) }, uHeight: { value: 0 }, uParticleStrength: { value: .08 }, dashScale: { value: 1 }, dashSize: { value: 1 }, dashOffset: { value: 0 }, gapSize: { value: 1 }, opacity: { value: 1 } }, vertexShader: "#define GLSLIFY 1\nuniform float uTime;\nuniform float uProgress;\nuniform vec3 uMousePos;\nuniform float uHeight;\nuniform float uDisplace;\nuniform float uMouseSize;\nuniform float uMouseStrength;\n\nattribute vec3 aRandom;\nattribute float aScale;\nattribute vec3 aCenterPoint;\n\nvarying vec2 vUv;\nvarying float vD;\nvarying float vAlpha;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main(){\n    vUv = uv;\n\n    vec3 newPos = position;\n    newPos *= aScale;\n\n    vec3 up = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);\n    vec3 right = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);\n    newPos = right * newPos.x + up * newPos.y;\n\n\t#ifdef USE_INSTANCING\n\t\tnewPos = (instanceMatrix * vec4(newPos, 1.0)).xyz;\n\t#endif\n\n\tvec3 worldPos = vec4(modelMatrix * vec4(newPos, 1.)).xyz;\n\n\tfloat mappedWorldY = map(worldPos.y, 10., 26. * 4., 0., 1.); // Map across the whole main building\n\tfloat edge =  uProgress - mappedWorldY;\n\tedge /= 0.07;\n\tedge = clamp(edge, 0., 1.);\n\n\t// Map tween progress\n\tfloat mappedY = map(newPos.y, 0., uHeight, 0., 1.);\n\tfloat mapProgress = map(edge, 0., 1., 0., 2.);\n\tfloat stag = mapProgress - mappedY;\n\tfloat am = edge * clamp(stag, 0., 1.);\n\n\tvAlpha = am;\n\n\tvec3 randomPos = newPos + aRandom;\n\n    // rotate\n\trandomPos.x += sin(uTime * aScale + aRandom.x * 100.) * uDisplace;\n\trandomPos.y -= cos(uTime * aScale + aRandom.y * 100.) * uDisplace;\n\n\tfloat floatingOffset = sin(uTime * 0.7) * 0.04;\n\n    vec3 interactPos = (modelMatrix * vec4(aCenterPoint, 1.0)).xyz;\n\n    // mouse interaction\n    vec3 mouseDir = normalize(uMousePos - cameraPosition);\n    vec3 camToWorld = interactPos - cameraPosition;\n    float distFromCam = dot(camToWorld, mouseDir);\n    vec3 p = interactPos - (cameraPosition + distFromCam * mouseDir);\n\tp /= uMouseSize;\n    float d = length(p);\n    vec3 dir = p / d;\n\tdir *= uMouseStrength;\n\n    // displace\n\trandomPos += smoothstep(0.75, -0.75, d + 0.1) * dir;\n\n\tnewPos = mix(newPos, randomPos, am);\n\n\tvD = d;\n\n    vec4 mvPosition = modelMatrix * vec4(newPos, 1.0);\n\n    mvPosition = viewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n}\n", fragmentShader: "#define GLSLIFY 1\nuniform vec3 uParticlesColor;\nuniform float uGroundFloorBegin;\nuniform float uProgress;\nuniform float uParticleStrength;\n\nvarying vec2 vUv;\nvarying float vD;\nvarying float vAlpha;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n\tfloat distanceToCenter = distance(vUv, vec2(0.5));\n\tfloat mouseAffect = 1. - smoothstep(0.5, 1., vD) + 0.5;\n\t// TODO: Checking with Tiago what suits better\n\t//float strength = 1. - smoothstep(0.9, 0.901, distanceToCenter);\n\tfloat strength = uParticleStrength / distanceToCenter - (uParticleStrength * 2.);\n\n\t// TODO: Checking with Tiago what suits better\n\t//gl_FragColor = vec4(uParticlesColor, strength * 3. * mouseAffect * 0.5 * vAlpha);\n\tgl_FragColor = vec4(uParticlesColor, strength * vAlpha);\n\n\t#include <tonemapping_fragment>\n}\n", transparent: !0, depthWrite: !1, blending: e ? b : A }), this.localUniforms = i, this.globalUniforms = r, this.uniforms = Object.assign(this.uniforms, this.localUniforms), this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } } function uE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function dE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? uE(Object(n), !0).forEach((function (e) { pE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : uE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function pE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class fE extends fr { constructor(t) { let { enableAdditiveBlending: e, uniforms: n, globalUniforms: i } = t; super({ uniforms: dE({ uTime: Fh.WebGL.globalUniforms.uTime, uProgress: { value: 0 }, uMousePos: { value: new An(10, 10, 10) }, uHeight: { value: 0 }, worldUnits: { value: 1 }, uParticleStrength: { value: .08 }, dashScale: { value: 1 }, dashSize: { value: 1 }, dashOffset: { value: 0 }, gapSize: { value: 1 }, opacity: { value: 1 }, uShapeWorldPosition: { value: 0 } }, Fh.MainScene.components.fog.globalUniforms), defines: dE(dE({}, Fh.MainScene.components.fog.fogDefines), {}, { WORLD_UNITS: "" }), vertexShader: "#define GLSLIFY 1\nvarying float vMappedWorldY;\nvarying float vAlpha;\n\nuniform float uProgress;\nuniform float uHeight;\nuniform float uTime;\nuniform vec3 uShapeWorldPosition;\n\n#include <fogParamsVert>\n\n#include <common>\n#include <color_pars_vertex>\n//#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// line material base\nuniform float linewidth;\nuniform vec2 resolution;\nattribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nvarying vec4 worldPos;\nvarying vec3 worldStart;\nvarying vec3 worldEnd;\nvarying vec2 vUv;\n\n#ifdef USE_DASH\n\tuniform float dashScale;\n\tattribute float instanceDistanceStart;\n\tattribute float instanceDistanceEnd;\n\tvarying float vLineDistance;\n#endif\n\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t// conservative estimate of the near plane\n\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\tfloat nearEstimate = - 0.5 * b / a;\n\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nmat4 inverseMat4(mat4 m) {\n\tfloat\n\ta00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n\ta10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n\ta20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n\ta30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n\tb00 = a00 * a11 - a01 * a10,\n\tb01 = a00 * a12 - a02 * a10,\n\tb02 = a00 * a13 - a03 * a10,\n\tb03 = a01 * a12 - a02 * a11,\n\tb04 = a01 * a13 - a03 * a11,\n\tb05 = a02 * a13 - a03 * a12,\n\tb06 = a20 * a31 - a21 * a30,\n\tb07 = a20 * a32 - a22 * a30,\n\tb08 = a20 * a33 - a23 * a30,\n\tb09 = a21 * a32 - a22 * a31,\n\tb10 = a21 * a33 - a23 * a31,\n\tb11 = a22 * a33 - a23 * a32,\n\n\tdet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n\treturn mat4(\n\ta11 * b11 - a12 * b10 + a13 * b09,\n\ta02 * b10 - a01 * b11 - a03 * b09,\n\ta31 * b05 - a32 * b04 + a33 * b03,\n\ta22 * b04 - a21 * b05 - a23 * b03,\n\ta12 * b08 - a10 * b11 - a13 * b07,\n\ta00 * b11 - a02 * b08 + a03 * b07,\n\ta32 * b02 - a30 * b05 - a33 * b01,\n\ta20 * b05 - a22 * b02 + a23 * b01,\n\ta10 * b10 - a11 * b08 + a13 * b06,\n\ta01 * b08 - a00 * b10 - a03 * b06,\n\ta30 * b04 - a31 * b02 + a33 * b00,\n\ta21 * b02 - a20 * b04 - a23 * b00,\n\ta11 * b07 - a10 * b09 - a12 * b06,\n\ta00 * b09 - a01 * b07 + a02 * b06,\n\ta31 * b01 - a30 * b03 - a32 * b00,\n\ta20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main() {\n\n\t#ifdef USE_COLOR\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\t#endif\n\n\t#ifdef USE_DASH\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t#endif\n\n\tfloat aspect = resolution.x / resolution.y;\n\tvUv = uv;\n\n\t// camera space\n\tvec4 start = modelMatrix * vec4( instanceStart, 1.0 );\n\tvec4 end = modelMatrix * vec4( instanceEnd, 1.0 );\n\n\t// camera space\n\tstart = viewMatrix * vec4( start.xyz, 1.0 );\n\tend = viewMatrix * vec4( end.xyz, 1.0 );\n\n\tworldStart = start.xyz;\n\tworldEnd = end.xyz;\n\n\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t// perhaps there is a more elegant solution -- WestLangley\n\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\tif ( perspective ) {\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\t\t\ttrimSegment( start, end );\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\t\t\ttrimSegment( end, start );\n\t\t}\n\t}\n\n\t// clip space\n\tvec4 clipStart = projectionMatrix * start;\n\tvec4 clipEnd = projectionMatrix * end;\n\n\t// ndc space\n\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t// direction\n\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t// account for clip-space aspect ratio\n\tdir.x *= aspect;\n\tdir = normalize( dir );\n\n\t// get the offset direction as perpendicular to the view vector\n\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\tvec3 offset;\n\tif ( position.y < 0.5 ) {\n\n\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t} else {\n\n\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t}\n\n\t// sign flip\n\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t// don't extend the line if we're rendering dashes because we\n\t// won't be rendering the endcaps\n\t#ifndef USE_DASH\n\t\t// extend the line bounds to encompass  endcaps\n\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\toffset.xy -= dir * forwardOffset;\n\t\toffset.z += 0.5;\n\t#endif\n\n\t// endcaps\n\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\t\toffset.xy += dir * 2.0 * forwardOffset;\n\t}\n\n\t// adjust for linewidth\n\toffset *= linewidth * 0.5;\n\n\t// set the world position\n\tworldPos = ( position.y < 0.5 ) ? start : end;\n\tworldPos.xyz += offset;\n\n\t// project the worldpos\n\tvec4 clip = projectionMatrix * worldPos;\n\n\t// shift the depth of the projected points so the line\n\t// segments overlap neatly\n\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\tclip.z = clipPose.z * clip.w;\n\n\tgl_Position = clip;\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n//\t#include <logdepthbuf_vertex>\n//\t#include <clipping_planes_vertex>\n//\t#include <fog_vertex>\n\n\t// Reveal\n\tvec3 transformedPosition = position;\n\n\tvec3 myWorldPos = (inverseMat4(viewMatrix) * worldPos).xyz;\n\tvec3 myLocalPos = (inverseMat4(modelViewMatrix) * worldPos).xyz;\n\n\tfloat mappedWorldY = map(myWorldPos.y, 10., 26. * 4., 0., 1.); // Map across the whole main building\n\tfloat edge = uProgress - mappedWorldY;\n\tedge /= 0.07;\n\tedge = clamp(edge, 0., 1.);\n\n\tfloat mappedY = map(myLocalPos.y, 0., uHeight, 0., 1.);\n\tfloat mapProgress = map(edge, 0., 1., 0., 2.);\n\tfloat stag = mapProgress - mappedY;\n\tvAlpha = edge * clamp(stag, 0., 1.);\n\n\tvMappedWorldY = map(myWorldPos.y, 0., uHeight, 0., 1.);\n\n\t#include <fogOutputVert>\n}\n", fragmentShader: "#define GLSLIFY 1\nuniform vec3 uLinesColor1;\nuniform vec3 uLinesColor2;\nuniform float uBlendFrequency;\nuniform float uBlendSpeed;\nuniform float uTime;\n\nvarying float vMappedWorldY;\nvarying float vAlpha;\n\n#include <fogParamsFrag>\n\nuniform float opacity;\nuniform float linewidth;\n\n#ifdef USE_DASH\n\tuniform float dashOffset;\n\tuniform float dashSize;\n\tuniform float gapSize;\n#endif\n\nvarying float vLineDistance;\n\nvarying vec4 worldPos;\nvarying vec3 worldStart;\nvarying vec3 worldEnd;\n\n#ifdef USE_DASH\n\tvarying vec2 vUv;\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\tfloat mua;\n\tfloat mub;\n\n\tvec3 p13 = p1 - p3;\n\tvec3 p43 = p4 - p3;\n\n\tvec3 p21 = p2 - p1;\n\n\tfloat d1343 = dot( p13, p43 );\n\tfloat d4321 = dot( p43, p21 );\n\tfloat d1321 = dot( p13, p21 );\n\tfloat d4343 = dot( p43, p43 );\n\tfloat d2121 = dot( p21, p21 );\n\n\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\tmua = numer / denom;\n\tmua = clamp( mua, 0.0, 1.0 );\n\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\tmub = clamp( mub, 0.0, 1.0 );\n\n\treturn vec2( mua, mub );\n\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\t#ifdef USE_DASH\n\n\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t#endif\n\n\tfloat alpha = opacity;\n\n\t#ifdef WORLD_UNITS\n\t\t// Find the closest points on the view ray and the line segment\n\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\tvec3 lineDir = worldEnd - worldStart;\n\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\tvec3 p2 = rayEnd * params.y;\n\t\tvec3 delta = p1 - p2;\n\t\tfloat len = length( delta );\n\t\tfloat norm = len / linewidth;\n\n\t\t#ifndef USE_DASH\n\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\t\t\t#else\n\t\t\t\tif ( norm > 0.5 ) discard;\n\t\t\t#endif\n\t\t#endif\n\t#else\n\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\t\t\t}\n\t\t#else\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\t\t\t}\n\t\t#endif\n\t#endif\n\n\tfloat sinMix = 0.5 + 0.5 * sin(vMappedWorldY * uBlendFrequency - uTime * uBlendSpeed);\n\tvec3 baseColor = mix(uLinesColor1, uLinesColor2, sinMix );\n\n\tgl_FragColor = vec4( baseColor, vAlpha );\n\n\t#include <fogOutputFrag>\n}\n", transparent: !0 }), this.localUniforms = n, this.globalUniforms = i, this.uniforms = Object.assign(this.uniforms, this.localUniforms), this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } } function mE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function gE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class vE extends ia { constructor(t) { let { geometry: e, objectData: n, particlesCount: i = 20, planeParticleSize: r, renderOrder: s = 0, linesUniforms: o, particlesUniforms: a, globalUniforms: l = {}, randomSpread: h, rotationOrientation: c, labels: u, domLabels: d, rotationDirection: p = 1, globalOptions: f } = t; super(), gE(this, "calculatePanelMaxSize", (() => { for (let t = 0; t < this.labelPanelsContainer.length; t++) { this.labelPanelsContainer[t].style.display = "block"; const e = this.labelPanelsContainer[t].offsetWidth, n = this.labelPanelsContainer[t].offsetHeight; e > this.panelMaxWidth && (this.panelMaxWidth = e), n > this.panelMaxHeight && (this.panelMaxHeight = n), this.labelPanelsContainer[t].style.display = "none" } })), gE(this, "onLabelMouseEnter", ((t, e, n, i) => { mg.to(this, { rotationThreshold: 0, ease: "power2.in", duration: .4 }); const { top: r, left: s, width: o, height: a } = t.getBoundingClientRect(), l = Fh.window.w - s, h = Fh.window.h - r - a; h - 20 > this.panelMaxHeight ? mg.set(e, { top: r + a + 20 }) : mg.set(e, { bottom: h + a + 20 }), l > this.panelMaxWidth ? mg.set(e, { left: s }) : mg.set(e, { right: l - o }), this.labelTl = mg.timeline(), this.labelTl.set(e, { display: "block" }).scramble(n, { duration: .6 }).set(i, { opacity: 0 }, .1).set(i, { opacity: 1 }, .15).set(i, { opacity: 0 }, .2).set(i, { opacity: 1 }, .25) })), gE(this, "onLabelMouseLeave", ((t, e, n, i) => { var r; mg.to(this, { rotationThreshold: 1, ease: "power2.out", duration: .4 }), null === (r = this.labelTl) || void 0 === r || r.kill(), mg.timeline().set(i, { opacity: 1, delay: .05 }).set(i, { opacity: 0, delay: .03 }).set(i, { opacity: 1, delay: .05 }).set(i, { opacity: 0, delay: .03 }).set(e, { display: "none" }).set(e, { clearProps: "top,left,bottom,right" }) })), gE(this, "onShapeBeforeRender", (t => { this.current.lerp(Fh.pointer.glNormalized, this.globalOptions.mouseLerp * Fh.WebGL.normalizeDelta), this.mouseVector.set(this.current.x, this.current.y, .5), this.time += .01 * this.rotationThreshold * this.rotationDirection * Fh.WebGL.normalizeDelta, this.position.y = this.initialPosY + .04 * Math.sin(.7 * Fh.WebGL.globalUniforms.uTime.value), this.shape.rotation.y = .08 * this.time, this.particlesMesh.rotation.y = .08 * this.time, this.mouseVector.unproject(Fh.MainScene.camera), this.mouseVector.sub(Fh.MainScene.camera.position).normalize(); const e = this._vec3.copy(t.position).sub(Fh.MainScene.camera.position).dot(this.mouseVector); t.material.uniforms.uMousePos.value.copy(Fh.MainScene.camera.position).add(this.mouseVector.multiplyScalar(e)) })), this.options = { particlesMaterialOptions: { enableAdditiveBlending: !0, radius: .7, distortion: .09 }, planeParticleSize: r, randomSpread: h, rotationOrientation: c }, this.globalOptions = f, this.globalUniforms = l, this.mouseVector = new An, this.current = new He, this._vec3 = new An, this.rotationThreshold = 1, this.time = 20, this.geometry = e, this.linesUniforms = o, this.particlesUniforms = a, this.particlesCount = i, this.renderOrder = s, this.labels = u, this.domLabels = d, this.rotationDirection = p, this.labelPoints = Mh(".js-label-point", this.domLabels), this.labelPanelsContainer = Mh(".js-label-panel", this.domLabels), this.points = [], this.panelMaxWidth = 0, this.panelMaxHeight = 0, this.calculatePanelMaxSize(), ec.on(ic.RESIZE, this.calculatePanelMaxSize), lw(this, n), this.initialPosY = this.position.y, this.build(), Fh.isTouch || (this.shape.onBeforeRender = () => this.onShapeBeforeRender(this.particlesMesh)) } build() { this.edgeGeom = new cl(this.geometry); const t = new Iw; t.setPositions(this.edgeGeom.attributes.position.array), this.particlesMaterial = new cE(function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? mE(Object(n), !0).forEach((function (e) { gE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : mE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({ uniforms: this.particlesUniforms, globalUniforms: this.globalUniforms }, this.options.particlesMaterialOptions)), this.lineMaterial = new fE({ globalUniforms: this.globalUniforms, uniforms: this.linesUniforms }), this.shape = new qw(t, this.lineMaterial), this.shape.computeLineDistances(), this.add(this.shape), t.computeBoundingBox(), this.shapeSize = new An, t.boundingBox.getSize(this.shapeSize), this.particlesMaterial.uniforms.uHeight.value = this.shapeSize.y, this.shapeWorldPosition = new An, this.shape.getWorldPosition(this.shapeWorldPosition), this.lineMaterial.uniforms.uShapeWorldPosition.value = this.shapeWorldPosition, this.lineMaterial.uniforms.uHeight.value = this.shapeSize.y; const e = this.edgeGeom.attributes.position.array.length / 6, n = new bi, i = new Tr(this.options.planeParticleSize, this.options.planeParticleSize); this.particlesMesh = new Ba(i, this.particlesMaterial, this.particlesCount * e), this.particlesMesh.frustumCulled = !0; const r = new xn; null === i.boundingBox && i.computeBoundingBox(); const s = i.boundingBox.clone(); i.boundingBox.makeEmpty(), null === i.boundingSphere && i.computeBoundingSphere(), i.boundingSphere.makeEmpty(); const o = [], a = new Float32Array(3 * this.particlesCount * e), l = new Float32Array(this.particlesCount * e), h = new Float32Array(3 * this.particlesCount * e), c = this.options.randomSpread; this.addLabels(); for (let t = 0; t < e; t++) { const e = this.edgeGeom.attributes.position.array[6 * t], u = this.edgeGeom.attributes.position.array[6 * t + 1], d = this.edgeGeom.attributes.position.array[6 * t + 2], p = this.edgeGeom.attributes.position.array[6 * t + 3] - e, f = this.edgeGeom.attributes.position.array[6 * t + 4] - u, m = this.edgeGeom.attributes.position.array[6 * t + 5] - d; for (let g = 0; g < this.particlesCount; g++) { const v = t * (3 * this.particlesCount) + 3 * g, A = e + p / (this.particlesCount + 1) * (g + 1), b = u + f / (this.particlesCount + 1) * (g + 1), y = d + m / (this.particlesCount + 1) * (g + 1); n.position.set(A, b, y), n.updateMatrix(), r.copy(s).applyMatrix4(n.matrix), i.boundingBox.union(r); const x = n.position.clone(); o.push(x), this.particlesMesh.setMatrixAt(t * this.particlesCount + g, n.matrix), a[v] = Ge.randFloat(-c, c), a[v + 1] = Ge.randFloat(-c, c), a[v + 2] = Ge.randFloat(-c, c), l[t * this.particlesCount + g] = Ge.randFloat(.4, .6), h[v] = A, h[v + 1] = b, h[v + 2] = y } } i.setAttribute("aRandom", new Sa(a, 3)), i.setAttribute("aScale", new Sa(l, 1)), i.setAttribute("aCenterPoint", new Sa(h, 3)), i.boundingSphere.setFromPoints(o), this.add(this.particlesMesh) } addLabels() { this.labelsGroup = new ia; const t = Sh(".js-panels"); for (let e = 0; e < this.labelPoints.length; e++) { const { x: n, y: i, z: r } = this.labels[e]; this.labelPoints[e].classList.add("d-none"), this.points.push(this.labelPoints[e]); const s = new C_(this.labelPoints[e]), o = this.labelPanelsContainer[e]; t.append(o); const a = Sh(".js-label-panel-title", o), l = Sh(".js-label-panel-text", o); ec.on("mouseenter", s.element, (() => this.onLabelMouseEnter(s.element, o, a, l))), ec.on("mouseleave", s.element, (() => this.onLabelMouseLeave(s.element, o, a, l))), s.position.set(n, i, r), s.scale.setScalar(.01), this.shape.attach(s), s.layers.set(0) } Fh.labels.push(this.points) } disposeShapeParticles() { this.shape.geometry.dispose(), this.shape.material.dispose(), this.particlesMesh.geometry.dispose(), this.particlesMesh.material.dispose() } } function AE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function bE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? AE(Object(n), !0).forEach((function (e) { yE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : AE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function yE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class xE extends ia { constructor() { super(), this.shapes = [], this.globalOptions = { mouseLerp: .1 }, this.options = { k0: { particlesCount: 120, planeParticleSize: .15, rotationOrientation: -1, randomSpread: .03 }, k1: { particlesCount: 10, planeParticleSize: .13, rotationOrientation: 1, randomSpread: .03 }, k2: { particlesCount: 10, planeParticleSize: .11, rotationOrientation: -1, randomSpread: .03 } }, this.uniforms = { lines: { k0: { linewidth: { value: .021 }, uLinesColor1: { value: new on(16757910) }, uLinesColor2: { value: new on(16551011) }, uBlendFrequency: { value: 5 }, uBlendSpeed: { value: 1.9 } }, k1: { linewidth: { value: .013 }, uLinesColor1: { value: new on(16625547) }, uLinesColor2: { value: new on(16551011) }, uBlendFrequency: { value: 1 }, uBlendSpeed: { value: .7 } }, k2: { linewidth: { value: .018 }, uLinesColor1: { value: new on(16757910) }, uLinesColor2: { value: new on(16551011) }, uBlendFrequency: { value: 7.7 }, uBlendSpeed: { value: 1 } } }, particles: { k0: { uParticlesColor: { value: new on(16750448) }, uDisplace: { value: .1 }, uMouseSize: { value: 1.3 }, uMouseStrength: { value: .5 } }, k1: { uParticlesColor: { value: new on(16750448) }, uDisplace: { value: .1 }, uMouseSize: { value: 2.16 }, uMouseStrength: { value: .5 } }, k2: { uParticlesColor: { value: new on(16750448) }, uDisplace: { value: .1 }, uMouseSize: { value: 1.14 }, uMouseStrength: { value: .5 } } } }; const t = new He; Fh.WebGL.renderer.getSize(t), this.globalUniforms = { uProgress: { value: 0 }, uParticleStrength: { value: .1 }, resolution: { value: t }, uTime: Fh.WebGL.globalUniforms.uTime }, this.x = { current: 0, target: 0 }, this.y = { current: 0, target: 0 }, this.load() } build(t) { this.domLabels = Mh(".js-labels"), this.shape1 = new vE(bE(bE({}, this.options.k0), {}, { geometry: this.assets.models.k0.geometry, objectData: t.objects.k0[0], renderOrder: 10, linesUniforms: this.uniforms.lines.k0, particlesUniforms: this.uniforms.particles.k0, globalUniforms: this.globalUniforms, domLabels: this.domLabels[0], labels: this.getLabelsVector3(t, ["k0-e0", "k0-e1", "k0-e2", "k0-e3"]), rotationDirection: -1, globalOptions: this.globalOptions })), this.shape2 = new vE(bE(bE({}, this.options.k1), {}, { geometry: this.assets.models.k1.geometry, objectData: t.objects.k1[0], renderOrder: 11, linesUniforms: this.uniforms.lines.k1, particlesUniforms: this.uniforms.particles.k1, globalUniforms: this.globalUniforms, domLabels: this.domLabels[1], labels: this.getLabelsVector3(t, ["k1-e0", "k1-e1"]), globalOptions: this.globalOptions })), this.shape3 = new vE(bE(bE({}, this.options.k2), {}, { geometry: this.assets.models.k2.geometry, objectData: t.objects.k2[0], renderOrder: 12, linesUniforms: this.uniforms.lines.k2, particlesUniforms: this.uniforms.particles.k2, globalUniforms: this.globalUniforms, domLabels: this.domLabels[2], labels: this.getLabelsVector3(t, ["k2-e0", "k2-e1"]), rotationDirection: -1, globalOptions: this.globalOptions })), this.shapes.push(this.shape1, this.shape2, this.shape3), this.add(...this.shapes) } getLabelsVector3(t, e) { const n = []; return e.forEach((e => { const [i, r, s] = t.objects[e][0][0]; n.push(new An(i, r, s)) })), n } load() { this.assets = { models: {}, textures: {} };["k0", "k1", "k2"].forEach((t => { Fh.AssetLoader.loadGltf(Fh.publicUrl + `webgl/models/${t}.glb`).then((e => { this.assets.models[t] = e.scene.children[0] })) })) } removeShapes() { this.shapes.forEach((t => { t.disposeShapeParticles(), this.remove(t) })), this.shapes = [] } } function _E(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function wE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? _E(Object(n), !0).forEach((function (e) { EE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _E(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function EE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class CE extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: wE({ uProgress: { value: null }, uTime: Fh.WebGL.globalUniforms.uTime, uIndex: { value: null }, uColor1: { value: null }, uColor2: { value: null }, uBlendFrequency: { value: null }, uBlendSpeed: { value: null }, uTexture: { value: null } }, Fh.MainScene.components.fog.globalUniforms), defines: wE({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\nuniform float uProgress;\n\n#include <fogParamsVert>\n\nvoid main() {\n    \n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n    vUv = uv;\n    \n    vec3 transformedPosition = position;\n    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz; // global coordinates\n    vLocalPos = position; // Local position\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    #include <fogOutputVert>\n\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\nuniform float uProgress;\nuniform float uTime;\nuniform float uBlendFrequency;\nuniform float uBlendSpeed;\nuniform float uFloorIndex;\nuniform float uIndex;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform sampler2D uTexture;\n\n#include <fogParamsFrag>\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat randomOffset(float value) {\n    return (cos(value) + fract(value)) * value;\n}\n\nvoid main() {\n\n    // Reveal\n    float uGroundFloorBegin =  0.0;\n    // Remap uProgress\n    float numOfFloors = 4.0;\n    float uProgressMapped = map(uProgress, 0.0, 1.0, 0.0, 1.0 + abs(uGroundFloorBegin));\n    float uProgressPlusFloor = uProgressMapped + uGroundFloorBegin;\n    float uProgressClamp = clamp(uProgressPlusFloor, uGroundFloorBegin + 0.0 + uFloorIndex * 1.0/numOfFloors, 1.0/numOfFloors + uFloorIndex * 1.0/numOfFloors);\n    float uProgressRemapped = map(uProgressClamp, uGroundFloorBegin + 0.0 + uFloorIndex * 1.0/numOfFloors, 1.0/numOfFloors + uFloorIndex * 1.0/numOfFloors, 0.0, 1.0 );\n    \n    float progress;\n    if(uFloorIndex == 0.0) {\n        progress = map(uProgressRemapped, 0.4, 0.9, 0.0, 1.0);\n    } else {\n        progress = map(uProgressRemapped, 0.0, 0.5, 0.0, 1.0);\n    }\n\n    // Colours\n    vec3 color1 = uColor1;\n    vec3 color2 = uColor2;\n\n    // Animated gradient to mix between the colours + Remap so we don't get negative values\n    // Use uIndex to add an offset\n    float sinMix = 0.5 + 0.5 * sin(vUv.y * uBlendFrequency + randomOffset(uIndex) + uTime * uBlendSpeed);\n    \n    vec3 baseColor = mix(color1, color2, sinMix );\n\n    vec3 alphaMask = texture2D(uTexture, vUv).rgb;\n\n    gl_FragColor = vec4(baseColor.rgb, progress * alphaMask.r);\n\n    // if (alphaMask.r < 0.15) {\n    //     discard;\n    // }\n\n    #include <tonemapping_fragment>\n    \n    // Add fog\n    #include <fogOutputFrag>\n}", uniforms: t.uniforms, defines: t.defines, transparent: !1, blending: _, blendEquation: w, blendSrc: B, blendDst: L }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } function SE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function ME(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? SE(Object(n), !0).forEach((function (e) { PE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : SE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function PE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class IE extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: ME({ uCityProgress: { value: 0 }, uIndex: { value: null }, uTime: Fh.WebGL.globalUniforms.uTime, uColor1: { value: null }, uColor2: { value: null }, uBlendFrequency: { value: null }, uBlendSpeed: { value: null }, uTexture: { value: null }, uSpeed: { value: null }, uStartOffset: { value: null }, uGroundFloorBegin: { value: null }, uGradientSpread: { value: null } }, Fh.MainScene.components.fog.globalUniforms), defines: ME({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\nuniform float uProgress;\n\n#include <fogParamsVert>\n\nvoid main() {\n    \n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n    vUv = uv;\n    \n    vec3 transformedPosition = position;\n    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz; // global coordinates\n    vLocalPos = position; // Local position\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    #include <fogOutputVert>\n\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\n// Reveal effects\nuniform float uCityProgress;\nuniform float uGroundFloorBegin;\nuniform float uSpeed;\nuniform float uStartOffset;\nuniform float uGradientSpread;\n// Color effects\nuniform float uIndex;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform float uBlendFrequency;\nuniform float uBlendSpeed;\n\n#include <fogParamsFrag>\n\n// uniform float uFloorIndex;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat randomOffset(float value) {\n  return ( cos(value) + fract(value) ) * value;\n}\n\nvoid main() {\n\n  // Reveal\n  // float objectSize = 26.0 * 4.;\n  float objectSize = 100.;\n\n  float mappedY = map(vWorldPos.y, uGroundFloorBegin, objectSize, 0.0, 1.0);\n  float progress = (uCityProgress + uStartOffset) * uSpeed;\n\n  float bottomEdge = mappedY - progress;\n  bottomEdge /= uGradientSpread;\n  bottomEdge = clamp(bottomEdge, 0.0, 1.0);\n  bottomEdge = 1.0 - bottomEdge;\n\n  // Colours\n  vec3 color1 = uColor1;\n  vec3 color2 = uColor2;\n\n  // Animated gradient to mix between the colours + Remap so we don't get negative values\n  // Use uIndex to add an offset\n  float sinMix = 0.5 + 0.5 * sin(vUv.y * uBlendFrequency + randomOffset(uIndex) + uTime * uBlendSpeed);\n  \n  vec3 baseColor = mix(color1, color2, sinMix );\n\n  vec3 alphaMask = texture2D(uTexture, vUv).rgb;\n\n  gl_FragColor = vec4(baseColor.rgb, bottomEdge * alphaMask.r);\n\n  if (bottomEdge * alphaMask.r < 0.15) {\n    discard;\n  }\n\n  #include <tonemapping_fragment>\n  \n  // Add fog\n  #include <fogOutputFrag>\n}", uniforms: t.uniforms, defines: t.defines, transparent: !0 }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } class TE extends ia { constructor() { super(), this.globalUniforms = { uProgress: { value: 0 }, uBlendFrequency: { value: 8 }, uBlendSpeed: { value: 1.8 } }, this.load(), this.renderOrder = 100 } build(t) { this.meshes = { city: { city0: [], city1: [], city2: [] }, main: {} }; const e = Object.keys(t).filter((t => t.startsWith("sign"))).reduce(((e, n) => (e[n] = t[n], e)), {}), n = Object.keys(t).filter((t => t.startsWith("city"))).reduce(((e, n) => (e[n] = t[n], e)), {}); for (const t in e) { const i = parseInt(t.replace("sign-", "")), r = 26; let s; this.meshes.main[t] = {}; for (let o = 0; o < e[t].length; o++) { const a = e[t][o][3].section; if (0 === a) { const n = e[t][o][0][1]; n <= r ? s = 0 : n <= 2 * r ? s = 1 : n <= 3 * r ? s = 2 : n <= 4 * r && (s = 3); const a = new ar(this.assets.models.sign.geometry.clone(), new CE({ uniforms: { uTexture: { value: this.assets.textures[`sign-${i}`] }, uColor1: Fh.MainScene.options.signs.uColor1, uColor2: Fh.MainScene.options.signs.uColor2, uFloorIndex: { value: s }, uIndex: { value: o } }, globalUniforms: this.globalUniforms })); this.meshes.main[t][o] = a, lw(this.meshes.main[t][o], e[t][o]), this.add(this.meshes.main[t][o]) } else { const r = .2 * Ge.seededRandom(a), s = .5 * (Ge.seededRandom(a) + 1); let l; for (const t in n) n[`${t}`].forEach((e => { e[3].section === a && (l = t) })); const h = new ar(this.assets.models.sign.geometry.clone(), new IE({ uniforms: { uTexture: { value: this.assets.textures[`sign-${i}`] }, uIndex: { value: o }, uColor1: Fh.MainScene.options.signs.uColor1, uColor2: Fh.MainScene.options.signs.uColor2, uSpeed: { value: s }, uStartOffset: { value: r }, uGroundFloorBegin: { value: -25 }, uGradientSpread: { value: .1 } }, globalUniforms: this.globalUniforms })); this.meshes.city[l].push(h), lw(h, e[t][o]), this.add(h) } } } } updateProgress(t) { for (const e in this.meshes.city) this.meshes.city[e].forEach((e => { e.material.uniforms.uCityProgress.value = t })) } load() { this.assets = { models: {}, textures: {} }, Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/sign.glb").then((t => { this.assets.models.sign = t.scene.children[0] })); for (let t = 0; t < 11; ++t)Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + `webgl/images/signs/sign_${t}.ktx2`, { flipY: !1, encoding: be }).then((e => { this.assets.textures[`sign-${t}`] = e })) } } function DE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function BE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? DE(Object(n), !0).forEach((function (e) { LE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : DE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function LE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class FE extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: BE({ uProgress: { value: 0 }, uTime: Fh.WebGL.globalUniforms.uTime, uAnimate: { value: null }, uAnimateUp: { value: null }, tRailsTex: { value: null }, tRecText: { value: null }, tHexText: { value: null }, tColorText: { value: null } }, Fh.MainScene.components.fog.globalUniforms), defines: BE({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nattribute float startOffset;\nattribute float objectHeight;\nattribute float textureNum;\nattribute float speed;\nattribute vec4 color;\n\n// Values to be passed to fragment shader\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\nvarying float vStartOffset;\nvarying vec2 vUv;\nvarying float vObjectHeight;\nvarying float vTextureNumber;\nvarying float vSpeed;\nvarying vec4 c_rails;\n\nuniform float uProgress;\nuniform float uGroundFloorBegin;\n\nuniform sampler2D tRecText;\nuniform float uRecTexScale;\n\nuniform float uVertDispOffset;\nuniform float uVertDispMult;\nuniform float uVertFalloffStart;\nuniform float uVertFalloffEnd;\n\n#include <fogParamsVert>\n\nvoid main()\t{\n    \n  vec3 objectNormal = vec3(normal);\n  vec3 transformedNormal = objectNormal;\n  #ifdef USE_INSTANCING\n      mat3 m = mat3( instanceMatrix );\n      transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n      transformedNormal = m * transformedNormal;\n  #endif\n  transformedNormal = normalMatrix * transformedNormal;\n  vNormal = transformedNormal;\n\n  vUv = uv;\n  vStartOffset = startOffset;\n  vObjectHeight = objectHeight;\n  vTextureNumber = textureNum;\n  vSpeed = speed;\n\n  vec3 transformedPosition = position;\n  vWorldPos = vec4(modelMatrix * vec4(position, 1.0)).xyz; // global coordinates\n  vLocalPos = position; // Local position\n\n  vec4 mvPosition = vec4( transformedPosition, 1.0 );\n  #ifdef USE_INSTANCING\n      mvPosition = instanceMatrix * mvPosition;\n  #endif\n\n  mvPosition = modelViewMatrix * mvPosition;\n  gl_Position = projectionMatrix * mvPosition;\n  vViewPosition = -mvPosition.xyz;\n\n  #include <fogOutputVert>\n\n  c_rails = color;\n}", fragmentShader: '#define GLSLIFY 1\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Passed through the vertex shader\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos; // Global vertex position\nvarying vec3 vLocalPos; // Local vertex position\nvarying float vStartOffset; // Random starting position of the reveal\nvarying float vObjectHeight;\nvarying float vTextureNumber;\nvarying float vSpeed;\nvarying vec4 c_rails;\n\n// Uniforms\nuniform float uTime;\nuniform bool uAnimate;\nuniform float uAnimateUp;\nuniform float uProgress; // Animation progress variable\nuniform float uFloorIndex;\nuniform float uGroundFloorBegin;\n\n// Baked Textures\nuniform sampler2D tColorText0;\nuniform sampler2D tColorText1;\nuniform sampler2D tColorText2;\nuniform sampler2D tColorText3;\n// uniform sampler2D tMatCap;\n// uniform sampler2D tRepeatedTexW; // Detail texture\n\n// Masking textures\nuniform sampler2D tMatCap; \nuniform sampler2D tHexText; // Hex grid texture\nuniform sampler2D tRecText; // Recursive texture\nuniform float uHexTexScale;\nuniform float uRecTexScale;\n\nuniform sampler2D tRepeatedTexWalls;\nuniform sampler2D tRailsTex;\n\n// Effect fine tuning uniforms\nuniform float uOverallGradientSpread;\nuniform float uEdgeTextureSubtractStrength; // Controls how much of the texture we subtract from the edge\nuniform float uFlameBandWidth; // How "thick" the flame is\nuniform float uFlameColorChangeOffset; // Where the flame colours change in the gradient\nuniform float uFlameColorGradientSpread; // How steeply or smoothly to interpolate between the flame colours\nuniform float uFlameStrength; // How bright the flame colour is\n\nuniform vec3 uFlameTopColor;\nuniform vec3 uFlameBottomColor;\n\nuniform float uFragNoiseSpeed;\nuniform float uFragNoiseScale;\nuniform float uFragNoiseStrength;\n\nuniform int uBalconiesBlendMode;\nuniform float uBalconiesBlendAlpha;\nuniform vec3 uBalconyBaseColorTop;\nuniform vec3 uBalconyBaseColorBottom;\n\n#include <fogParamsFrag>\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n\n    //Time\n    float time;\n    if (uAnimate) time = uTime * 1.;\n    else time = 0.0;\n\n    // matcap UVs\n    vec3 normal = normalize( vNormal );\n    vec3 viewDir = normalize( vViewPosition );\n    vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n    vec3 y = cross( viewDir, x );\n    vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\n    // Textures for masking\n    vec4 tHex = texture2D(tHexText, vUv * vec2(uHexTexScale)); // hex texture\n    float tHexClamped = clamp(tHex.r, 0.2, 1.0);\n\n    vec4 baseColor;\n    \n    if(vTextureNumber < 0.5) {\n        baseColor = texture2D(tColorText0, vUv);\n    } else if(vTextureNumber > 0.5 && vTextureNumber < 1.5) {\n        baseColor = texture2D(tColorText1, vUv);\n    } else if(vTextureNumber > 1.5 && vTextureNumber < 2.5) {\n        baseColor = texture2D(tColorText2, vUv);\n    }  else if(vTextureNumber > 2.5 && vTextureNumber < 3.5) {\n        baseColor = texture2D(tColorText3, vUv);\n    }\n\n    if (c_rails.r > 0.0) {\n        /**\n            Balconies material\n        */\n        // Sample the gradient texture\n        float balconyGradient = texture2D(tRailsTex, vUv).r;\n        vec3 colourGradient = mix(uBalconyBaseColorBottom, uBalconyBaseColorTop, balconyGradient);\n        // baseColor.rgb = colourGradient;\n        // baseColor = vec4(uBalconyBaseColorTop, 1.0);\n        // baseColor = vec4(blendSoftLight(baseColor.rgb, uBalconyBaseColorTop, 1.), 1.0 );\n        if(uBalconiesBlendMode == 0) baseColor = vec4(blendSoftLight(colourGradient, baseColor.rgb, uBalconiesBlendAlpha), 1.0 );\n        else if(uBalconiesBlendMode == 1) baseColor = vec4(blendLinearLight(baseColor.rgb, colourGradient, uBalconiesBlendAlpha), 1.0 );\n\n    } else {\n        baseColor = vec4(blendSoftLight(baseColor.rgb, texture2D(tRepeatedTexWalls, vUv * 35.).rgb, 1.), 1.0 );\n    }\n    /**\n        Walls material\n    */\n    // Scale the progress according to the object size\n    // Map the local position of the vertices between 0.0 and 1.0 for easier calculations\n    // float objectSize = vObjectHeight;\n    float objectSize = 100.; // "uniform"\n    // float mappedY = map(vLocalPos.y, 0.0 + 3., objectSize+3., 0.0, 1.0);\n    float mappedY = map(vWorldPos.y, uGroundFloorBegin, objectSize+3., 0.0, 1.0);\n    \n    // Random offsets for each building - if doing this make objectSize a uniform so \n    // the buildings don\'t finish revealing all at the exact same moment\n    // float progress = map(uProgress, vStartOffset + 0.052, 1.0, 0.0, 1.0);\n    \n    // No mapping and using the random speed varying\n    float progress = (uProgress + vStartOffset) * vSpeed; // or\n    // float progress = uProgress * vSpeed;\n\n    // float progress = uProgress; // Scratch vStartOffset since we start all of them from 0\n\n    // Edges\n    // Edge based on local position, moving up the model as progress increases\n    float bottomEdge = mappedY - progress;\n    bottomEdge /= uOverallGradientSpread;\n    float topEdge = bottomEdge - uFlameBandWidth; // Top edge\n\n    // Gradient edge where the flame colours will change\n    float colorChangeEdge = bottomEdge - uFlameColorChangeOffset; // Offset to control where the middle point is of the change\n    float colorChangeEdgeSteepness = colorChangeEdge/uFlameColorGradientSpread;\n    float clampedColorChangeEdgeGradient = clamp(colorChangeEdgeSteepness, 0.0, 1.0); // Make sure to clamp the range before using it for colours\n\n    // Bottom edge: flamed + sharp (no gradient) edge\n    // Option 1: flamed + gradient edge\n    float flameBottomEdge = bottomEdge - tHex.r * uEdgeTextureSubtractStrength; // "flame" the edge line to add detail, this essentially flames it UP because it subtracts more\n    float flamedSharpEdge = step(0.0, flameBottomEdge); // make a sharp edge line instead of gradient, flamed; top part white, bottom black \n\n    // Top edge \n    // Flame Top edge: flamed + sharp (no gradient) edge\n    float flameTopEdge = topEdge - tHex.r * uEdgeTextureSubtractStrength;\n    float flamedSharpTopEdge = step(0.0, flameTopEdge);\n\n    // Alpha masking\n    // Mask the desired top bit with textures\n    float texturedEdgeMask = flamedSharpEdge * (1.0 - tHexClamped * uFlameStrength); \n    // Invert it so we can add another mask (the top edge mask)\n    float invertedTexturedEdgeMask = 1.0 - texturedEdgeMask;\n    // Mask layer 2: add mask width (aka top edge mask)\n    float texturedAlphaMask = invertedTexturedEdgeMask * (1.0 - flamedSharpTopEdge); // Use this for alpha ! // Flamed\n\n    // Apply final colours\n    vec4 layer1flameColor = vec4(mix(uFlameBottomColor, uFlameTopColor, clampedColorChangeEdgeGradient), 1.0);\n    vec4 overallColor = mix(baseColor, layer1flameColor, flamedSharpEdge); // Mask it with the base\n\n    // Apply matcaps\n    #ifdef USE_MATCAP\n        vec4 matcapColor = texture2D( tMatCap, uv );\n    #else\n        vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n    #endif\n    // vec3 outgoingLight = overallColor.rgb * matcapColor.rgb;\n    vec4 outgoingLight = overallColor; // ignore matcaps for now\n\n    // gl_FragColor = vec4(outgoingLight.rgb, 1.);\n    \n    if (texturedAlphaMask * overallColor.a < 0.1) {\n        discard;\n    }\n    \n    gl_FragColor = vec4(outgoingLight.rgb, texturedAlphaMask * overallColor.a);\n\n    #include <tonemapping_fragment>\n\n    // Add fog\n    #include <fogOutputFrag>\n\n}', uniforms: t.uniforms, defines: t.defines, transparent: !1, blending: _, blendEquation: w, blendSrc: B, blendDst: L }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } class kE extends ia { constructor() { super(), this.globalUniforms = { uGroundFloorBegin: { value: -50 }, uAnimate: { value: !0 }, uAnimateUpFlag: { value: !1 }, uAnimateUp: { value: -1 }, uFragNoiseScale: { value: 10 }, uFragNoiseSpeed: { value: 2.5 }, uFragNoiseStrength: { value: .13 }, uHexTexScale: { value: 20 }, uRecTexScale: { value: 0 }, uOverallGradientSpread: { value: .13 }, uFlameBandWidth: { value: .462 }, uEdgeTextureSubtractStrength: { value: .559 }, uFlameColorGradientSpread: { value: .15 }, uFlameColorChangeOffset: { value: .239 }, uFlameStrength: { value: .75 }, uFlameTopColor: { value: new on(16764607) }, uFlameBottomColor: { value: new on(16752742) }, uBalconiesBlendMode: { value: 0 }, uBalconiesBlendAlpha: { value: 1 }, uBalconyBaseColorTop: { value: new on(16772837) }, uBalconyBaseColorBottom: { value: new on(7286290) } }, this.instanceDummy = new bi, this._v = new An, this._q = new vn, this.animated = !1, this.load() } build(t) { this.meshes = {}; for (const e in t) e.startsWith("city") && (this.meshes[e] = {}, this.buildInstancedMesh(t, e, this.assets.models[e].geometry.clone(), new FE({ uniforms: { tColorText0: { value: this.assets.textures[`${e}-b0`] }, tColorText1: { value: this.assets.textures[`${e}-b1`] }, tColorText2: { value: this.assets.textures[`${e}-b2`] }, tColorText3: { value: this.assets.textures[`${e}-b3`] }, tRailsTex: { value: this.assets.textures[`rails-${e}`] }, tRecText: { value: Fh.MainScene.assets.textures.recursiveMask2 }, tHexText: { value: Fh.MainScene.assets.textures.hexTexture }, tMatCap: { value: Fh.MainScene.assets.textures.matcap }, tRepeatedTexWalls: { value: this.assets.textures.repeatWalls } }, globalUniforms: this.globalUniforms, defines: { USE_MATCAP: !0 } }))) } buildInstancedMesh(t, e, n, i) { const r = t[e], s = Object.keys(r).length; this.meshes[e] = new Ba(n, i, s); const o = [], a = [], l = [], h = []; for (let t = 0; t < s; t++) { lw(this.instanceDummy, r[t]), this.instanceDummy.updateMatrix(), this.meshes[e].setMatrixAt(t, this.instanceDummy.matrix), this.meshes[e].geometry.computeBoundingBox(), this.meshes[e].geometry.boundingBox.getSize(this._v); const n = this._v.clone().y; let i; const s = Math.round(Ge.radToDeg(this.instanceDummy.rotation.y)); 0 === s ? i = 0 : 90 === s ? i = 1 : 180 === s ? i = 2 : -90 === s && (i = 3); const c = r[t][3].section, u = .2 * Ge.seededRandom(c), d = .5 * (Ge.seededRandom(c) + 1); l.push(u), a.push(n), o.push(i), h.push(d) } this.meshes[e].geometry.setAttribute("startOffset", new Sa(new Float32Array(l), 1)), this.meshes[e].geometry.setAttribute("speed", new Sa(new Float32Array(h), 1)), this.meshes[e].geometry.setAttribute("objectHeight", new Sa(new Float32Array(a), 1)), this.meshes[e].geometry.setAttribute("textureNum", new Sa(new Float32Array(o), 1)), this.add(this.meshes[e]) } updateProgress(t) { for (const e in this.meshes) this.meshes[e].material.uniforms.uProgress.value = t } load() { this.assets = { models: {}, textures: {} }; for (let t = 0; t < 3; t++) { Fh.AssetLoader.loadGltf(Fh.publicUrl + `webgl/models/city${t}.glb`).then((e => { this.assets.models[`city${t}`] = e.scene.children[0] })); for (let e = 0; e < 4; e++)Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + `webgl/images/city${t}-b${e}-lightmap.ktx2`, { wrapping: at, flipY: !1, encoding: be }).then((n => { this.assets.textures[`city${t}-b${e}`] = n })); Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + `webgl/images/rails-city${t}.ktx2`, { wrapping: at, flipY: !1, encoding: be }).then((e => { this.assets.textures[`rails-city${t}`] = e })) } Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/walls-2.ktx2", { wrapping: at }).then((t => { this.assets.textures.repeatWalls = t })) } destroy() { this.animated = !1 } } class RE extends ar { constructor() { super(), this.load() } build(t) { this.geometry = this.assets.models.floor.geometry, this.material = new Aw({ uniforms: { uTexture: { value: this.assets.textures.floor } }, defines: { USE_TEXTURE: !0 } }), lw(this, t.objects.floor[0]) } load() { this.assets = { models: {}, textures: {} }, Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/floor.glb").then((t => { this.assets.models.floor = t.scene.children[0] })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/floor-lightmap.ktx2", { flipY: !1, encoding: be }).then((t => { this.assets.textures.floor = t })) } } const OE = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}" }; class NE { constructor() { this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 } setSize() { } render() { console.error("THREE.Pass: .render() must be implemented in derived pass.") } dispose() { } } const UE = new Vr(-1, 1, 1, -1, 0, 1), zE = new qi; zE.setAttribute("position", new Ui([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), zE.setAttribute("uv", new Ui([0, 2, 0, 0, 2, 0], 2)); class VE { constructor(t) { this._mesh = new ar(zE, t) } dispose() { this._mesh.geometry.dispose() } render(t) { t.render(this._mesh, UE) } get material() { return this._mesh.material } set material(t) { this._mesh.material = t } } class QE extends NE { constructor(t, e) { super(), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof fr ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = pr.clone(t.uniforms), this.material = new fr({ defines: Object.assign({}, t.defines), uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })), this.fsQuad = new VE(this.material) } render(t, e, n) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t)) } dispose() { this.material.dispose(), this.fsQuad.dispose() } } class GE extends NE { constructor(t, e) { super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1 } render(t, e, n) { const i = t.getContext(), r = t.state; let s, o; r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0), this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295), r.buffers.stencil.setClear(o), r.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(!0) } } class HE extends NE { constructor() { super(), this.needsSwap = !1 } render(t) { t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1) } } class jE { constructor(t, e) { if (this.renderer = t, void 0 === e) { const n = t.getSize(new He); this._pixelRatio = t.getPixelRatio(), this._width = n.width, this._height = n.height, (e = new fn(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1" } else this._pixelRatio = 1, this._width = e.width, this._height = e.height; this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new QE(OE), this.clock = new hh } swapBuffers() { const t = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = t } addPass(t) { this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } insertPass(t, e) { this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } removePass(t) { const e = this.passes.indexOf(t); -1 !== e && this.passes.splice(e, 1) } isLastEnabledPass(t) { for (let e = t + 1; e < this.passes.length; e++)if (this.passes[e].enabled) return !1; return !0 } render(t) { void 0 === t && (t = this.clock.getDelta()); const e = this.renderer.getRenderTarget(); let n = !1; for (let e = 0, i = this.passes.length; e < i; e++) { const i = this.passes[e]; if (!1 !== i.enabled) { if (i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e), i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), i.needsSwap) { if (n) { const e = this.renderer.getContext(), n = this.renderer.state.buffers.stencil; n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295) } this.swapBuffers() } void 0 !== GE && (i instanceof GE ? n = !0 : i instanceof HE && (n = !1)) } } this.renderer.setRenderTarget(e) } reset(t) { if (void 0 === t) { const e = this.renderer.getSize(new He); this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2 } setSize(t, e) { this._width = t, this._height = e; const n = this._width * this._pixelRatio, i = this._height * this._pixelRatio; this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i); for (let t = 0; t < this.passes.length; t++)this.passes[t].setSize(n, i) } setPixelRatio(t) { this._pixelRatio = t, this.setSize(this._width, this._height) } dispose() { this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose() } } class WE extends NE { constructor(t, e, n, i, r) { super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== r ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new on } render(t, e, n) { const i = t.autoClear; let r, s; t.autoClear = !1, void 0 !== this.overrideMaterial && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), r = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s), t.autoClear = i } } const qE = { uniforms: { tDiffuse: { value: null }, resolution: { value: new He(1 / 1024, 1 / 512) } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t" }, YE = { shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new on(0) }, defaultOpacity: { value: 0 } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}" }; class XE extends NE { constructor(t, e, n, i) { super(), this.strength = void 0 !== e ? e : 1, this.radius = n, this.threshold = i, this.resolution = void 0 !== t ? new He(t.x, t.y) : new He(256, 256), this.clearColor = new on(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5; let r = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2); this.renderTargetBright = new fn(r, s), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1; for (let t = 0; t < this.nMips; t++) { const e = new fn(r, s); e.texture.name = "UnrealBloomPass.h" + t, e.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(e); const n = new fn(r, s); n.texture.name = "UnrealBloomPass.v" + t, n.texture.generateMipmaps = !1, this.renderTargetsVertical.push(n), r = Math.round(r / 2), s = Math.round(s / 2) } const o = YE; this.highPassUniforms = pr.clone(o.uniforms), this.highPassUniforms.luminosityThreshold.value = i, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new fr({ uniforms: this.highPassUniforms, vertexShader: o.vertexShader, fragmentShader: o.fragmentShader, defines: {} }), this.separableBlurMaterials = []; const a = [3, 5, 7, 9, 11]; r = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2); for (let t = 0; t < this.nMips; t++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(a[t])), this.separableBlurMaterials[t].uniforms.texSize.value = new He(r, s), r = Math.round(r / 2), s = Math.round(s / 2); this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0; this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new An(1, 1, 1), new An(1, 1, 1), new An(1, 1, 1), new An(1, 1, 1), new An(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors; const l = OE; this.copyUniforms = pr.clone(l.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new fr({ uniforms: this.copyUniforms, vertexShader: l.vertexShader, fragmentShader: l.fragmentShader, blending: b, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new on, this.oldClearAlpha = 1, this.basic = new Li, this.fsQuad = new VE(null) } dispose() { for (let t = 0; t < this.renderTargetsHorizontal.length; t++)this.renderTargetsHorizontal[t].dispose(); for (let t = 0; t < this.renderTargetsVertical.length; t++)this.renderTargetsVertical[t].dispose(); this.renderTargetBright.dispose(); for (let t = 0; t < this.separableBlurMaterials.length; t++)this.separableBlurMaterials[t].dispose(); this.compositeMaterial.dispose(), this.materialCopy.dispose(), this.basic.dispose(), this.fsQuad.dispose() } setSize(t, e) { let n = Math.round(t / 2), i = Math.round(e / 2); this.renderTargetBright.setSize(n, i); for (let t = 0; t < this.nMips; t++)this.renderTargetsHorizontal[t].setSize(n, i), this.renderTargetsVertical[t].setSize(n, i), this.separableBlurMaterials[t].uniforms.texSize.value = new He(n, i), n = Math.round(n / 2), i = Math.round(i / 2) } render(t, e, n, i, r) { t.getClearColor(this._oldClearColor), this.oldClearAlpha = t.getClearAlpha(); const s = t.autoClear; t.autoClear = !1, t.setClearColor(this.clearColor, 0), r && t.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t.setRenderTarget(this.renderTargetBright), t.clear(), this.fsQuad.render(t); let o = this.renderTargetBright; for (let e = 0; e < this.nMips; e++)this.fsQuad.material = this.separableBlurMaterials[e], this.separableBlurMaterials[e].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[e].uniforms.direction.value = XE.BlurDirectionX, t.setRenderTarget(this.renderTargetsHorizontal[e]), t.clear(), this.fsQuad.render(t), this.separableBlurMaterials[e].uniforms.colorTexture.value = this.renderTargetsHorizontal[e].texture, this.separableBlurMaterials[e].uniforms.direction.value = XE.BlurDirectionY, t.setRenderTarget(this.renderTargetsVertical[e]), t.clear(), this.fsQuad.render(t), o = this.renderTargetsVertical[e]; this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t.setRenderTarget(this.renderTargetsHorizontal[0]), t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && t.state.buffers.stencil.setTest(!0), this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(n), this.fsQuad.render(t)), t.setClearColor(this._oldClearColor, this.oldClearAlpha), t.autoClear = s } getSeperableBlurMaterial(t) { return new fr({ defines: { KERNEL_RADIUS: t, SIGMA: t }, uniforms: { colorTexture: { value: null }, texSize: { value: new He(.5, .5) }, direction: { value: new He(.5, .5) } }, vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}", fragmentShader: "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}" }) } getCompositeMaterial(t) { return new fr({ defines: { NUM_MIPS: t }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}", fragmentShader: "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}" }) } } XE.BlurDirectionX = new He(1, 0), XE.BlurDirectionY = new He(0, 1); function KE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function JE(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? KE(Object(n), !0).forEach((function (e) { ZE(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : KE(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function ZE(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class $E extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: JE({ uTime: Fh.WebGL.globalUniforms.uTime, uColor1: { value: null }, uColor2: { value: null }, uTexture: { value: null }, uTextureGradient: { value: null }, uTextureRecursive: { value: null }, uUvScale: { value: new He(50, 50) }, uBakeBlend: { value: 1 }, uBlendAlpha: { value: 1 }, uAlphaMin: { value: .33 }, uAlphaMax: { value: 1 } }, Fh.MainScene.components.fog.globalUniforms), defines: JE({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nattribute vec3 color;\n\nvarying vec3 vThreshold;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\nuniform float uProgress;\n\n#include <fogParamsVert>\n\nvoid main() {\n    \n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    vNormal = transformedNormal;\n    vUv = uv;\n    \n    vec3 transformedPosition = position;\n    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz; // global coordinates\n    vLocalPos = position; // Local position\n\n    vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n\n    vThreshold = color;\n\n    #include <fogOutputVert>\n\n}", fragmentShader: "#define GLSLIFY 1\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvarying vec3 vThreshold;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\n\nuniform float uProgress;\nuniform float uTime;\nuniform float uFloorIndex;\nuniform float uGradientSpread;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform sampler2D uTexture;\nuniform sampler2D uTextureGradient;\nuniform sampler2D uTextureRecursive;\nuniform vec2 uUvScale; \nuniform float uBlendAlpha;\nuniform float uAlphaMin;\nuniform float uAlphaMax;\nuniform float uBakeBlend;\n\n#include <fogParamsFrag>\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat random(float val) {\n    return fract(sin(val)*1.0);\n}\n\nvoid main() {\n\n    // Reveal\n    float objectSize = 130.0;\n    float urand = random(vWorldPos.y);\n    float mappedY = map(vWorldPos.y, 0.0, objectSize, 0.0, 1.0);\n\n    float threshold = clamp(vThreshold.r, 0.0, 1.0);\n    // float bottomEdge = threshold - uProgress;\n    float bottomEdge = mappedY - uProgress;\n    bottomEdge /= 0.5;\n    bottomEdge = clamp(bottomEdge, 0.0, 1.0);\n    bottomEdge = 1.0 - bottomEdge;\n\n    float sideRevealMix = mix(-2.0, 2.0, bottomEdge);\n    \n    float sideReveal = vUv.x - sideRevealMix;\n    sideReveal /= 0.08;\n    sideReveal = clamp(sideReveal, 0.0, 1.0);\n    sideReveal = 1.0 - sideReveal;\n\n    // Colours\n    vec3 color1 = uColor1;\n    vec3 color2 = uColor2;\n\n    // Animated gradient to mix between the colours + Remap so we don't get negative values\n    float sinMix = 0.5 + 0.5 * sin(vUv.x * 30.0 + uTime + urand * 0.65);\n    float clampSin = clamp(sinMix, 0.65, 1.0);\n\n    // Colours\n    vec3 diffuseCol = texture2D(uTexture, vUv).rgb; // Texture bake\n\n    float rimMask = texture2D(uTextureGradient, vUv).r;\n    float maskAnimate = rimMask*clampSin;\n    // float recursiveMask = texture2D(uTextureRecursive, vUv * uUvScale).r;\n    // float blendMask = blendLinearLight(vec3(rimMask), vec3(recursiveMask), uBlendAlpha).r;\n    // float blendMask = blendLighten(vec3(rimMask), vec3(recursiveMask), uBlendAlpha).r;\n    \n    // float blendMask = blendSoftLight(vec3(rimMask), vec3(recursiveMask), uBlendAlpha).r;\n    // float blendMask = blendColorDodge(vec3(rimMask), vec3(recursiveMask), uBlendAlpha).r;\n    vec3 baseColor = mix(uColor1, uColor2, maskAnimate);\n    baseColor = blendColorDodge(baseColor, diffuseCol, uBakeBlend);\n    float alphaMask = clamp(rimMask, uAlphaMin, uAlphaMax);\n\n    if (bottomEdge * alphaMask < 0.1) {\n      discard;\n    }\n    gl_FragColor = vec4(baseColor.rgb, sideReveal * alphaMask);\n\n    // gl_FragColor = vec4(vec3(sideReveal), 1.0);\n\n    #include <tonemapping_fragment>\n    \n    // Add fog\n    #include <fogOutputFrag>\n}", uniforms: t.uniforms, defines: t.defines, side: m, transparent: !1, blending: _, blendEquation: w, blendSrc: B, blendDst: L }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } class tC extends ia { constructor() { super(), this.globalUniforms = { uProgress: { value: 0 }, uColor1: { value: new on(7603456) }, uColor2: { value: new on(16761996) }, uGradientSpread: { value: .0182 }, uTextureNum: { value: 3 } }, this.load() } build(t) { this.meshes = {}; const e = new ar(this.assets.models.bridges.geometry.clone(), new $E({ uniforms: { uTexture: { value: this.assets.textures.bridgesDiffuse }, uTextureGradient: { value: this.assets.textures.bridgesGradient }, uTextureRecursive: { value: Fh.MainScene.assets.textures.recursiveMask3 } }, globalUniforms: this.globalUniforms })); this.meshes.bridges = e, lw(this.meshes.bridges, t.objects.bridges[0]), this.add(this.meshes.bridges) } animateUp() { mg.timeline().to(this.meshes.bridges.material.uniforms.uProgress, { value: 1, duration: 12, ease: "sine.inOut" }, 0) } load() { this.assets = { models: {}, textures: {} }, Fh.AssetLoader.loadGltf(Fh.publicUrl + "webgl/models/bridges.glb").then((t => { this.assets.models.bridges = t.scene.children[0] })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/bridges-rim.ktx2", { flipY: !1, encoding: be }).then((t => { this.assets.textures.bridgesGradient = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/bridges-lightmap.ktx2", { flipY: !1, encoding: be }).then((t => { this.assets.textures.bridgesDiffuse = t })) } destroy() { this.meshes.bridges.material.uniforms.uProgress.value = 0 } } function eC(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function nC(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? eC(Object(n), !0).forEach((function (e) { iC(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : eC(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function iC(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class rC extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: nC({ uProgress: { value: 0 }, uTime: Fh.WebGL.globalUniforms.uTime, uColor1: { value: null }, uColor2: { value: null }, uColMultiply: { value: 1 }, uSpeed: { value: null }, uStartOffset: { value: null }, uSection: { value: null }, vertexColors: { value: !1 }, worldUnits: { value: !0 }, resolution: { value: null }, dashed: { value: !1 }, dashScale: { value: 1 }, dashSize: { value: 1 }, dashOffset: { value: 0 }, gapSize: { value: 1 }, opacity: { value: 1 } }, Fh.MainScene.components.fog.globalUniforms), defines: nC({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vFakeUv;\nvarying float vAlpha;\n\n// varying vec2 vUv;\n// varying vec3 vNormal;\n// varying vec3 vViewPosition;\n// varying vec3 vWorldPos;\n// varying vec3 vLocalPos;\n\n// Reveal\nuniform float uProgress;\nuniform float uGradientSpread;\nuniform float uGroundFloorBegin;\nuniform float uSpeed;\nuniform float uStartOffset;\n\n#include <fogParamsVert>\n\n// Line material\n#include <common>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nuniform float linewidth;\nuniform vec2 resolution;\nattribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nvarying vec4 worldPos;\nvarying vec3 worldStart;\nvarying vec3 worldEnd;\n#ifdef USE_DASH\n    uniform float dashScale;\n    attribute float instanceDistanceStart;\n    attribute float instanceDistanceEnd;\n    varying float vLineDistance;\n#endif\n\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\n    // trim end segment so it terminates between the camera plane and the near plane\n    // conservative estimate of the near plane\n    float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n    float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n    float nearEstimate = - 0.5 * b / a;\n    float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n    end.xyz = mix( start.xyz, end.xyz, alpha );\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nmat4 inverseMat4(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main() {\n    \n    vec3 objectNormal = vec3(normal);\n    vec3 transformedNormal = objectNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n\n    #ifdef USE_COLOR\n        vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n    #endif\n    #ifdef USE_DASH\n        vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n    #endif\n    float aspect = resolution.x / resolution.y;\n    vUv = uv;\n    // camera space\n    vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n    vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n    worldStart = start.xyz;\n    worldEnd = end.xyz;\n    // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n    // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n    // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n    // perhaps there is a more elegant solution -- WestLangley\n    bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n    if ( perspective ) {\n        if ( start.z < 0.0 && end.z >= 0.0 ) {\n            trimSegment( start, end );\n        } else if ( end.z < 0.0 && start.z >= 0.0 ) {\n            trimSegment( end, start );\n        }\n    }\n    // clip space\n    vec4 clipStart = projectionMatrix * start;\n    vec4 clipEnd = projectionMatrix * end;\n    // ndc space\n    vec3 ndcStart = clipStart.xyz / clipStart.w;\n    vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n    // direction\n    vec2 dir = ndcEnd.xy - ndcStart.xy;\n    // account for clip-space aspect ratio\n    dir.x *= aspect;\n    dir = normalize( dir );\n\n    #ifdef WORLD_UNITS\n        // get the offset direction as perpendicular to the view vector\n        vec3 worldDir = normalize( end.xyz - start.xyz );\n        vec3 offset;\n        if ( position.y < 0.5 ) {\n            offset = normalize( cross( start.xyz, worldDir ) );\n        } else {\n            offset = normalize( cross( end.xyz, worldDir ) );\n        }\n        // sign flip\n        if ( position.x < 0.0 ) offset *= - 1.0;\n        float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        #ifndef USE_DASH\n            // extend the line bounds to encompass  endcaps\n            start.xyz += - worldDir * linewidth * 0.5;\n            end.xyz += worldDir * linewidth * 0.5;\n            // shift the position of the quad so it hugs the forward edge of the line\n            offset.xy -= dir * forwardOffset;\n            offset.z += 0.5;\n        #endif\n        // endcaps\n        if ( position.y > 1.0 || position.y < 0.0 ) {\n            offset.xy += dir * 2.0 * forwardOffset;\n        }\n        // adjust for linewidth\n        offset *= linewidth * 0.5;\n        // set the world position\n        worldPos = ( position.y < 0.5 ) ? start : end;\n        worldPos.xyz += offset;\n        // project the worldpos\n        vec4 clip = projectionMatrix * worldPos;\n        // shift the depth of the projected points so the line\n        // segements overlap neatly\n        vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n        clip.z = clipPose.z * clip.w;\n    #else\n    vec2 offset = vec2( dir.y, - dir.x );\n    // undo aspect ratio adjustment\n    dir.x /= aspect;\n    offset.x /= aspect;\n    // sign flip\n    if ( position.x < 0.0 ) offset *= - 1.0;\n    // endcaps\n    if ( position.y < 0.0 ) {\n        offset += - dir;\n    } else if ( position.y > 1.0 ) {\n        offset += dir;\n    }\n    // adjust for linewidth\n    offset *= linewidth;\n    // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n    offset /= resolution.y;\n    // select end\n    vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n    // back to clip space\n    offset *= clip.w;\n    clip.xy += offset;\n    #endif\n    gl_Position = clip;\n    vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n    // Reveal\n    vec3 myWorldPos = (inverseMat4(viewMatrix) * worldPos).xyz;\n    vec3 myLocalPos = (inverseMat4(modelViewMatrix) * worldPos).xyz;\n    vec3 transformedPosition = position;\n\n    float objectSize = 100.;\n    float mappedY = map(myWorldPos.y, uGroundFloorBegin, objectSize + 3., 0.0, 1.0);\n    float progress = (uProgress + uStartOffset) * uSpeed;\n    // float mappedX = map(myWorldPos.x, -11.5, 11.5, 0.0, 1.0);\n    // float mappedZ = map(myWorldPos.z, -11.5, 11.5, 0.0, 1.0); \n    float mappedX = map(myLocalPos.x, -27.5, 27.5, 0.0, 1.0); // local // approx for buildings\n    float mappedZ = map(myLocalPos.z, -27.5, 27.5, 0.0, 1.0);  // local\n\n    float bottomEdge = mappedY - progress;\n    bottomEdge /= uGradientSpread;\n    bottomEdge = clamp(bottomEdge,0.0, 1.0);\n    bottomEdge = 1.0 - bottomEdge;\n    \n    // float bottomEdge = mappedY - uProgress;\n    // bottomEdge /= uGradientSpread;\n    // bottomEdge = 1.0 - bottomEdge;\n    // bottomEdge = clamp(bottomEdge,0.0, 1.0);\n\n    vAlpha = bottomEdge; // Send the alpha to the fragment to be nicely interpolated\n    vFakeUv = vec3(mappedX, mappedY, mappedZ); // Send a \"UV\" to the fragment to get a gradient between 0 and 1 on XY\n\n    // vec3 transformedPosition = position;\n    // // vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz; // global coordinates\n    // vWorldPos = (modelMatrix * vec4(instanceStart, 1.0)).xyz; // global coordinates with instances\n    // vLocalPos = position; // Local position\n\n    // vec4 mvPosition = vec4( transformedPosition, 1.0 );\n    // mvPosition = modelViewMatrix * mvPosition;\n    // gl_Position = projectionMatrix * mvPosition;\n    // vViewPosition = -mvPosition.xyz;\n\n    // #include <logdepthbuf_vertex>\n    // #include <clipping_planes_vertex>\n    #include <fogOutputVert>\n\n}\n\n// #include <common>\n// #include <color_pars_vertex>\n// #include <fog_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\n\n// void main() {\n//     #ifdef USE_COLOR\n//         vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n//     #endif\n//     #ifdef USE_DASH\n//         vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n//     #endif\n//     float aspect = resolution.x / resolution.y;\n//     vUv = uv;\n//     // camera space\n//     vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n//     vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n//     worldStart = start.xyz;\n//     worldEnd = end.xyz;\n//     // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n//     // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n//     // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n//     // perhaps there is a more elegant solution -- WestLangley\n//     bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n//     if ( perspective ) {\n//         if ( start.z < 0.0 && end.z >= 0.0 ) {\n//             trimSegment( start, end );\n//         } else if ( end.z < 0.0 && start.z >= 0.0 ) {\n//             trimSegment( end, start );\n//         }\n//     }\n//     // clip space\n//     vec4 clipStart = projectionMatrix * start;\n//     vec4 clipEnd = projectionMatrix * end;\n//     // ndc space\n//     vec3 ndcStart = clipStart.xyz / clipStart.w;\n//     vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n//     // direction\n//     vec2 dir = ndcEnd.xy - ndcStart.xy;\n//     // account for clip-space aspect ratio\n//     dir.x *= aspect;\n//     dir = normalize( dir );\n//     #ifdef WORLD_UNITS\n//         // get the offset direction as perpendicular to the view vector\n//         vec3 worldDir = normalize( end.xyz - start.xyz );\n//         vec3 offset;\n//         if ( position.y < 0.5 ) {\n//             offset = normalize( cross( start.xyz, worldDir ) );\n//         } else {\n//             offset = normalize( cross( end.xyz, worldDir ) );\n//         }\n//         // sign flip\n//         if ( position.x < 0.0 ) offset *= - 1.0;\n//         float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n//         // don't extend the line if we're rendering dashes because we\n//         // won't be rendering the endcaps\n//         #ifndef USE_DASH\n//             // extend the line bounds to encompass  endcaps\n//             start.xyz += - worldDir * linewidth * 0.5;\n//             end.xyz += worldDir * linewidth * 0.5;\n//             // shift the position of the quad so it hugs the forward edge of the line\n//             offset.xy -= dir * forwardOffset;\n//             offset.z += 0.5;\n//         #endif\n//         // endcaps\n//         if ( position.y > 1.0 || position.y < 0.0 ) {\n//             offset.xy += dir * 2.0 * forwardOffset;\n//         }\n//         // adjust for linewidth\n//         offset *= linewidth * 0.5;\n//         // set the world position\n//         worldPos = ( position.y < 0.5 ) ? start : end;\n//         worldPos.xyz += offset;\n//         // project the worldpos\n//         vec4 clip = projectionMatrix * worldPos;\n//         // shift the depth of the projected points so the line\n//         // segements overlap neatly\n//         vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n//         clip.z = clipPose.z * clip.w;\n//     #else\n//     vec2 offset = vec2( dir.y, - dir.x );\n//     // undo aspect ratio adjustment\n//     dir.x /= aspect;\n//     offset.x /= aspect;\n//     // sign flip\n//     if ( position.x < 0.0 ) offset *= - 1.0;\n//     // endcaps\n//     if ( position.y < 0.0 ) {\n//         offset += - dir;\n//     } else if ( position.y > 1.0 ) {\n//         offset += dir;\n//     }\n//     // adjust for linewidth\n//     offset *= linewidth;\n//     // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n//     offset /= resolution.y;\n//     // select end\n//     vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n//     // back to clip space\n//     offset *= clip.w;\n//     clip.xy += offset;\n//     #endif\n//     gl_Position = clip;\n//     vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n//     // #include <logdepthbuf_vertex>\n//     // #include <clipping_planes_vertex>\n//     // #include <fog_vertex>\n// }", fragmentShader: "#define GLSLIFY 1\nvarying vec3 vFakeUv;\nvarying float vAlpha;\n\n// Animated colour gradient\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform float uColMultiply;\nuniform float uTime;\nuniform float uSection;\nuniform float uBlendFrequency;\nuniform float uBlendSpeed;\n\n#include <fogParamsFrag>\n\n// Line material\nuniform float opacity;\nuniform float linewidth;\n\n#ifdef USE_DASH\n  uniform float dashOffset;\n  uniform float dashSize;\n  uniform float gapSize;\n#endif\nvarying float vLineDistance;\n#ifdef WORLD_UNITS\n  varying vec4 worldPos;\n  varying vec3 worldStart;\n  varying vec3 worldEnd;\n  #ifdef USE_DASH\n    varying vec2 vUv;\n  #endif\n#else\n  varying vec2 vUv;\n#endif\n#include <common>\n// #include <color_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nfloat randomOffset(vec3 value, float section) {\n  return (0.5 + 0.5 * cos(section) + fract(value.z)) * abs(value.x) * abs(value.z);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  float mua;\n  float mub;\n  vec3 p13 = p1 - p3;\n  vec3 p43 = p4 - p3;\n  vec3 p21 = p2 - p1;\n  float d1343 = dot( p13, p43 );\n  float d4321 = dot( p43, p21 );\n  float d1321 = dot( p13, p21 );\n  float d4343 = dot( p43, p43 );\n  float d2121 = dot( p21, p21 );\n  float denom = d2121 * d4343 - d4321 * d4321;\n  float numer = d1343 * d4321 - d1321 * d4343;\n  mua = numer / denom;\n  mua = clamp( mua, 0.0, 1.0 );\n  mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n  mub = clamp( mub, 0.0, 1.0 );\n  return vec2( mua, mub );\n}\n\nvoid main() {\n  // #include <clipping_planes_fragment>\n  #ifdef USE_DASH\n    if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n    if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n  #endif\n  float alpha = opacity;\n  #ifdef WORLD_UNITS\n    // Find the closest points on the view ray and the line segment\n    vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n    vec3 lineDir = worldEnd - worldStart;\n    vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n    vec3 p1 = worldStart + lineDir * params.x;\n    vec3 p2 = rayEnd * params.y;\n    vec3 delta = p1 - p2;\n    float len = length( delta );\n    float norm = len / linewidth;\n    #ifndef USE_DASH\n      #ifdef USE_ALPHA_TO_COVERAGE\n        float dnorm = fwidth( norm );\n        alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n      #else\n        if ( norm > 0.5 ) {\n          discard;\n        }\n      #endif\n    #endif\n  #else\n    #ifdef USE_ALPHA_TO_COVERAGE\n      // artifacts appear on some hardware if a derivative is taken within a conditional\n      float a = vUv.x;\n      float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n      float len2 = a * a + b * b;\n      float dlen = fwidth( len2 );\n      if ( abs( vUv.y ) > 1.0 ) {\n        alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n      }\n    #else\n      if ( abs( vUv.y ) > 1.0 ) {\n        float a = vUv.x;\n        float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n        float len2 = a * a + b * b;\n        if ( len2 > 1.0 ) discard;\n      }\n    #endif\n  #endif\n\n  // if (alpha * bottomEdge < 0.005) {\n  //   discard;\n  // }\n  \n  // Reveal\n  // // float objectSize = 26.0 * 4.;\n  // float objectSize = 100.;\n\n  // float mappedY = map(vWorldPos.y, uGroundFloorBegin, objectSize + 3., 0.0, 1.0);\n  // float progress = (uProgress + uStartOffset) * uSpeed;\n\n  // float bottomEdge = mappedY - progress;\n  // bottomEdge /= uGradientSpread;\n  // bottomEdge = clamp(bottomEdge,0.0, 1.0);\n  // bottomEdge = 1.0 - bottomEdge;\n\n  // gl_FragColor = vec4(uColor, bottomEdge);\n   \n  if (vAlpha < 0.05) {\n    discard;\n  }\n\n  float sinMix = 0.5 + 0.5 * sin(vFakeUv.y * uBlendFrequency + randomOffset(vFakeUv, uSection) - uTime * uBlendSpeed);\n  vec3 baseColor = mix(uColor1, uColor2, sinMix );\n  baseColor *= uColMultiply;\n  gl_FragColor = vec4( baseColor, alpha * vAlpha );\n\n  #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  // Add fog\n  #include <fogOutputFrag>\n  // #include <premultiplied_alpha_fragment>\n  \n}", uniforms: t.uniforms, defines: t.defines, transparent: !1, blending: _, blendEquation: w, blendSrc: B, blendDst: L }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } class sC extends ia { constructor() { super(), this.instanceDummy = new bi, this._v = new An, this.globalUniforms = { uGroundFloorBegin: { value: -50 }, uGradientSpread: { value: .07 }, linewidth: { value: .15 }, uBlendFrequency: { value: 120 }, uBlendSpeed: { value: 1.8 } }, this.load() } build(t) { this.paths = { vectors: {}, pipes: {} }; const e = Object.keys(t.paths).filter((t => t.startsWith("pip-city"))).sort(((t, e) => t.replace("pip", "") - e.replace("pip", ""))).reduce(((e, n) => (e[n] = t.paths[n], e)), {}); for (const t in e) { this.paths.vectors[t.replace("pip-", "").concat("-temp")] = []; for (let n = 0; n < e[t].length - 1; n++) { const i = []; for (let r = 0; r < e[t][n].length; r++) { const s = e[t][n][r]; i.push(new An(s[0], s[1], s[2])) } this.paths.vectors[t.replace("pip-", "").concat("-temp")].push(i) } } for (const e in t) if (e.startsWith("city")) { const n = Object.keys(t[e]).length; this.paths.pipes[e] = []; for (let i = 0; i < n; i++) { lw(this.instanceDummy, t[e][i]); const n = t[e][i][3].section; this.instanceDummy.updateMatrix(); const r = .2 * Ge.seededRandom(n), s = .5 * (Ge.seededRandom(n) + 1); for (let t = 0; t < this.paths.vectors[e.concat("-temp")].length; t++) { const i = []; this.paths.vectors[e.concat("-temp")][t].forEach((t => { const e = t.clone(); e.applyMatrix4(this.instanceDummy.matrix), i.push(e.x, e.y, e.z) })); const o = new Tw; o.setPositions(i); const a = new He; Fh.WebGL.renderer.getSize(a); const l = new Yw(o, new rC({ uniforms: { uColor1: Fh.MainScene.options.pipes.uColor1, uColor2: Fh.MainScene.options.pipes.uColor2, uColMultiply: { value: 1 }, resolution: { value: a }, uSpeed: { value: s }, uStartOffset: { value: r }, uSection: { value: n } }, globalUniforms: this.globalUniforms, defines: { WORLD_UNITS: "" } })); this.add(l), this.paths.pipes[e].push(l) } } } } updateProgress(t) { for (const e in this.paths.pipes) this.paths.pipes[e].forEach((e => { e.material.uniforms.uProgress.value = t })) } load() { this.assets = { models: {}, textures: {} } } } function oC(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class aC { constructor() { oC(this, "toggleAllowInvalidate", (() => { Fh.MainScene.enabled && !this.allowInvalidate && setTimeout((() => { this.allowInvalidate = !0 }), 100) })), this.fogTweenEndPoint = .12, this.activeInsideFogTween = 1, this.allowInvalidate = !1, this.fogValues = { start: { uWorldFogColor: new on(0), uFogNear_D: 0, uFogFar_D: 37, uFogStrength_D: 1, uFogNear_H: -15.2, uFogFar_H: -75, uFogStrength_H: 1, uFogStrength: 1, uWorldFogColorMix: .7065, lights: [{ near: 0, far: 467.4, strength: 0, color: new on(6179898), position: new An(-190, 263, -258) }, { near: 50, far: 869.6, strength: 1, color: new on(12189953), position: new An(-296, 20, -17) }, { near: 16.9, far: 750, strength: 0, color: new on(1052696), position: new An(146, 6.7, -230) }] }, outsideBuilding: { uWorldFogColor: new on(5111808), uFogNear_D: 23.91, uFogFar_D: 250, uFogStrength_D: 1, uFogNear_H: -47.8, uFogFar_H: -64.1, uFogStrength_H: 1, uFogStrength: 1, uWorldFogColorMix: .51, lights: [{ near: 0, far: 369.6, strength: 1, color: new on(16760111), position: new An(-190, 50, -258) }, { near: 50, far: 260.87, strength: 1, color: new on(9043968), position: new An(-296, 20, -17) }, { near: 16.85, far: 288.04, strength: 1.304, color: new on(0), position: new An(146, 6.7, -230) }] }, insideBuilding: { uWorldFogColor: new on(0), uFogNear_D: 10.87, uFogFar_D: 108.7, uFogStrength_D: .8478, uFogNear_H: -35.5, uFogFar_H: -68.1, uFogStrength_H: 1, uFogStrength: 1, uWorldFogColorMix: 1, lights: [{ near: 0, far: 369.6, strength: 1, color: new on(16773441), position: new An(-190, 50, -258) }, { near: 50, far: 260.87, strength: 1, color: new on(9518607), position: new An(-296, 20, -17) }, { near: 16.85, far: 288.04, strength: 1.304, color: new on(49528), position: new An(146, 6.7, -230) }] } }, this.fogTweenValues = { 0: this.fogValues.start, [this.fogTweenEndPoint]: this.fogValues.outsideBuilding }, this.insideFogTweenPoints = [[.15, .264], [.38, .514], [.628, .775]] } build() { this.buildLights(), this.buildSky(), this.buildFogTween(), this.buildInsideFogTween(), this.fogTween.progress(.001), ec.on("Loader:Complete", this.toggleAllowInvalidate) } buildLights() { this.globalUniforms = { uEnableFog: { value: Fh.MainScene.options.fogEnabled }, uColouredMaterials: { value: !1 }, volumetricLights: { value: [...this.fogTweenValues[0].lights] }, uFogNear_D: { value: this.fogTweenValues[0].uFogNear_D }, uFogFar_D: { value: this.fogTweenValues[0].uFogFar_D }, uFogStrength_D: { value: this.fogTweenValues[0].uFogStrength_D }, uFogNear_H: { value: this.fogTweenValues[0].uFogNear_H }, uFogFar_H: { value: this.fogTweenValues[0].uFogFar_H }, uFogStrength_H: { value: this.fogTweenValues[0].uFogStrength_H }, uFogStrength: { value: this.fogTweenValues[0].uFogStrength }, uWorldFogColor: { value: this.fogTweenValues[0].uWorldFogColor }, uWorldFogColorMix: { value: this.fogTweenValues[0].uWorldFogColorMix }, uDebugFog: { value: !1 } }, this.lightCount = this.globalUniforms.volumetricLights.value.length, this.fogDefines = { NUM_V_LIGHTS: this.lightCount }, this.helpers = new ia; for (let t = 0; t < this.lightCount; t++)this.addLightHelper(t); this.helpers.visible = Fh.MainScene.options.lightHelpersEnabled, Fh.MainScene.add(this.helpers) } buildSky() { this.fogBox = new ar(new hr, new Aw({ uniforms: { uColor: { value: new on(0) } } })), this.fogBox.material.side = f, this.fogBox.material.depthWrite = !1, this.fogBox.renderOrder = -1, this.fogBox.scale.setScalar(500), this.fogBox.position.y = 249, Fh.MainScene.add(this.fogBox) } buildFogTween() { this.fogTween = mg.timeline({ paused: !0, defaults: { duration: 1, ease: "sine.inOut" } }).fromTo(this.globalUniforms.uWorldFogColor.value, { r: this.fogTweenValues[0].uWorldFogColor.r, g: this.fogTweenValues[0].uWorldFogColor.g, b: this.fogTweenValues[0].uWorldFogColor.b }, { r: this.fogTweenValues[this.fogTweenEndPoint].uWorldFogColor.r, g: this.fogTweenValues[this.fogTweenEndPoint].uWorldFogColor.g, b: this.fogTweenValues[this.fogTweenEndPoint].uWorldFogColor.b }, 0).fromTo(this.globalUniforms.uFogNear_D, { value: this.fogTweenValues[0].uFogNear_D }, { value: this.fogTweenValues[this.fogTweenEndPoint].uFogNear_D }, 0).fromTo(this.globalUniforms.uFogFar_D, { value: this.fogTweenValues[0].uFogFar_D }, { value: this.fogTweenValues[this.fogTweenEndPoint].uFogFar_D }, 0).fromTo(this.globalUniforms.uFogStrength_D, { value: this.fogTweenValues[0].uFogStrength_D }, { value: this.fogTweenValues[this.fogTweenEndPoint].uFogStrength_D }, 0).fromTo(this.globalUniforms.uFogNear_H, { value: this.fogTweenValues[0].uFogNear_H }, { value: this.fogTweenValues[this.fogTweenEndPoint].uFogNear_H }, 0).fromTo(this.globalUniforms.uFogFar_H, { value: this.fogTweenValues[0].uFogFar_H }, { value: this.fogTweenValues[this.fogTweenEndPoint].uFogFar_H }, 0).fromTo(this.globalUniforms.uFogStrength_H, { value: this.fogTweenValues[0].uFogStrength_H }, { value: this.fogTweenValues[this.fogTweenEndPoint].uFogStrength_H }, 0).fromTo(this.globalUniforms.uFogStrength, { value: this.fogTweenValues[0].uFogStrength }, { value: this.fogTweenValues[this.fogTweenEndPoint].uFogStrength }, 0).fromTo(this.globalUniforms.uWorldFogColorMix, { value: this.fogTweenValues[0].uWorldFogColorMix }, { value: this.fogTweenValues[this.fogTweenEndPoint].uWorldFogColorMix }, 0); for (let t = 0; t < this.fogTweenValues[0].lights.length; t++) { const e = this.fogTweenValues[0].lights[t], n = this.fogTweenValues[this.fogTweenEndPoint].lights[t]; this.fogTween.fromTo(this.globalUniforms.volumetricLights.value[t], { near: e.near, far: e.far, strength: e.strength }, { near: n.near, far: n.far, strength: n.strength }, 0), this.fogTween.fromTo(this.globalUniforms.volumetricLights.value[t].color, { r: e.color.r, g: e.color.g, b: e.color.b }, { r: n.color.r, g: n.color.g, b: n.color.b }, 0), this.fogTween.fromTo(this.globalUniforms.volumetricLights.value[t].position, { x: e.position.x, y: e.position.y, z: e.position.z }, { x: n.position.x, y: n.position.y, z: n.position.z }, 0) } } buildInsideFogTween() { this.insideFogTween = mg.timeline({ paused: !0, defaults: { duration: .5, ease: "sine.inOut" } }).to(this.globalUniforms.uWorldFogColor.value, { r: this.fogValues.insideBuilding.uWorldFogColor.r, g: this.fogValues.insideBuilding.uWorldFogColor.g, b: this.fogValues.insideBuilding.uWorldFogColor.b }, 0).to(this.globalUniforms.uFogNear_D, { value: this.fogValues.insideBuilding.uFogNear_D }, 0).to(this.globalUniforms.uFogFar_D, { value: this.fogValues.insideBuilding.uFogFar_D }, 0).to(this.globalUniforms.uFogStrength_D, { value: this.fogValues.insideBuilding.uFogStrength_D }, 0).to(this.globalUniforms.uFogNear_H, { value: this.fogValues.insideBuilding.uFogNear_H }, 0).to(this.globalUniforms.uFogFar_H, { value: this.fogValues.insideBuilding.uFogFar_H }, 0).to(this.globalUniforms.uFogStrength_H, { value: this.fogValues.insideBuilding.uFogStrength_H }, 0).to(this.globalUniforms.uFogStrength, { value: this.fogValues.insideBuilding.uFogStrength }, 0).to(this.globalUniforms.uWorldFogColorMix, { value: this.fogValues.insideBuilding.uWorldFogColorMix }, 0).to(this.globalUniforms.uWorldFogColor.value, { r: this.fogValues.outsideBuilding.uWorldFogColor.r, g: this.fogValues.outsideBuilding.uWorldFogColor.g, b: this.fogValues.outsideBuilding.uWorldFogColor.b }, .5).to(this.globalUniforms.uFogNear_D, { value: this.fogValues.outsideBuilding.uFogNear_D }, .5).to(this.globalUniforms.uFogFar_D, { value: this.fogValues.outsideBuilding.uFogFar_D }, .5).to(this.globalUniforms.uFogStrength_D, { value: this.fogValues.outsideBuilding.uFogStrength_D }, .5).to(this.globalUniforms.uFogNear_H, { value: this.fogValues.outsideBuilding.uFogNear_H }, .5).to(this.globalUniforms.uFogFar_H, { value: this.fogValues.outsideBuilding.uFogFar_H }, .5).to(this.globalUniforms.uFogStrength_H, { value: this.fogValues.outsideBuilding.uFogStrength_H }, .5).to(this.globalUniforms.uFogStrength, { value: this.fogValues.outsideBuilding.uFogStrength }, .5).to(this.globalUniforms.uWorldFogColorMix, { value: this.fogValues.outsideBuilding.uWorldFogColorMix }, .5) } addLightHelper(t) { const e = new ar(new ul(5, 6, 6), new Li({ wireframe: !0, color: this.globalUniforms.volumetricLights.value[t].color })); e.position.copy(this.globalUniforms.volumetricLights.value[t].position), e.add(new ar(new ul(5, 6, 6), new Li({ wireframe: !0, color: this.globalUniforms.volumetricLights.value[t].color }))), e.children[0].rotation.y = 90 * Math.PI / 180, this.helpers.add(e) } update() { this.fogTween.progress(Fh.MainScene.options.scrollPosition / this.fogTweenEndPoint); const t = this.activeInsideFogTween; Fh.MainScene.options.scrollPosition >= this.insideFogTweenPoints[0][0] - .05 && Fh.MainScene.options.scrollPosition <= this.insideFogTweenPoints[0][1] + .05 ? (this.activeInsideFogTween = 0, this.insideFogTween.progress((Fh.MainScene.options.scrollPosition - this.insideFogTweenPoints[0][0]) / (this.insideFogTweenPoints[0][1] - this.insideFogTweenPoints[0][0]))) : Fh.MainScene.options.scrollPosition >= this.insideFogTweenPoints[1][0] - .05 && Fh.MainScene.options.scrollPosition <= this.insideFogTweenPoints[1][1] + .05 ? (this.activeInsideFogTween = 1, this.insideFogTween.progress((Fh.MainScene.options.scrollPosition - this.insideFogTweenPoints[1][0]) / (this.insideFogTweenPoints[1][1] - this.insideFogTweenPoints[1][0]))) : Fh.MainScene.options.scrollPosition >= this.insideFogTweenPoints[2][0] - .05 && Fh.MainScene.options.scrollPosition <= this.insideFogTweenPoints[2][1] + .05 ? (this.activeInsideFogTween = 2, this.insideFogTween.progress((Fh.MainScene.options.scrollPosition - this.insideFogTweenPoints[2][0]) / (this.insideFogTweenPoints[2][1] - this.insideFogTweenPoints[2][0]))) : this.activeInsideFogTween = !1, this.allowInvalidate && t !== this.activeInsideFogTween && this.insideFogTween.invalidate() } } function lC() { this.position = new An, this.rotation = new vn, this.scale = new An(1, 1, 1), this.matrix = new Yn, this.enablePositionNoise = !0, this.enableRotationNoise = !0, this.positionFrequency = .25, this.rotationFrequency = .25, this.positionAmplitude = .3, this.rotationAmplitude = .003, this.positionScale = new An(1, 1, 1), this.rotationScale = new An(1, 1, 0), this.positionFractalLevel = 3, this.rotationFractalLevel = 3, this.times = new Float32Array(6), this.rehash() } var hC = lC; const cC = lC.prototype; cC.rehash = function () { for (let t = 0; t < 6; t++)this.times[t] = -1e4 * Math.random() }, cC.update = function (t) { let e; if (t = void 0 === t ? 1e3 / 60 : t, this.enablePositionNoise) { for (e = 0; e < 3; e++)this.times[e] += this.positionFrequency * t; dC.set(mC(this.times[0], this.positionFractalLevel), mC(this.times[1], this.positionFractalLevel), mC(this.times[2], this.positionFractalLevel)), dC.multiply(this.positionScale), dC.multiplyScalar(this.positionAmplitude * pC), this.position.copy(dC) } if (this.enableRotationNoise) { for (e = 0; e < 3; e++)this.times[e + 3] += this.rotationFrequency * t; dC.set(mC(this.times[3], this.rotationFractalLevel), mC(this.times[4], this.rotationFractalLevel), mC(this.times[5], this.rotationFractalLevel)), dC.multiply(this.rotationScale), dC.multiplyScalar(this.rotationAmplitude * pC), uC.set(dC.x, dC.y, dC.z), this.rotation.setFromEuler(uC) } this.matrix.compose(this.position, this.rotation, this.scale) }; const uC = new ri, dC = new An, pC = 1 / .75; const fC = new function () { let t = 1, e = 1; const n = []; for (let t = 0; t < 256; ++t)n.push(Math.random()); const i = function (t, e, n) { return t * (1 - n) + e * n }; return { getVal: function (r) { const s = r * e, o = Math.floor(s), a = s - o, l = a * a * (3 - 2 * a), h = 255 & o, c = h + 1 & 255; return i(n[h], n[c], l) * t }, setAmplitude: function (e) { t = e }, setScale: function (t) { e = t } } }; function mC(t, e) { let n = 0, i = .5; for (let r = 0; r < e; r++)n += i * fC.getVal(t), t *= 2, i *= .5; return n } function gC(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function vC(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? gC(Object(n), !0).forEach((function (e) { AC(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : gC(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function AC(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class bC extends fr { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = ew({ uniforms: vC({ uTime: Fh.WebGL.globalUniforms.uTime, uPixelRatio: Fh.WebGL.globalUniforms.uPixelRatio }, Fh.MainScene.components.fog.globalUniforms), defines: vC({}, Fh.MainScene.components.fog.fogDefines) }, t), super({ vertexShader: "#define GLSLIFY 1\nattribute float size;\nattribute float random;\n\nvarying float vRandom;\nvarying float vOpacity;\n\nuniform float uTime;\nuniform float uPixelRatio;\nuniform vec3 uBounds;\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\nfloat pnoise(vec3 P, vec3 rep) {\n    vec3 Pi0 = mod(floor(P), rep);\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep);\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P);\n    vec3 Pf1 = Pf0 - vec3(1.0);\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nconst float noiseFreq = 0.5;\nconst float noiseStrength = 0.5;\nconst float noiseTime = 0.2;\n\nvoid main() {\n    vRandom = random;\n\n    vec3 pos = position;\n    pos.y += uTime * 0.1;\n\n    vec3 displacement = vec3(\n        pnoise(noiseFreq * position + vec3(0., uTime * noiseTime, 0.), vec3(101.0)) * noiseStrength,\n        pnoise(noiseFreq * position + vec3(0., uTime * noiseTime, 0.), vec3(202.0)) * noiseStrength,\n        pnoise(noiseFreq * position + vec3(0., uTime * noiseTime, 0.), vec3(303.0)) * noiseStrength\n    );\n\n    pos += displacement;\n    pos = mod(pos - cameraPosition, uBounds); // loop position inside bounds\n\n    vec3 opacity = smoothstep(vec3(0.), vec3(5.), pos);\n    vOpacity = opacity.x * opacity.y * opacity.z; // fade opacity around edges of bounds\n\n    vOpacity *= smoothstep(40., 20., cameraPosition.z);\n    \n    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n\n    gl_PointSize = size * ( 300.0 / -mvPosition.z ) * uPixelRatio;\n\n    gl_Position = projectionMatrix * mvPosition;\n\n    vOpacity -= smoothstep(5., 1., -mvPosition.z); // fade opacity close to camera\n}", fragmentShader: "#define GLSLIFY 1\nvarying float vRandom;\nvarying float vOpacity;\n\nuniform float uTime;\n\nconst float falloff = 0.08;\n\nvoid main() {\n\tvec3 color = vec3(1., 0.2, 0.2);\n    color += cos(uTime + vRandom * 10.);\n\n    vec2 uv = gl_PointCoord.xy;\n\n    float distanceToCenter = distance(uv, vec2(0.5));\n\tfloat strength = falloff / distanceToCenter - (falloff * 2.);\n\n    gl_FragColor = vec4(color, strength * vOpacity);\n}", uniforms: t.uniforms, defines: t.defines, transparent: !0, blending: b, depthWrite: !1 }), this.globalUniforms = t.globalUniforms, this.uniforms = Object.assign(this.uniforms, this.globalUniforms) } clone(t) { const e = super.clone(); return e.uniforms = Object.assign(e.uniforms, this.globalUniforms), e.uniforms = Object.assign(e.uniforms, t), e } } class yC extends Xa { constructor() { super(); const t = 3e3; this.bounds = new An(60, 40, 20); const e = new Float32Array(9e3), n = new Float32Array(t), i = new Float32Array(t), r = new An; for (let s = 0; s < t; s++)r.x = Ge.randFloat(.5 * -this.bounds.x, .5 * this.bounds.x), r.y = Ge.randFloat(.5 * -this.bounds.y, .5 * this.bounds.y), r.z = Ge.randFloat(.5 * -this.bounds.z, .5 * this.bounds.z), r.toArray(e, 3 * s), n[s] = .35, i[s] = Math.random(); this.geometry.setAttribute("position", new Ri(e, 3)), this.geometry.setAttribute("size", new Ri(n, 1)), this.geometry.setAttribute("random", new Ri(i, 1)), this.frustumCulled = !1, this.renderOrder = 100 } build() { this.material = new bC({ uniforms: { uBounds: { value: this.bounds } } }) } update() { this.position.set(Fh.MainScene.camera.position.x - .5 * this.bounds.x, Fh.MainScene.camera.position.y - .5 * this.bounds.y, Fh.MainScene.camera.position.z - this.bounds.z) } } function xC(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function _C(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class wC extends ua { constructor() { super(), _C(this, "onRaf", (() => { this.enabled && (this.controls.enabled && this.controls.update(), this.smoothMouse[0].lerp(Fh.pointer.glNormalized, .04 * Fh.WebGL.normalizeDelta), this.smoothMouse[1].lerp(Fh.pointer.glNormalized, .03 * Fh.WebGL.normalizeDelta), this.options.noui && !this.controls.enabled && (this.options.scrollPosition = Ge.lerp(this.options.scrollPosition, this.scrollPosition, .1)), this.pathTween.progress(this.options.scrollPosition), this.components.fog.update(), !1 === this.components.towers.animated && (this.components.towers.updateProgress(this.options.revealProgress), this.components.cityPipes.updateProgress(this.options.revealProgress), this.components.signs.updateProgress(this.options.revealProgress), this.components.bridges.globalUniforms.uProgress.value = this.options.mainBuildingReveal, !1 === this.options.towersScroll && this.options.scrollPosition >= .008 && (this.components.towers.animated = !0, this.animateTowers(this.options.revealProgress), this.components.bridges.animateUp(), this.components.cars.enabled = !0)), this.components.mainTower.globalUniforms.uProgress.value = this.options.mainBuildingReveal, this.components.people.globalUniforms.uProgress.value = this.options.revealProgress, this.components.pipes.globalUniforms.uProgress.value = this.options.mainBuildingReveal, this.components.signs.globalUniforms.uProgress.value = this.options.mainBuildingReveal, this.components.shape.globalUniforms.uProgress.value = this.options.revealProgress, this.updateCamera(), this.components.particles.update(), this.controls.enabled ? Fh.WebGL.renderer.render(this, this.devCamera) : (this.composer.render(), this.labelRendererEnabled && Fh.WebGL.labelRenderer.render(this, this.camera)), Fh.Gui && Fh.Gui.refresh(!1)) })), _C(this, "onWheel", (t => { this.controls.enabled || (this.scrollPosition += 1e-4 * t.deltaY * this.options.scrollSpeed, this.scrollPosition = Ge.clamp(this.scrollPosition, 0, 1)) })), _C(this, "onResize", (() => { this.camera.aspect = Fh.window.w / Fh.window.fullHeight, this.camera.updateProjectionMatrix(), this.camera.setFocalLength(80), this.fxaaPass.material.uniforms.resolution.value.x = 1 / (Fh.window.w * Fh.WebGL.renderer.getPixelRatio()), this.fxaaPass.material.uniforms.resolution.value.y = 1 / (Fh.window.fullHeight * Fh.WebGL.renderer.getPixelRatio()), this.bloomPass.setSize(Fh.window.w, Fh.window.fullHeight), this.composer.setSize(Fh.window.w, Fh.window.fullHeight), this.labelRendererEnabled = !Fh.isTouch && Fh.mq.md.matches })), _C(this, "onFPSChecked", (t => { t < 4 && (2 === Fh.WebGL.renderer.getPixelRatio() ? (Fh.WebGL.renderer.setPixelRatio(1.5), this.composer.setPixelRatio(1.5)) : 1.5 === Fh.WebGL.renderer.getPixelRatio() ? (Fh.WebGL.renderer.setPixelRatio(1), this.composer.setPixelRatio(1)) : this.screenFxPass.enabled ? (this.screenFxPass.enabled = !1, this.components.mainTower.globalUniforms.uUseNoise.value = !1) : t < 3 && 1 === Fh.WebGL.renderer.getPixelRatio() && (this.bloomPass.enabled = !1, Fh.WebGL.renderer.setPixelRatio(.75), this.composer.setPixelRatio(.75)), this.fxaaPass.material.uniforms.resolution.value.set(1 / (Fh.window.w * Fh.WebGL.renderer.getPixelRatio()), 1 / (Fh.window.fullHeight * Fh.WebGL.renderer.getPixelRatio())), this.bloomPass.setSize(Fh.window.w, Fh.window.fullHeight), Fh.WebGL.globalUniforms.uResolution.value.set(Fh.window.w * Fh.WebGL.renderer.getPixelRatio(), Fh.window.fullHeight * Fh.WebGL.renderer.getPixelRatio()), Fh.WebGL.globalUniforms.uPixelRatio.value = Fh.WebGL.renderer.getPixelRatio() / Fh.window.dpr) })), this.enabled = !1, this.options = { cameraTargetPathProgress: 0, scrollPosition: parseFloat(Fh.urlParams.get("scrollPos") || 0), scrollSpeed: 1, mouseMoveAngle: new He(.05, .035), cameraMotionPosAmplitude: .026, cameraMotionRotAmplitude: .0132, cameraMotionPosFrequency: .21, cameraMotionRotFrequency: .59, cameraZOffset: 0, cameraYTranslate: 5, cameraZTranslate: 15, revealProgress: 0, mainBuildingReveal: 0, signs: { uColor1: { value: new on(16759194) }, uColor2: { value: new on(15368282) } }, pipes: { uColor1: { value: new on(16759194) }, uColor2: { value: new on(15368282) } }, controls: Fh.urlParams.has("controls"), fogEnabled: !0, lightHelpersEnabled: !1, bloomEnabled: !Fh.urlParams.has("disableBloom"), towersScroll: Fh.urlParams.has("towersScroll"), noui: Fh.urlParams.has("noui") }, this.origOptions = function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? xC(Object(n), !0).forEach((function (e) { _C(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : xC(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({}, this.options), this.scrollPosition = this.options.scrollPosition, this.camera = new gr(45, Fh.window.w / Fh.window.fullHeight, 1, 500), this.camera.filmGauge = 100, this.camera.setFocalLength(80), this.cameraPosition = new An, this.cameraLookAt = new An, this.camera.layers.enableAll(), this.add(this.camera), this.labelRendererEnabled = !1, this.cameraHelper = new Eh(this.camera), this.cameraHelper.visible = !1, this.add(this.cameraHelper), this.devCamera = new gr(45, Fh.window.w / Fh.window.fullHeight, .1, 1e3), this.devCamera.position.z = 150, this.devCamera.position.y = 100, this.controls = new Q_(this.devCamera, Fh.WebGL.renderer.domElement), this.controls.target.set(0, 50, 0), this.controls.enabled = this.options.controls, this.controls.enableDamping = !0, this.background = new on(16630641), this._quaternion = new vn, this._euler = new ri, this.smoothMouse = [new He, new He], this.brownianMotion = new hC, this.brownianMotion.positionAmplitude = this.options.cameraMotionPosAmplitude, this.brownianMotion.rotationAmplitude = this.options.cameraMotionRotAmplitude, this.brownianMotion.positionFrequency = this.options.cameraMotionPosFrequency, this.brownianMotion.rotationFrequency = this.options.cameraMotionRotFrequency, this.composer = new jE(Fh.WebGL.renderer), this.components = { fog: new aC, worldFloor: new RE, mainTower: new bw, pipes: new $w, people: new Sw, logo: new cw, shape: new xE, towers: new kE, cityPipes: new sC, cars: new tw, reflectiveFloors: new hE, signs: new TE, bridges: new tC, particles: new yC }, this.load() } enable() { this.enabled = !0 } disable() { this.enabled = !1 } build() { this.buildPaths(), this.buildPathTween(), this.buildPasses(); for (const t in this.components) this.components[t].build(this.objectData), this.components[t].add && this.add(this.components[t]); Fh.WebGL.renderer.compile(this, this.camera), ec.on(ic.RESIZE, this.onResize) } initialise() { this.setupSectionScrollTriggers(), this.addEvents(), this.enable() } buildPaths() { this.paths = { cars: {}, c: {} }; for (const t in this.objectData.paths) if ("c" === t) for (let e = 0; e < this.objectData.paths[t].length; e++) { if (!this.objectData.paths[t][e].length) continue; const n = []; for (let i = 0; i < this.objectData.paths[t][e].length; i++) { const r = this.objectData.paths[t][e][i]; n.push(new An(r[0], r[1], r[2])) } this.paths.c["c" + e] = new sl(n) } else { const e = []; for (let n = 0; n < this.objectData.paths[t][0].length; n++) { const i = this.objectData.paths[t][0][n]; e.push(new An(i[0], i[1], i[2])) } t.startsWith("car") ? this.paths.cars[t] = new sl(e) : this.paths[t] = new sl(e) } } buildPathTween() { this.pathTween = mg.timeline({ paused: !0, defaults: { ease: "none" } }); for (let t = 0; t < this.objectData.paths.cam[1].stops.length - 1; t++) { const e = .01 * this.objectData.paths.tgt[1].stops[t + 1], n = .01 * this.objectData.paths.cam[1].stops[t + 1], i = .01 * this.objectData.paths.cam[1].stops[t], r = .01 * this.objectData.paths.reveal[1].stops[t + 1], s = .01 * (this.objectData.paths.reveal[1].stops[t + 1] + 5); this.pathTween.to(this.options, { cameraTargetPathProgress: e, duration: n - i, revealProgress: r, mainBuildingReveal: s }) } } setupSectionScrollTriggers() { const t = Zx.create("custom", "M0,0,C0.4,0.018,0.398,0.3,0.507,0.512,0.6,0.693,0.6,0.984,1,1"), e = [{ start: "top top", end: "top+=50% top", ease: t, pivotDistance: 15 }, { start: "top+=50% top", end: "top+=50% top", ease: t, pivotDistance: 10 }, { start: "top+=50% top", end: "top+=50% top", ease: t, pivotDistance: 12 }, { start: "top+=50% top", end: "bottom top", ease: t, pivotDistance: 12 }, { pivotDistance: 100 }]; this.options.cameraZOffset = e[0].pivotDistance, this.sectionScrollTriggers = []; for (let t = 0; t < 4; t++) { const n = mg.timeline({ paused: !0 }).fromTo(this.options, { scrollPosition: .01 * this.objectData.paths.cam[1].stops[t], cameraZOffset: e[t].pivotDistance }, { scrollPosition: .01 * this.objectData.paths.cam[1].stops[t + 1], cameraZOffset: e[t + 1].pivotDistance, ease: e[t].ease, immediateRender: !1 }), i = xy.create({ trigger: `.js-section-${t}`, endTrigger: `.js-section-${t + 1}`, start: e[t].start, end: e[t].end, refreshPriority: -1, onUpdate: t => { n.progress(t.progress) } }); this.sectionScrollTriggers.push(n, i) } } buildPasses() { this.renderScene = new WE(this, this.camera), this.fxaaPass = new QE(qE), this.fxaaPass.material.uniforms.resolution.value.x = 1 / (Fh.window.w * Fh.WebGL.renderer.getPixelRatio()), this.fxaaPass.material.uniforms.resolution.value.y = 1 / (Fh.window.fullHeight * Fh.WebGL.renderer.getPixelRatio()), this.bloomPass = new XE(new He(Fh.window.w, Fh.window.fullHeight), 2.12, 1, .717), this.bloomPass.enabled = this.options.bloomEnabled, this.screenFxPass = new QE(new fr({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main()\t{\n    vec4 mvPosition = vec4( position, 1.0 );\n    #ifdef USE_INSTANCING\n        mvPosition = instanceMatrix * mvPosition;\n    #endif\n    vUv = uv;\n    mvPosition = modelViewMatrix * mvPosition;\n    gl_Position = projectionMatrix * mvPosition;\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform sampler2D tDiffuse;\nuniform float uMaxDistort;\nuniform int uIterations;\nuniform float uBendAmount;\n\nconst int iterations = 5;\n\nvec2 barrelDistortion(vec2 coord, float amt) {\n\tvec2 cc = coord - 0.5;\n\tfloat dist = dot(cc, cc);\n\treturn coord + cc * dist * amt;\n}\n\nfloat sat( float t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n\nfloat remap( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}\n\nvec4 spectrum_offset( float t ) {\n\tvec4 ret;\n\tfloat lo = step(t,0.5);\n\tfloat hi = 1.0-lo;\n\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\n\treturn pow( ret, vec4(1.0/2.2) );\n}\n\nvoid main()\n{\t\n\tvec4 sumcol = vec4(0.0);\n\tvec4 sumw = vec4(0.0);\n    float reci_num_iter_f = 1.0 / float(iterations);\n\tfor (int i = 0; i < iterations; i++){\n\t\tfloat t = float(i) * reci_num_iter_f;\n\t\tvec4 w = spectrum_offset( t );\n\t\tsumw += w;\n\t\tsumcol += w * texture2D( tDiffuse, barrelDistortion(vUv, uBendAmount * uMaxDistort*t ) );\n\t}\n\t\t\n\tgl_FragColor = vec4(sumcol / sumw);\n}", uniforms: { tDiffuse: { value: null }, uMaxDistort: { value: .251 }, uBendAmount: { value: -.272 } } })), this.composer.addPass(this.renderScene), this.composer.addPass(this.fxaaPass), this.composer.addPass(this.bloomPass), this.composer.addPass(this.screenFxPass) } playIntro() { Fh.MainScene.options.scrollPosition <= .015 && this.components.logo.animateIn(), mg.to(this.options, { cameraYTranslate: 0, cameraZTranslate: 0, ease: "expo.out", duration: 3 }) } updateCamera() { this.paths.cam.getPointAt(this.options.scrollPosition, this.cameraPosition), Fh.mq.md.matches ? this.paths.tgt.getPointAt(this.options.cameraTargetPathProgress, this.cameraLookAt) : this.paths["tgt-mob"].getPointAt(this.options.cameraTargetPathProgress, this.cameraLookAt), this.camera.position.copy(this.cameraPosition), this.camera.lookAt(this.cameraLookAt), this.camera.translateZ(this.options.cameraZTranslate), this.camera.translateY(this.options.cameraYTranslate), Fh.isTouch || this.controls.enabled || (this.brownianMotion.update(.5 * Fh.WebGL.clockDelta * Fh.WebGL.normalizeDelta), this.camera.updateMatrix(), this.camera.matrix.multiply(this.brownianMotion.matrix), this.camera.matrix.decompose(this.camera.position, this.camera.quaternion, this.camera.scale), this.camera.translateZ(-this.options.cameraZOffset), this._euler.set(this.smoothMouse[0].y * this.options.mouseMoveAngle.y, -this.smoothMouse[0].x * this.options.mouseMoveAngle.x, 0), this._quaternion.setFromEuler(this._euler), this.camera.quaternion.multiply(this._quaternion), this._euler.set(0, 0, -.05 * (this.smoothMouse[0].x - this.smoothMouse[1].x)), this._quaternion.setFromEuler(this._euler), this.camera.quaternion.multiply(this._quaternion), this.camera.translateZ(this.options.cameraZOffset), this.camera.updateMatrixWorld()) } addEvents() { ec.on("FPSChecked", this.onFPSChecked), Fh.urlParams.has("noui") && ec.on("wheel", window, this.onWheel), Fh.RAFCollection.add(this.onRaf, 99) } removeEvents() { ec.off("FPSChecked", this.onFPSChecked), Fh.urlParams.has("noui") && ec.off("wheel", window, this.onWheel), Fh.RAFCollection.remove(this.onRaf) } animateTowers(t) { const e = mg.timeline(); for (const t in this.components.towers.meshes) { const n = Ge.randFloat(8, 12); e.to(this.components.towers.meshes[t].material.uniforms.uProgress, { value: 2, duration: n, ease: "sine.inOut", delay: 0 }, 0), this.components.cityPipes.paths.pipes[t].forEach((t => { e.to(t.material.uniforms.uProgress, { value: 2, duration: n, ease: "sine.inOut", delay: 0 }, 0) })), this.components.signs.meshes.city[t].forEach((t => { e.to(t.material.uniforms.uCityProgress, { value: 2, duration: n, ease: "sine.inOut", delay: 0 }, 0) })) } } load() { this.assets = { textures: {}, models: {} }, Fh.AssetLoader.loadJson(Fh.publicUrl + "webgl/objectdata.unseen").then((t => { this.objectData = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/faces_2.ktx2", { wrapping: at }).then((t => { this.assets.textures.recursiveMask2 = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/faces_3.ktx2", { wrapping: at }).then((t => { this.assets.textures.recursiveMask3 = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/hex.ktx2", { wrapping: at, encoding: be }).then((t => { this.assets.textures.hexTexture = t })), Fh.AssetLoader.loadKtxTexture(Fh.publicUrl + "webgl/images/matcap.ktx2", { encoding: be }).then((t => { this.assets.textures.matcap = t })) } destroy() { this.removeEvents(), this.sectionScrollTriggers.forEach((t => { t.kill() })); for (const t in this.components) this.components[t].destroy && this.components[t].destroy(); Object.assign(this.options, this.origOptions) } } function EC(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } class CC { constructor() { EC(this, "check", (() => { if (!this.run) return; this.frames++; const t = performance.now(); if (t >= this.prevTime + this.checkInterval) { const e = 1e3 * this.frames / (t - this.prevTime); if (e > 1 && (this.avgFps.push(e), this.checkCount++, 5 === this.checkCount)) { this.run = !1; const t = Math.min(...this.avgFps), e = Math.max(...this.avgFps); for (let e = 0; e < this.avgFps.length; e++)if (this.avgFps[e] === t) { this.avgFps.splice(e, 1); break } for (let t = 0; t < this.avgFps.length; t++)if (this.avgFps[t] === e) { this.avgFps.splice(t, 1); break } const n = Math.ceil(this.avgFps.reduce(((t, e) => t + e), 0) / this.avgFps.length); this.avgFps = [], Fh.gpuTier = this.tiers.filter((t => n >= t)).length, this.totalChecks++, requestAnimationFrame((() => { setTimeout((() => { ec.emit("FPSChecked", Fh.gpuTier) }), 0) })), Fh.gpuTier < this.totalCheckLimit && this.totalChecks < this.totalCheckLimit && this.enable() } this.prevTime = t, this.frames = 0 } })), EC(this, "onDocVisibilityChange", (() => { this.run && "visible" === document.visibilityState && (this.prevTime = performance.now(), this.frames = 0) })), EC(this, "onResize", (() => { this.run && (this.prevTime = performance.now(), this.frames = 0, this.checkCount = 0, this.avgFps = []) })), this.run = !1, this.hasRun = !1, this.checkInterval = 800, this.frames = 0, this.prevTime = 0, this.checkCount = 0, this.totalChecks = 0, this.tiers = [15, 30, 45, 55], this.totalCheckLimit = 10, Fh.gpuTier = this.tiers.length, this.avgFps = [], Fh.urlParams.has("forcehq") || (Fh.RAFCollection.add(this.check, 100), document.addEventListener("visibilitychange", this.onDocVisibilityChange), ec.on(ic.RESIZE, this.onResize), ec.on("CheckFPS", (() => { this.avgFps = [], this.totalChecks = 0, this.hasRun = !0, this.enable() }))) } enable() { this.checkCount = 0, this.run = !0 } disable() { this.run = !1 } } function SC(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), n.push.apply(n, i) } return n } function MC(t, e, n) { return (e = function (t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var i = n.call(t, e || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) }(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } ec.on("DOMContentLoaded", window, (function () { var t; ic.enableResize(100), ic.enableRAF(mg), ic.detectTouchDevice(), ic.enablePointerEvents(), ic.enableDrag(), mg.registerPlugin(xy), mg.registerPlugin(Zx), mg.registerPlugin(h_), Zx.create("customOut", "0.29, 0.01, 0, 1"), xy.config({ ignoreMobileResize: !0 }), window.history.scrollRestoration && (window.history.scrollRestoration = "manual"), document.documentElement.style.setProperty("--vh", .01 * window.innerHeight + "px"), Fh.window.fullHeight = null === (t = document.querySelector(".height-div")) || void 0 === t ? void 0 : t.clientHeight, Fh.isIOS && Fh.window.fullHeight === Fh.window.h && (Fh.window.fullHeight *= 1.2), Array.from(document.styleSheets).filter((t => null === t.href || t.href.startsWith(window.location.origin))).reduce(((t, e) => [...t, ...Array.from(e.cssRules).reduce(((t, e) => ":root" === e.selectorText ? [...t, ...Array.from(e.style).filter((t => t.startsWith("--bp-")))] : t), [])]), []).forEach((t => { Fh.mq[t.replace("--bp-", "")] = window.matchMedia(getComputedStyle(document.documentElement).getPropertyValue(t)) })), Object.assign(Fh, function (t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}; e % 2 ? SC(Object(n), !0).forEach((function (e) { MC(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : SC(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t }({}, window.globalData)), window.store = Fh, Fh.RAFCollection = new sc, Fh.FPSChecker = new CC, Fh.AssetLoader = new Su, Fh.ScrollAnimations = new Cg, Fh.urlParams.has("nowebgl") || (Fh.WebGL = new N_, Fh.MainScene = new wC), Fh.urlParams.has("noui") && window.setTimeout((() => { document.querySelector("[data-taxi]").style.display = "none", document.querySelector("header").style.display = "none", document.querySelector(".loader").style.display = "none", document.querySelector(".js-hero").style.display = "none" })), Fh.Lenis = new g_({ wrapper: Sh(".scroll-container"), content: Sh(".scroll-container > div"), easing: t => 1 - Math.pow(1 - t, 4) }), Fh.Lenis.stop(), Fh.RAFCollection.add((t => { Fh.Lenis.raf(1e3 * t) }), 0), Fh.Lenis.on("scroll", (() => { xy.update() })), xy.defaults({ scroller: Sh(".scroll-container") }), Fh.Taxi = new Ix, Fh.pinType = "fixed", Fh.staticComponents.add(Ry, A_, By), Fh.Header = new y_(Sh(".js-header")), Mg.init(); let e = .01 * Fh.window.h; document.documentElement.style.setProperty("--vh", `${e}px`), window.addEventListener("resize", (() => { e = .01 * window.innerHeight, document.documentElement.style.setProperty("--vh", `${e}px`) })) })) }, 9742: function (t, e) { "use strict"; e.byteLength = function (t) { var e = l(t), n = e[0], i = e[1]; return 3 * (n + i) / 4 - i }, e.toByteArray = function (t) { var e, n, s = l(t), o = s[0], a = s[1], h = new r(function (t, e, n) { return 3 * (e + n) / 4 - n }(0, o, a)), c = 0, u = a > 0 ? o - 4 : o; for (n = 0; n < u; n += 4)e = i[t.charCodeAt(n)] << 18 | i[t.charCodeAt(n + 1)] << 12 | i[t.charCodeAt(n + 2)] << 6 | i[t.charCodeAt(n + 3)], h[c++] = e >> 16 & 255, h[c++] = e >> 8 & 255, h[c++] = 255 & e; 2 === a && (e = i[t.charCodeAt(n)] << 2 | i[t.charCodeAt(n + 1)] >> 4, h[c++] = 255 & e); 1 === a && (e = i[t.charCodeAt(n)] << 10 | i[t.charCodeAt(n + 1)] << 4 | i[t.charCodeAt(n + 2)] >> 2, h[c++] = e >> 8 & 255, h[c++] = 255 & e); return h }, e.fromByteArray = function (t) { for (var e, i = t.length, r = i % 3, s = [], o = 16383, a = 0, l = i - r; a < l; a += o)s.push(h(t, a, a + o > l ? l : a + o)); 1 === r ? (e = t[i - 1], s.push(n[e >> 2] + n[e << 4 & 63] + "==")) : 2 === r && (e = (t[i - 2] << 8) + t[i - 1], s.push(n[e >> 10] + n[e >> 4 & 63] + n[e << 2 & 63] + "=")); return s.join("") }; for (var n = [], i = [], r = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = s.length; o < a; ++o)n[o] = s[o], i[s.charCodeAt(o)] = o; function l(t) { var e = t.length; if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var n = t.indexOf("="); return -1 === n && (n = e), [n, n === e ? 0 : 4 - n % 4] } function h(t, e, i) { for (var r, s, o = [], a = e; a < i; a += 3)r = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), o.push(n[(s = r) >> 18 & 63] + n[s >> 12 & 63] + n[s >> 6 & 63] + n[63 & s]); return o.join("") } i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63 }, 8764: function (t, e, n) { "use strict"; var i = n(9742), r = n(645), s = n(5826); function o() { return l.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function a(t, e) { if (o() < e) throw new RangeError("Invalid typed array length"); return l.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = l.prototype : (null === t && (t = new l(e)), t.length = e), t } function l(t, e, n) { if (!(l.TYPED_ARRAY_SUPPORT || this instanceof l)) return new l(t, e, n); if ("number" == typeof t) { if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string"); return u(this, t) } return h(this, t, e, n) } function h(t, e, n, i) { if ("number" == typeof e) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, n, i) { if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < n + (i || 0)) throw new RangeError("'length' is out of bounds"); e = void 0 === n && void 0 === i ? new Uint8Array(e) : void 0 === i ? new Uint8Array(e, n) : new Uint8Array(e, n, i); l.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = l.prototype : t = d(t, e); return t }(t, e, n, i) : "string" == typeof e ? function (t, e, n) { "string" == typeof n && "" !== n || (n = "utf8"); if (!l.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var i = 0 | f(e, n); t = a(t, i); var r = t.write(e, n); r !== i && (t = t.slice(0, r)); return t }(t, e, n) : function (t, e) { if (l.isBuffer(e)) { var n = 0 | p(e.length); return 0 === (t = a(t, n)).length || e.copy(t, 0, 0, n), t } if (e) { if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (i = e.length) != i ? a(t, 0) : d(t, e); if ("Buffer" === e.type && s(e.data)) return d(t, e.data) } var i; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(t, e) } function c(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function u(t, e) { if (c(e), t = a(t, e < 0 ? 0 : 0 | p(e)), !l.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n)t[n] = 0; return t } function d(t, e) { var n = e.length < 0 ? 0 : 0 | p(e.length); t = a(t, n); for (var i = 0; i < n; i += 1)t[i] = 255 & e[i]; return t } function p(t) { if (t >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes"); return 0 | t } function f(t, e) { if (l.isBuffer(t)) return t.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength; "string" != typeof t && (t = "" + t); var n = t.length; if (0 === n) return 0; for (var i = !1; ;)switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return V(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return Q(t).length; default: if (i) return V(t).length; e = ("" + e).toLowerCase(), i = !0 } } function m(t, e, n) { var i = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return T(this, e, n); case "utf8": case "utf-8": return S(this, e, n); case "ascii": return P(this, e, n); case "latin1": case "binary": return I(this, e, n); case "base64": return C(this, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return D(this, e, n); default: if (i) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), i = !0 } } function g(t, e, n) { var i = t[e]; t[e] = t[n], t[n] = i } function v(t, e, n, i, r) { if (0 === t.length) return -1; if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = r ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) { if (r) return -1; n = t.length - 1 } else if (n < 0) { if (!r) return -1; n = 0 } if ("string" == typeof e && (e = l.from(e, i)), l.isBuffer(e)) return 0 === e.length ? -1 : A(t, e, n, i, r); if ("number" == typeof e) return e &= 255, l.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : A(t, [e], n, i, r); throw new TypeError("val must be string, number or Buffer") } function A(t, e, n, i, r) { var s, o = 1, a = t.length, l = e.length; if (void 0 !== i && ("ucs2" === (i = String(i).toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) { if (t.length < 2 || e.length < 2) return -1; o = 2, a /= 2, l /= 2, n /= 2 } function h(t, e) { return 1 === o ? t[e] : t.readUInt16BE(e * o) } if (r) { var c = -1; for (s = n; s < a; s++)if (h(t, s) === h(e, -1 === c ? 0 : s - c)) { if (-1 === c && (c = s), s - c + 1 === l) return c * o } else -1 !== c && (s -= s - c), c = -1 } else for (n + l > a && (n = a - l), s = n; s >= 0; s--) { for (var u = !0, d = 0; d < l; d++)if (h(t, s + d) !== h(e, d)) { u = !1; break } if (u) return s } return -1 } function b(t, e, n, i) { n = Number(n) || 0; var r = t.length - n; i ? (i = Number(i)) > r && (i = r) : i = r; var s = e.length; if (s % 2 != 0) throw new TypeError("Invalid hex string"); i > s / 2 && (i = s / 2); for (var o = 0; o < i; ++o) { var a = parseInt(e.substr(2 * o, 2), 16); if (isNaN(a)) return o; t[n + o] = a } return o } function y(t, e, n, i) { return G(V(e, t.length - n), t, n, i) } function x(t, e, n, i) { return G(function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(255 & t.charCodeAt(n)); return e }(e), t, n, i) } function _(t, e, n, i) { return x(t, e, n, i) } function w(t, e, n, i) { return G(Q(e), t, n, i) } function E(t, e, n, i) { return G(function (t, e) { for (var n, i, r, s = [], o = 0; o < t.length && !((e -= 2) < 0); ++o)i = (n = t.charCodeAt(o)) >> 8, r = n % 256, s.push(r), s.push(i); return s }(e, t.length - n), t, n, i) } function C(t, e, n) { return 0 === e && n === t.length ? i.fromByteArray(t) : i.fromByteArray(t.slice(e, n)) } function S(t, e, n) { n = Math.min(t.length, n); for (var i = [], r = e; r < n;) { var s, o, a, l, h = t[r], c = null, u = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1; if (r + u <= n) switch (u) { case 1: h < 128 && (c = h); break; case 2: 128 == (192 & (s = t[r + 1])) && (l = (31 & h) << 6 | 63 & s) > 127 && (c = l); break; case 3: s = t[r + 1], o = t[r + 2], 128 == (192 & s) && 128 == (192 & o) && (l = (15 & h) << 12 | (63 & s) << 6 | 63 & o) > 2047 && (l < 55296 || l > 57343) && (c = l); break; case 4: s = t[r + 1], o = t[r + 2], a = t[r + 3], 128 == (192 & s) && 128 == (192 & o) && 128 == (192 & a) && (l = (15 & h) << 18 | (63 & s) << 12 | (63 & o) << 6 | 63 & a) > 65535 && l < 1114112 && (c = l) }null === c ? (c = 65533, u = 1) : c > 65535 && (c -= 65536, i.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), i.push(c), r += u } return function (t) { var e = t.length; if (e <= M) return String.fromCharCode.apply(String, t); var n = "", i = 0; for (; i < e;)n += String.fromCharCode.apply(String, t.slice(i, i += M)); return n }(i) } e.lW = l, e.h2 = 50, l.TYPED_ARRAY_SUPPORT = void 0 !== n.g.TYPED_ARRAY_SUPPORT ? n.g.TYPED_ARRAY_SUPPORT : function () { try { var t = new Uint8Array(1); return t.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength } catch (t) { return !1 } }(), o(), l.poolSize = 8192, l._augment = function (t) { return t.__proto__ = l.prototype, t }, l.from = function (t, e, n) { return h(null, t, e, n) }, l.TYPED_ARRAY_SUPPORT && (l.prototype.__proto__ = Uint8Array.prototype, l.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && l[Symbol.species] === l && Object.defineProperty(l, Symbol.species, { value: null, configurable: !0 })), l.alloc = function (t, e, n) { return function (t, e, n, i) { return c(e), e <= 0 ? a(t, e) : void 0 !== n ? "string" == typeof i ? a(t, e).fill(n, i) : a(t, e).fill(n) : a(t, e) }(null, t, e, n) }, l.allocUnsafe = function (t) { return u(null, t) }, l.allocUnsafeSlow = function (t) { return u(null, t) }, l.isBuffer = function (t) { return !(null == t || !t._isBuffer) }, l.compare = function (t, e) { if (!l.isBuffer(t) || !l.isBuffer(e)) throw new TypeError("Arguments must be Buffers"); if (t === e) return 0; for (var n = t.length, i = e.length, r = 0, s = Math.min(n, i); r < s; ++r)if (t[r] !== e[r]) { n = t[r], i = e[r]; break } return n < i ? -1 : i < n ? 1 : 0 }, l.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, l.concat = function (t, e) { if (!s(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return l.alloc(0); var n; if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n)e += t[n].length; var i = l.allocUnsafe(e), r = 0; for (n = 0; n < t.length; ++n) { var o = t[n]; if (!l.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers'); o.copy(i, r), r += o.length } return i }, l.byteLength = f, l.prototype._isBuffer = !0, l.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var e = 0; e < t; e += 2)g(this, e, e + 1); return this }, l.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var e = 0; e < t; e += 4)g(this, e, e + 3), g(this, e + 1, e + 2); return this }, l.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var e = 0; e < t; e += 8)g(this, e, e + 7), g(this, e + 1, e + 6), g(this, e + 2, e + 5), g(this, e + 3, e + 4); return this }, l.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? S(this, 0, t) : m.apply(this, arguments) }, l.prototype.equals = function (t) { if (!l.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === l.compare(this, t) }, l.prototype.inspect = function () { var t = "", n = e.h2; return this.length > 0 && (t = this.toString("hex", 0, n).match(/.{2}/g).join(" "), this.length > n && (t += " ... ")), "<Buffer " + t + ">" }, l.prototype.compare = function (t, e, n, i, r) { if (!l.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === i && (i = 0), void 0 === r && (r = this.length), e < 0 || n > t.length || i < 0 || r > this.length) throw new RangeError("out of range index"); if (i >= r && e >= n) return 0; if (i >= r) return -1; if (e >= n) return 1; if (this === t) return 0; for (var s = (r >>>= 0) - (i >>>= 0), o = (n >>>= 0) - (e >>>= 0), a = Math.min(s, o), h = this.slice(i, r), c = t.slice(e, n), u = 0; u < a; ++u)if (h[u] !== c[u]) { s = h[u], o = c[u]; break } return s < o ? -1 : o < s ? 1 : 0 }, l.prototype.includes = function (t, e, n) { return -1 !== this.indexOf(t, e, n) }, l.prototype.indexOf = function (t, e, n) { return v(this, t, e, n, !0) }, l.prototype.lastIndexOf = function (t, e, n) { return v(this, t, e, n, !1) }, l.prototype.write = function (t, e, n, i) { if (void 0 === e) i = "utf8", n = this.length, e = 0; else if (void 0 === n && "string" == typeof e) i = e, n = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e |= 0, isFinite(n) ? (n |= 0, void 0 === i && (i = "utf8")) : (i = n, n = void 0) } var r = this.length - e; if ((void 0 === n || n > r) && (n = r), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); i || (i = "utf8"); for (var s = !1; ;)switch (i) { case "hex": return b(this, t, e, n); case "utf8": case "utf-8": return y(this, t, e, n); case "ascii": return x(this, t, e, n); case "latin1": case "binary": return _(this, t, e, n); case "base64": return w(this, t, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return E(this, t, e, n); default: if (s) throw new TypeError("Unknown encoding: " + i); i = ("" + i).toLowerCase(), s = !0 } }, l.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var M = 4096; function P(t, e, n) { var i = ""; n = Math.min(t.length, n); for (var r = e; r < n; ++r)i += String.fromCharCode(127 & t[r]); return i } function I(t, e, n) { var i = ""; n = Math.min(t.length, n); for (var r = e; r < n; ++r)i += String.fromCharCode(t[r]); return i } function T(t, e, n) { var i = t.length; (!e || e < 0) && (e = 0), (!n || n < 0 || n > i) && (n = i); for (var r = "", s = e; s < n; ++s)r += z(t[s]); return r } function D(t, e, n) { for (var i = t.slice(e, n), r = "", s = 0; s < i.length; s += 2)r += String.fromCharCode(i[s] + 256 * i[s + 1]); return r } function B(t, e, n) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > n) throw new RangeError("Trying to access beyond buffer length") } function L(t, e, n, i, r, s) { if (!l.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > r || e < s) throw new RangeError('"value" argument is out of bounds'); if (n + i > t.length) throw new RangeError("Index out of range") } function F(t, e, n, i) { e < 0 && (e = 65535 + e + 1); for (var r = 0, s = Math.min(t.length - n, 2); r < s; ++r)t[n + r] = (e & 255 << 8 * (i ? r : 1 - r)) >>> 8 * (i ? r : 1 - r) } function k(t, e, n, i) { e < 0 && (e = 4294967295 + e + 1); for (var r = 0, s = Math.min(t.length - n, 4); r < s; ++r)t[n + r] = e >>> 8 * (i ? r : 3 - r) & 255 } function R(t, e, n, i, r, s) { if (n + i > t.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function O(t, e, n, i, s) { return s || R(t, 0, n, 4), r.write(t, e, n, i, 23, 4), n + 4 } function N(t, e, n, i, s) { return s || R(t, 0, n, 8), r.write(t, e, n, i, 52, 8), n + 8 } l.prototype.slice = function (t, e) { var n, i = this.length; if ((t = ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i), (e = void 0 === e ? i : ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i), e < t && (e = t), l.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, e)).__proto__ = l.prototype; else { var r = e - t; n = new l(r, void 0); for (var s = 0; s < r; ++s)n[s] = this[s + t] } return n }, l.prototype.readUIntLE = function (t, e, n) { t |= 0, e |= 0, n || B(t, e, this.length); for (var i = this[t], r = 1, s = 0; ++s < e && (r *= 256);)i += this[t + s] * r; return i }, l.prototype.readUIntBE = function (t, e, n) { t |= 0, e |= 0, n || B(t, e, this.length); for (var i = this[t + --e], r = 1; e > 0 && (r *= 256);)i += this[t + --e] * r; return i }, l.prototype.readUInt8 = function (t, e) { return e || B(t, 1, this.length), this[t] }, l.prototype.readUInt16LE = function (t, e) { return e || B(t, 2, this.length), this[t] | this[t + 1] << 8 }, l.prototype.readUInt16BE = function (t, e) { return e || B(t, 2, this.length), this[t] << 8 | this[t + 1] }, l.prototype.readUInt32LE = function (t, e) { return e || B(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, l.prototype.readUInt32BE = function (t, e) { return e || B(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, l.prototype.readIntLE = function (t, e, n) { t |= 0, e |= 0, n || B(t, e, this.length); for (var i = this[t], r = 1, s = 0; ++s < e && (r *= 256);)i += this[t + s] * r; return i >= (r *= 128) && (i -= Math.pow(2, 8 * e)), i }, l.prototype.readIntBE = function (t, e, n) { t |= 0, e |= 0, n || B(t, e, this.length); for (var i = e, r = 1, s = this[t + --i]; i > 0 && (r *= 256);)s += this[t + --i] * r; return s >= (r *= 128) && (s -= Math.pow(2, 8 * e)), s }, l.prototype.readInt8 = function (t, e) { return e || B(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, l.prototype.readInt16LE = function (t, e) { e || B(t, 2, this.length); var n = this[t] | this[t + 1] << 8; return 32768 & n ? 4294901760 | n : n }, l.prototype.readInt16BE = function (t, e) { e || B(t, 2, this.length); var n = this[t + 1] | this[t] << 8; return 32768 & n ? 4294901760 | n : n }, l.prototype.readInt32LE = function (t, e) { return e || B(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, l.prototype.readInt32BE = function (t, e) { return e || B(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, l.prototype.readFloatLE = function (t, e) { return e || B(t, 4, this.length), r.read(this, t, !0, 23, 4) }, l.prototype.readFloatBE = function (t, e) { return e || B(t, 4, this.length), r.read(this, t, !1, 23, 4) }, l.prototype.readDoubleLE = function (t, e) { return e || B(t, 8, this.length), r.read(this, t, !0, 52, 8) }, l.prototype.readDoubleBE = function (t, e) { return e || B(t, 8, this.length), r.read(this, t, !1, 52, 8) }, l.prototype.writeUIntLE = function (t, e, n, i) { (t = +t, e |= 0, n |= 0, i) || L(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var r = 1, s = 0; for (this[e] = 255 & t; ++s < n && (r *= 256);)this[e + s] = t / r & 255; return e + n }, l.prototype.writeUIntBE = function (t, e, n, i) { (t = +t, e |= 0, n |= 0, i) || L(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var r = n - 1, s = 1; for (this[e + r] = 255 & t; --r >= 0 && (s *= 256);)this[e + r] = t / s & 255; return e + n }, l.prototype.writeUInt8 = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 1, 255, 0), l.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1 }, l.prototype.writeUInt16LE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 2, 65535, 0), l.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : F(this, t, e, !0), e + 2 }, l.prototype.writeUInt16BE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 2, 65535, 0), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : F(this, t, e, !1), e + 2 }, l.prototype.writeUInt32LE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 4, 4294967295, 0), l.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : k(this, t, e, !0), e + 4 }, l.prototype.writeUInt32BE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 4, 4294967295, 0), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : k(this, t, e, !1), e + 4 }, l.prototype.writeIntLE = function (t, e, n, i) { if (t = +t, e |= 0, !i) { var r = Math.pow(2, 8 * n - 1); L(this, t, e, n, r - 1, -r) } var s = 0, o = 1, a = 0; for (this[e] = 255 & t; ++s < n && (o *= 256);)t < 0 && 0 === a && 0 !== this[e + s - 1] && (a = 1), this[e + s] = (t / o >> 0) - a & 255; return e + n }, l.prototype.writeIntBE = function (t, e, n, i) { if (t = +t, e |= 0, !i) { var r = Math.pow(2, 8 * n - 1); L(this, t, e, n, r - 1, -r) } var s = n - 1, o = 1, a = 0; for (this[e + s] = 255 & t; --s >= 0 && (o *= 256);)t < 0 && 0 === a && 0 !== this[e + s + 1] && (a = 1), this[e + s] = (t / o >> 0) - a & 255; return e + n }, l.prototype.writeInt8 = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 1, 127, -128), l.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, l.prototype.writeInt16LE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 2, 32767, -32768), l.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : F(this, t, e, !0), e + 2 }, l.prototype.writeInt16BE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 2, 32767, -32768), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : F(this, t, e, !1), e + 2 }, l.prototype.writeInt32LE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 4, 2147483647, -2147483648), l.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : k(this, t, e, !0), e + 4 }, l.prototype.writeInt32BE = function (t, e, n) { return t = +t, e |= 0, n || L(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : k(this, t, e, !1), e + 4 }, l.prototype.writeFloatLE = function (t, e, n) { return O(this, t, e, !0, n) }, l.prototype.writeFloatBE = function (t, e, n) { return O(this, t, e, !1, n) }, l.prototype.writeDoubleLE = function (t, e, n) { return N(this, t, e, !0, n) }, l.prototype.writeDoubleBE = function (t, e, n) { return N(this, t, e, !1, n) }, l.prototype.copy = function (t, e, n, i) { if (n || (n = 0), i || 0 === i || (i = this.length), e >= t.length && (e = t.length), e || (e = 0), i > 0 && i < n && (i = n), i === n) return 0; if (0 === t.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (i < 0) throw new RangeError("sourceEnd out of bounds"); i > this.length && (i = this.length), t.length - e < i - n && (i = t.length - e + n); var r, s = i - n; if (this === t && n < e && e < i) for (r = s - 1; r >= 0; --r)t[r + e] = this[r + n]; else if (s < 1e3 || !l.TYPED_ARRAY_SUPPORT) for (r = 0; r < s; ++r)t[r + e] = this[r + n]; else Uint8Array.prototype.set.call(t, this.subarray(n, n + s), e); return s }, l.prototype.fill = function (t, e, n, i) { if ("string" == typeof t) { if ("string" == typeof e ? (i = e, e = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), 1 === t.length) { var r = t.charCodeAt(0); r < 256 && (t = r) } if (void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string"); if ("string" == typeof i && !l.isEncoding(i)) throw new TypeError("Unknown encoding: " + i) } else "number" == typeof t && (t &= 255); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; var s; if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (s = e; s < n; ++s)this[s] = t; else { var o = l.isBuffer(t) ? t : V(new l(t, i).toString()), a = o.length; for (s = 0; s < n - e; ++s)this[s + e] = o[s % a] } return this }; var U = /[^+\/0-9A-Za-z-_]/g; function z(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function V(t, e) { var n; e = e || 1 / 0; for (var i = t.length, r = null, s = [], o = 0; o < i; ++o) { if ((n = t.charCodeAt(o)) > 55295 && n < 57344) { if (!r) { if (n > 56319) { (e -= 3) > -1 && s.push(239, 191, 189); continue } if (o + 1 === i) { (e -= 3) > -1 && s.push(239, 191, 189); continue } r = n; continue } if (n < 56320) { (e -= 3) > -1 && s.push(239, 191, 189), r = n; continue } n = 65536 + (r - 55296 << 10 | n - 56320) } else r && (e -= 3) > -1 && s.push(239, 191, 189); if (r = null, n < 128) { if ((e -= 1) < 0) break; s.push(n) } else if (n < 2048) { if ((e -= 2) < 0) break; s.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((e -= 3) < 0) break; s.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; s.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return s } function Q(t) { return i.toByteArray(function (t) { if ((t = function (t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") }(t).replace(U, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function G(t, e, n, i) { for (var r = 0; r < i && !(r + n >= e.length || r >= t.length); ++r)e[r + n] = t[r]; return r } }, 9662: function (t, e, n) { var i = n(614), r = n(6330), s = TypeError; t.exports = function (t) { if (i(t)) return t; throw s(r(t) + " is not a function") } }, 9483: function (t, e, n) { var i = n(4411), r = n(6330), s = TypeError; t.exports = function (t) { if (i(t)) return t; throw s(r(t) + " is not a constructor") } }, 7944: function (t, e, n) { var i = n(614), r = String, s = TypeError; t.exports = function (t) { if ("object" == typeof t || i(t)) return t; throw s("Can't set " + r(t) + " as a prototype") } }, 1223: function (t, e, n) { var i = n(5112), r = n(30), s = n(3070).f, o = i("unscopables"), a = Array.prototype; null == a[o] && s(a, o, { configurable: !0, value: r(null) }), t.exports = function (t) { a[o][t] = !0 } }, 1530: function (t, e, n) { "use strict"; var i = n(8710).charAt; t.exports = function (t, e, n) { return e + (n ? i(t, e).length : 1) } }, 5787: function (t, e, n) { var i = n(7976), r = TypeError; t.exports = function (t, e) { if (i(e, t)) return t; throw r("Incorrect invocation") } }, 9670: function (t, e, n) { var i = n(111), r = String, s = TypeError; t.exports = function (t) { if (i(t)) return t; throw s(r(t) + " is not an object") } }, 3013: function (t) { t.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView }, 260: function (t, e, n) { "use strict"; var i, r, s, o = n(3013), a = n(9781), l = n(7854), h = n(614), c = n(111), u = n(2597), d = n(648), p = n(6330), f = n(8880), m = n(8052), g = n(7045), v = n(7976), A = n(9518), b = n(7674), y = n(5112), x = n(9711), _ = n(9909), w = _.enforce, E = _.get, C = l.Int8Array, S = C && C.prototype, M = l.Uint8ClampedArray, P = M && M.prototype, I = C && A(C), T = S && A(S), D = Object.prototype, B = l.TypeError, L = y("toStringTag"), F = x("TYPED_ARRAY_TAG"), k = "TypedArrayConstructor", R = o && !!b && "Opera" !== d(l.opera), O = !1, N = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, U = { BigInt64Array: 8, BigUint64Array: 8 }, z = function (t) { var e = A(t); if (c(e)) { var n = E(e); return n && u(n, k) ? n[k] : z(e) } }, V = function (t) { if (!c(t)) return !1; var e = d(t); return u(N, e) || u(U, e) }; for (i in N) (s = (r = l[i]) && r.prototype) ? w(s)[k] = r : R = !1; for (i in U) (s = (r = l[i]) && r.prototype) && (w(s)[k] = r); if ((!R || !h(I) || I === Function.prototype) && (I = function () { throw B("Incorrect invocation") }, R)) for (i in N) l[i] && b(l[i], I); if ((!R || !T || T === D) && (T = I.prototype, R)) for (i in N) l[i] && b(l[i].prototype, T); if (R && A(P) !== T && b(P, T), a && !u(T, L)) for (i in O = !0, g(T, L, { configurable: !0, get: function () { return c(this) ? this[F] : void 0 } }), N) l[i] && f(l[i], F, i); t.exports = { NATIVE_ARRAY_BUFFER_VIEWS: R, TYPED_ARRAY_TAG: O && F, aTypedArray: function (t) { if (V(t)) return t; throw B("Target is not a typed array") }, aTypedArrayConstructor: function (t) { if (h(t) && (!b || v(I, t))) return t; throw B(p(t) + " is not a typed array constructor") }, exportTypedArrayMethod: function (t, e, n, i) { if (a) { if (n) for (var r in N) { var s = l[r]; if (s && u(s.prototype, t)) try { delete s.prototype[t] } catch (n) { try { s.prototype[t] = e } catch (t) { } } } T[t] && !n || m(T, t, n ? e : R && S[t] || e, i) } }, exportTypedArrayStaticMethod: function (t, e, n) { var i, r; if (a) { if (b) { if (n) for (i in N) if ((r = l[i]) && u(r, t)) try { delete r[t] } catch (t) { } if (I[t] && !n) return; try { return m(I, t, n ? e : R && I[t] || e) } catch (t) { } } for (i in N) !(r = l[i]) || r[t] && !n || m(r, t, e) } }, getTypedArrayConstructor: z, isView: function (t) { if (!c(t)) return !1; var e = d(t); return "DataView" === e || u(N, e) || u(U, e) }, isTypedArray: V, TypedArray: I, TypedArrayPrototype: T } }, 3331: function (t, e, n) { "use strict"; var i = n(7854), r = n(1702), s = n(9781), o = n(3013), a = n(6530), l = n(8880), h = n(7045), c = n(9190), u = n(7293), d = n(5787), p = n(9303), f = n(7466), m = n(7067), g = n(1179), v = n(9518), A = n(7674), b = n(8006).f, y = n(1285), x = n(1589), _ = n(8003), w = n(9909), E = a.PROPER, C = a.CONFIGURABLE, S = "ArrayBuffer", M = "DataView", P = "prototype", I = "Wrong index", T = w.getterFor(S), D = w.getterFor(M), B = w.set, L = i[S], F = L, k = F && F[P], R = i[M], O = R && R[P], N = Object.prototype, U = i.Array, z = i.RangeError, V = r(y), Q = r([].reverse), G = g.pack, H = g.unpack, j = function (t) { return [255 & t] }, W = function (t) { return [255 & t, t >> 8 & 255] }, q = function (t) { return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255] }, Y = function (t) { return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0] }, X = function (t) { return G(t, 23, 4) }, K = function (t) { return G(t, 52, 8) }, J = function (t, e, n) { h(t[P], e, { configurable: !0, get: function () { return n(this)[e] } }) }, Z = function (t, e, n, i) { var r = m(n), s = D(t); if (r + e > s.byteLength) throw z(I); var o = s.bytes, a = r + s.byteOffset, l = x(o, a, a + e); return i ? l : Q(l) }, $ = function (t, e, n, i, r, s) { var o = m(n), a = D(t); if (o + e > a.byteLength) throw z(I); for (var l = a.bytes, h = o + a.byteOffset, c = i(+r), u = 0; u < e; u++)l[h + u] = c[s ? u : e - u - 1] }; if (o) { var tt = E && L.name !== S; if (u((function () { L(1) })) && u((function () { new L(-1) })) && !u((function () { return new L, new L(1.5), new L(NaN), 1 != L.length || tt && !C }))) tt && C && l(L, "name", S); else { (F = function (t) { return d(this, k), new L(m(t)) })[P] = k; for (var et, nt = b(L), it = 0; nt.length > it;)(et = nt[it++]) in F || l(F, et, L[et]); k.constructor = F } A && v(O) !== N && A(O, N); var rt = new R(new F(2)), st = r(O.setInt8); rt.setInt8(0, 2147483648), rt.setInt8(1, 2147483649), !rt.getInt8(0) && rt.getInt8(1) || c(O, { setInt8: function (t, e) { st(this, t, e << 24 >> 24) }, setUint8: function (t, e) { st(this, t, e << 24 >> 24) } }, { unsafe: !0 }) } else k = (F = function (t) { d(this, k); var e = m(t); B(this, { type: S, bytes: V(U(e), 0), byteLength: e }), s || (this.byteLength = e, this.detached = !1) })[P], O = (R = function (t, e, n) { d(this, O), d(t, k); var i = T(t), r = i.byteLength, o = p(e); if (o < 0 || o > r) throw z("Wrong offset"); if (o + (n = void 0 === n ? r - o : f(n)) > r) throw z("Wrong length"); B(this, { type: M, buffer: t, byteLength: n, byteOffset: o, bytes: i.bytes }), s || (this.buffer = t, this.byteLength = n, this.byteOffset = o) })[P], s && (J(F, "byteLength", T), J(R, "buffer", D), J(R, "byteLength", D), J(R, "byteOffset", D)), c(O, { getInt8: function (t) { return Z(this, 1, t)[0] << 24 >> 24 }, getUint8: function (t) { return Z(this, 1, t)[0] }, getInt16: function (t) { var e = Z(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return (e[1] << 8 | e[0]) << 16 >> 16 }, getUint16: function (t) { var e = Z(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return e[1] << 8 | e[0] }, getInt32: function (t) { return Y(Z(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) }, getUint32: function (t) { return Y(Z(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) >>> 0 }, getFloat32: function (t) { return H(Z(this, 4, t, arguments.length > 1 ? arguments[1] : void 0), 23) }, getFloat64: function (t) { return H(Z(this, 8, t, arguments.length > 1 ? arguments[1] : void 0), 52) }, setInt8: function (t, e) { $(this, 1, t, j, e) }, setUint8: function (t, e) { $(this, 1, t, j, e) }, setInt16: function (t, e) { $(this, 2, t, W, e, arguments.length > 2 ? arguments[2] : void 0) }, setUint16: function (t, e) { $(this, 2, t, W, e, arguments.length > 2 ? arguments[2] : void 0) }, setInt32: function (t, e) { $(this, 4, t, q, e, arguments.length > 2 ? arguments[2] : void 0) }, setUint32: function (t, e) { $(this, 4, t, q, e, arguments.length > 2 ? arguments[2] : void 0) }, setFloat32: function (t, e) { $(this, 4, t, X, e, arguments.length > 2 ? arguments[2] : void 0) }, setFloat64: function (t, e) { $(this, 8, t, K, e, arguments.length > 2 ? arguments[2] : void 0) } }); _(F, S), _(R, M), t.exports = { ArrayBuffer: F, DataView: R } }, 1285: function (t, e, n) { "use strict"; var i = n(7908), r = n(1400), s = n(6244); t.exports = function (t) { for (var e = i(this), n = s(e), o = arguments.length, a = r(o > 1 ? arguments[1] : void 0, n), l = o > 2 ? arguments[2] : void 0, h = void 0 === l ? n : r(l, n); h > a;)e[a++] = t; return e } }, 8457: function (t, e, n) { "use strict"; var i = n(9974), r = n(6916), s = n(7908), o = n(3411), a = n(7659), l = n(4411), h = n(6244), c = n(6135), u = n(4121), d = n(1246), p = Array; t.exports = function (t) { var e = s(t), n = l(this), f = arguments.length, m = f > 1 ? arguments[1] : void 0, g = void 0 !== m; g && (m = i(m, f > 2 ? arguments[2] : void 0)); var v, A, b, y, x, _, w = d(e), E = 0; if (!w || this === p && a(w)) for (v = h(e), A = n ? new this(v) : p(v); v > E; E++)_ = g ? m(e[E], E) : e[E], c(A, E, _); else for (x = (y = u(e, w)).next, A = n ? new this : []; !(b = r(x, y)).done; E++)_ = g ? o(y, m, [b.value, E], !0) : b.value, c(A, E, _); return A.length = E, A } }, 1318: function (t, e, n) { var i = n(5656), r = n(1400), s = n(6244), o = function (t) { return function (e, n, o) { var a, l = i(e), h = s(l), c = r(o, h); if (t && n != n) { for (; h > c;)if ((a = l[c++]) != a) return !0 } else for (; h > c; c++)if ((t || c in l) && l[c] === n) return t || c || 0; return !t && -1 } }; t.exports = { includes: o(!0), indexOf: o(!1) } }, 2092: function (t, e, n) { var i = n(9974), r = n(1702), s = n(8361), o = n(7908), a = n(6244), l = n(5417), h = r([].push), c = function (t) { var e = 1 == t, n = 2 == t, r = 3 == t, c = 4 == t, u = 6 == t, d = 7 == t, p = 5 == t || u; return function (f, m, g, v) { for (var A, b, y = o(f), x = s(y), _ = i(m, g), w = a(x), E = 0, C = v || l, S = e ? C(f, w) : n || d ? C(f, 0) : void 0; w > E; E++)if ((p || E in x) && (b = _(A = x[E], E, y), t)) if (e) S[E] = b; else if (b) switch (t) { case 3: return !0; case 5: return A; case 6: return E; case 2: h(S, A) } else switch (t) { case 4: return !1; case 7: h(S, A) }return u ? -1 : r || c ? c : S } }; t.exports = { forEach: c(0), map: c(1), filter: c(2), some: c(3), every: c(4), find: c(5), findIndex: c(6), filterReject: c(7) } }, 1589: function (t, e, n) { var i = n(1400), r = n(6244), s = n(6135), o = Array, a = Math.max; t.exports = function (t, e, n) { for (var l = r(t), h = i(e, l), c = i(void 0 === n ? l : n, l), u = o(a(c - h, 0)), d = 0; h < c; h++, d++)s(u, d, t[h]); return u.length = d, u } }, 4362: function (t, e, n) { var i = n(1589), r = Math.floor, s = function (t, e) { var n = t.length, l = r(n / 2); return n < 8 ? o(t, e) : a(t, s(i(t, 0, l), e), s(i(t, l), e), e) }, o = function (t, e) { for (var n, i, r = t.length, s = 1; s < r;) { for (i = s, n = t[s]; i && e(t[i - 1], n) > 0;)t[i] = t[--i]; i !== s++ && (t[i] = n) } return t }, a = function (t, e, n, i) { for (var r = e.length, s = n.length, o = 0, a = 0; o < r || a < s;)t[o + a] = o < r && a < s ? i(e[o], n[a]) <= 0 ? e[o++] : n[a++] : o < r ? e[o++] : n[a++]; return t }; t.exports = s }, 7475: function (t, e, n) { var i = n(3157), r = n(4411), s = n(111), o = n(5112)("species"), a = Array; t.exports = function (t) { var e; return i(t) && (e = t.constructor, (r(e) && (e === a || i(e.prototype)) || s(e) && null === (e = e[o])) && (e = void 0)), void 0 === e ? a : e } }, 5417: function (t, e, n) { var i = n(7475); t.exports = function (t, e) { return new (i(t))(0 === e ? 0 : e) } }, 3411: function (t, e, n) { var i = n(9670), r = n(9212); t.exports = function (t, e, n, s) { try { return s ? e(i(n)[0], n[1]) : e(n) } catch (e) { r(t, "throw", e) } } }, 7072: function (t, e, n) { var i = n(5112)("iterator"), r = !1; try { var s = 0, o = { next: function () { return { done: !!s++ } }, return: function () { r = !0 } }; o[i] = function () { return this }, Array.from(o, (function () { throw 2 })) } catch (t) { } t.exports = function (t, e) { if (!e && !r) return !1; var n = !1; try { var s = {}; s[i] = function () { return { next: function () { return { done: n = !0 } } } }, t(s) } catch (t) { } return n } }, 4326: function (t, e, n) { var i = n(1702), r = i({}.toString), s = i("".slice); t.exports = function (t) { return s(r(t), 8, -1) } }, 648: function (t, e, n) { var i = n(1694), r = n(614), s = n(4326), o = n(5112)("toStringTag"), a = Object, l = "Arguments" == s(function () { return arguments }()); t.exports = i ? s : function (t) { var e, n, i; return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) { try { return t[e] } catch (t) { } }(e = a(t), o)) ? n : l ? s(e) : "Object" == (i = s(e)) && r(e.callee) ? "Arguments" : i } }, 9920: function (t, e, n) { var i = n(2597), r = n(3887), s = n(1236), o = n(3070); t.exports = function (t, e, n) { for (var a = r(e), l = o.f, h = s.f, c = 0; c < a.length; c++) { var u = a[c]; i(t, u) || n && i(n, u) || l(t, u, h(e, u)) } } }, 8544: function (t, e, n) { var i = n(7293); t.exports = !i((function () { function t() { } return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype })) }, 6178: function (t) { t.exports = function (t, e) { return { value: t, done: e } } }, 8880: function (t, e, n) { var i = n(9781), r = n(3070), s = n(9114); t.exports = i ? function (t, e, n) { return r.f(t, e, s(1, n)) } : function (t, e, n) { return t[e] = n, t } }, 9114: function (t) { t.exports = function (t, e) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e } } }, 6135: function (t, e, n) { "use strict"; var i = n(4948), r = n(3070), s = n(9114); t.exports = function (t, e, n) { var o = i(e); o in t ? r.f(t, o, s(0, n)) : t[o] = n } }, 7045: function (t, e, n) { var i = n(6339), r = n(3070); t.exports = function (t, e, n) { return n.get && i(n.get, e, { getter: !0 }), n.set && i(n.set, e, { setter: !0 }), r.f(t, e, n) } }, 8052: function (t, e, n) { var i = n(614), r = n(3070), s = n(6339), o = n(3072); t.exports = function (t, e, n, a) { a || (a = {}); var l = a.enumerable, h = void 0 !== a.name ? a.name : e; if (i(n) && s(n, h, a), a.global) l ? t[e] = n : o(e, n); else { try { a.unsafe ? t[e] && (l = !0) : delete t[e] } catch (t) { } l ? t[e] = n : r.f(t, e, { value: n, enumerable: !1, configurable: !a.nonConfigurable, writable: !a.nonWritable }) } return t } }, 9190: function (t, e, n) { var i = n(8052); t.exports = function (t, e, n) { for (var r in e) i(t, r, e[r], n); return t } }, 3072: function (t, e, n) { var i = n(7854), r = Object.defineProperty; t.exports = function (t, e) { try { r(i, t, { value: e, configurable: !0, writable: !0 }) } catch (n) { i[t] = e } return e } }, 9781: function (t, e, n) { var i = n(7293); t.exports = !i((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })) }, 4154: function (t) { var e = "object" == typeof document && document.all, n = void 0 === e && void 0 !== e; t.exports = { all: e, IS_HTMLDDA: n } }, 317: function (t, e, n) { var i = n(7854), r = n(111), s = i.document, o = r(s) && r(s.createElement); t.exports = function (t) { return o ? s.createElement(t) : {} } }, 8324: function (t) { t.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 } }, 8509: function (t, e, n) { var i = n(317)("span").classList, r = i && i.constructor && i.constructor.prototype; t.exports = r === Object.prototype ? void 0 : r }, 8886: function (t, e, n) { var i = n(8113).match(/firefox\/(\d+)/i); t.exports = !!i && +i[1] }, 256: function (t, e, n) { var i = n(8113); t.exports = /MSIE|Trident/.test(i) }, 8113: function (t) { t.exports = "undefined" != typeof navigator && String(navigator.userAgent) || "" }, 7392: function (t, e, n) { var i, r, s = n(7854), o = n(8113), a = s.process, l = s.Deno, h = a && a.versions || l && l.version, c = h && h.v8; c && (r = (i = c.split("."))[0] > 0 && i[0] < 4 ? 1 : +(i[0] + i[1])), !r && o && (!(i = o.match(/Edge\/(\d+)/)) || i[1] >= 74) && (i = o.match(/Chrome\/(\d+)/)) && (r = +i[1]), t.exports = r }, 8008: function (t, e, n) { var i = n(8113).match(/AppleWebKit\/(\d+)\./); t.exports = !!i && +i[1] }, 748: function (t) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, 2109: function (t, e, n) { var i = n(7854), r = n(1236).f, s = n(8880), o = n(8052), a = n(3072), l = n(9920), h = n(4705); t.exports = function (t, e) { var n, c, u, d, p, f = t.target, m = t.global, g = t.stat; if (n = m ? i : g ? i[f] || a(f, {}) : (i[f] || {}).prototype) for (c in e) { if (d = e[c], u = t.dontCallGetSet ? (p = r(n, c)) && p.value : n[c], !h(m ? c : f + (g ? "." : "#") + c, t.forced) && void 0 !== u) { if (typeof d == typeof u) continue; l(d, u) } (t.sham || u && u.sham) && s(d, "sham", !0), o(n, c, d, t) } } }, 7293: function (t) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, 7007: function (t, e, n) { "use strict"; n(4916); var i = n(1470), r = n(8052), s = n(2261), o = n(7293), a = n(5112), l = n(8880), h = a("species"), c = RegExp.prototype; t.exports = function (t, e, n, u) { var d = a(t), p = !o((function () { var e = {}; return e[d] = function () { return 7 }, 7 != ""[t](e) })), f = p && !o((function () { var e = !1, n = /a/; return "split" === t && ((n = {}).constructor = {}, n.constructor[h] = function () { return n }, n.flags = "", n[d] = /./[d]), n.exec = function () { return e = !0, null }, n[d](""), !e })); if (!p || !f || n) { var m = i(/./[d]), g = e(d, ""[t], (function (t, e, n, r, o) { var a = i(t), l = e.exec; return l === s || l === c.exec ? p && !o ? { done: !0, value: m(e, n, r) } : { done: !0, value: a(n, e, r) } : { done: !1 } })); r(String.prototype, t, g[0]), r(c, d, g[1]) } u && l(c[d], "sham", !0) } }, 2104: function (t, e, n) { var i = n(4374), r = Function.prototype, s = r.apply, o = r.call; t.exports = "object" == typeof Reflect && Reflect.apply || (i ? o.bind(s) : function () { return o.apply(s, arguments) }) }, 9974: function (t, e, n) { var i = n(1470), r = n(9662), s = n(4374), o = i(i.bind); t.exports = function (t, e) { return r(t), void 0 === e ? t : s ? o(t, e) : function () { return t.apply(e, arguments) } } }, 4374: function (t, e, n) { var i = n(7293); t.exports = !i((function () { var t = function () { }.bind(); return "function" != typeof t || t.hasOwnProperty("prototype") })) }, 6916: function (t, e, n) { var i = n(4374), r = Function.prototype.call; t.exports = i ? r.bind(r) : function () { return r.apply(r, arguments) } }, 6530: function (t, e, n) { var i = n(9781), r = n(2597), s = Function.prototype, o = i && Object.getOwnPropertyDescriptor, a = r(s, "name"), l = a && "something" === function () { }.name, h = a && (!i || i && o(s, "name").configurable); t.exports = { EXISTS: a, PROPER: l, CONFIGURABLE: h } }, 5668: function (t, e, n) { var i = n(1702), r = n(9662); t.exports = function (t, e, n) { try { return i(r(Object.getOwnPropertyDescriptor(t, e)[n])) } catch (t) { } } }, 1470: function (t, e, n) { var i = n(4326), r = n(1702); t.exports = function (t) { if ("Function" === i(t)) return r(t) } }, 1702: function (t, e, n) { var i = n(4374), r = Function.prototype, s = r.call, o = i && r.bind.bind(s, s); t.exports = i ? o : function (t) { return function () { return s.apply(t, arguments) } } }, 5005: function (t, e, n) { var i = n(7854), r = n(614), s = function (t) { return r(t) ? t : void 0 }; t.exports = function (t, e) { return arguments.length < 2 ? s(i[t]) : i[t] && i[t][e] } }, 1246: function (t, e, n) { var i = n(648), r = n(8173), s = n(8554), o = n(7497), a = n(5112)("iterator"); t.exports = function (t) { if (!s(t)) return r(t, a) || r(t, "@@iterator") || o[i(t)] } }, 4121: function (t, e, n) { var i = n(6916), r = n(9662), s = n(9670), o = n(6330), a = n(1246), l = TypeError; t.exports = function (t, e) { var n = arguments.length < 2 ? a(t) : e; if (r(n)) return s(i(n, t)); throw l(o(t) + " is not iterable") } }, 8173: function (t, e, n) { var i = n(9662), r = n(8554); t.exports = function (t, e) { var n = t[e]; return r(n) ? void 0 : i(n) } }, 647: function (t, e, n) { var i = n(1702), r = n(7908), s = Math.floor, o = i("".charAt), a = i("".replace), l = i("".slice), h = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, c = /\$([$&'`]|\d{1,2})/g; t.exports = function (t, e, n, i, u, d) { var p = n + t.length, f = i.length, m = c; return void 0 !== u && (u = r(u), m = h), a(d, m, (function (r, a) { var h; switch (o(a, 0)) { case "$": return "$"; case "&": return t; case "`": return l(e, 0, n); case "'": return l(e, p); case "<": h = u[l(a, 1, -1)]; break; default: var c = +a; if (0 === c) return r; if (c > f) { var d = s(c / 10); return 0 === d ? r : d <= f ? void 0 === i[d - 1] ? o(a, 1) : i[d - 1] + o(a, 1) : r } h = i[c - 1] }return void 0 === h ? "" : h })) } }, 7854: function (t, e, n) { var i = function (t) { return t && t.Math == Math && t }; t.exports = i("object" == typeof globalThis && globalThis) || i("object" == typeof window && window) || i("object" == typeof self && self) || i("object" == typeof n.g && n.g) || function () { return this }() || Function("return this")() }, 2597: function (t, e, n) { var i = n(1702), r = n(7908), s = i({}.hasOwnProperty); t.exports = Object.hasOwn || function (t, e) { return s(r(t), e) } }, 3501: function (t) { t.exports = {} }, 490: function (t, e, n) { var i = n(5005); t.exports = i("document", "documentElement") }, 4664: function (t, e, n) { var i = n(9781), r = n(7293), s = n(317); t.exports = !i && !r((function () { return 7 != Object.defineProperty(s("div"), "a", { get: function () { return 7 } }).a })) }, 1179: function (t) { var e = Array, n = Math.abs, i = Math.pow, r = Math.floor, s = Math.log, o = Math.LN2; t.exports = { pack: function (t, a, l) { var h, c, u, d = e(l), p = 8 * l - a - 1, f = (1 << p) - 1, m = f >> 1, g = 23 === a ? i(2, -24) - i(2, -77) : 0, v = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0, A = 0; for ((t = n(t)) != t || t === 1 / 0 ? (c = t != t ? 1 : 0, h = f) : (h = r(s(t) / o), t * (u = i(2, -h)) < 1 && (h--, u *= 2), (t += h + m >= 1 ? g / u : g * i(2, 1 - m)) * u >= 2 && (h++, u /= 2), h + m >= f ? (c = 0, h = f) : h + m >= 1 ? (c = (t * u - 1) * i(2, a), h += m) : (c = t * i(2, m - 1) * i(2, a), h = 0)); a >= 8;)d[A++] = 255 & c, c /= 256, a -= 8; for (h = h << a | c, p += a; p > 0;)d[A++] = 255 & h, h /= 256, p -= 8; return d[--A] |= 128 * v, d }, unpack: function (t, e) { var n, r = t.length, s = 8 * r - e - 1, o = (1 << s) - 1, a = o >> 1, l = s - 7, h = r - 1, c = t[h--], u = 127 & c; for (c >>= 7; l > 0;)u = 256 * u + t[h--], l -= 8; for (n = u & (1 << -l) - 1, u >>= -l, l += e; l > 0;)n = 256 * n + t[h--], l -= 8; if (0 === u) u = 1 - a; else { if (u === o) return n ? NaN : c ? -1 / 0 : 1 / 0; n += i(2, e), u -= a } return (c ? -1 : 1) * n * i(2, u - e) } } }, 8361: function (t, e, n) { var i = n(1702), r = n(7293), s = n(4326), o = Object, a = i("".split); t.exports = r((function () { return !o("z").propertyIsEnumerable(0) })) ? function (t) { return "String" == s(t) ? a(t, "") : o(t) } : o }, 9587: function (t, e, n) { var i = n(614), r = n(111), s = n(7674); t.exports = function (t, e, n) { var o, a; return s && i(o = e.constructor) && o !== n && r(a = o.prototype) && a !== n.prototype && s(t, a), t } }, 2788: function (t, e, n) { var i = n(1702), r = n(614), s = n(5465), o = i(Function.toString); r(s.inspectSource) || (s.inspectSource = function (t) { return o(t) }), t.exports = s.inspectSource }, 9909: function (t, e, n) { var i, r, s, o = n(4811), a = n(7854), l = n(111), h = n(8880), c = n(2597), u = n(5465), d = n(6200), p = n(3501), f = "Object already initialized", m = a.TypeError, g = a.WeakMap; if (o || u.state) { var v = u.state || (u.state = new g); v.get = v.get, v.has = v.has, v.set = v.set, i = function (t, e) { if (v.has(t)) throw m(f); return e.facade = t, v.set(t, e), e }, r = function (t) { return v.get(t) || {} }, s = function (t) { return v.has(t) } } else { var A = d("state"); p[A] = !0, i = function (t, e) { if (c(t, A)) throw m(f); return e.facade = t, h(t, A, e), e }, r = function (t) { return c(t, A) ? t[A] : {} }, s = function (t) { return c(t, A) } } t.exports = { set: i, get: r, has: s, enforce: function (t) { return s(t) ? r(t) : i(t, {}) }, getterFor: function (t) { return function (e) { var n; if (!l(e) || (n = r(e)).type !== t) throw m("Incompatible receiver, " + t + " required"); return n } } } }, 7659: function (t, e, n) { var i = n(5112), r = n(7497), s = i("iterator"), o = Array.prototype; t.exports = function (t) { return void 0 !== t && (r.Array === t || o[s] === t) } }, 3157: function (t, e, n) { var i = n(4326); t.exports = Array.isArray || function (t) { return "Array" == i(t) } }, 4067: function (t, e, n) { var i = n(648); t.exports = function (t) { var e = i(t); return "BigInt64Array" == e || "BigUint64Array" == e } }, 614: function (t, e, n) { var i = n(4154), r = i.all; t.exports = i.IS_HTMLDDA ? function (t) { return "function" == typeof t || t === r } : function (t) { return "function" == typeof t } }, 4411: function (t, e, n) { var i = n(1702), r = n(7293), s = n(614), o = n(648), a = n(5005), l = n(2788), h = function () { }, c = [], u = a("Reflect", "construct"), d = /^\s*(?:class|function)\b/, p = i(d.exec), f = !d.exec(h), m = function (t) { if (!s(t)) return !1; try { return u(h, c, t), !0 } catch (t) { return !1 } }, g = function (t) { if (!s(t)) return !1; switch (o(t)) { case "AsyncFunction": case "GeneratorFunction": case "AsyncGeneratorFunction": return !1 }try { return f || !!p(d, l(t)) } catch (t) { return !0 } }; g.sham = !0, t.exports = !u || r((function () { var t; return m(m.call) || !m(Object) || !m((function () { t = !0 })) || t })) ? g : m }, 4705: function (t, e, n) { var i = n(7293), r = n(614), s = /#|\.prototype\./, o = function (t, e) { var n = l[a(t)]; return n == c || n != h && (r(e) ? i(e) : !!e) }, a = o.normalize = function (t) { return String(t).replace(s, ".").toLowerCase() }, l = o.data = {}, h = o.NATIVE = "N", c = o.POLYFILL = "P"; t.exports = o }, 5988: function (t, e, n) { var i = n(111), r = Math.floor; t.exports = Number.isInteger || function (t) { return !i(t) && isFinite(t) && r(t) === t } }, 8554: function (t) { t.exports = function (t) { return null == t } }, 111: function (t, e, n) { var i = n(614), r = n(4154), s = r.all; t.exports = r.IS_HTMLDDA ? function (t) { return "object" == typeof t ? null !== t : i(t) || t === s } : function (t) { return "object" == typeof t ? null !== t : i(t) } }, 1913: function (t) { t.exports = !1 }, 2190: function (t, e, n) { var i = n(5005), r = n(614), s = n(7976), o = n(3307), a = Object; t.exports = o ? function (t) { return "symbol" == typeof t } : function (t) { var e = i("Symbol"); return r(e) && s(e.prototype, a(t)) } }, 9212: function (t, e, n) { var i = n(6916), r = n(9670), s = n(8173); t.exports = function (t, e, n) { var o, a; r(t); try { if (!(o = s(t, "return"))) { if ("throw" === e) throw n; return n } o = i(o, t) } catch (t) { a = !0, o = t } if ("throw" === e) throw n; if (a) throw o; return r(o), n } }, 3061: function (t, e, n) { "use strict"; var i = n(3383).IteratorPrototype, r = n(30), s = n(9114), o = n(8003), a = n(7497), l = function () { return this }; t.exports = function (t, e, n, h) { var c = e + " Iterator"; return t.prototype = r(i, { next: s(+!h, n) }), o(t, c, !1, !0), a[c] = l, t } }, 1656: function (t, e, n) { "use strict"; var i = n(2109), r = n(6916), s = n(1913), o = n(6530), a = n(614), l = n(3061), h = n(9518), c = n(7674), u = n(8003), d = n(8880), p = n(8052), f = n(5112), m = n(7497), g = n(3383), v = o.PROPER, A = o.CONFIGURABLE, b = g.IteratorPrototype, y = g.BUGGY_SAFARI_ITERATORS, x = f("iterator"), _ = "keys", w = "values", E = "entries", C = function () { return this }; t.exports = function (t, e, n, o, f, g, S) { l(n, e, o); var M, P, I, T = function (t) { if (t === f && k) return k; if (!y && t in L) return L[t]; switch (t) { case _: case w: case E: return function () { return new n(this, t) } }return function () { return new n(this) } }, D = e + " Iterator", B = !1, L = t.prototype, F = L[x] || L["@@iterator"] || f && L[f], k = !y && F || T(f), R = "Array" == e && L.entries || F; if (R && (M = h(R.call(new t))) !== Object.prototype && M.next && (s || h(M) === b || (c ? c(M, b) : a(M[x]) || p(M, x, C)), u(M, D, !0, !0), s && (m[D] = C)), v && f == w && F && F.name !== w && (!s && A ? d(L, "name", w) : (B = !0, k = function () { return r(F, this) })), f) if (P = { values: T(w), keys: g ? k : T(_), entries: T(E) }, S) for (I in P) (y || B || !(I in L)) && p(L, I, P[I]); else i({ target: e, proto: !0, forced: y || B }, P); return s && !S || L[x] === k || p(L, x, k, { name: f }), m[e] = k, P } }, 3383: function (t, e, n) { "use strict"; var i, r, s, o = n(7293), a = n(614), l = n(111), h = n(30), c = n(9518), u = n(8052), d = n(5112), p = n(1913), f = d("iterator"), m = !1;[].keys && ("next" in (s = [].keys()) ? (r = c(c(s))) !== Object.prototype && (i = r) : m = !0), !l(i) || o((function () { var t = {}; return i[f].call(t) !== t })) ? i = {} : p && (i = h(i)), a(i[f]) || u(i, f, (function () { return this })), t.exports = { IteratorPrototype: i, BUGGY_SAFARI_ITERATORS: m } }, 7497: function (t) { t.exports = {} }, 6244: function (t, e, n) { var i = n(7466); t.exports = function (t) { return i(t.length) } }, 6339: function (t, e, n) { var i = n(1702), r = n(7293), s = n(614), o = n(2597), a = n(9781), l = n(6530).CONFIGURABLE, h = n(2788), c = n(9909), u = c.enforce, d = c.get, p = String, f = Object.defineProperty, m = i("".slice), g = i("".replace), v = i([].join), A = a && !r((function () { return 8 !== f((function () { }), "length", { value: 8 }).length })), b = String(String).split("String"), y = t.exports = function (t, e, n) { "Symbol(" === m(p(e), 0, 7) && (e = "[" + g(p(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!o(t, "name") || l && t.name !== e) && (a ? f(t, "name", { value: e, configurable: !0 }) : t.name = e), A && n && o(n, "arity") && t.length !== n.arity && f(t, "length", { value: n.arity }); try { n && o(n, "constructor") && n.constructor ? a && f(t, "prototype", { writable: !1 }) : t.prototype && (t.prototype = void 0) } catch (t) { } var i = u(t); return o(i, "source") || (i.source = v(b, "string" == typeof e ? e : "")), t }; Function.prototype.toString = y((function () { return s(this) && d(this).source || h(this) }), "toString") }, 4758: function (t) { var e = Math.ceil, n = Math.floor; t.exports = Math.trunc || function (t) { var i = +t; return (i > 0 ? n : e)(i) } }, 8523: function (t, e, n) { "use strict"; var i = n(9662), r = TypeError, s = function (t) { var e, n; this.promise = new t((function (t, i) { if (void 0 !== e || void 0 !== n) throw r("Bad Promise constructor"); e = t, n = i })), this.resolve = i(e), this.reject = i(n) }; t.exports.f = function (t) { return new s(t) } }, 1574: function (t, e, n) { "use strict"; var i = n(9781), r = n(1702), s = n(6916), o = n(7293), a = n(1956), l = n(5181), h = n(5296), c = n(7908), u = n(8361), d = Object.assign, p = Object.defineProperty, f = r([].concat); t.exports = !d || o((function () { if (i && 1 !== d({ b: 1 }, d(p({}, "a", { enumerable: !0, get: function () { p(this, "b", { value: 3, enumerable: !1 }) } }), { b: 2 })).b) return !0; var t = {}, e = {}, n = Symbol(), r = "abcdefghijklmnopqrst"; return t[n] = 7, r.split("").forEach((function (t) { e[t] = t })), 7 != d({}, t)[n] || a(d({}, e)).join("") != r })) ? function (t, e) { for (var n = c(t), r = arguments.length, o = 1, d = l.f, p = h.f; r > o;)for (var m, g = u(arguments[o++]), v = d ? f(a(g), d(g)) : a(g), A = v.length, b = 0; A > b;)m = v[b++], i && !s(p, g, m) || (n[m] = g[m]); return n } : d }, 30: function (t, e, n) { var i, r = n(9670), s = n(6048), o = n(748), a = n(3501), l = n(490), h = n(317), c = n(6200), u = "prototype", d = "script", p = c("IE_PROTO"), f = function () { }, m = function (t) { return "<" + d + ">" + t + "</" + d + ">" }, g = function (t) { t.write(m("")), t.close(); var e = t.parentWindow.Object; return t = null, e }, v = function () { try { i = new ActiveXObject("htmlfile") } catch (t) { } var t, e, n; v = "undefined" != typeof document ? document.domain && i ? g(i) : (e = h("iframe"), n = "java" + d + ":", e.style.display = "none", l.appendChild(e), e.src = String(n), (t = e.contentWindow.document).open(), t.write(m("document.F=Object")), t.close(), t.F) : g(i); for (var r = o.length; r--;)delete v[u][o[r]]; return v() }; a[p] = !0, t.exports = Object.create || function (t, e) { var n; return null !== t ? (f[u] = r(t), n = new f, f[u] = null, n[p] = t) : n = v(), void 0 === e ? n : s.f(n, e) } }, 6048: function (t, e, n) { var i = n(9781), r = n(3353), s = n(3070), o = n(9670), a = n(5656), l = n(1956); e.f = i && !r ? Object.defineProperties : function (t, e) { o(t); for (var n, i = a(e), r = l(e), h = r.length, c = 0; h > c;)s.f(t, n = r[c++], i[n]); return t } }, 3070: function (t, e, n) { var i = n(9781), r = n(4664), s = n(3353), o = n(9670), a = n(4948), l = TypeError, h = Object.defineProperty, c = Object.getOwnPropertyDescriptor, u = "enumerable", d = "configurable", p = "writable"; e.f = i ? s ? function (t, e, n) { if (o(t), e = a(e), o(n), "function" == typeof t && "prototype" === e && "value" in n && p in n && !n[p]) { var i = c(t, e); i && i[p] && (t[e] = n.value, n = { configurable: d in n ? n[d] : i[d], enumerable: u in n ? n[u] : i[u], writable: !1 }) } return h(t, e, n) } : h : function (t, e, n) { if (o(t), e = a(e), o(n), r) try { return h(t, e, n) } catch (t) { } if ("get" in n || "set" in n) throw l("Accessors not supported"); return "value" in n && (t[e] = n.value), t } }, 1236: function (t, e, n) { var i = n(9781), r = n(6916), s = n(5296), o = n(9114), a = n(5656), l = n(4948), h = n(2597), c = n(4664), u = Object.getOwnPropertyDescriptor; e.f = i ? u : function (t, e) { if (t = a(t), e = l(e), c) try { return u(t, e) } catch (t) { } if (h(t, e)) return o(!r(s.f, t, e), t[e]) } }, 8006: function (t, e, n) { var i = n(6324), r = n(748).concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (t) { return i(t, r) } }, 5181: function (t, e) { e.f = Object.getOwnPropertySymbols }, 9518: function (t, e, n) { var i = n(2597), r = n(614), s = n(7908), o = n(6200), a = n(8544), l = o("IE_PROTO"), h = Object, c = h.prototype; t.exports = a ? h.getPrototypeOf : function (t) { var e = s(t); if (i(e, l)) return e[l]; var n = e.constructor; return r(n) && e instanceof n ? n.prototype : e instanceof h ? c : null } }, 7976: function (t, e, n) { var i = n(1702); t.exports = i({}.isPrototypeOf) }, 6324: function (t, e, n) { var i = n(1702), r = n(2597), s = n(5656), o = n(1318).indexOf, a = n(3501), l = i([].push); t.exports = function (t, e) { var n, i = s(t), h = 0, c = []; for (n in i) !r(a, n) && r(i, n) && l(c, n); for (; e.length > h;)r(i, n = e[h++]) && (~o(c, n) || l(c, n)); return c } }, 1956: function (t, e, n) { var i = n(6324), r = n(748); t.exports = Object.keys || function (t) { return i(t, r) } }, 5296: function (t, e) { "use strict"; var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, r = i && !n.call({ 1: 2 }, 1); e.f = r ? function (t) { var e = i(this, t); return !!e && e.enumerable } : n }, 7674: function (t, e, n) { var i = n(5668), r = n(9670), s = n(7944); t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () { var t, e = !1, n = {}; try { (t = i(Object.prototype, "__proto__", "set"))(n, []), e = n instanceof Array } catch (t) { } return function (n, i) { return r(n), s(i), e ? t(n, i) : n.__proto__ = i, n } }() : void 0) }, 2140: function (t, e, n) { var i = n(6916), r = n(614), s = n(111), o = TypeError; t.exports = function (t, e) { var n, a; if ("string" === e && r(n = t.toString) && !s(a = i(n, t))) return a; if (r(n = t.valueOf) && !s(a = i(n, t))) return a; if ("string" !== e && r(n = t.toString) && !s(a = i(n, t))) return a; throw o("Can't convert object to primitive value") } }, 3887: function (t, e, n) { var i = n(5005), r = n(1702), s = n(8006), o = n(5181), a = n(9670), l = r([].concat); t.exports = i("Reflect", "ownKeys") || function (t) { var e = s.f(a(t)), n = o.f; return n ? l(e, n(t)) : e } }, 2492: function (t, e, n) { var i = n(7854); t.exports = i.Promise }, 9478: function (t, e, n) { var i = n(9670), r = n(111), s = n(8523); t.exports = function (t, e) { if (i(t), r(e) && e.constructor === t) return e; var n = s.f(t); return (0, n.resolve)(e), n.promise } }, 7651: function (t, e, n) { var i = n(6916), r = n(9670), s = n(614), o = n(4326), a = n(2261), l = TypeError; t.exports = function (t, e) { var n = t.exec; if (s(n)) { var h = i(n, t, e); return null !== h && r(h), h } if ("RegExp" === o(t)) return i(a, t, e); throw l("RegExp#exec called on incompatible receiver") } }, 2261: function (t, e, n) { "use strict"; var i, r, s = n(6916), o = n(1702), a = n(1340), l = n(7066), h = n(2999), c = n(2309), u = n(30), d = n(9909).get, p = n(9441), f = n(7168), m = c("native-string-replace", String.prototype.replace), g = RegExp.prototype.exec, v = g, A = o("".charAt), b = o("".indexOf), y = o("".replace), x = o("".slice), _ = (r = /b*/g, s(g, i = /a/, "a"), s(g, r, "a"), 0 !== i.lastIndex || 0 !== r.lastIndex), w = h.BROKEN_CARET, E = void 0 !== /()??/.exec("")[1]; (_ || E || w || p || f) && (v = function (t) { var e, n, i, r, o, h, c, p = this, f = d(p), C = a(t), S = f.raw; if (S) return S.lastIndex = p.lastIndex, e = s(v, S, C), p.lastIndex = S.lastIndex, e; var M = f.groups, P = w && p.sticky, I = s(l, p), T = p.source, D = 0, B = C; if (P && (I = y(I, "y", ""), -1 === b(I, "g") && (I += "g"), B = x(C, p.lastIndex), p.lastIndex > 0 && (!p.multiline || p.multiline && "\n" !== A(C, p.lastIndex - 1)) && (T = "(?: " + T + ")", B = " " + B, D++), n = new RegExp("^(?:" + T + ")", I)), E && (n = new RegExp("^" + T + "$(?!\\s)", I)), _ && (i = p.lastIndex), r = s(g, P ? n : p, B), P ? r ? (r.input = x(r.input, D), r[0] = x(r[0], D), r.index = p.lastIndex, p.lastIndex += r[0].length) : p.lastIndex = 0 : _ && r && (p.lastIndex = p.global ? r.index + r[0].length : i), E && r && r.length > 1 && s(m, r[0], n, (function () { for (o = 1; o < arguments.length - 2; o++)void 0 === arguments[o] && (r[o] = void 0) })), r && M) for (r.groups = h = u(null), o = 0; o < M.length; o++)h[(c = M[o])[0]] = r[c[1]]; return r }), t.exports = v }, 7066: function (t, e, n) { "use strict"; var i = n(9670); t.exports = function () { var t = i(this), e = ""; return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e } }, 2999: function (t, e, n) { var i = n(7293), r = n(7854).RegExp, s = i((function () { var t = r("a", "y"); return t.lastIndex = 2, null != t.exec("abcd") })), o = s || i((function () { return !r("a", "y").sticky })), a = s || i((function () { var t = r("^r", "gy"); return t.lastIndex = 2, null != t.exec("str") })); t.exports = { BROKEN_CARET: a, MISSED_STICKY: o, UNSUPPORTED_Y: s } }, 9441: function (t, e, n) { var i = n(7293), r = n(7854).RegExp; t.exports = i((function () { var t = r(".", "s"); return !(t.dotAll && t.exec("\n") && "s" === t.flags) })) }, 7168: function (t, e, n) { var i = n(7293), r = n(7854).RegExp; t.exports = i((function () { var t = r("(?<a>b)", "g"); return "b" !== t.exec("b").groups.a || "bc" !== "b".replace(t, "$<a>c") })) }, 4488: function (t, e, n) { var i = n(8554), r = TypeError; t.exports = function (t) { if (i(t)) throw r("Can't call method on " + t); return t } }, 6340: function (t, e, n) { "use strict"; var i = n(5005), r = n(7045), s = n(5112), o = n(9781), a = s("species"); t.exports = function (t) { var e = i(t); o && e && !e[a] && r(e, a, { configurable: !0, get: function () { return this } }) } }, 8003: function (t, e, n) { var i = n(3070).f, r = n(2597), s = n(5112)("toStringTag"); t.exports = function (t, e, n) { t && !n && (t = t.prototype), t && !r(t, s) && i(t, s, { configurable: !0, value: e }) } }, 6200: function (t, e, n) { var i = n(2309), r = n(9711), s = i("keys"); t.exports = function (t) { return s[t] || (s[t] = r(t)) } }, 5465: function (t, e, n) { var i = n(7854), r = n(3072), s = "__core-js_shared__", o = i[s] || r(s, {}); t.exports = o }, 2309: function (t, e, n) { var i = n(1913), r = n(5465); (t.exports = function (t, e) { return r[t] || (r[t] = void 0 !== e ? e : {}) })("versions", []).push({ version: "3.29.0", mode: i ? "pure" : "global", copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.29.0/LICENSE", source: "https://github.com/zloirock/core-js" }) }, 6707: function (t, e, n) { var i = n(9670), r = n(9483), s = n(8554), o = n(5112)("species"); t.exports = function (t, e) { var n, a = i(t).constructor; return void 0 === a || s(n = i(a)[o]) ? e : r(n) } }, 8710: function (t, e, n) { var i = n(1702), r = n(9303), s = n(1340), o = n(4488), a = i("".charAt), l = i("".charCodeAt), h = i("".slice), c = function (t) { return function (e, n) { var i, c, u = s(o(e)), d = r(n), p = u.length; return d < 0 || d >= p ? t ? "" : void 0 : (i = l(u, d)) < 55296 || i > 56319 || d + 1 === p || (c = l(u, d + 1)) < 56320 || c > 57343 ? t ? a(u, d) : i : t ? h(u, d, d + 2) : c - 56320 + (i - 55296 << 10) + 65536 } }; t.exports = { codeAt: c(!1), charAt: c(!0) } }, 3197: function (t, e, n) { var i = n(1702), r = 2147483647, s = /[^\0-\u007E]/, o = /[.\u3002\uFF0E\uFF61]/g, a = "Overflow: input needs wider integers to process", l = RangeError, h = i(o.exec), c = Math.floor, u = String.fromCharCode, d = i("".charCodeAt), p = i([].join), f = i([].push), m = i("".replace), g = i("".split), v = i("".toLowerCase), A = function (t) { return t + 22 + 75 * (t < 26) }, b = function (t, e, n) { var i = 0; for (t = n ? c(t / 700) : t >> 1, t += c(t / e); t > 455;)t = c(t / 35), i += 36; return c(i + 36 * t / (t + 38)) }, y = function (t) { var e = []; t = function (t) { for (var e = [], n = 0, i = t.length; n < i;) { var r = d(t, n++); if (r >= 55296 && r <= 56319 && n < i) { var s = d(t, n++); 56320 == (64512 & s) ? f(e, ((1023 & r) << 10) + (1023 & s) + 65536) : (f(e, r), n--) } else f(e, r) } return e }(t); var n, i, s = t.length, o = 128, h = 0, m = 72; for (n = 0; n < t.length; n++)(i = t[n]) < 128 && f(e, u(i)); var g = e.length, v = g; for (g && f(e, "-"); v < s;) { var y = r; for (n = 0; n < t.length; n++)(i = t[n]) >= o && i < y && (y = i); var x = v + 1; if (y - o > c((r - h) / x)) throw l(a); for (h += (y - o) * x, o = y, n = 0; n < t.length; n++) { if ((i = t[n]) < o && ++h > r) throw l(a); if (i == o) { for (var _ = h, w = 36; ;) { var E = w <= m ? 1 : w >= m + 26 ? 26 : w - m; if (_ < E) break; var C = _ - E, S = 36 - E; f(e, u(A(E + C % S))), _ = c(C / S), w += 36 } f(e, u(A(_))), m = b(h, x, v == g), h = 0, v++ } } h++, o++ } return p(e, "") }; t.exports = function (t) { var e, n, i = [], r = g(m(v(t), o, "."), "."); for (e = 0; e < r.length; e++)n = r[e], f(i, h(s, n) ? "xn--" + y(n) : n); return p(i, ".") } }, 6293: function (t, e, n) { var i = n(7392), r = n(7293); t.exports = !!Object.getOwnPropertySymbols && !r((function () { var t = Symbol(); return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && i && i < 41 })) }, 1400: function (t, e, n) { var i = n(9303), r = Math.max, s = Math.min; t.exports = function (t, e) { var n = i(t); return n < 0 ? r(n + e, 0) : s(n, e) } }, 4599: function (t, e, n) { var i = n(7593), r = TypeError; t.exports = function (t) { var e = i(t, "number"); if ("number" == typeof e) throw r("Can't convert number to bigint"); return BigInt(e) } }, 7067: function (t, e, n) { var i = n(9303), r = n(7466), s = RangeError; t.exports = function (t) { if (void 0 === t) return 0; var e = i(t), n = r(e); if (e !== n) throw s("Wrong length or index"); return n } }, 5656: function (t, e, n) { var i = n(8361), r = n(4488); t.exports = function (t) { return i(r(t)) } }, 9303: function (t, e, n) { var i = n(4758); t.exports = function (t) { var e = +t; return e != e || 0 === e ? 0 : i(e) } }, 7466: function (t, e, n) { var i = n(9303), r = Math.min; t.exports = function (t) { return t > 0 ? r(i(t), 9007199254740991) : 0 } }, 7908: function (t, e, n) { var i = n(4488), r = Object; t.exports = function (t) { return r(i(t)) } }, 4590: function (t, e, n) { var i = n(3002), r = RangeError; t.exports = function (t, e) { var n = i(t); if (n % e) throw r("Wrong offset"); return n } }, 3002: function (t, e, n) { var i = n(9303), r = RangeError; t.exports = function (t) { var e = i(t); if (e < 0) throw r("The argument can't be less than 0"); return e } }, 7593: function (t, e, n) { var i = n(6916), r = n(111), s = n(2190), o = n(8173), a = n(2140), l = n(5112), h = TypeError, c = l("toPrimitive"); t.exports = function (t, e) { if (!r(t) || s(t)) return t; var n, l = o(t, c); if (l) { if (void 0 === e && (e = "default"), n = i(l, t, e), !r(n) || s(n)) return n; throw h("Can't convert object to primitive value") } return void 0 === e && (e = "number"), a(t, e) } }, 4948: function (t, e, n) { var i = n(7593), r = n(2190); t.exports = function (t) { var e = i(t, "string"); return r(e) ? e : e + "" } }, 1694: function (t, e, n) { var i = {}; i[n(5112)("toStringTag")] = "z", t.exports = "[object z]" === String(i) }, 1340: function (t, e, n) { var i = n(648), r = String; t.exports = function (t) { if ("Symbol" === i(t)) throw TypeError("Cannot convert a Symbol value to a string"); return r(t) } }, 6330: function (t) { var e = String; t.exports = function (t) { try { return e(t) } catch (t) { return "Object" } } }, 9843: function (t, e, n) { "use strict"; var i = n(2109), r = n(7854), s = n(6916), o = n(9781), a = n(3832), l = n(260), h = n(3331), c = n(5787), u = n(9114), d = n(8880), p = n(5988), f = n(7466), m = n(7067), g = n(4590), v = n(4948), A = n(2597), b = n(648), y = n(111), x = n(2190), _ = n(30), w = n(7976), E = n(7674), C = n(8006).f, S = n(7321), M = n(2092).forEach, P = n(6340), I = n(7045), T = n(3070), D = n(1236), B = n(9909), L = n(9587), F = B.get, k = B.set, R = B.enforce, O = T.f, N = D.f, U = Math.round, z = r.RangeError, V = h.ArrayBuffer, Q = V.prototype, G = h.DataView, H = l.NATIVE_ARRAY_BUFFER_VIEWS, j = l.TYPED_ARRAY_TAG, W = l.TypedArray, q = l.TypedArrayPrototype, Y = l.aTypedArrayConstructor, X = l.isTypedArray, K = "BYTES_PER_ELEMENT", J = "Wrong length", Z = function (t, e) { Y(t); for (var n = 0, i = e.length, r = new t(i); i > n;)r[n] = e[n++]; return r }, $ = function (t, e) { I(t, e, { configurable: !0, get: function () { return F(this)[e] } }) }, tt = function (t) { var e; return w(Q, t) || "ArrayBuffer" == (e = b(t)) || "SharedArrayBuffer" == e }, et = function (t, e) { return X(t) && !x(e) && e in t && p(+e) && e >= 0 }, nt = function (t, e) { return e = v(e), et(t, e) ? u(2, t[e]) : N(t, e) }, it = function (t, e, n) { return e = v(e), !(et(t, e) && y(n) && A(n, "value")) || A(n, "get") || A(n, "set") || n.configurable || A(n, "writable") && !n.writable || A(n, "enumerable") && !n.enumerable ? O(t, e, n) : (t[e] = n.value, t) }; o ? (H || (D.f = nt, T.f = it, $(q, "buffer"), $(q, "byteOffset"), $(q, "byteLength"), $(q, "length")), i({ target: "Object", stat: !0, forced: !H }, { getOwnPropertyDescriptor: nt, defineProperty: it }), t.exports = function (t, e, n) { var o = t.match(/\d+/)[0] / 8, l = t + (n ? "Clamped" : "") + "Array", h = "get" + t, u = "set" + t, p = r[l], v = p, A = v && v.prototype, b = {}, x = function (t, e) { O(t, e, { get: function () { return function (t, e) { var n = F(t); return n.view[h](e * o + n.byteOffset, !0) }(this, e) }, set: function (t) { return function (t, e, i) { var r = F(t); n && (i = (i = U(i)) < 0 ? 0 : i > 255 ? 255 : 255 & i), r.view[u](e * o + r.byteOffset, i, !0) }(this, e, t) }, enumerable: !0 }) }; H ? a && (v = e((function (t, e, n, i) { return c(t, A), L(y(e) ? tt(e) ? void 0 !== i ? new p(e, g(n, o), i) : void 0 !== n ? new p(e, g(n, o)) : new p(e) : X(e) ? Z(v, e) : s(S, v, e) : new p(m(e)), t, v) })), E && E(v, W), M(C(p), (function (t) { t in v || d(v, t, p[t]) })), v.prototype = A) : (v = e((function (t, e, n, i) { c(t, A); var r, a, l, h = 0, u = 0; if (y(e)) { if (!tt(e)) return X(e) ? Z(v, e) : s(S, v, e); r = e, u = g(n, o); var d = e.byteLength; if (void 0 === i) { if (d % o) throw z(J); if ((a = d - u) < 0) throw z(J) } else if ((a = f(i) * o) + u > d) throw z(J); l = a / o } else l = m(e), r = new V(a = l * o); for (k(t, { buffer: r, byteOffset: u, byteLength: a, length: l, view: new G(r) }); h < l;)x(t, h++) })), E && E(v, W), A = v.prototype = _(q)), A.constructor !== v && d(A, "constructor", v), R(A).TypedArrayConstructor = v, j && d(A, j, l); var w = v != p; b[l] = v, i({ global: !0, constructor: !0, forced: w, sham: !H }, b), K in v || d(v, K, o), K in A || d(A, K, o), P(l) }) : t.exports = function () { } }, 3832: function (t, e, n) { var i = n(7854), r = n(7293), s = n(7072), o = n(260).NATIVE_ARRAY_BUFFER_VIEWS, a = i.ArrayBuffer, l = i.Int8Array; t.exports = !o || !r((function () { l(1) })) || !r((function () { new l(-1) })) || !s((function (t) { new l, new l(null), new l(1.5), new l(t) }), !0) || r((function () { return 1 !== new l(new a(2), 1, void 0).length })) }, 7321: function (t, e, n) { var i = n(9974), r = n(6916), s = n(9483), o = n(7908), a = n(6244), l = n(4121), h = n(1246), c = n(7659), u = n(4067), d = n(260).aTypedArrayConstructor, p = n(4599); t.exports = function (t) { var e, n, f, m, g, v, A, b, y = s(this), x = o(t), _ = arguments.length, w = _ > 1 ? arguments[1] : void 0, E = void 0 !== w, C = h(x); if (C && !c(C)) for (b = (A = l(x, C)).next, x = []; !(v = r(b, A)).done;)x.push(v.value); for (E && _ > 2 && (w = i(w, arguments[2])), n = a(x), f = new (d(y))(n), m = u(f), e = 0; n > e; e++)g = E ? w(x[e], e) : x[e], f[e] = m ? p(g) : +g; return f } }, 9711: function (t, e, n) { var i = n(1702), r = 0, s = Math.random(), o = i(1..toString); t.exports = function (t) { return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++r + s, 36) } }, 5143: function (t, e, n) { var i = n(7293), r = n(5112), s = n(9781), o = n(1913), a = r("iterator"); t.exports = !i((function () { var t = new URL("b?a=1&b=2&c=3", "http://a"), e = t.searchParams, n = ""; return t.pathname = "c%20d", e.forEach((function (t, i) { e.delete("b"), n += i + t })), o && !t.toJSON || !e.size && (o || !s) || !e.sort || "http://a/c%20d?a=1&c=3" !== t.href || "3" !== e.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !e[a] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://тест").host || "#%D0%B1" !== new URL("http://a#б").hash || "a1c3" !== n || "x" !== new URL("http://x", void 0).host })) }, 3307: function (t, e, n) { var i = n(6293); t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator }, 3353: function (t, e, n) { var i = n(9781), r = n(7293); t.exports = i && r((function () { return 42 != Object.defineProperty((function () { }), "prototype", { value: 42, writable: !1 }).prototype })) }, 8053: function (t) { var e = TypeError; t.exports = function (t, n) { if (t < n) throw e("Not enough arguments"); return t } }, 4811: function (t, e, n) { var i = n(7854), r = n(614), s = i.WeakMap; t.exports = r(s) && /native code/.test(String(s)) }, 5112: function (t, e, n) { var i = n(7854), r = n(2309), s = n(2597), o = n(9711), a = n(6293), l = n(3307), h = i.Symbol, c = r("wks"), u = l ? h.for || h : h && h.withoutSetter || o; t.exports = function (t) { return s(c, t) || (c[t] = a && s(h, t) ? h[t] : u("Symbol." + t)), c[t] } }, 6992: function (t, e, n) { "use strict"; var i = n(5656), r = n(1223), s = n(7497), o = n(9909), a = n(3070).f, l = n(1656), h = n(6178), c = n(1913), u = n(9781), d = "Array Iterator", p = o.set, f = o.getterFor(d); t.exports = l(Array, "Array", (function (t, e) { p(this, { type: d, target: i(t), index: 0, kind: e }) }), (function () { var t = f(this), e = t.target, n = t.kind, i = t.index++; return !e || i >= e.length ? (t.target = void 0, h(void 0, !0)) : h("keys" == n ? i : "values" == n ? e[i] : [i, e[i]], !1) }), "values"); var m = s.Arguments = s.Array; if (r("keys"), r("values"), r("entries"), !c && u && "values" !== m.name) try { a(m, "name", { value: "values" }) } catch (t) { } }, 7727: function (t, e, n) { "use strict"; var i = n(2109), r = n(1913), s = n(2492), o = n(7293), a = n(5005), l = n(614), h = n(6707), c = n(9478), u = n(8052), d = s && s.prototype; if (i({ target: "Promise", proto: !0, real: !0, forced: !!s && o((function () { d.finally.call({ then: function () { } }, (function () { })) })) }, { finally: function (t) { var e = h(this, a("Promise")), n = l(t); return this.then(n ? function (n) { return c(e, t()).then((function () { return n })) } : t, n ? function (n) { return c(e, t()).then((function () { throw n })) } : t) } }), !r && l(s)) { var p = a("Promise").prototype.finally; d.finally !== p && u(d, "finally", p, { unsafe: !0 }) } }, 4916: function (t, e, n) { "use strict"; var i = n(2109), r = n(2261); i({ target: "RegExp", proto: !0, forced: /./.exec !== r }, { exec: r }) }, 8783: function (t, e, n) { "use strict"; var i = n(8710).charAt, r = n(1340), s = n(9909), o = n(1656), a = n(6178), l = "String Iterator", h = s.set, c = s.getterFor(l); o(String, "String", (function (t) { h(this, { type: l, string: r(t), index: 0 }) }), (function () { var t, e = c(this), n = e.string, r = e.index; return r >= n.length ? a(void 0, !0) : (t = i(n, r), e.index += t.length, a(t, !1)) })) }, 5306: function (t, e, n) { "use strict"; var i = n(2104), r = n(6916), s = n(1702), o = n(7007), a = n(7293), l = n(9670), h = n(614), c = n(8554), u = n(9303), d = n(7466), p = n(1340), f = n(4488), m = n(1530), g = n(8173), v = n(647), A = n(7651), b = n(5112)("replace"), y = Math.max, x = Math.min, _ = s([].concat), w = s([].push), E = s("".indexOf), C = s("".slice), S = "$0" === "a".replace(/./, "$0"), M = !!/./[b] && "" === /./[b]("a", "$0"); o("replace", (function (t, e, n) { var s = M ? "$" : "$0"; return [function (t, n) { var i = f(this), s = c(t) ? void 0 : g(t, b); return s ? r(s, t, i, n) : r(e, p(i), t, n) }, function (t, r) { var o = l(this), a = p(t); if ("string" == typeof r && -1 === E(r, s) && -1 === E(r, "$<")) { var c = n(e, o, a, r); if (c.done) return c.value } var f = h(r); f || (r = p(r)); var g = o.global; if (g) { var b = o.unicode; o.lastIndex = 0 } for (var S = []; ;) { var M = A(o, a); if (null === M) break; if (w(S, M), !g) break; "" === p(M[0]) && (o.lastIndex = m(a, d(o.lastIndex), b)) } for (var P, I = "", T = 0, D = 0; D < S.length; D++) { for (var B = p((M = S[D])[0]), L = y(x(u(M.index), a.length), 0), F = [], k = 1; k < M.length; k++)w(F, void 0 === (P = M[k]) ? P : String(P)); var R = M.groups; if (f) { var O = _([B], F, L, a); void 0 !== R && w(O, R); var N = p(i(r, void 0, O)) } else N = v(B, a, L, F, R, r); L >= T && (I += C(a, T, L) + N, T = L + B.length) } return I + C(a, T) }] }), !!a((function () { var t = /./; return t.exec = function () { var t = []; return t.groups = { a: "7" }, t }, "7" !== "".replace(t, "$<a>") })) || !S || M) }, 3105: function (t, e, n) { "use strict"; var i = n(260), r = n(1285), s = n(4599), o = n(648), a = n(6916), l = n(1702), h = n(7293), c = i.aTypedArray, u = i.exportTypedArrayMethod, d = l("".slice); u("fill", (function (t) { var e = arguments.length; c(this); var n = "Big" === d(o(this), 0, 3) ? s(t) : +t; return a(r, this, n, e > 1 ? arguments[1] : void 0, e > 2 ? arguments[2] : void 0) }), h((function () { var t = 0; return new Int8Array(2).fill({ valueOf: function () { return t++ } }), 1 !== t }))) }, 4197: function (t, e, n) { n(9843)("Float32", (function (t) { return function (e, n, i) { return t(this, e, n, i) } })) }, 3462: function (t, e, n) { "use strict"; var i = n(7854), r = n(6916), s = n(260), o = n(6244), a = n(4590), l = n(7908), h = n(7293), c = i.RangeError, u = i.Int8Array, d = u && u.prototype, p = d && d.set, f = s.aTypedArray, m = s.exportTypedArrayMethod, g = !h((function () { var t = new Uint8ClampedArray(2); return r(p, t, { length: 1, 0: 3 }, 1), 3 !== t[1] })), v = g && s.NATIVE_ARRAY_BUFFER_VIEWS && h((function () { var t = new u(2); return t.set(1), t.set("2", 1), 0 !== t[0] || 2 !== t[1] })); m("set", (function (t) { f(this); var e = a(arguments.length > 1 ? arguments[1] : void 0, 1), n = l(t); if (g) return r(p, this, n, e); var i = this.length, s = o(n), h = 0; if (s + e > i) throw c("Wrong length"); for (; h < s;)this[e + h] = n[h++] }), !g || v) }, 3824: function (t, e, n) { "use strict"; var i = n(7854), r = n(1470), s = n(7293), o = n(9662), a = n(4362), l = n(260), h = n(8886), c = n(256), u = n(7392), d = n(8008), p = l.aTypedArray, f = l.exportTypedArrayMethod, m = i.Uint16Array, g = m && r(m.prototype.sort), v = !(!g || s((function () { g(new m(2), null) })) && s((function () { g(new m(2), {}) }))), A = !!g && !s((function () { if (u) return u < 74; if (h) return h < 67; if (c) return !0; if (d) return d < 602; var t, e, n = new m(516), i = Array(516); for (t = 0; t < 516; t++)e = t % 4, n[t] = 515 - t, i[t] = t - 2 * e + 3; for (g(n, (function (t, e) { return (t / 4 | 0) - (e / 4 | 0) })), t = 0; t < 516; t++)if (n[t] !== i[t]) return !0 })); f("sort", (function (t) { return void 0 !== t && o(t), A ? g(this, t) : a(p(this), function (t) { return function (e, n) { return void 0 !== t ? +t(e, n) || 0 : n != n ? -1 : e != e ? 1 : 0 === e && 0 === n ? 1 / e > 0 && 1 / n < 0 ? 1 : -1 : e > n } }(t)) }), !A || v) }, 3948: function (t, e, n) { var i = n(7854), r = n(8324), s = n(8509), o = n(6992), a = n(8880), l = n(5112), h = l("iterator"), c = l("toStringTag"), u = o.values, d = function (t, e) { if (t) { if (t[h] !== u) try { a(t, h, u) } catch (e) { t[h] = u } if (t[c] || a(t, c, e), r[e]) for (var n in o) if (t[n] !== o[n]) try { a(t, n, o[n]) } catch (e) { t[n] = o[n] } } }; for (var p in r) d(i[p] && i[p].prototype, p); d(s, "DOMTokenList") }, 5556: function (t, e, n) { "use strict"; n(6992); var i = n(2109), r = n(7854), s = n(6916), o = n(1702), a = n(9781), l = n(5143), h = n(8052), c = n(7045), u = n(9190), d = n(8003), p = n(3061), f = n(9909), m = n(5787), g = n(614), v = n(2597), A = n(9974), b = n(648), y = n(9670), x = n(111), _ = n(1340), w = n(30), E = n(9114), C = n(4121), S = n(1246), M = n(8053), P = n(5112), I = n(4362), T = P("iterator"), D = "URLSearchParams", B = D + "Iterator", L = f.set, F = f.getterFor(D), k = f.getterFor(B), R = Object.getOwnPropertyDescriptor, O = function (t) { if (!a) return r[t]; var e = R(r, t); return e && e.value }, N = O("fetch"), U = O("Request"), z = O("Headers"), V = U && U.prototype, Q = z && z.prototype, G = r.RegExp, H = r.TypeError, j = r.decodeURIComponent, W = r.encodeURIComponent, q = o("".charAt), Y = o([].join), X = o([].push), K = o("".replace), J = o([].shift), Z = o([].splice), $ = o("".split), tt = o("".slice), et = /\+/g, nt = Array(4), it = function (t) { return nt[t - 1] || (nt[t - 1] = G("((?:%[\\da-f]{2}){" + t + "})", "gi")) }, rt = function (t) { try { return j(t) } catch (e) { return t } }, st = function (t) { var e = K(t, et, " "), n = 4; try { return j(e) } catch (t) { for (; n;)e = K(e, it(n--), rt); return e } }, ot = /[!'()~]|%20/g, at = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, lt = function (t) { return at[t] }, ht = function (t) { return K(W(t), ot, lt) }, ct = p((function (t, e) { L(this, { type: B, iterator: C(F(t).entries), kind: e }) }), "Iterator", (function () { var t = k(this), e = t.kind, n = t.iterator.next(), i = n.value; return n.done || (n.value = "keys" === e ? i.key : "values" === e ? i.value : [i.key, i.value]), n }), !0), ut = function (t) { this.entries = [], this.url = null, void 0 !== t && (x(t) ? this.parseObject(t) : this.parseQuery("string" == typeof t ? "?" === q(t, 0) ? tt(t, 1) : t : _(t))) }; ut.prototype = { type: D, bindURL: function (t) { this.url = t, this.update() }, parseObject: function (t) { var e, n, i, r, o, a, l, h = S(t); if (h) for (n = (e = C(t, h)).next; !(i = s(n, e)).done;) { if (o = (r = C(y(i.value))).next, (a = s(o, r)).done || (l = s(o, r)).done || !s(o, r).done) throw H("Expected sequence with length 2"); X(this.entries, { key: _(a.value), value: _(l.value) }) } else for (var c in t) v(t, c) && X(this.entries, { key: c, value: _(t[c]) }) }, parseQuery: function (t) { if (t) for (var e, n, i = $(t, "&"), r = 0; r < i.length;)(e = i[r++]).length && (n = $(e, "="), X(this.entries, { key: st(J(n)), value: st(Y(n, "=")) })) }, serialize: function () { for (var t, e = this.entries, n = [], i = 0; i < e.length;)t = e[i++], X(n, ht(t.key) + "=" + ht(t.value)); return Y(n, "&") }, update: function () { this.entries.length = 0, this.parseQuery(this.url.query) }, updateURL: function () { this.url && this.url.update() } }; var dt = function () { m(this, pt); var t = L(this, new ut(arguments.length > 0 ? arguments[0] : void 0)); a || (this.length = t.entries.length) }, pt = dt.prototype; if (u(pt, { append: function (t, e) { M(arguments.length, 2); var n = F(this); X(n.entries, { key: _(t), value: _(e) }), a || this.length++, n.updateURL() }, delete: function (t) { M(arguments.length, 1); for (var e = F(this), n = e.entries, i = _(t), r = 0; r < n.length;)n[r].key === i ? Z(n, r, 1) : r++; a || (this.length = n.length), e.updateURL() }, get: function (t) { M(arguments.length, 1); for (var e = F(this).entries, n = _(t), i = 0; i < e.length; i++)if (e[i].key === n) return e[i].value; return null }, getAll: function (t) { M(arguments.length, 1); for (var e = F(this).entries, n = _(t), i = [], r = 0; r < e.length; r++)e[r].key === n && X(i, e[r].value); return i }, has: function (t) { M(arguments.length, 1); for (var e = F(this).entries, n = _(t), i = 0; i < e.length;)if (e[i++].key === n) return !0; return !1 }, set: function (t, e) { M(arguments.length, 1); for (var n, i = F(this), r = i.entries, s = !1, o = _(t), l = _(e), h = 0; h < r.length; h++)(n = r[h]).key === o && (s ? Z(r, h--, 1) : (s = !0, n.value = l)); s || X(r, { key: o, value: l }), a || (this.length = r.length), i.updateURL() }, sort: function () { var t = F(this); I(t.entries, (function (t, e) { return t.key > e.key ? 1 : -1 })), t.updateURL() }, forEach: function (t) { for (var e, n = F(this).entries, i = A(t, arguments.length > 1 ? arguments[1] : void 0), r = 0; r < n.length;)i((e = n[r++]).value, e.key, this) }, keys: function () { return new ct(this, "keys") }, values: function () { return new ct(this, "values") }, entries: function () { return new ct(this, "entries") } }, { enumerable: !0 }), h(pt, T, pt.entries, { name: "entries" }), h(pt, "toString", (function () { return F(this).serialize() }), { enumerable: !0 }), a && c(pt, "size", { get: function () { return F(this).entries.length }, configurable: !0, enumerable: !0 }), d(dt, D), i({ global: !0, constructor: !0, forced: !l }, { URLSearchParams: dt }), !l && g(z)) { var ft = o(Q.has), mt = o(Q.set), gt = function (t) { if (x(t)) { var e, n = t.body; if (b(n) === D) return e = t.headers ? new z(t.headers) : new z, ft(e, "content-type") || mt(e, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), w(t, { body: E(0, _(n)), headers: E(0, e) }) } return t }; if (g(N) && i({ global: !0, enumerable: !0, dontCallGetSet: !0, forced: !0 }, { fetch: function (t) { return N(t, arguments.length > 1 ? gt(arguments[1]) : {}) } }), g(U)) { var vt = function (t) { return m(this, V), new U(t, arguments.length > 1 ? gt(arguments[1]) : {}) }; V.constructor = vt, vt.prototype = V, i({ global: !0, constructor: !0, dontCallGetSet: !0, forced: !0 }, { Request: vt }) } } t.exports = { URLSearchParams: dt, getState: F } }, 1637: function (t, e, n) { n(5556) }, 8789: function (t, e, n) { "use strict"; n(8783); var i, r = n(2109), s = n(9781), o = n(5143), a = n(7854), l = n(9974), h = n(1702), c = n(8052), u = n(7045), d = n(5787), p = n(2597), f = n(1574), m = n(8457), g = n(1589), v = n(8710).codeAt, A = n(3197), b = n(1340), y = n(8003), x = n(8053), _ = n(5556), w = n(9909), E = w.set, C = w.getterFor("URL"), S = _.URLSearchParams, M = _.getState, P = a.URL, I = a.TypeError, T = a.parseInt, D = Math.floor, B = Math.pow, L = h("".charAt), F = h(/./.exec), k = h([].join), R = h(1..toString), O = h([].pop), N = h([].push), U = h("".replace), z = h([].shift), V = h("".split), Q = h("".slice), G = h("".toLowerCase), H = h([].unshift), j = "Invalid scheme", W = "Invalid host", q = "Invalid port", Y = /[a-z]/i, X = /[\d+-.a-z]/i, K = /\d/, J = /^0x/i, Z = /^[0-7]+$/, $ = /^\d+$/, tt = /^[\da-f]+$/i, et = /[\0\t\n\r #%/:<>?@[\\\]^|]/, nt = /[\0\t\n\r #/:<>?@[\\\]^|]/, it = /^[\u0000-\u0020]+/, rt = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, st = /[\t\n\r]/g, ot = function (t) { var e, n, i, r; if ("number" == typeof t) { for (e = [], n = 0; n < 4; n++)H(e, t % 256), t = D(t / 256); return k(e, ".") } if ("object" == typeof t) { for (e = "", i = function (t) { for (var e = null, n = 1, i = null, r = 0, s = 0; s < 8; s++)0 !== t[s] ? (r > n && (e = i, n = r), i = null, r = 0) : (null === i && (i = s), ++r); return r > n && (e = i, n = r), e }(t), n = 0; n < 8; n++)r && 0 === t[n] || (r && (r = !1), i === n ? (e += n ? ":" : "::", r = !0) : (e += R(t[n], 16), n < 7 && (e += ":"))); return "[" + e + "]" } return t }, at = {}, lt = f({}, at, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), ht = f({}, lt, { "#": 1, "?": 1, "{": 1, "}": 1 }), ct = f({}, ht, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), ut = function (t, e) { var n = v(t, 0); return n > 32 && n < 127 && !p(e, t) ? t : encodeURIComponent(t) }, dt = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, pt = function (t, e) { var n; return 2 == t.length && F(Y, L(t, 0)) && (":" == (n = L(t, 1)) || !e && "|" == n) }, ft = function (t) { var e; return t.length > 1 && pt(Q(t, 0, 2)) && (2 == t.length || "/" === (e = L(t, 2)) || "\\" === e || "?" === e || "#" === e) }, mt = function (t) { return "." === t || "%2e" === G(t) }, gt = {}, vt = {}, At = {}, bt = {}, yt = {}, xt = {}, _t = {}, wt = {}, Et = {}, Ct = {}, St = {}, Mt = {}, Pt = {}, It = {}, Tt = {}, Dt = {}, Bt = {}, Lt = {}, Ft = {}, kt = {}, Rt = {}, Ot = function (t, e, n) { var i, r, s, o = b(t); if (e) { if (r = this.parse(o)) throw I(r); this.searchParams = null } else { if (void 0 !== n && (i = new Ot(n, !0)), r = this.parse(o, null, i)) throw I(r); (s = M(new S)).bindURL(this), this.searchParams = s } }; Ot.prototype = { type: "URL", parse: function (t, e, n) { var r, s, o, a, l, h = this, c = e || gt, u = 0, d = "", f = !1, v = !1, A = !1; for (t = b(t), e || (h.scheme = "", h.username = "", h.password = "", h.host = null, h.port = null, h.path = [], h.query = null, h.fragment = null, h.cannotBeABaseURL = !1, t = U(t, it, ""), t = U(t, rt, "$1")), t = U(t, st, ""), r = m(t); u <= r.length;) { switch (s = r[u], c) { case gt: if (!s || !F(Y, s)) { if (e) return j; c = At; continue } d += G(s), c = vt; break; case vt: if (s && (F(X, s) || "+" == s || "-" == s || "." == s)) d += G(s); else { if (":" != s) { if (e) return j; d = "", c = At, u = 0; continue } if (e && (h.isSpecial() != p(dt, d) || "file" == d && (h.includesCredentials() || null !== h.port) || "file" == h.scheme && !h.host)) return; if (h.scheme = d, e) return void (h.isSpecial() && dt[h.scheme] == h.port && (h.port = null)); d = "", "file" == h.scheme ? c = It : h.isSpecial() && n && n.scheme == h.scheme ? c = bt : h.isSpecial() ? c = wt : "/" == r[u + 1] ? (c = yt, u++) : (h.cannotBeABaseURL = !0, N(h.path, ""), c = Ft) } break; case At: if (!n || n.cannotBeABaseURL && "#" != s) return j; if (n.cannotBeABaseURL && "#" == s) { h.scheme = n.scheme, h.path = g(n.path), h.query = n.query, h.fragment = "", h.cannotBeABaseURL = !0, c = Rt; break } c = "file" == n.scheme ? It : xt; continue; case bt: if ("/" != s || "/" != r[u + 1]) { c = xt; continue } c = Et, u++; break; case yt: if ("/" == s) { c = Ct; break } c = Lt; continue; case xt: if (h.scheme = n.scheme, s == i) h.username = n.username, h.password = n.password, h.host = n.host, h.port = n.port, h.path = g(n.path), h.query = n.query; else if ("/" == s || "\\" == s && h.isSpecial()) c = _t; else if ("?" == s) h.username = n.username, h.password = n.password, h.host = n.host, h.port = n.port, h.path = g(n.path), h.query = "", c = kt; else { if ("#" != s) { h.username = n.username, h.password = n.password, h.host = n.host, h.port = n.port, h.path = g(n.path), h.path.length--, c = Lt; continue } h.username = n.username, h.password = n.password, h.host = n.host, h.port = n.port, h.path = g(n.path), h.query = n.query, h.fragment = "", c = Rt } break; case _t: if (!h.isSpecial() || "/" != s && "\\" != s) { if ("/" != s) { h.username = n.username, h.password = n.password, h.host = n.host, h.port = n.port, c = Lt; continue } c = Ct } else c = Et; break; case wt: if (c = Et, "/" != s || "/" != L(d, u + 1)) continue; u++; break; case Et: if ("/" != s && "\\" != s) { c = Ct; continue } break; case Ct: if ("@" == s) { f && (d = "%40" + d), f = !0, o = m(d); for (var y = 0; y < o.length; y++) { var x = o[y]; if (":" != x || A) { var _ = ut(x, ct); A ? h.password += _ : h.username += _ } else A = !0 } d = "" } else if (s == i || "/" == s || "?" == s || "#" == s || "\\" == s && h.isSpecial()) { if (f && "" == d) return "Invalid authority"; u -= m(d).length + 1, d = "", c = St } else d += s; break; case St: case Mt: if (e && "file" == h.scheme) { c = Dt; continue } if (":" != s || v) { if (s == i || "/" == s || "?" == s || "#" == s || "\\" == s && h.isSpecial()) { if (h.isSpecial() && "" == d) return W; if (e && "" == d && (h.includesCredentials() || null !== h.port)) return; if (a = h.parseHost(d)) return a; if (d = "", c = Bt, e) return; continue } "[" == s ? v = !0 : "]" == s && (v = !1), d += s } else { if ("" == d) return W; if (a = h.parseHost(d)) return a; if (d = "", c = Pt, e == Mt) return } break; case Pt: if (!F(K, s)) { if (s == i || "/" == s || "?" == s || "#" == s || "\\" == s && h.isSpecial() || e) { if ("" != d) { var w = T(d, 10); if (w > 65535) return q; h.port = h.isSpecial() && w === dt[h.scheme] ? null : w, d = "" } if (e) return; c = Bt; continue } return q } d += s; break; case It: if (h.scheme = "file", "/" == s || "\\" == s) c = Tt; else { if (!n || "file" != n.scheme) { c = Lt; continue } if (s == i) h.host = n.host, h.path = g(n.path), h.query = n.query; else if ("?" == s) h.host = n.host, h.path = g(n.path), h.query = "", c = kt; else { if ("#" != s) { ft(k(g(r, u), "")) || (h.host = n.host, h.path = g(n.path), h.shortenPath()), c = Lt; continue } h.host = n.host, h.path = g(n.path), h.query = n.query, h.fragment = "", c = Rt } } break; case Tt: if ("/" == s || "\\" == s) { c = Dt; break } n && "file" == n.scheme && !ft(k(g(r, u), "")) && (pt(n.path[0], !0) ? N(h.path, n.path[0]) : h.host = n.host), c = Lt; continue; case Dt: if (s == i || "/" == s || "\\" == s || "?" == s || "#" == s) { if (!e && pt(d)) c = Lt; else if ("" == d) { if (h.host = "", e) return; c = Bt } else { if (a = h.parseHost(d)) return a; if ("localhost" == h.host && (h.host = ""), e) return; d = "", c = Bt } continue } d += s; break; case Bt: if (h.isSpecial()) { if (c = Lt, "/" != s && "\\" != s) continue } else if (e || "?" != s) if (e || "#" != s) { if (s != i && (c = Lt, "/" != s)) continue } else h.fragment = "", c = Rt; else h.query = "", c = kt; break; case Lt: if (s == i || "/" == s || "\\" == s && h.isSpecial() || !e && ("?" == s || "#" == s)) { if (".." === (l = G(l = d)) || "%2e." === l || ".%2e" === l || "%2e%2e" === l ? (h.shortenPath(), "/" == s || "\\" == s && h.isSpecial() || N(h.path, "")) : mt(d) ? "/" == s || "\\" == s && h.isSpecial() || N(h.path, "") : ("file" == h.scheme && !h.path.length && pt(d) && (h.host && (h.host = ""), d = L(d, 0) + ":"), N(h.path, d)), d = "", "file" == h.scheme && (s == i || "?" == s || "#" == s)) for (; h.path.length > 1 && "" === h.path[0];)z(h.path); "?" == s ? (h.query = "", c = kt) : "#" == s && (h.fragment = "", c = Rt) } else d += ut(s, ht); break; case Ft: "?" == s ? (h.query = "", c = kt) : "#" == s ? (h.fragment = "", c = Rt) : s != i && (h.path[0] += ut(s, at)); break; case kt: e || "#" != s ? s != i && ("'" == s && h.isSpecial() ? h.query += "%27" : h.query += "#" == s ? "%23" : ut(s, at)) : (h.fragment = "", c = Rt); break; case Rt: s != i && (h.fragment += ut(s, lt)) }u++ } }, parseHost: function (t) { var e, n, i; if ("[" == L(t, 0)) { if ("]" != L(t, t.length - 1)) return W; if (e = function (t) { var e, n, i, r, s, o, a, l = [0, 0, 0, 0, 0, 0, 0, 0], h = 0, c = null, u = 0, d = function () { return L(t, u) }; if (":" == d()) { if (":" != L(t, 1)) return; u += 2, c = ++h } for (; d();) { if (8 == h) return; if (":" != d()) { for (e = n = 0; n < 4 && F(tt, d());)e = 16 * e + T(d(), 16), u++, n++; if ("." == d()) { if (0 == n) return; if (u -= n, h > 6) return; for (i = 0; d();) { if (r = null, i > 0) { if (!("." == d() && i < 4)) return; u++ } if (!F(K, d())) return; for (; F(K, d());) { if (s = T(d(), 10), null === r) r = s; else { if (0 == r) return; r = 10 * r + s } if (r > 255) return; u++ } l[h] = 256 * l[h] + r, 2 != ++i && 4 != i || h++ } if (4 != i) return; break } if (":" == d()) { if (u++, !d()) return } else if (d()) return; l[h++] = e } else { if (null !== c) return; u++, c = ++h } } if (null !== c) for (o = h - c, h = 7; 0 != h && o > 0;)a = l[h], l[h--] = l[c + o - 1], l[c + --o] = a; else if (8 != h) return; return l }(Q(t, 1, -1)), !e) return W; this.host = e } else if (this.isSpecial()) { if (t = A(t), F(et, t)) return W; if (e = function (t) { var e, n, i, r, s, o, a, l = V(t, "."); if (l.length && "" == l[l.length - 1] && l.length--, (e = l.length) > 4) return t; for (n = [], i = 0; i < e; i++) { if ("" == (r = l[i])) return t; if (s = 10, r.length > 1 && "0" == L(r, 0) && (s = F(J, r) ? 16 : 8, r = Q(r, 8 == s ? 1 : 2)), "" === r) o = 0; else { if (!F(10 == s ? $ : 8 == s ? Z : tt, r)) return t; o = T(r, s) } N(n, o) } for (i = 0; i < e; i++)if (o = n[i], i == e - 1) { if (o >= B(256, 5 - e)) return null } else if (o > 255) return null; for (a = O(n), i = 0; i < n.length; i++)a += n[i] * B(256, 3 - i); return a }(t), null === e) return W; this.host = e } else { if (F(nt, t)) return W; for (e = "", n = m(t), i = 0; i < n.length; i++)e += ut(n[i], at); this.host = e } }, cannotHaveUsernamePasswordPort: function () { return !this.host || this.cannotBeABaseURL || "file" == this.scheme }, includesCredentials: function () { return "" != this.username || "" != this.password }, isSpecial: function () { return p(dt, this.scheme) }, shortenPath: function () { var t = this.path, e = t.length; !e || "file" == this.scheme && 1 == e && pt(t[0], !0) || t.length-- }, serialize: function () { var t = this, e = t.scheme, n = t.username, i = t.password, r = t.host, s = t.port, o = t.path, a = t.query, l = t.fragment, h = e + ":"; return null !== r ? (h += "//", t.includesCredentials() && (h += n + (i ? ":" + i : "") + "@"), h += ot(r), null !== s && (h += ":" + s)) : "file" == e && (h += "//"), h += t.cannotBeABaseURL ? o[0] : o.length ? "/" + k(o, "/") : "", null !== a && (h += "?" + a), null !== l && (h += "#" + l), h }, setHref: function (t) { var e = this.parse(t); if (e) throw I(e); this.searchParams.update() }, getOrigin: function () { var t = this.scheme, e = this.port; if ("blob" == t) try { return new Nt(t.path[0]).origin } catch (t) { return "null" } return "file" != t && this.isSpecial() ? t + "://" + ot(this.host) + (null !== e ? ":" + e : "") : "null" }, getProtocol: function () { return this.scheme + ":" }, setProtocol: function (t) { this.parse(b(t) + ":", gt) }, getUsername: function () { return this.username }, setUsername: function (t) { var e = m(b(t)); if (!this.cannotHaveUsernamePasswordPort()) { this.username = ""; for (var n = 0; n < e.length; n++)this.username += ut(e[n], ct) } }, getPassword: function () { return this.password }, setPassword: function (t) { var e = m(b(t)); if (!this.cannotHaveUsernamePasswordPort()) { this.password = ""; for (var n = 0; n < e.length; n++)this.password += ut(e[n], ct) } }, getHost: function () { var t = this.host, e = this.port; return null === t ? "" : null === e ? ot(t) : ot(t) + ":" + e }, setHost: function (t) { this.cannotBeABaseURL || this.parse(t, St) }, getHostname: function () { var t = this.host; return null === t ? "" : ot(t) }, setHostname: function (t) { this.cannotBeABaseURL || this.parse(t, Mt) }, getPort: function () { var t = this.port; return null === t ? "" : b(t) }, setPort: function (t) { this.cannotHaveUsernamePasswordPort() || ("" == (t = b(t)) ? this.port = null : this.parse(t, Pt)) }, getPathname: function () { var t = this.path; return this.cannotBeABaseURL ? t[0] : t.length ? "/" + k(t, "/") : "" }, setPathname: function (t) { this.cannotBeABaseURL || (this.path = [], this.parse(t, Bt)) }, getSearch: function () { var t = this.query; return t ? "?" + t : "" }, setSearch: function (t) { "" == (t = b(t)) ? this.query = null : ("?" == L(t, 0) && (t = Q(t, 1)), this.query = "", this.parse(t, kt)), this.searchParams.update() }, getSearchParams: function () { return this.searchParams.facade }, getHash: function () { var t = this.fragment; return t ? "#" + t : "" }, setHash: function (t) { "" != (t = b(t)) ? ("#" == L(t, 0) && (t = Q(t, 1)), this.fragment = "", this.parse(t, Rt)) : this.fragment = null }, update: function () { this.query = this.searchParams.serialize() || null } }; var Nt = function (t) { var e = d(this, Ut), n = x(arguments.length, 1) > 1 ? arguments[1] : void 0, i = E(e, new Ot(t, !1, n)); s || (e.href = i.serialize(), e.origin = i.getOrigin(), e.protocol = i.getProtocol(), e.username = i.getUsername(), e.password = i.getPassword(), e.host = i.getHost(), e.hostname = i.getHostname(), e.port = i.getPort(), e.pathname = i.getPathname(), e.search = i.getSearch(), e.searchParams = i.getSearchParams(), e.hash = i.getHash()) }, Ut = Nt.prototype, zt = function (t, e) { return { get: function () { return C(this)[t]() }, set: e && function (t) { return C(this)[e](t) }, configurable: !0, enumerable: !0 } }; if (s && (u(Ut, "href", zt("serialize", "setHref")), u(Ut, "origin", zt("getOrigin")), u(Ut, "protocol", zt("getProtocol", "setProtocol")), u(Ut, "username", zt("getUsername", "setUsername")), u(Ut, "password", zt("getPassword", "setPassword")), u(Ut, "host", zt("getHost", "setHost")), u(Ut, "hostname", zt("getHostname", "setHostname")), u(Ut, "port", zt("getPort", "setPort")), u(Ut, "pathname", zt("getPathname", "setPathname")), u(Ut, "search", zt("getSearch", "setSearch")), u(Ut, "searchParams", zt("getSearchParams")), u(Ut, "hash", zt("getHash", "setHash"))), c(Ut, "toJSON", (function () { return C(this).serialize() }), { enumerable: !0 }), c(Ut, "toString", (function () { return C(this).serialize() }), { enumerable: !0 }), P) { var Vt = P.createObjectURL, Qt = P.revokeObjectURL; Vt && c(Nt, "createObjectURL", l(Vt, P)), Qt && c(Nt, "revokeObjectURL", l(Qt, P)) } y(Nt, "URL"), r({ global: !0, constructor: !0, forced: !o, sham: !s }, { URL: Nt }) }, 285: function (t, e, n) { n(8789) }, 645: function (t, e) { e.read = function (t, e, n, i, r) { var s, o, a = 8 * r - i - 1, l = (1 << a) - 1, h = l >> 1, c = -7, u = n ? r - 1 : 0, d = n ? -1 : 1, p = t[e + u]; for (u += d, s = p & (1 << -c) - 1, p >>= -c, c += a; c > 0; s = 256 * s + t[e + u], u += d, c -= 8); for (o = s & (1 << -c) - 1, s >>= -c, c += i; c > 0; o = 256 * o + t[e + u], u += d, c -= 8); if (0 === s) s = 1 - h; else { if (s === l) return o ? NaN : 1 / 0 * (p ? -1 : 1); o += Math.pow(2, i), s -= h } return (p ? -1 : 1) * o * Math.pow(2, s - i) }, e.write = function (t, e, n, i, r, s) { var o, a, l, h = 8 * s - r - 1, c = (1 << h) - 1, u = c >> 1, d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = i ? 0 : s - 1, f = i ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (e += o + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (o++, l /= 2), o + u >= c ? (a = 0, o = c) : o + u >= 1 ? (a = (e * l - 1) * Math.pow(2, r), o += u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, r), o = 0)); r >= 8; t[n + p] = 255 & a, p += f, a /= 256, r -= 8); for (o = o << r | a, h += r; h > 0; t[n + p] = 255 & o, p += f, o /= 256, h -= 8); t[n + p - f] |= 128 * m } }, 5826: function (t) { var e = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == e.call(t) } }, 1248: function (module, exports, __webpack_require__) { var factory; "undefined" != typeof navigator && (factory = function () { "use strict"; var svgNS = "http://www.w3.org/2000/svg", locationHref = "", _useWebWorker = !1, initialDefaultFrame = -999999, setWebWorker = function (t) { _useWebWorker = !!t }, getWebWorker = function () { return _useWebWorker }, setLocationHref = function (t) { locationHref = t }, getLocationHref = function () { return locationHref }; function createTag(t) { return document.createElement(t) } function extendPrototype(t, e) { var n, i, r = t.length; for (n = 0; n < r; n += 1)for (var s in i = t[n].prototype) Object.prototype.hasOwnProperty.call(i, s) && (e.prototype[s] = i[s]) } function getDescriptor(t, e) { return Object.getOwnPropertyDescriptor(t, e) } function createProxyFunction(t) { function e() { } return e.prototype = t, e } var audioControllerFactory = function () { function t(t) { this.audios = [], this.audioFactory = t, this._volume = 1, this._isMuted = !1 } return t.prototype = { addAudio: function (t) { this.audios.push(t) }, pause: function () { var t, e = this.audios.length; for (t = 0; t < e; t += 1)this.audios[t].pause() }, resume: function () { var t, e = this.audios.length; for (t = 0; t < e; t += 1)this.audios[t].resume() }, setRate: function (t) { var e, n = this.audios.length; for (e = 0; e < n; e += 1)this.audios[e].setRate(t) }, createAudio: function (t) { return this.audioFactory ? this.audioFactory(t) : window.Howl ? new window.Howl({ src: [t] }) : { isPlaying: !1, play: function () { this.isPlaying = !0 }, seek: function () { this.isPlaying = !1 }, playing: function () { }, rate: function () { }, setVolume: function () { } } }, setAudioFactory: function (t) { this.audioFactory = t }, setVolume: function (t) { this._volume = t, this._updateVolume() }, mute: function () { this._isMuted = !0, this._updateVolume() }, unmute: function () { this._isMuted = !1, this._updateVolume() }, getVolume: function () { return this._volume }, _updateVolume: function () { var t, e = this.audios.length; for (t = 0; t < e; t += 1)this.audios[t].volume(this._volume * (this._isMuted ? 0 : 1)) } }, function () { return new t } }(), createTypedArray = function () { function t(t, e) { var n, i = 0, r = []; switch (t) { case "int16": case "uint8c": n = 1; break; default: n = 1.1 }for (i = 0; i < e; i += 1)r.push(n); return r } return "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function (e, n) { return "float32" === e ? new Float32Array(n) : "int16" === e ? new Int16Array(n) : "uint8c" === e ? new Uint8ClampedArray(n) : t(e, n) } : t }(); function createSizedArray(t) { return Array.apply(null, { length: t }) } function _typeof$6(t) { return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof$6(t) } var subframeEnabled = !0, expressionsPlugin = null, expressionsInterfaces = null, idPrefix$1 = "", isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), _shouldRoundValues = !1, bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min, BMMath = {}; function ProjectInterface$1() { return {} } !function () { var t, e = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], n = e.length; for (t = 0; t < n; t += 1)BMMath[e[t]] = Math[e[t]] }(), BMMath.random = Math.random, BMMath.abs = function (t) { if ("object" === _typeof$6(t) && t.length) { var e, n = createSizedArray(t.length), i = t.length; for (e = 0; e < i; e += 1)n[e] = Math.abs(t[e]); return n } return Math.abs(t) }; var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = .5519; function roundValues(t) { _shouldRoundValues = !!t } function bmRnd(t) { return _shouldRoundValues ? Math.round(t) : t } function styleDiv(t) { t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.display = "block", t.style.transformOrigin = "0 0", t.style.webkitTransformOrigin = "0 0", t.style.backfaceVisibility = "visible", t.style.webkitBackfaceVisibility = "visible", t.style.transformStyle = "preserve-3d", t.style.webkitTransformStyle = "preserve-3d", t.style.mozTransformStyle = "preserve-3d" } function BMEnterFrameEvent(t, e, n, i) { this.type = t, this.currentTime = e, this.totalTime = n, this.direction = i < 0 ? -1 : 1 } function BMCompleteEvent(t, e) { this.type = t, this.direction = e < 0 ? -1 : 1 } function BMCompleteLoopEvent(t, e, n, i) { this.type = t, this.currentLoop = n, this.totalLoops = e, this.direction = i < 0 ? -1 : 1 } function BMSegmentStartEvent(t, e, n) { this.type = t, this.firstFrame = e, this.totalFrames = n } function BMDestroyEvent(t, e) { this.type = t, this.target = e } function BMRenderFrameErrorEvent(t, e) { this.type = "renderFrameError", this.nativeError = t, this.currentTime = e } function BMConfigErrorEvent(t) { this.type = "configError", this.nativeError = t } function BMAnimationConfigErrorEvent(t, e) { this.type = t, this.nativeError = e } var createElementID = (_count = 0, function () { return idPrefix$1 + "__lottie_element_" + (_count += 1) }), _count; function HSVtoRGB(t, e, n) { var i, r, s, o, a, l, h, c; switch (l = n * (1 - e), h = n * (1 - (a = 6 * t - (o = Math.floor(6 * t))) * e), c = n * (1 - (1 - a) * e), o % 6) { case 0: i = n, r = c, s = l; break; case 1: i = h, r = n, s = l; break; case 2: i = l, r = n, s = c; break; case 3: i = l, r = h, s = n; break; case 4: i = c, r = l, s = n; break; case 5: i = n, r = l, s = h }return [i, r, s] } function RGBtoHSV(t, e, n) { var i, r = Math.max(t, e, n), s = Math.min(t, e, n), o = r - s, a = 0 === r ? 0 : o / r, l = r / 255; switch (r) { case s: i = 0; break; case t: i = e - n + o * (e < n ? 6 : 0), i /= 6 * o; break; case e: i = n - t + 2 * o, i /= 6 * o; break; case n: i = t - e + 4 * o, i /= 6 * o }return [i, a, l] } function addSaturationToRGB(t, e) { var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]); return n[1] += e, n[1] > 1 ? n[1] = 1 : n[1] <= 0 && (n[1] = 0), HSVtoRGB(n[0], n[1], n[2]) } function addBrightnessToRGB(t, e) { var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]); return n[2] += e, n[2] > 1 ? n[2] = 1 : n[2] < 0 && (n[2] = 0), HSVtoRGB(n[0], n[1], n[2]) } function addHueToRGB(t, e) { var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]); return n[0] += e / 360, n[0] > 1 ? n[0] -= 1 : n[0] < 0 && (n[0] += 1), HSVtoRGB(n[0], n[1], n[2]) } var rgbToHex = function () { var t, e, n = []; for (t = 0; t < 256; t += 1)e = t.toString(16), n[t] = 1 === e.length ? "0" + e : e; return function (t, e, i) { return t < 0 && (t = 0), e < 0 && (e = 0), i < 0 && (i = 0), "#" + n[t] + n[e] + n[i] } }(), setSubframeEnabled = function (t) { subframeEnabled = !!t }, getSubframeEnabled = function () { return subframeEnabled }, setExpressionsPlugin = function (t) { expressionsPlugin = t }, getExpressionsPlugin = function () { return expressionsPlugin }, setExpressionInterfaces = function (t) { expressionsInterfaces = t }, getExpressionInterfaces = function () { return expressionsInterfaces }, setDefaultCurveSegments = function (t) { defaultCurveSegments = t }, getDefaultCurveSegments = function () { return defaultCurveSegments }, setIdPrefix = function (t) { idPrefix$1 = t }, getIdPrefix = function () { return idPrefix$1 }; function createNS(t) { return document.createElementNS(svgNS, t) } function _typeof$5(t) { return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof$5(t) } var dataManager = function () { var t, e, n = 1, i = [], r = { onmessage: function () { }, postMessage: function (e) { t({ data: e }) } }, s = { postMessage: function (t) { r.onmessage({ data: t }) } }; function o() { e || (e = function (e) { if (window.Worker && window.Blob && getWebWorker()) { var n = new Blob(["var _workerSelf = self; self.onmessage = ", e.toString()], { type: "text/javascript" }), i = URL.createObjectURL(n); return new Worker(i) } return t = e, r }((function (t) { if (s.dataManager || (s.dataManager = function () { function t(r, s) { var o, a, l, h, c, d, p = r.length; for (a = 0; a < p; a += 1)if ("ks" in (o = r[a]) && !o.completed) { if (o.completed = !0, o.hasMask) { var f = o.masksProperties; for (h = f.length, l = 0; l < h; l += 1)if (f[l].pt.k.i) i(f[l].pt.k); else for (d = f[l].pt.k.length, c = 0; c < d; c += 1)f[l].pt.k[c].s && i(f[l].pt.k[c].s[0]), f[l].pt.k[c].e && i(f[l].pt.k[c].e[0]) } 0 === o.ty ? (o.layers = e(o.refId, s), t(o.layers, s)) : 4 === o.ty ? n(o.shapes) : 5 === o.ty && u(o) } } function e(t, e) { var n = function (t, e) { for (var n = 0, i = e.length; n < i;) { if (e[n].id === t) return e[n]; n += 1 } return null }(t, e); return n ? n.layers.__used ? JSON.parse(JSON.stringify(n.layers)) : (n.layers.__used = !0, n.layers) : null } function n(t) { var e, r, s; for (e = t.length - 1; e >= 0; e -= 1)if ("sh" === t[e].ty) if (t[e].ks.k.i) i(t[e].ks.k); else for (s = t[e].ks.k.length, r = 0; r < s; r += 1)t[e].ks.k[r].s && i(t[e].ks.k[r].s[0]), t[e].ks.k[r].e && i(t[e].ks.k[r].e[0]); else "gr" === t[e].ty && n(t[e].it) } function i(t) { var e, n = t.i.length; for (e = 0; e < n; e += 1)t.i[e][0] += t.v[e][0], t.i[e][1] += t.v[e][1], t.o[e][0] += t.v[e][0], t.o[e][1] += t.v[e][1] } function r(t, e) { var n = e ? e.split(".") : [100, 100, 100]; return t[0] > n[0] || !(n[0] > t[0]) && (t[1] > n[1] || !(n[1] > t[1]) && (t[2] > n[2] || !(n[2] > t[2]) && null)) } var s, o = function () { var t = [4, 4, 14]; function e(t) { var e, n, i, r = t.length; for (e = 0; e < r; e += 1)5 === t[e].ty && (i = void 0, i = (n = t[e]).t.d, n.t.d = { k: [{ s: i, t: 0 }] }) } return function (n) { if (r(t, n.v) && (e(n.layers), n.assets)) { var i, s = n.assets.length; for (i = 0; i < s; i += 1)n.assets[i].layers && e(n.assets[i].layers) } } }(), a = (s = [4, 7, 99], function (t) { if (t.chars && !r(s, t.v)) { var e, i = t.chars.length; for (e = 0; e < i; e += 1) { var o = t.chars[e]; o.data && o.data.shapes && (n(o.data.shapes), o.data.ip = 0, o.data.op = 99999, o.data.st = 0, o.data.sr = 1, o.data.ks = { p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 } }, t.chars[e].t || (o.data.shapes.push({ ty: "no" }), o.data.shapes[0].it.push({ p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 }, sk: { k: 0, a: 0 }, sa: { k: 0, a: 0 }, ty: "tr" }))) } } }), l = function () { var t = [5, 7, 15]; function e(t) { var e, n, i = t.length; for (e = 0; e < i; e += 1)5 === t[e].ty && (n = void 0, "number" == typeof (n = t[e].t.p).a && (n.a = { a: 0, k: n.a }), "number" == typeof n.p && (n.p = { a: 0, k: n.p }), "number" == typeof n.r && (n.r = { a: 0, k: n.r })) } return function (n) { if (r(t, n.v) && (e(n.layers), n.assets)) { var i, s = n.assets.length; for (i = 0; i < s; i += 1)n.assets[i].layers && e(n.assets[i].layers) } } }(), h = function () { var t = [4, 1, 9]; function e(t) { var n, i, r, s = t.length; for (n = 0; n < s; n += 1)if ("gr" === t[n].ty) e(t[n].it); else if ("fl" === t[n].ty || "st" === t[n].ty) if (t[n].c.k && t[n].c.k[0].i) for (r = t[n].c.k.length, i = 0; i < r; i += 1)t[n].c.k[i].s && (t[n].c.k[i].s[0] /= 255, t[n].c.k[i].s[1] /= 255, t[n].c.k[i].s[2] /= 255, t[n].c.k[i].s[3] /= 255), t[n].c.k[i].e && (t[n].c.k[i].e[0] /= 255, t[n].c.k[i].e[1] /= 255, t[n].c.k[i].e[2] /= 255, t[n].c.k[i].e[3] /= 255); else t[n].c.k[0] /= 255, t[n].c.k[1] /= 255, t[n].c.k[2] /= 255, t[n].c.k[3] /= 255 } function n(t) { var n, i = t.length; for (n = 0; n < i; n += 1)4 === t[n].ty && e(t[n].shapes) } return function (e) { if (r(t, e.v) && (n(e.layers), e.assets)) { var i, s = e.assets.length; for (i = 0; i < s; i += 1)e.assets[i].layers && n(e.assets[i].layers) } } }(), c = function () { var t = [4, 4, 18]; function e(t) { var n, i, r; for (n = t.length - 1; n >= 0; n -= 1)if ("sh" === t[n].ty) if (t[n].ks.k.i) t[n].ks.k.c = t[n].closed; else for (r = t[n].ks.k.length, i = 0; i < r; i += 1)t[n].ks.k[i].s && (t[n].ks.k[i].s[0].c = t[n].closed), t[n].ks.k[i].e && (t[n].ks.k[i].e[0].c = t[n].closed); else "gr" === t[n].ty && e(t[n].it) } function n(t) { var n, i, r, s, o, a, l = t.length; for (i = 0; i < l; i += 1) { if ((n = t[i]).hasMask) { var h = n.masksProperties; for (s = h.length, r = 0; r < s; r += 1)if (h[r].pt.k.i) h[r].pt.k.c = h[r].cl; else for (a = h[r].pt.k.length, o = 0; o < a; o += 1)h[r].pt.k[o].s && (h[r].pt.k[o].s[0].c = h[r].cl), h[r].pt.k[o].e && (h[r].pt.k[o].e[0].c = h[r].cl) } 4 === n.ty && e(n.shapes) } } return function (e) { if (r(t, e.v) && (n(e.layers), e.assets)) { var i, s = e.assets.length; for (i = 0; i < s; i += 1)e.assets[i].layers && n(e.assets[i].layers) } } }(); function u(t) { 0 === t.t.a.length && t.t.p } var d = { completeData: function (n) { n.__complete || (h(n), o(n), a(n), l(n), c(n), t(n.layers, n.assets), function (n, i) { if (n) { var r = 0, s = n.length; for (r = 0; r < s; r += 1)1 === n[r].t && (n[r].data.layers = e(n[r].data.refId, i), t(n[r].data.layers, i)) } }(n.chars, n.assets), n.__complete = !0) } }; return d.checkColors = h, d.checkChars = a, d.checkPathProperties = l, d.checkShapes = c, d.completeLayers = t, d }()), s.assetLoader || (s.assetLoader = function () { function t(t) { var e = t.getResponseHeader("content-type"); return e && "json" === t.responseType && -1 !== e.indexOf("json") || t.response && "object" === _typeof$5(t.response) ? t.response : t.response && "string" == typeof t.response ? JSON.parse(t.response) : t.responseText ? JSON.parse(t.responseText) : null } return { load: function (e, n, i, r) { var s, o = new XMLHttpRequest; try { o.responseType = "json" } catch (t) { } o.onreadystatechange = function () { if (4 === o.readyState) if (200 === o.status) s = t(o), i(s); else try { s = t(o), i(s) } catch (t) { r && r(t) } }; try { o.open(["G", "E", "T"].join(""), e, !0) } catch (t) { o.open(["G", "E", "T"].join(""), n + "/" + e, !0) } o.send() } } }()), "loadAnimation" === t.data.type) s.assetLoader.load(t.data.path, t.data.fullPath, (function (e) { s.dataManager.completeData(e), s.postMessage({ id: t.data.id, payload: e, status: "success" }) }), (function () { s.postMessage({ id: t.data.id, status: "error" }) })); else if ("complete" === t.data.type) { var e = t.data.animation; s.dataManager.completeData(e), s.postMessage({ id: t.data.id, payload: e, status: "success" }) } else "loadData" === t.data.type && s.assetLoader.load(t.data.path, t.data.fullPath, (function (e) { s.postMessage({ id: t.data.id, payload: e, status: "success" }) }), (function () { s.postMessage({ id: t.data.id, status: "error" }) })) })), e.onmessage = function (t) { var e = t.data, n = e.id, r = i[n]; i[n] = null, "success" === e.status ? r.onComplete(e.payload) : r.onError && r.onError() }) } function a(t, e) { var r = "processId_" + (n += 1); return i[r] = { onComplete: t, onError: e }, r } return { loadAnimation: function (t, n, i) { o(); var r = a(n, i); e.postMessage({ type: "loadAnimation", path: t, fullPath: window.location.origin + window.location.pathname, id: r }) }, loadData: function (t, n, i) { o(); var r = a(n, i); e.postMessage({ type: "loadData", path: t, fullPath: window.location.origin + window.location.pathname, id: r }) }, completeAnimation: function (t, n, i) { o(); var r = a(n, i); e.postMessage({ type: "complete", animation: t, id: r }) } } }(), ImagePreloader = function () { var t = function () { var t = createTag("canvas"); t.width = 1, t.height = 1; var e = t.getContext("2d"); return e.fillStyle = "rgba(0,0,0,0)", e.fillRect(0, 0, 1, 1), t }(); function e() { this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function n() { this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function i(t, e, n) { var i = ""; if (t.e) i = t.p; else if (e) { var r = t.p; -1 !== r.indexOf("images/") && (r = r.split("/")[1]), i = e + r } else i = n, i += t.u ? t.u : "", i += t.p; return i } function r(t) { var e = 0, n = setInterval(function () { (t.getBBox().width || e > 500) && (this._imageLoaded(), clearInterval(n)), e += 1 }.bind(this), 50) } function s(t) { var e = { assetData: t }, n = i(t, this.assetsPath, this.path); return dataManager.loadData(n, function (t) { e.img = t, this._footageLoaded() }.bind(this), function () { e.img = {}, this._footageLoaded() }.bind(this)), e } function o() { this._imageLoaded = e.bind(this), this._footageLoaded = n.bind(this), this.testImageLoaded = r.bind(this), this.createFootageData = s.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = [] } return o.prototype = { loadAssets: function (t, e) { var n; this.imagesLoadedCb = e; var i = t.length; for (n = 0; n < i; n += 1)t[n].layers || (t[n].t && "seq" !== t[n].t ? 3 === t[n].t && (this.totalFootages += 1, this.images.push(this.createFootageData(t[n]))) : (this.totalImages += 1, this.images.push(this._createImageData(t[n])))) }, setAssetsPath: function (t) { this.assetsPath = t || "" }, setPath: function (t) { this.path = t || "" }, loadedImages: function () { return this.totalImages === this.loadedAssets }, loadedFootages: function () { return this.totalFootages === this.loadedFootagesCount }, destroy: function () { this.imagesLoadedCb = null, this.images.length = 0 }, getAsset: function (t) { for (var e = 0, n = this.images.length; e < n;) { if (this.images[e].assetData === t) return this.images[e].img; e += 1 } return null }, createImgData: function (e) { var n = i(e, this.assetsPath, this.path), r = createTag("img"); r.crossOrigin = "anonymous", r.addEventListener("load", this._imageLoaded, !1), r.addEventListener("error", function () { s.img = t, this._imageLoaded() }.bind(this), !1), r.src = n; var s = { img: r, assetData: e }; return s }, createImageData: function (e) { var n = i(e, this.assetsPath, this.path), r = createNS("image"); isSafari ? this.testImageLoaded(r) : r.addEventListener("load", this._imageLoaded, !1), r.addEventListener("error", function () { s.img = t, this._imageLoaded() }.bind(this), !1), r.setAttributeNS("http://www.w3.org/1999/xlink", "href", n), this._elementHelper.append ? this._elementHelper.append(r) : this._elementHelper.appendChild(r); var s = { img: r, assetData: e }; return s }, imageLoaded: e, footageLoaded: n, setCacheType: function (t, e) { "svg" === t ? (this._elementHelper = e, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this) } }, o }(); function BaseEvent() { } BaseEvent.prototype = { triggerEvent: function (t, e) { if (this._cbs[t]) for (var n = this._cbs[t], i = 0; i < n.length; i += 1)n[i](e) }, addEventListener: function (t, e) { return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e), function () { this.removeEventListener(t, e) }.bind(this) }, removeEventListener: function (t, e) { if (e) { if (this._cbs[t]) { for (var n = 0, i = this._cbs[t].length; n < i;)this._cbs[t][n] === e && (this._cbs[t].splice(n, 1), n -= 1, i -= 1), n += 1; this._cbs[t].length || (this._cbs[t] = null) } } else this._cbs[t] = null } }; var markerParser = function () { function t(t) { for (var e, n = t.split("\r\n"), i = {}, r = 0, s = 0; s < n.length; s += 1)2 === (e = n[s].split(":")).length && (i[e[0]] = e[1].trim(), r += 1); if (0 === r) throw new Error; return i } return function (e) { for (var n = [], i = 0; i < e.length; i += 1) { var r = e[i], s = { time: r.tm, duration: r.dr }; try { s.payload = JSON.parse(e[i].cm) } catch (n) { try { s.payload = t(e[i].cm) } catch (t) { s.payload = { name: e[i].cm } } } n.push(s) } return n } }(), ProjectInterface = function () { function t(t) { this.compositions.push(t) } return function () { function e(t) { for (var e = 0, n = this.compositions.length; e < n;) { if (this.compositions[e].data && this.compositions[e].data.nm === t) return this.compositions[e].prepareFrame && this.compositions[e].data.xt && this.compositions[e].prepareFrame(this.currentFrame), this.compositions[e].compInterface; e += 1 } return null } return e.compositions = [], e.currentFrame = 0, e.registerComposition = t, e } }(), renderers = {}, registerRenderer = function (t, e) { renderers[t] = e }; function getRenderer(t) { return renderers[t] } function _typeof$4(t) { return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof$4(t) } var AnimationItem = function () { this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0) }; extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (t) { (t.wrapper || t.container) && (this.wrapper = t.wrapper || t.container); var e = "svg"; t.animType ? e = t.animType : t.renderer && (e = t.renderer); var n = getRenderer(e); this.renderer = new n(this, t.rendererSettings), this.imagePreloader.setCacheType(e, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = e, "" === t.loop || null === t.loop || void 0 === t.loop || !0 === t.loop ? this.loop = !0 : !1 === t.loop ? this.loop = !1 : this.loop = parseInt(t.loop, 10), this.autoplay = !("autoplay" in t) || t.autoplay, this.name = t.name ? t.name : "", this.autoloadSegments = !Object.prototype.hasOwnProperty.call(t, "autoloadSegments") || t.autoloadSegments, this.assetsPath = t.assetsPath, this.initialSegment = t.initialSegment, t.audioFactory && this.audioController.setAudioFactory(t.audioFactory), t.animationData ? this.setupAnimation(t.animationData) : t.path && (-1 !== t.path.lastIndexOf("\\") ? this.path = t.path.substr(0, t.path.lastIndexOf("\\") + 1) : this.path = t.path.substr(0, t.path.lastIndexOf("/") + 1), this.fileName = t.path.substr(t.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(t.path, this.configAnimation, this.onSetupError)) }, AnimationItem.prototype.onSetupError = function () { this.trigger("data_failed") }, AnimationItem.prototype.setupAnimation = function (t) { dataManager.completeAnimation(t, this.configAnimation) }, AnimationItem.prototype.setData = function (t, e) { e && "object" !== _typeof$4(e) && (e = JSON.parse(e)); var n = { wrapper: t, animationData: e }, i = t.attributes; n.path = i.getNamedItem("data-animation-path") ? i.getNamedItem("data-animation-path").value : i.getNamedItem("data-bm-path") ? i.getNamedItem("data-bm-path").value : i.getNamedItem("bm-path") ? i.getNamedItem("bm-path").value : "", n.animType = i.getNamedItem("data-anim-type") ? i.getNamedItem("data-anim-type").value : i.getNamedItem("data-bm-type") ? i.getNamedItem("data-bm-type").value : i.getNamedItem("bm-type") ? i.getNamedItem("bm-type").value : i.getNamedItem("data-bm-renderer") ? i.getNamedItem("data-bm-renderer").value : i.getNamedItem("bm-renderer") ? i.getNamedItem("bm-renderer").value : "canvas"; var r = i.getNamedItem("data-anim-loop") ? i.getNamedItem("data-anim-loop").value : i.getNamedItem("data-bm-loop") ? i.getNamedItem("data-bm-loop").value : i.getNamedItem("bm-loop") ? i.getNamedItem("bm-loop").value : ""; "false" === r ? n.loop = !1 : "true" === r ? n.loop = !0 : "" !== r && (n.loop = parseInt(r, 10)); var s = i.getNamedItem("data-anim-autoplay") ? i.getNamedItem("data-anim-autoplay").value : i.getNamedItem("data-bm-autoplay") ? i.getNamedItem("data-bm-autoplay").value : !i.getNamedItem("bm-autoplay") || i.getNamedItem("bm-autoplay").value; n.autoplay = "false" !== s, n.name = i.getNamedItem("data-name") ? i.getNamedItem("data-name").value : i.getNamedItem("data-bm-name") ? i.getNamedItem("data-bm-name").value : i.getNamedItem("bm-name") ? i.getNamedItem("bm-name").value : "", "false" === (i.getNamedItem("data-anim-prerender") ? i.getNamedItem("data-anim-prerender").value : i.getNamedItem("data-bm-prerender") ? i.getNamedItem("data-bm-prerender").value : i.getNamedItem("bm-prerender") ? i.getNamedItem("bm-prerender").value : "") && (n.prerender = !1), this.setParams(n) }, AnimationItem.prototype.includeLayers = function (t) { t.op > this.animationData.op && (this.animationData.op = t.op, this.totalFrames = Math.floor(t.op - this.animationData.ip)); var e, n, i = this.animationData.layers, r = i.length, s = t.layers, o = s.length; for (n = 0; n < o; n += 1)for (e = 0; e < r;) { if (i[e].id === s[n].id) { i[e] = s[n]; break } e += 1 } if ((t.chars || t.fonts) && (this.renderer.globalData.fontManager.addChars(t.chars), this.renderer.globalData.fontManager.addFonts(t.fonts, this.renderer.globalData.defs)), t.assets) for (r = t.assets.length, e = 0; e < r; e += 1)this.animationData.assets.push(t.assets[e]); this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete) }, AnimationItem.prototype.onSegmentComplete = function (t) { this.animationData = t; var e = getExpressionsPlugin(); e && e.initExpressions(this), this.loadNextSegment() }, AnimationItem.prototype.loadNextSegment = function () { var t = this.animationData.segments; if (!t || 0 === t.length || !this.autoloadSegments) return this.trigger("data_ready"), void (this.timeCompleted = this.totalFrames); var e = t.shift(); this.timeCompleted = e.time * this.frameRate; var n = this.path + this.fileName + "_" + this.segmentPos + ".json"; this.segmentPos += 1, dataManager.loadData(n, this.includeLayers.bind(this), function () { this.trigger("data_failed") }.bind(this)) }, AnimationItem.prototype.loadSegments = function () { this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment() }, AnimationItem.prototype.imagesLoaded = function () { this.trigger("loaded_images"), this.checkLoaded() }, AnimationItem.prototype.preloadImages = function () { this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this)) }, AnimationItem.prototype.configAnimation = function (t) { if (this.renderer) try { this.animationData = t, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(t), t.assets || (t.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(t.assets), this.markers = markerParser(t.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause() } catch (t) { this.triggerConfigError(t) } }, AnimationItem.prototype.waitForFontsLoaded = function () { this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20)) }, AnimationItem.prototype.checkLoaded = function () { if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || "canvas" !== this.renderer.rendererType) && this.imagePreloader.loadedFootages()) { this.isLoaded = !0; var t = getExpressionsPlugin(); t && t.initExpressions(this), this.renderer.initItems(), setTimeout(function () { this.trigger("DOMLoaded") }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play() } }, AnimationItem.prototype.resize = function (t, e) { var n = "number" == typeof t ? t : void 0, i = "number" == typeof e ? e : void 0; this.renderer.updateContainerSize(n, i) }, AnimationItem.prototype.setSubframe = function (t) { this.isSubframeEnabled = !!t }, AnimationItem.prototype.gotoFrame = function () { this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame") }, AnimationItem.prototype.renderFrame = function () { if (!1 !== this.isLoaded && this.renderer) try { this.renderer.renderFrame(this.currentFrame + this.firstFrame) } catch (t) { this.triggerRenderFrameError(t) } }, AnimationItem.prototype.play = function (t) { t && this.name !== t || !0 === this.isPaused && (this.isPaused = !1, this.trigger("_pause"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active"))) }, AnimationItem.prototype.pause = function (t) { t && this.name !== t || !1 === this.isPaused && (this.isPaused = !0, this.trigger("_play"), this._idle = !0, this.trigger("_idle"), this.audioController.pause()) }, AnimationItem.prototype.togglePause = function (t) { t && this.name !== t || (!0 === this.isPaused ? this.play() : this.pause()) }, AnimationItem.prototype.stop = function (t) { t && this.name !== t || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0)) }, AnimationItem.prototype.getMarkerData = function (t) { for (var e, n = 0; n < this.markers.length; n += 1)if ((e = this.markers[n]).payload && e.payload.name === t) return e; return null }, AnimationItem.prototype.goToAndStop = function (t, e, n) { if (!n || this.name === n) { var i = Number(t); if (isNaN(i)) { var r = this.getMarkerData(t); r && this.goToAndStop(r.time, !0) } else e ? this.setCurrentRawFrameValue(t) : this.setCurrentRawFrameValue(t * this.frameModifier); this.pause() } }, AnimationItem.prototype.goToAndPlay = function (t, e, n) { if (!n || this.name === n) { var i = Number(t); if (isNaN(i)) { var r = this.getMarkerData(t); r && (r.duration ? this.playSegments([r.time, r.time + r.duration], !0) : this.goToAndStop(r.time, !0)) } else this.goToAndStop(i, e, n); this.play() } }, AnimationItem.prototype.advanceTime = function (t) { if (!0 !== this.isPaused && !1 !== this.isLoaded) { var e = this.currentRawFrame + t * this.frameModifier, n = !1; e >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? e >= this.totalFrames ? (this.playCount += 1, this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(e) : this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (n = !0, e = this.totalFrames - 1) : e < 0 ? this.checkSegments(e % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (n = !0, e = 0) : (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(e), n && (this.setCurrentRawFrameValue(e), this.pause(), this.trigger("complete")) } }, AnimationItem.prototype.adjustSegment = function (t, e) { this.playCount = 0, t[1] < t[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = t[0] - t[1], this.timeCompleted = this.totalFrames, this.firstFrame = t[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - e)) : t[1] > t[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = t[1] - t[0], this.timeCompleted = this.totalFrames, this.firstFrame = t[0], this.setCurrentRawFrameValue(.001 + e)), this.trigger("segmentStart") }, AnimationItem.prototype.setSegment = function (t, e) { var n = -1; this.isPaused && (this.currentRawFrame + this.firstFrame < t ? n = t : this.currentRawFrame + this.firstFrame > e && (n = e - t)), this.firstFrame = t, this.totalFrames = e - t, this.timeCompleted = this.totalFrames, -1 !== n && this.goToAndStop(n, !0) }, AnimationItem.prototype.playSegments = function (t, e) { if (e && (this.segments.length = 0), "object" === _typeof$4(t[0])) { var n, i = t.length; for (n = 0; n < i; n += 1)this.segments.push(t[n]) } else this.segments.push(t); this.segments.length && e && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play() }, AnimationItem.prototype.resetSegments = function (t) { this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), t && this.checkSegments(0) }, AnimationItem.prototype.checkSegments = function (t) { return !!this.segments.length && (this.adjustSegment(this.segments.shift(), t), !0) }, AnimationItem.prototype.destroy = function (t) { t && this.name !== t || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.renderer = null, this.imagePreloader = null, this.projectInterface = null) }, AnimationItem.prototype.setCurrentRawFrameValue = function (t) { this.currentRawFrame = t, this.gotoFrame() }, AnimationItem.prototype.setSpeed = function (t) { this.playSpeed = t, this.updaFrameModifier() }, AnimationItem.prototype.setDirection = function (t) { this.playDirection = t < 0 ? -1 : 1, this.updaFrameModifier() }, AnimationItem.prototype.setLoop = function (t) { this.loop = t }, AnimationItem.prototype.setVolume = function (t, e) { e && this.name !== e || this.audioController.setVolume(t) }, AnimationItem.prototype.getVolume = function () { return this.audioController.getVolume() }, AnimationItem.prototype.mute = function (t) { t && this.name !== t || this.audioController.mute() }, AnimationItem.prototype.unmute = function (t) { t && this.name !== t || this.audioController.unmute() }, AnimationItem.prototype.updaFrameModifier = function () { this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection) }, AnimationItem.prototype.getPath = function () { return this.path }, AnimationItem.prototype.getAssetsPath = function (t) { var e = ""; if (t.e) e = t.p; else if (this.assetsPath) { var n = t.p; -1 !== n.indexOf("images/") && (n = n.split("/")[1]), e = this.assetsPath + n } else e = this.path, e += t.u ? t.u : "", e += t.p; return e }, AnimationItem.prototype.getAssetData = function (t) { for (var e = 0, n = this.assets.length; e < n;) { if (t === this.assets[e].id) return this.assets[e]; e += 1 } return null }, AnimationItem.prototype.hide = function () { this.renderer.hide() }, AnimationItem.prototype.show = function () { this.renderer.show() }, AnimationItem.prototype.getDuration = function (t) { return t ? this.totalFrames : this.totalFrames / this.frameRate }, AnimationItem.prototype.updateDocumentData = function (t, e, n) { try { this.renderer.getElementByPath(t).updateDocumentData(e, n) } catch (t) { } }, AnimationItem.prototype.trigger = function (t) { if (this._cbs && this._cbs[t]) switch (t) { case "enterFrame": this.triggerEvent(t, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameModifier)); break; case "drawnFrame": this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(t, this.drawnFrameEvent); break; case "loopComplete": this.triggerEvent(t, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)); break; case "complete": this.triggerEvent(t, new BMCompleteEvent(t, this.frameMult)); break; case "segmentStart": this.triggerEvent(t, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)); break; case "destroy": this.triggerEvent(t, new BMDestroyEvent(t, this)); break; default: this.triggerEvent(t) }"enterFrame" === t && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameMult)), "loopComplete" === t && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)), "complete" === t && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(t, this.frameMult)), "segmentStart" === t && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)), "destroy" === t && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(t, this)) }, AnimationItem.prototype.triggerRenderFrameError = function (t) { var e = new BMRenderFrameErrorEvent(t, this.currentFrame); this.triggerEvent("error", e), this.onError && this.onError.call(this, e) }, AnimationItem.prototype.triggerConfigError = function (t) { var e = new BMConfigErrorEvent(t, this.currentFrame); this.triggerEvent("error", e), this.onError && this.onError.call(this, e) }; var animationManager = function () { var t = {}, e = [], n = 0, i = 0, r = 0, s = !0, o = !1; function a(t) { for (var n = 0, r = t.target; n < i;)e[n].animation === r && (e.splice(n, 1), n -= 1, i -= 1, r.isPaused || c()), n += 1 } function l(t, n) { if (!t) return null; for (var r = 0; r < i;) { if (e[r].elem === t && null !== e[r].elem) return e[r].animation; r += 1 } var s = new AnimationItem; return u(s, t), s.setData(t, n), s } function h() { r += 1, f() } function c() { r -= 1 } function u(t, n) { t.addEventListener("destroy", a), t.addEventListener("_active", h), t.addEventListener("_idle", c), e.push({ elem: n, animation: t }), i += 1 } function d(t) { var a, l = t - n; for (a = 0; a < i; a += 1)e[a].animation.advanceTime(l); n = t, r && !o ? window.requestAnimationFrame(d) : s = !0 } function p(t) { n = t, window.requestAnimationFrame(d) } function f() { !o && r && s && (window.requestAnimationFrame(p), s = !1) } return t.registerAnimation = l, t.loadAnimation = function (t) { var e = new AnimationItem; return u(e, null), e.setParams(t), e }, t.setSpeed = function (t, n) { var r; for (r = 0; r < i; r += 1)e[r].animation.setSpeed(t, n) }, t.setDirection = function (t, n) { var r; for (r = 0; r < i; r += 1)e[r].animation.setDirection(t, n) }, t.play = function (t) { var n; for (n = 0; n < i; n += 1)e[n].animation.play(t) }, t.pause = function (t) { var n; for (n = 0; n < i; n += 1)e[n].animation.pause(t) }, t.stop = function (t) { var n; for (n = 0; n < i; n += 1)e[n].animation.stop(t) }, t.togglePause = function (t) { var n; for (n = 0; n < i; n += 1)e[n].animation.togglePause(t) }, t.searchAnimations = function (t, e, n) { var i, r = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), s = r.length; for (i = 0; i < s; i += 1)n && r[i].setAttribute("data-bm-type", n), l(r[i], t); if (e && 0 === s) { n || (n = "svg"); var o = document.getElementsByTagName("body")[0]; o.innerText = ""; var a = createTag("div"); a.style.width = "100%", a.style.height = "100%", a.setAttribute("data-bm-type", n), o.appendChild(a), l(a, t) } }, t.resize = function () { var t; for (t = 0; t < i; t += 1)e[t].animation.resize() }, t.goToAndStop = function (t, n, r) { var s; for (s = 0; s < i; s += 1)e[s].animation.goToAndStop(t, n, r) }, t.destroy = function (t) { var n; for (n = i - 1; n >= 0; n -= 1)e[n].animation.destroy(t) }, t.freeze = function () { o = !0 }, t.unfreeze = function () { o = !1, f() }, t.setVolume = function (t, n) { var r; for (r = 0; r < i; r += 1)e[r].animation.setVolume(t, n) }, t.mute = function (t) { var n; for (n = 0; n < i; n += 1)e[n].animation.mute(t) }, t.unmute = function (t) { var n; for (n = 0; n < i; n += 1)e[n].animation.unmute(t) }, t.getRegisteredAnimations = function () { var t, n = e.length, i = []; for (t = 0; t < n; t += 1)i.push(e[t].animation); return i }, t }(), BezierFactory = function () { var t = { getBezierEasing: function (t, n, i, r, s) { var o = s || ("bez_" + t + "_" + n + "_" + i + "_" + r).replace(/\./g, "p"); if (e[o]) return e[o]; var a = new p([t, n, i, r]); return e[o] = a, a } }, e = {}, n = 4, i = 1e-7, r = 10, s = 11, o = 1 / (s - 1), a = "function" == typeof Float32Array; function l(t, e) { return 1 - 3 * e + 3 * t } function h(t, e) { return 3 * e - 6 * t } function c(t) { return 3 * t } function u(t, e, n) { return ((l(e, n) * t + h(e, n)) * t + c(e)) * t } function d(t, e, n) { return 3 * l(e, n) * t * t + 2 * h(e, n) * t + c(e) } function p(t) { this._p = t, this._mSampleValues = a ? new Float32Array(s) : new Array(s), this._precomputed = !1, this.get = this.get.bind(this) } return p.prototype = { get: function (t) { var e = this._p[0], n = this._p[1], i = this._p[2], r = this._p[3]; return this._precomputed || this._precompute(), e === n && i === r ? t : 0 === t ? 0 : 1 === t ? 1 : u(this._getTForX(t), n, r) }, _precompute: function () { var t = this._p[0], e = this._p[1], n = this._p[2], i = this._p[3]; this._precomputed = !0, t === e && n === i || this._calcSampleValues() }, _calcSampleValues: function () { for (var t = this._p[0], e = this._p[2], n = 0; n < s; ++n)this._mSampleValues[n] = u(n * o, t, e) }, _getTForX: function (t) { for (var e = this._p[0], a = this._p[2], l = this._mSampleValues, h = 0, c = 1, p = s - 1; c !== p && l[c] <= t; ++c)h += o; var f = h + (t - l[--c]) / (l[c + 1] - l[c]) * o, m = d(f, e, a); return m >= .001 ? function (t, e, i, r) { for (var s = 0; s < n; ++s) { var o = d(e, i, r); if (0 === o) return e; e -= (u(e, i, r) - t) / o } return e }(t, f, e, a) : 0 === m ? f : function (t, e, n, s, o) { var a, l, h = 0; do { (a = u(l = e + (n - e) / 2, s, o) - t) > 0 ? n = l : e = l } while (Math.abs(a) > i && ++h < r); return l }(t, h, h + o, e, a) } }, t }(), pooling = { double: function (t) { return t.concat(createSizedArray(t.length)) } }, poolFactory = function (t, e, n) { var i = 0, r = t, s = createSizedArray(r); return { newElement: function () { return i ? s[i -= 1] : e() }, release: function (t) { i === r && (s = pooling.double(s), r *= 2), n && n(t), s[i] = t, i += 1 } } }, bezierLengthPool = poolFactory(8, (function () { return { addedLength: 0, percents: createTypedArray("float32", getDefaultCurveSegments()), lengths: createTypedArray("float32", getDefaultCurveSegments()) } })), segmentsLengthPool = poolFactory(8, (function () { return { lengths: [], totalLength: 0 } }), (function (t) { var e, n = t.lengths.length; for (e = 0; e < n; e += 1)bezierLengthPool.release(t.lengths[e]); t.lengths.length = 0 })); function bezFunction() { var t = Math; function e(t, e, n, i, r, s) { var o = t * i + e * r + n * s - r * i - s * t - n * e; return o > -.001 && o < .001 } var n = function (t, e, n, i) { var r, s, o, a, l, h, c = getDefaultCurveSegments(), u = 0, d = [], p = [], f = bezierLengthPool.newElement(); for (o = n.length, r = 0; r < c; r += 1) { for (l = r / (c - 1), h = 0, s = 0; s < o; s += 1)a = bmPow(1 - l, 3) * t[s] + 3 * bmPow(1 - l, 2) * l * n[s] + 3 * (1 - l) * bmPow(l, 2) * i[s] + bmPow(l, 3) * e[s], d[s] = a, null !== p[s] && (h += bmPow(d[s] - p[s], 2)), p[s] = d[s]; h && (u += h = bmSqrt(h)), f.percents[r] = l, f.lengths[r] = u } return f.addedLength = u, f }; function i(t) { this.segmentLength = 0, this.points = new Array(t) } function r(t, e) { this.partialLength = t, this.point = e } var s, o = (s = {}, function (t, n, o, a) { var l = (t[0] + "_" + t[1] + "_" + n[0] + "_" + n[1] + "_" + o[0] + "_" + o[1] + "_" + a[0] + "_" + a[1]).replace(/\./g, "p"); if (!s[l]) { var h, c, u, d, p, f, m, g = getDefaultCurveSegments(), v = 0, A = null; 2 === t.length && (t[0] !== n[0] || t[1] !== n[1]) && e(t[0], t[1], n[0], n[1], t[0] + o[0], t[1] + o[1]) && e(t[0], t[1], n[0], n[1], n[0] + a[0], n[1] + a[1]) && (g = 2); var b = new i(g); for (u = o.length, h = 0; h < g; h += 1) { for (m = createSizedArray(u), p = h / (g - 1), f = 0, c = 0; c < u; c += 1)d = bmPow(1 - p, 3) * t[c] + 3 * bmPow(1 - p, 2) * p * (t[c] + o[c]) + 3 * (1 - p) * bmPow(p, 2) * (n[c] + a[c]) + bmPow(p, 3) * n[c], m[c] = d, null !== A && (f += bmPow(m[c] - A[c], 2)); v += f = bmSqrt(f), b.points[h] = new r(f, m), A = m } b.segmentLength = v, s[l] = b } return s[l] }); function a(t, e) { var n = e.percents, i = e.lengths, r = n.length, s = bmFloor((r - 1) * t), o = t * e.addedLength, a = 0; if (s === r - 1 || 0 === s || o === i[s]) return n[s]; for (var l = i[s] > o ? -1 : 1, h = !0; h;)if (i[s] <= o && i[s + 1] > o ? (a = (o - i[s]) / (i[s + 1] - i[s]), h = !1) : s += l, s < 0 || s >= r - 1) { if (s === r - 1) return n[s]; h = !1 } return n[s] + (n[s + 1] - n[s]) * a } var l = createTypedArray("float32", 8); return { getSegmentsLength: function (t) { var e, i = segmentsLengthPool.newElement(), r = t.c, s = t.v, o = t.o, a = t.i, l = t._length, h = i.lengths, c = 0; for (e = 0; e < l - 1; e += 1)h[e] = n(s[e], s[e + 1], o[e], a[e + 1]), c += h[e].addedLength; return r && l && (h[e] = n(s[e], s[0], o[e], a[0]), c += h[e].addedLength), i.totalLength = c, i }, getNewSegment: function (e, n, i, r, s, o, h) { s < 0 ? s = 0 : s > 1 && (s = 1); var c, u = a(s, h), d = a(o = o > 1 ? 1 : o, h), p = e.length, f = 1 - u, m = 1 - d, g = f * f * f, v = u * f * f * 3, A = u * u * f * 3, b = u * u * u, y = f * f * m, x = u * f * m + f * u * m + f * f * d, _ = u * u * m + f * u * d + u * f * d, w = u * u * d, E = f * m * m, C = u * m * m + f * d * m + f * m * d, S = u * d * m + f * d * d + u * m * d, M = u * d * d, P = m * m * m, I = d * m * m + m * d * m + m * m * d, T = d * d * m + m * d * d + d * m * d, D = d * d * d; for (c = 0; c < p; c += 1)l[4 * c] = t.round(1e3 * (g * e[c] + v * i[c] + A * r[c] + b * n[c])) / 1e3, l[4 * c + 1] = t.round(1e3 * (y * e[c] + x * i[c] + _ * r[c] + w * n[c])) / 1e3, l[4 * c + 2] = t.round(1e3 * (E * e[c] + C * i[c] + S * r[c] + M * n[c])) / 1e3, l[4 * c + 3] = t.round(1e3 * (P * e[c] + I * i[c] + T * r[c] + D * n[c])) / 1e3; return l }, getPointInSegment: function (e, n, i, r, s, o) { var l = a(s, o), h = 1 - l; return [t.round(1e3 * (h * h * h * e[0] + (l * h * h + h * l * h + h * h * l) * i[0] + (l * l * h + h * l * l + l * h * l) * r[0] + l * l * l * n[0])) / 1e3, t.round(1e3 * (h * h * h * e[1] + (l * h * h + h * l * h + h * h * l) * i[1] + (l * l * h + h * l * l + l * h * l) * r[1] + l * l * l * n[1])) / 1e3] }, buildBezierData: o, pointOnLine2D: e, pointOnLine3D: function (n, i, r, s, o, a, l, h, c) { if (0 === r && 0 === a && 0 === c) return e(n, i, s, o, l, h); var u, d = t.sqrt(t.pow(s - n, 2) + t.pow(o - i, 2) + t.pow(a - r, 2)), p = t.sqrt(t.pow(l - n, 2) + t.pow(h - i, 2) + t.pow(c - r, 2)), f = t.sqrt(t.pow(l - s, 2) + t.pow(h - o, 2) + t.pow(c - a, 2)); return (u = d > p ? d > f ? d - p - f : f - p - d : f > p ? f - p - d : p - d - f) > -1e-4 && u < 1e-4 } } } var bez = bezFunction(), PropertyFactory = function () { var t = initialDefaultFrame, e = Math.abs; function n(t, e) { var n, r = this.offsetTime; "multidimensional" === this.propType && (n = createTypedArray("float32", this.pv.length)); for (var s, o, a, l, h, c, u, d, p, f = e.lastIndex, m = f, g = this.keyframes.length - 1, v = !0; v;) { if (s = this.keyframes[m], o = this.keyframes[m + 1], m === g - 1 && t >= o.t - r) { s.h && (s = o), f = 0; break } if (o.t - r > t) { f = m; break } m < g - 1 ? m += 1 : (f = 0, v = !1) } a = this.keyframesMetadata[m] || {}; var A, b, y, x, _, w, E, C, S, M, P = o.t - r, I = s.t - r; if (s.to) { a.bezierData || (a.bezierData = bez.buildBezierData(s.s, o.s || s.e, s.to, s.ti)); var T = a.bezierData; if (t >= P || t < I) { var D = t >= P ? T.points.length - 1 : 0; for (h = T.points[D].point.length, l = 0; l < h; l += 1)n[l] = T.points[D].point[l] } else { a.__fnct ? p = a.__fnct : (p = BezierFactory.getBezierEasing(s.o.x, s.o.y, s.i.x, s.i.y, s.n).get, a.__fnct = p), c = p((t - I) / (P - I)); var B, L = T.segmentLength * c, F = e.lastFrame < t && e._lastKeyframeIndex === m ? e._lastAddedLength : 0; for (d = e.lastFrame < t && e._lastKeyframeIndex === m ? e._lastPoint : 0, v = !0, u = T.points.length; v;) { if (F += T.points[d].partialLength, 0 === L || 0 === c || d === T.points.length - 1) { for (h = T.points[d].point.length, l = 0; l < h; l += 1)n[l] = T.points[d].point[l]; break } if (L >= F && L < F + T.points[d + 1].partialLength) { for (B = (L - F) / T.points[d + 1].partialLength, h = T.points[d].point.length, l = 0; l < h; l += 1)n[l] = T.points[d].point[l] + (T.points[d + 1].point[l] - T.points[d].point[l]) * B; break } d < u - 1 ? d += 1 : v = !1 } e._lastPoint = d, e._lastAddedLength = F - T.points[d].partialLength, e._lastKeyframeIndex = m } } else { var k, R, O, N, U; if (g = s.s.length, A = o.s || s.e, this.sh && 1 !== s.h) if (t >= P) n[0] = A[0], n[1] = A[1], n[2] = A[2]; else if (t <= I) n[0] = s.s[0], n[1] = s.s[1], n[2] = s.s[2]; else { var z = i(s.s), V = i(A); b = n, y = function (t, e, n) { var i, r, s, o, a, l = [], h = t[0], c = t[1], u = t[2], d = t[3], p = e[0], f = e[1], m = e[2], g = e[3]; return (r = h * p + c * f + u * m + d * g) < 0 && (r = -r, p = -p, f = -f, m = -m, g = -g), 1 - r > 1e-6 ? (i = Math.acos(r), s = Math.sin(i), o = Math.sin((1 - n) * i) / s, a = Math.sin(n * i) / s) : (o = 1 - n, a = n), l[0] = o * h + a * p, l[1] = o * c + a * f, l[2] = o * u + a * m, l[3] = o * d + a * g, l }(z, V, (t - I) / (P - I)), x = y[0], _ = y[1], w = y[2], E = y[3], C = Math.atan2(2 * _ * E - 2 * x * w, 1 - 2 * _ * _ - 2 * w * w), S = Math.asin(2 * x * _ + 2 * w * E), M = Math.atan2(2 * x * E - 2 * _ * w, 1 - 2 * x * x - 2 * w * w), b[0] = C / degToRads, b[1] = S / degToRads, b[2] = M / degToRads } else for (m = 0; m < g; m += 1)1 !== s.h && (t >= P ? c = 1 : t < I ? c = 0 : (s.o.x.constructor === Array ? (a.__fnct || (a.__fnct = []), a.__fnct[m] ? p = a.__fnct[m] : (k = void 0 === s.o.x[m] ? s.o.x[0] : s.o.x[m], R = void 0 === s.o.y[m] ? s.o.y[0] : s.o.y[m], O = void 0 === s.i.x[m] ? s.i.x[0] : s.i.x[m], N = void 0 === s.i.y[m] ? s.i.y[0] : s.i.y[m], p = BezierFactory.getBezierEasing(k, R, O, N).get, a.__fnct[m] = p)) : a.__fnct ? p = a.__fnct : (k = s.o.x, R = s.o.y, O = s.i.x, N = s.i.y, p = BezierFactory.getBezierEasing(k, R, O, N).get, s.keyframeMetadata = p), c = p((t - I) / (P - I)))), A = o.s || s.e, U = 1 === s.h ? s.s[m] : s.s[m] + (A[m] - s.s[m]) * c, "multidimensional" === this.propType ? n[m] = U : n = U } return e.lastIndex = f, n } function i(t) { var e = t[0] * degToRads, n = t[1] * degToRads, i = t[2] * degToRads, r = Math.cos(e / 2), s = Math.cos(n / 2), o = Math.cos(i / 2), a = Math.sin(e / 2), l = Math.sin(n / 2), h = Math.sin(i / 2); return [a * l * o + r * s * h, a * s * o + r * l * h, r * l * o - a * s * h, r * s * o - a * l * h] } function r() { var e = this.comp.renderedFrame - this.offsetTime, n = this.keyframes[0].t - this.offsetTime, i = this.keyframes[this.keyframes.length - 1].t - this.offsetTime; if (!(e === this._caching.lastFrame || this._caching.lastFrame !== t && (this._caching.lastFrame >= i && e >= i || this._caching.lastFrame < n && e < n))) { this._caching.lastFrame >= e && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0); var r = this.interpolateValue(e, this._caching); this.pv = r } return this._caching.lastFrame = e, this.pv } function s(t) { var n; if ("unidimensional" === this.propType) n = t * this.mult, e(this.v - n) > 1e-5 && (this.v = n, this._mdf = !0); else for (var i = 0, r = this.v.length; i < r;)n = t[i] * this.mult, e(this.v[i] - n) > 1e-5 && (this.v[i] = n, this._mdf = !0), i += 1 } function o() { if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length) if (this.lock) this.setVValue(this.pv); else { var t; this.lock = !0, this._mdf = this._isFirstFrame; var e = this.effectsSequence.length, n = this.kf ? this.pv : this.data.k; for (t = 0; t < e; t += 1)n = this.effectsSequence[t](n); this.setVValue(n), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId } } function a(t) { this.effectsSequence.push(t), this.container.addDynamicProperty(this) } function l(t, e, n, i) { this.propType = "unidimensional", this.mult = n || 1, this.data = e, this.v = n ? e.k * n : e.k, this.pv = e.k, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = o, this.setVValue = s, this.addEffect = a } function h(t, e, n, i) { var r; this.propType = "multidimensional", this.mult = n || 1, this.data = e, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.frameId = -1; var l = e.k.length; for (this.v = createTypedArray("float32", l), this.pv = createTypedArray("float32", l), this.vel = createTypedArray("float32", l), r = 0; r < l; r += 1)this.v[r] = e.k[r] * this.mult, this.pv[r] = e.k[r]; this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = o, this.setVValue = s, this.addEffect = a } function c(e, i, l, h) { this.propType = "unidimensional", this.keyframes = i.k, this.keyframesMetadata = [], this.offsetTime = e.data.st, this.frameId = -1, this._caching = { lastFrame: t, lastIndex: 0, value: 0, _lastKeyframeIndex: -1 }, this.k = !0, this.kf = !0, this.data = i, this.mult = l || 1, this.elem = e, this.container = h, this.comp = e.comp, this.v = t, this.pv = t, this._isFirstFrame = !0, this.getValue = o, this.setVValue = s, this.interpolateValue = n, this.effectsSequence = [r.bind(this)], this.addEffect = a } function u(e, i, l, h) { var c; this.propType = "multidimensional"; var u, d, p, f, m = i.k.length; for (c = 0; c < m - 1; c += 1)i.k[c].to && i.k[c].s && i.k[c + 1] && i.k[c + 1].s && (u = i.k[c].s, d = i.k[c + 1].s, p = i.k[c].to, f = i.k[c].ti, (2 === u.length && (u[0] !== d[0] || u[1] !== d[1]) && bez.pointOnLine2D(u[0], u[1], d[0], d[1], u[0] + p[0], u[1] + p[1]) && bez.pointOnLine2D(u[0], u[1], d[0], d[1], d[0] + f[0], d[1] + f[1]) || 3 === u.length && (u[0] !== d[0] || u[1] !== d[1] || u[2] !== d[2]) && bez.pointOnLine3D(u[0], u[1], u[2], d[0], d[1], d[2], u[0] + p[0], u[1] + p[1], u[2] + p[2]) && bez.pointOnLine3D(u[0], u[1], u[2], d[0], d[1], d[2], d[0] + f[0], d[1] + f[1], d[2] + f[2])) && (i.k[c].to = null, i.k[c].ti = null), u[0] === d[0] && u[1] === d[1] && 0 === p[0] && 0 === p[1] && 0 === f[0] && 0 === f[1] && (2 === u.length || u[2] === d[2] && 0 === p[2] && 0 === f[2]) && (i.k[c].to = null, i.k[c].ti = null)); this.effectsSequence = [r.bind(this)], this.data = i, this.keyframes = i.k, this.keyframesMetadata = [], this.offsetTime = e.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = l || 1, this.elem = e, this.container = h, this.comp = e.comp, this.getValue = o, this.setVValue = s, this.interpolateValue = n, this.frameId = -1; var g = i.k[0].s.length; for (this.v = createTypedArray("float32", g), this.pv = createTypedArray("float32", g), c = 0; c < g; c += 1)this.v[c] = t, this.pv[c] = t; this._caching = { lastFrame: t, lastIndex: 0, value: createTypedArray("float32", g) }, this.addEffect = a } return { getProp: function (t, e, n, i, r) { var s; if (e.k.length) if ("number" == typeof e.k[0]) s = new h(t, e, i, r); else switch (n) { case 0: s = new c(t, e, i, r); break; case 1: s = new u(t, e, i, r) } else s = new l(t, e, i, r); return s.effectsSequence.length && r.addDynamicProperty(s), s } } }(); function DynamicPropertyContainer() { } DynamicPropertyContainer.prototype = { addDynamicProperty: function (t) { -1 === this.dynamicProperties.indexOf(t) && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0) }, iterateDynamicProperties: function () { var t; this._mdf = !1; var e = this.dynamicProperties.length; for (t = 0; t < e; t += 1)this.dynamicProperties[t].getValue(), this.dynamicProperties[t]._mdf && (this._mdf = !0) }, initDynamicPropertyContainer: function (t) { this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1 } }; var pointPool = poolFactory(8, (function () { return createTypedArray("float32", 2) })); function ShapePath() { this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength) } ShapePath.prototype.setPathData = function (t, e) { this.c = t, this.setLength(e); for (var n = 0; n < e;)this.v[n] = pointPool.newElement(), this.o[n] = pointPool.newElement(), this.i[n] = pointPool.newElement(), n += 1 }, ShapePath.prototype.setLength = function (t) { for (; this._maxLength < t;)this.doubleArrayLength(); this._length = t }, ShapePath.prototype.doubleArrayLength = function () { this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2 }, ShapePath.prototype.setXYAt = function (t, e, n, i, r) { var s; switch (this._length = Math.max(this._length, i + 1), this._length >= this._maxLength && this.doubleArrayLength(), n) { case "v": s = this.v; break; case "i": s = this.i; break; case "o": s = this.o; break; default: s = [] }(!s[i] || s[i] && !r) && (s[i] = pointPool.newElement()), s[i][0] = t, s[i][1] = e }, ShapePath.prototype.setTripleAt = function (t, e, n, i, r, s, o, a) { this.setXYAt(t, e, "v", o, a), this.setXYAt(n, i, "o", o, a), this.setXYAt(r, s, "i", o, a) }, ShapePath.prototype.reverse = function () { var t = new ShapePath; t.setPathData(this.c, this._length); var e = this.v, n = this.o, i = this.i, r = 0; this.c && (t.setTripleAt(e[0][0], e[0][1], i[0][0], i[0][1], n[0][0], n[0][1], 0, !1), r = 1); var s, o = this._length - 1, a = this._length; for (s = r; s < a; s += 1)t.setTripleAt(e[o][0], e[o][1], i[o][0], i[o][1], n[o][0], n[o][1], s, !1), o -= 1; return t }, ShapePath.prototype.length = function () { return this._length }; var shapePool = (factory = poolFactory(4, (function () { return new ShapePath }), (function (t) { var e, n = t._length; for (e = 0; e < n; e += 1)pointPool.release(t.v[e]), pointPool.release(t.i[e]), pointPool.release(t.o[e]), t.v[e] = null, t.i[e] = null, t.o[e] = null; t._length = 0, t.c = !1 })), factory.clone = function (t) { var e, n = factory.newElement(), i = void 0 === t._length ? t.v.length : t._length; for (n.setLength(i), n.c = t.c, e = 0; e < i; e += 1)n.setTripleAt(t.v[e][0], t.v[e][1], t.o[e][0], t.o[e][1], t.i[e][0], t.i[e][1], e); return n }, factory), factory; function ShapeCollection() { this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength) } ShapeCollection.prototype.addShape = function (t) { this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = t, this._length += 1 }, ShapeCollection.prototype.releaseShapes = function () { var t; for (t = 0; t < this._length; t += 1)shapePool.release(this.shapes[t]); this._length = 0 }; var shapeCollectionPool = (ob = { newShapeCollection: function () { return _length ? pool[_length -= 1] : new ShapeCollection }, release: function (t) { var e, n = t._length; for (e = 0; e < n; e += 1)shapePool.release(t.shapes[e]); t._length = 0, _length === _maxLength && (pool = pooling.double(pool), _maxLength *= 2), pool[_length] = t, _length += 1 } }, _length = 0, _maxLength = 4, pool = createSizedArray(_maxLength), ob), ob, _length, _maxLength, pool, ShapePropertyFactory = function () { var t = -999999; function e(t, e, n) { var i, r, s, o, a, l, h, c, u, d = n.lastIndex, p = this.keyframes; if (t < p[0].t - this.offsetTime) i = p[0].s[0], s = !0, d = 0; else if (t >= p[p.length - 1].t - this.offsetTime) i = p[p.length - 1].s ? p[p.length - 1].s[0] : p[p.length - 2].e[0], s = !0; else { for (var f, m, g, v = d, A = p.length - 1, b = !0; b && (f = p[v], !((m = p[v + 1]).t - this.offsetTime > t));)v < A - 1 ? v += 1 : b = !1; if (g = this.keyframesMetadata[v] || {}, d = v, !(s = 1 === f.h)) { if (t >= m.t - this.offsetTime) c = 1; else if (t < f.t - this.offsetTime) c = 0; else { var y; g.__fnct ? y = g.__fnct : (y = BezierFactory.getBezierEasing(f.o.x, f.o.y, f.i.x, f.i.y).get, g.__fnct = y), c = y((t - (f.t - this.offsetTime)) / (m.t - this.offsetTime - (f.t - this.offsetTime))) } r = m.s ? m.s[0] : f.e[0] } i = f.s[0] } for (l = e._length, h = i.i[0].length, n.lastIndex = d, o = 0; o < l; o += 1)for (a = 0; a < h; a += 1)u = s ? i.i[o][a] : i.i[o][a] + (r.i[o][a] - i.i[o][a]) * c, e.i[o][a] = u, u = s ? i.o[o][a] : i.o[o][a] + (r.o[o][a] - i.o[o][a]) * c, e.o[o][a] = u, u = s ? i.v[o][a] : i.v[o][a] + (r.v[o][a] - i.v[o][a]) * c, e.v[o][a] = u } function n() { var e = this.comp.renderedFrame - this.offsetTime, n = this.keyframes[0].t - this.offsetTime, i = this.keyframes[this.keyframes.length - 1].t - this.offsetTime, r = this._caching.lastFrame; return r !== t && (r < n && e < n || r > i && e > i) || (this._caching.lastIndex = r < e ? this._caching.lastIndex : 0, this.interpolateShape(e, this.pv, this._caching)), this._caching.lastFrame = e, this.pv } function i() { this.paths = this.localShapeCollection } function r(t) { (function (t, e) { if (t._length !== e._length || t.c !== e.c) return !1; var n, i = t._length; for (n = 0; n < i; n += 1)if (t.v[n][0] !== e.v[n][0] || t.v[n][1] !== e.v[n][1] || t.o[n][0] !== e.o[n][0] || t.o[n][1] !== e.o[n][1] || t.i[n][0] !== e.i[n][0] || t.i[n][1] !== e.i[n][1]) return !1; return !0 })(this.v, t) || (this.v = shapePool.clone(t), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection) } function s() { if (this.elem.globalData.frameId !== this.frameId) if (this.effectsSequence.length) if (this.lock) this.setVValue(this.pv); else { var t, e; this.lock = !0, this._mdf = !1, t = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k; var n = this.effectsSequence.length; for (e = 0; e < n; e += 1)t = this.effectsSequence[e](t); this.setVValue(t), this.lock = !1, this.frameId = this.elem.globalData.frameId } else this._mdf = !1 } function o(t, e, n) { this.propType = "shape", this.comp = t.comp, this.container = t, this.elem = t, this.data = e, this.k = !1, this.kf = !1, this._mdf = !1; var r = 3 === n ? e.pt.k : e.ks.k; this.v = shapePool.clone(r), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = i, this.effectsSequence = [] } function a(t) { this.effectsSequence.push(t), this.container.addDynamicProperty(this) } function l(e, r, s) { this.propType = "shape", this.comp = e.comp, this.elem = e, this.container = e, this.offsetTime = e.data.st, this.keyframes = 3 === s ? r.pt.k : r.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0; var o = this.keyframes[0].s[0].i.length; this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, o), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = t, this.reset = i, this._caching = { lastFrame: t, lastIndex: 0 }, this.effectsSequence = [n.bind(this)] } o.prototype.interpolateShape = e, o.prototype.getValue = s, o.prototype.setVValue = r, o.prototype.addEffect = a, l.prototype.getValue = s, l.prototype.interpolateShape = e, l.prototype.setVValue = r, l.prototype.addEffect = a; var h = function () { var t = roundCorner; function e(t, e) { this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = e.d, this.elem = t, this.comp = t.comp, this.frameId = -1, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath()) } return e.prototype = { reset: i, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath()) }, convertEllToPath: function () { var e = this.p.v[0], n = this.p.v[1], i = this.s.v[0] / 2, r = this.s.v[1] / 2, s = 3 !== this.d, o = this.v; o.v[0][0] = e, o.v[0][1] = n - r, o.v[1][0] = s ? e + i : e - i, o.v[1][1] = n, o.v[2][0] = e, o.v[2][1] = n + r, o.v[3][0] = s ? e - i : e + i, o.v[3][1] = n, o.i[0][0] = s ? e - i * t : e + i * t, o.i[0][1] = n - r, o.i[1][0] = s ? e + i : e - i, o.i[1][1] = n - r * t, o.i[2][0] = s ? e + i * t : e - i * t, o.i[2][1] = n + r, o.i[3][0] = s ? e - i : e + i, o.i[3][1] = n + r * t, o.o[0][0] = s ? e + i * t : e - i * t, o.o[0][1] = n - r, o.o[1][0] = s ? e + i : e - i, o.o[1][1] = n + r * t, o.o[2][0] = s ? e - i * t : e + i * t, o.o[2][1] = n + r, o.o[3][0] = s ? e - i : e + i, o.o[3][1] = n - r * t } }, extendPrototype([DynamicPropertyContainer], e), e }(), c = function () { function t(t, e) { this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = t, this.comp = t.comp, this.data = e, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), 1 === e.sy ? (this.ir = PropertyFactory.getProp(t, e.ir, 0, 0, this), this.is = PropertyFactory.getProp(t, e.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(t, e.pt, 0, 0, this), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, degToRads, this), this.or = PropertyFactory.getProp(t, e.or, 0, 0, this), this.os = PropertyFactory.getProp(t, e.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath()) } return t.prototype = { reset: i, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath()) }, convertStarToPath: function () { var t, e, n, i, r = 2 * Math.floor(this.pt.v), s = 2 * Math.PI / r, o = !0, a = this.or.v, l = this.ir.v, h = this.os.v, c = this.is.v, u = 2 * Math.PI * a / (2 * r), d = 2 * Math.PI * l / (2 * r), p = -Math.PI / 2; p += this.r.v; var f = 3 === this.data.d ? -1 : 1; for (this.v._length = 0, t = 0; t < r; t += 1) { n = o ? h : c, i = o ? u : d; var m = (e = o ? a : l) * Math.cos(p), g = e * Math.sin(p), v = 0 === m && 0 === g ? 0 : g / Math.sqrt(m * m + g * g), A = 0 === m && 0 === g ? 0 : -m / Math.sqrt(m * m + g * g); m += +this.p.v[0], g += +this.p.v[1], this.v.setTripleAt(m, g, m - v * i * n * f, g - A * i * n * f, m + v * i * n * f, g + A * i * n * f, t, !0), o = !o, p += s * f } }, convertPolygonToPath: function () { var t, e = Math.floor(this.pt.v), n = 2 * Math.PI / e, i = this.or.v, r = this.os.v, s = 2 * Math.PI * i / (4 * e), o = .5 * -Math.PI, a = 3 === this.data.d ? -1 : 1; for (o += this.r.v, this.v._length = 0, t = 0; t < e; t += 1) { var l = i * Math.cos(o), h = i * Math.sin(o), c = 0 === l && 0 === h ? 0 : h / Math.sqrt(l * l + h * h), u = 0 === l && 0 === h ? 0 : -l / Math.sqrt(l * l + h * h); l += +this.p.v[0], h += +this.p.v[1], this.v.setTripleAt(l, h, l - c * s * r * a, h - u * s * r * a, l + c * s * r * a, h + u * s * r * a, t, !0), o += n * a } this.paths.length = 0, this.paths[0] = this.v } }, extendPrototype([DynamicPropertyContainer], t), t }(), u = function () { function t(t, e) { this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = t, this.comp = t.comp, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath()) } return t.prototype = { convertRectToPath: function () { var t = this.p.v[0], e = this.p.v[1], n = this.s.v[0] / 2, i = this.s.v[1] / 2, r = bmMin(n, i, this.r.v), s = r * (1 - roundCorner); this.v._length = 0, 2 === this.d || 1 === this.d ? (this.v.setTripleAt(t + n, e - i + r, t + n, e - i + r, t + n, e - i + s, 0, !0), this.v.setTripleAt(t + n, e + i - r, t + n, e + i - s, t + n, e + i - r, 1, !0), 0 !== r ? (this.v.setTripleAt(t + n - r, e + i, t + n - r, e + i, t + n - s, e + i, 2, !0), this.v.setTripleAt(t - n + r, e + i, t - n + s, e + i, t - n + r, e + i, 3, !0), this.v.setTripleAt(t - n, e + i - r, t - n, e + i - r, t - n, e + i - s, 4, !0), this.v.setTripleAt(t - n, e - i + r, t - n, e - i + s, t - n, e - i + r, 5, !0), this.v.setTripleAt(t - n + r, e - i, t - n + r, e - i, t - n + s, e - i, 6, !0), this.v.setTripleAt(t + n - r, e - i, t + n - s, e - i, t + n - r, e - i, 7, !0)) : (this.v.setTripleAt(t - n, e + i, t - n + s, e + i, t - n, e + i, 2), this.v.setTripleAt(t - n, e - i, t - n, e - i + s, t - n, e - i, 3))) : (this.v.setTripleAt(t + n, e - i + r, t + n, e - i + s, t + n, e - i + r, 0, !0), 0 !== r ? (this.v.setTripleAt(t + n - r, e - i, t + n - r, e - i, t + n - s, e - i, 1, !0), this.v.setTripleAt(t - n + r, e - i, t - n + s, e - i, t - n + r, e - i, 2, !0), this.v.setTripleAt(t - n, e - i + r, t - n, e - i + r, t - n, e - i + s, 3, !0), this.v.setTripleAt(t - n, e + i - r, t - n, e + i - s, t - n, e + i - r, 4, !0), this.v.setTripleAt(t - n + r, e + i, t - n + r, e + i, t - n + s, e + i, 5, !0), this.v.setTripleAt(t + n - r, e + i, t + n - s, e + i, t + n - r, e + i, 6, !0), this.v.setTripleAt(t + n, e + i - r, t + n, e + i - r, t + n, e + i - s, 7, !0)) : (this.v.setTripleAt(t - n, e - i, t - n + s, e - i, t - n, e - i, 1, !0), this.v.setTripleAt(t - n, e + i, t - n, e + i - s, t - n, e + i, 2, !0), this.v.setTripleAt(t + n, e + i, t + n - s, e + i, t + n, e + i, 3, !0))) }, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath()) }, reset: i }, extendPrototype([DynamicPropertyContainer], t), t }(), d = { getShapeProp: function (t, e, n) { var i; return 3 === n || 4 === n ? i = (3 === n ? e.pt : e.ks).k.length ? new l(t, e, n) : new o(t, e, n) : 5 === n ? i = new u(t, e) : 6 === n ? i = new h(t, e) : 7 === n && (i = new c(t, e)), i.k && t.addDynamicProperty(i), i }, getConstructorFunction: function () { return o }, getKeyframedConstructorFunction: function () { return l } }; return d }(), Matrix = function () { var t = Math.cos, e = Math.sin, n = Math.tan, i = Math.round; function r() { return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this } function s(n) { if (0 === n) return this; var i = t(n), r = e(n); return this._t(i, -r, 0, 0, r, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function o(n) { if (0 === n) return this; var i = t(n), r = e(n); return this._t(1, 0, 0, 0, 0, i, -r, 0, 0, r, i, 0, 0, 0, 0, 1) } function a(n) { if (0 === n) return this; var i = t(n), r = e(n); return this._t(i, 0, r, 0, 0, 1, 0, 0, -r, 0, i, 0, 0, 0, 0, 1) } function l(n) { if (0 === n) return this; var i = t(n), r = e(n); return this._t(i, -r, 0, 0, r, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function h(t, e) { return this._t(1, e, t, 1, 0, 0) } function c(t, e) { return this.shear(n(t), n(e)) } function u(i, r) { var s = t(r), o = e(r); return this._t(s, o, 0, 0, -o, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, n(i), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(s, -o, 0, 0, o, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function d(t, e, n) { return n || 0 === n || (n = 1), 1 === t && 1 === e && 1 === n ? this : this._t(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1) } function p(t, e, n, i, r, s, o, a, l, h, c, u, d, p, f, m) { return this.props[0] = t, this.props[1] = e, this.props[2] = n, this.props[3] = i, this.props[4] = r, this.props[5] = s, this.props[6] = o, this.props[7] = a, this.props[8] = l, this.props[9] = h, this.props[10] = c, this.props[11] = u, this.props[12] = d, this.props[13] = p, this.props[14] = f, this.props[15] = m, this } function f(t, e, n) { return n = n || 0, 0 !== t || 0 !== e || 0 !== n ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, n, 1) : this } function m(t, e, n, i, r, s, o, a, l, h, c, u, d, p, f, m) { var g = this.props; if (1 === t && 0 === e && 0 === n && 0 === i && 0 === r && 1 === s && 0 === o && 0 === a && 0 === l && 0 === h && 1 === c && 0 === u) return g[12] = g[12] * t + g[15] * d, g[13] = g[13] * s + g[15] * p, g[14] = g[14] * c + g[15] * f, g[15] *= m, this._identityCalculated = !1, this; var v = g[0], A = g[1], b = g[2], y = g[3], x = g[4], _ = g[5], w = g[6], E = g[7], C = g[8], S = g[9], M = g[10], P = g[11], I = g[12], T = g[13], D = g[14], B = g[15]; return g[0] = v * t + A * r + b * l + y * d, g[1] = v * e + A * s + b * h + y * p, g[2] = v * n + A * o + b * c + y * f, g[3] = v * i + A * a + b * u + y * m, g[4] = x * t + _ * r + w * l + E * d, g[5] = x * e + _ * s + w * h + E * p, g[6] = x * n + _ * o + w * c + E * f, g[7] = x * i + _ * a + w * u + E * m, g[8] = C * t + S * r + M * l + P * d, g[9] = C * e + S * s + M * h + P * p, g[10] = C * n + S * o + M * c + P * f, g[11] = C * i + S * a + M * u + P * m, g[12] = I * t + T * r + D * l + B * d, g[13] = I * e + T * s + D * h + B * p, g[14] = I * n + T * o + D * c + B * f, g[15] = I * i + T * a + D * u + B * m, this._identityCalculated = !1, this } function g() { return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]), this._identityCalculated = !0), this._identity } function v(t) { for (var e = 0; e < 16;) { if (t.props[e] !== this.props[e]) return !1; e += 1 } return !0 } function A(t) { var e; for (e = 0; e < 16; e += 1)t.props[e] = this.props[e]; return t } function b(t) { var e; for (e = 0; e < 16; e += 1)this.props[e] = t[e] } function y(t, e, n) { return { x: t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12], y: t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13], z: t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14] } } function x(t, e, n) { return t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12] } function _(t, e, n) { return t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13] } function w(t, e, n) { return t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14] } function E() { var t = this.props[0] * this.props[5] - this.props[1] * this.props[4], e = this.props[5] / t, n = -this.props[1] / t, i = -this.props[4] / t, r = this.props[0] / t, s = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / t, o = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / t, a = new Matrix; return a.props[0] = e, a.props[1] = n, a.props[4] = i, a.props[5] = r, a.props[12] = s, a.props[13] = o, a } function C(t) { return this.getInverseMatrix().applyToPointArray(t[0], t[1], t[2] || 0) } function S(t) { var e, n = t.length, i = []; for (e = 0; e < n; e += 1)i[e] = C(t[e]); return i } function M(t, e, n) { var i = createTypedArray("float32", 6); if (this.isIdentity()) i[0] = t[0], i[1] = t[1], i[2] = e[0], i[3] = e[1], i[4] = n[0], i[5] = n[1]; else { var r = this.props[0], s = this.props[1], o = this.props[4], a = this.props[5], l = this.props[12], h = this.props[13]; i[0] = t[0] * r + t[1] * o + l, i[1] = t[0] * s + t[1] * a + h, i[2] = e[0] * r + e[1] * o + l, i[3] = e[0] * s + e[1] * a + h, i[4] = n[0] * r + n[1] * o + l, i[5] = n[0] * s + n[1] * a + h } return i } function P(t, e, n) { return this.isIdentity() ? [t, e, n] : [t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12], t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13], t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14]] } function I(t, e) { if (this.isIdentity()) return t + "," + e; var n = this.props; return Math.round(100 * (t * n[0] + e * n[4] + n[12])) / 100 + "," + Math.round(100 * (t * n[1] + e * n[5] + n[13])) / 100 } function T() { for (var t = 0, e = this.props, n = "matrix3d("; t < 16;)n += i(1e4 * e[t]) / 1e4, n += 15 === t ? ")" : ",", t += 1; return n } function D(t) { return t < 1e-6 && t > 0 || t > -1e-6 && t < 0 ? i(1e4 * t) / 1e4 : t } function B() { var t = this.props; return "matrix(" + D(t[0]) + "," + D(t[1]) + "," + D(t[4]) + "," + D(t[5]) + "," + D(t[12]) + "," + D(t[13]) + ")" } return function () { this.reset = r, this.rotate = s, this.rotateX = o, this.rotateY = a, this.rotateZ = l, this.skew = c, this.skewFromAxis = u, this.shear = h, this.scale = d, this.setTransform = p, this.translate = f, this.transform = m, this.applyToPoint = y, this.applyToX = x, this.applyToY = _, this.applyToZ = w, this.applyToPointArray = P, this.applyToTriplePoints = M, this.applyToPointStringified = I, this.toCSS = T, this.to2dCSS = B, this.clone = A, this.cloneFromProps = b, this.equals = v, this.inversePoints = S, this.inversePoint = C, this.getInverseMatrix = E, this._t = this.transform, this.isIdentity = g, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset() } }(); function _typeof$3(t) { return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof$3(t) } var lottie = {}, standalone = "__[STANDALONE]__", animationData = "__[ANIMATIONDATA]__", renderer = ""; function setLocation(t) { setLocationHref(t) } function searchAnimations() { !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations() } function setSubframeRendering(t) { setSubframeEnabled(t) } function setPrefix(t) { setIdPrefix(t) } function loadAnimation(t) { return !0 === standalone && (t.animationData = JSON.parse(animationData)), animationManager.loadAnimation(t) } function setQuality(t) { if ("string" == typeof t) switch (t) { case "high": setDefaultCurveSegments(200); break; default: case "medium": setDefaultCurveSegments(50); break; case "low": setDefaultCurveSegments(10) } else !isNaN(t) && t > 1 && setDefaultCurveSegments(t); getDefaultCurveSegments() >= 50 ? roundValues(!1) : roundValues(!0) } function inBrowser() { return "undefined" != typeof navigator } function installPlugin(t, e) { "expressions" === t && setExpressionsPlugin(e) } function getFactory(t) { switch (t) { case "propertyFactory": return PropertyFactory; case "shapePropertyFactory": return ShapePropertyFactory; case "matrix": return Matrix; default: return null } } function checkReady() { "complete" === document.readyState && (clearInterval(readyStateCheckInterval), searchAnimations()) } function getQueryVariable(t) { for (var e = queryString.split("&"), n = 0; n < e.length; n += 1) { var i = e[n].split("="); if (decodeURIComponent(i[0]) == t) return decodeURIComponent(i[1]) } return null } lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.10.2"; var queryString = ""; if (standalone) { var scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || { src: "" }; queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", renderer = getQueryVariable("renderer") } var readyStateCheckInterval = setInterval(checkReady, 100); try { "object" !== _typeof$3(exports) && __webpack_require__.amdO } catch (t) { } var ShapeModifiers = function () { var t = {}, e = {}; return t.registerModifier = function (t, n) { e[t] || (e[t] = n) }, t.getModifier = function (t, n, i) { return new e[t](n, i) }, t }(); function ShapeModifier() { } function TrimModifier() { } function PuckerAndBloatModifier() { } ShapeModifier.prototype.initModifierProperties = function () { }, ShapeModifier.prototype.addShapeToModifier = function () { }, ShapeModifier.prototype.addShape = function (t) { if (!this.closed) { t.sh.container.addDynamicProperty(t.sh); var e = { shape: t.sh, data: t, localShapeCollection: shapeCollectionPool.newShapeCollection() }; this.shapes.push(e), this.addShapeToModifier(e), this._isAnimated && t.setAsAnimated() } }, ShapeModifier.prototype.init = function (t, e) { this.shapes = [], this.elem = t, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, ShapeModifier.prototype.processKeys = function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties()) }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (t, e) { this.s = PropertyFactory.getProp(t, e.s, 0, .01, this), this.e = PropertyFactory.getProp(t, e.e, 0, .01, this), this.o = PropertyFactory.getProp(t, e.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = e.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length }, TrimModifier.prototype.addShapeToModifier = function (t) { t.pathsData = [] }, TrimModifier.prototype.calculateShapeEdges = function (t, e, n, i, r) { var s = []; e <= 1 ? s.push({ s: t, e: e }) : t >= 1 ? s.push({ s: t - 1, e: e - 1 }) : (s.push({ s: t, e: 1 }), s.push({ s: 0, e: e - 1 })); var o, a, l = [], h = s.length; for (o = 0; o < h; o += 1) { var c, u; (a = s[o]).e * r < i || a.s * r > i + n || (c = a.s * r <= i ? 0 : (a.s * r - i) / n, u = a.e * r >= i + n ? 1 : (a.e * r - i) / n, l.push([c, u])) } return l.length || l.push([0, 0]), l }, TrimModifier.prototype.releasePathsData = function (t) { var e, n = t.length; for (e = 0; e < n; e += 1)segmentsLengthPool.release(t[e]); return t.length = 0, t }, TrimModifier.prototype.processShapes = function (t) { var e, n, i, r; if (this._mdf || t) { var s = this.o.v % 360 / 360; if (s < 0 && (s += 1), (e = this.s.v > 1 ? 1 + s : this.s.v < 0 ? 0 + s : this.s.v + s) > (n = this.e.v > 1 ? 1 + s : this.e.v < 0 ? 0 + s : this.e.v + s)) { var o = e; e = n, n = o } e = 1e-4 * Math.round(1e4 * e), n = 1e-4 * Math.round(1e4 * n), this.sValue = e, this.eValue = n } else e = this.sValue, n = this.eValue; var a, l, h, c, u, d = this.shapes.length, p = 0; if (n === e) for (r = 0; r < d; r += 1)this.shapes[r].localShapeCollection.releaseShapes(), this.shapes[r].shape._mdf = !0, this.shapes[r].shape.paths = this.shapes[r].localShapeCollection, this._mdf && (this.shapes[r].pathsData.length = 0); else if (1 === n && 0 === e || 0 === n && 1 === e) { if (this._mdf) for (r = 0; r < d; r += 1)this.shapes[r].pathsData.length = 0, this.shapes[r].shape._mdf = !0 } else { var f, m, g = []; for (r = 0; r < d; r += 1)if ((f = this.shapes[r]).shape._mdf || this._mdf || t || 2 === this.m) { if (l = (i = f.shape.paths)._length, u = 0, !f.shape._mdf && f.pathsData.length) u = f.totalShapeLength; else { for (h = this.releasePathsData(f.pathsData), a = 0; a < l; a += 1)c = bez.getSegmentsLength(i.shapes[a]), h.push(c), u += c.totalLength; f.totalShapeLength = u, f.pathsData = h } p += u, f.shape._mdf = !0 } else f.shape.paths = f.localShapeCollection; var v, A = e, b = n, y = 0; for (r = d - 1; r >= 0; r -= 1)if ((f = this.shapes[r]).shape._mdf) { for ((m = f.localShapeCollection).releaseShapes(), 2 === this.m && d > 1 ? (v = this.calculateShapeEdges(e, n, f.totalShapeLength, y, p), y += f.totalShapeLength) : v = [[A, b]], l = v.length, a = 0; a < l; a += 1) { A = v[a][0], b = v[a][1], g.length = 0, b <= 1 ? g.push({ s: f.totalShapeLength * A, e: f.totalShapeLength * b }) : A >= 1 ? g.push({ s: f.totalShapeLength * (A - 1), e: f.totalShapeLength * (b - 1) }) : (g.push({ s: f.totalShapeLength * A, e: f.totalShapeLength }), g.push({ s: 0, e: f.totalShapeLength * (b - 1) })); var x = this.addShapes(f, g[0]); if (g[0].s !== g[0].e) { if (g.length > 1) if (f.shape.paths.shapes[f.shape.paths._length - 1].c) { var _ = x.pop(); this.addPaths(x, m), x = this.addShapes(f, g[1], _) } else this.addPaths(x, m), x = this.addShapes(f, g[1]); this.addPaths(x, m) } } f.shape.paths = m } } }, TrimModifier.prototype.addPaths = function (t, e) { var n, i = t.length; for (n = 0; n < i; n += 1)e.addShape(t[n]) }, TrimModifier.prototype.addSegment = function (t, e, n, i, r, s, o) { r.setXYAt(e[0], e[1], "o", s), r.setXYAt(n[0], n[1], "i", s + 1), o && r.setXYAt(t[0], t[1], "v", s), r.setXYAt(i[0], i[1], "v", s + 1) }, TrimModifier.prototype.addSegmentFromArray = function (t, e, n, i) { e.setXYAt(t[1], t[5], "o", n), e.setXYAt(t[2], t[6], "i", n + 1), i && e.setXYAt(t[0], t[4], "v", n), e.setXYAt(t[3], t[7], "v", n + 1) }, TrimModifier.prototype.addShapes = function (t, e, n) { var i, r, s, o, a, l, h, c, u = t.pathsData, d = t.shape.paths.shapes, p = t.shape.paths._length, f = 0, m = [], g = !0; for (n ? (a = n._length, c = n._length) : (n = shapePool.newElement(), a = 0, c = 0), m.push(n), i = 0; i < p; i += 1) { for (l = u[i].lengths, n.c = d[i].c, s = d[i].c ? l.length : l.length + 1, r = 1; r < s; r += 1)if (f + (o = l[r - 1]).addedLength < e.s) f += o.addedLength, n.c = !1; else { if (f > e.e) { n.c = !1; break } e.s <= f && e.e >= f + o.addedLength ? (this.addSegment(d[i].v[r - 1], d[i].o[r - 1], d[i].i[r], d[i].v[r], n, a, g), g = !1) : (h = bez.getNewSegment(d[i].v[r - 1], d[i].v[r], d[i].o[r - 1], d[i].i[r], (e.s - f) / o.addedLength, (e.e - f) / o.addedLength, l[r - 1]), this.addSegmentFromArray(h, n, a, g), g = !1, n.c = !1), f += o.addedLength, a += 1 } if (d[i].c && l.length) { if (o = l[r - 1], f <= e.e) { var v = l[r - 1].addedLength; e.s <= f && e.e >= f + v ? (this.addSegment(d[i].v[r - 1], d[i].o[r - 1], d[i].i[0], d[i].v[0], n, a, g), g = !1) : (h = bez.getNewSegment(d[i].v[r - 1], d[i].v[0], d[i].o[r - 1], d[i].i[0], (e.s - f) / v, (e.e - f) / v, l[r - 1]), this.addSegmentFromArray(h, n, a, g), g = !1, n.c = !1) } else n.c = !1; f += o.addedLength, a += 1 } if (n._length && (n.setXYAt(n.v[c][0], n.v[c][1], "i", c), n.setXYAt(n.v[n._length - 1][0], n.v[n._length - 1][1], "o", n._length - 1)), f > e.e) break; i < p - 1 && (n = shapePool.newElement(), g = !0, m.push(n), a = 0) } return m }, extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function (t, e) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(t, e.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length }, PuckerAndBloatModifier.prototype.processPath = function (t, e) { var n = e / 100, i = [0, 0], r = t._length, s = 0; for (s = 0; s < r; s += 1)i[0] += t.v[s][0], i[1] += t.v[s][1]; i[0] /= r, i[1] /= r; var o, a, l, h, c, u, d = shapePool.newElement(); for (d.c = t.c, s = 0; s < r; s += 1)o = t.v[s][0] + (i[0] - t.v[s][0]) * n, a = t.v[s][1] + (i[1] - t.v[s][1]) * n, l = t.o[s][0] + (i[0] - t.o[s][0]) * -n, h = t.o[s][1] + (i[1] - t.o[s][1]) * -n, c = t.i[s][0] + (i[0] - t.i[s][0]) * -n, u = t.i[s][1] + (i[1] - t.i[s][1]) * -n, d.setTripleAt(o, a, l, h, c, u, s); return d }, PuckerAndBloatModifier.prototype.processShapes = function (t) { var e, n, i, r, s, o, a = this.shapes.length, l = this.amount.v; if (0 !== l) for (n = 0; n < a; n += 1) { if (o = (s = this.shapes[n]).localShapeCollection, s.shape._mdf || this._mdf || t) for (o.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, r = s.shape.paths._length, i = 0; i < r; i += 1)o.addShape(this.processPath(e[i], l)); s.shape.paths = s.localShapeCollection } this.dynamicProperties.length || (this._mdf = !1) }; var TransformPropertyFactory = function () { var t = [0, 0]; function e(t, e, n) { if (this.elem = t, this.frameId = -1, this.propType = "transform", this.data = e, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(n || t), e.p && e.p.s ? (this.px = PropertyFactory.getProp(t, e.p.x, 0, 0, this), this.py = PropertyFactory.getProp(t, e.p.y, 0, 0, this), e.p.z && (this.pz = PropertyFactory.getProp(t, e.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(t, e.p || { k: [0, 0, 0] }, 1, 0, this), e.rx) { if (this.rx = PropertyFactory.getProp(t, e.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(t, e.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(t, e.rz, 0, degToRads, this), e.or.k[0].ti) { var i, r = e.or.k.length; for (i = 0; i < r; i += 1)e.or.k[i].to = null, e.or.k[i].ti = null } this.or = PropertyFactory.getProp(t, e.or, 1, degToRads, this), this.or.sh = !0 } else this.r = PropertyFactory.getProp(t, e.r || { k: 0 }, 0, degToRads, this); e.sk && (this.sk = PropertyFactory.getProp(t, e.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(t, e.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(t, e.a || { k: [0, 0, 0] }, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s || { k: [100, 100, 100] }, 1, .01, this), e.o ? this.o = PropertyFactory.getProp(t, e.o, 0, .01, t) : this.o = { _mdf: !1, v: 1 }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0) } return e.prototype = { applyToMatrix: function (t) { var e = this._mdf; this.iterateDynamicProperties(), this._mdf = this._mdf || e, this.a && t.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && t.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && t.skewFromAxis(-this.sk.v, this.sa.v), this.r ? t.rotate(-this.r.v) : t.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? t.translate(this.px.v, this.py.v, -this.pz.v) : t.translate(this.px.v, this.py.v, 0) : t.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) }, getValue: function (e) { if (this.elem.globalData.frameId !== this.frameId) { if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || e) { var n; if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) { var i, r; if (n = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (i = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / n, 0), r = this.p.getValueAtTime(this.p.keyframes[0].t / n, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (i = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / n, 0), r = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / n, 0)) : (i = this.p.pv, r = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / n, this.p.offsetTime)); else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) { i = [], r = []; var s = this.px, o = this.py; s._caching.lastFrame + s.offsetTime <= s.keyframes[0].t ? (i[0] = s.getValueAtTime((s.keyframes[0].t + .01) / n, 0), i[1] = o.getValueAtTime((o.keyframes[0].t + .01) / n, 0), r[0] = s.getValueAtTime(s.keyframes[0].t / n, 0), r[1] = o.getValueAtTime(o.keyframes[0].t / n, 0)) : s._caching.lastFrame + s.offsetTime >= s.keyframes[s.keyframes.length - 1].t ? (i[0] = s.getValueAtTime(s.keyframes[s.keyframes.length - 1].t / n, 0), i[1] = o.getValueAtTime(o.keyframes[o.keyframes.length - 1].t / n, 0), r[0] = s.getValueAtTime((s.keyframes[s.keyframes.length - 1].t - .01) / n, 0), r[1] = o.getValueAtTime((o.keyframes[o.keyframes.length - 1].t - .01) / n, 0)) : (i = [s.pv, o.pv], r[0] = s.getValueAtTime((s._caching.lastFrame + s.offsetTime - .01) / n, s.offsetTime), r[1] = o.getValueAtTime((o._caching.lastFrame + o.offsetTime - .01) / n, o.offsetTime)) } else i = r = t; this.v.rotate(-Math.atan2(i[1] - r[1], i[0] - r[0])) } this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) } this.frameId = this.elem.globalData.frameId } }, precalculateMatrix: function () { if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) { if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) { if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return; this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3 } this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4) } }, autoOrient: function () { } }, extendPrototype([DynamicPropertyContainer], e), e.prototype.addDynamicProperty = function (t) { this._addDynamicProperty(t), this.elem.addDynamicProperty(t), this._isDirty = !0 }, e.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, { getTransformProperty: function (t, n, i) { return new e(t, n, i) } } }(); function RepeaterModifier() { } function RoundCornersModifier() { } function floatEqual(t, e) { return 1e5 * Math.abs(t - e) <= Math.min(Math.abs(t), Math.abs(e)) } function floatZero(t) { return Math.abs(t) <= 1e-5 } function lerp(t, e, n) { return t * (1 - n) + e * n } function lerpPoint(t, e, n) { return [lerp(t[0], e[0], n), lerp(t[1], e[1], n)] } function quadRoots(t, e, n) { if (0 === t) return []; var i = e * e - 4 * t * n; if (i < 0) return []; var r = -e / (2 * t); if (0 === i) return [r]; var s = Math.sqrt(i) / (2 * t); return [r - s, r + s] } function polynomialCoefficients(t, e, n, i) { return [3 * e - t - 3 * n + i, 3 * t - 6 * e + 3 * n, -3 * t + 3 * e, t] } function singlePoint(t) { return new PolynomialBezier(t, t, t, t, !1) } function PolynomialBezier(t, e, n, i, r) { r && pointEqual(t, e) && (e = lerpPoint(t, i, 1 / 3)), r && pointEqual(n, i) && (n = lerpPoint(t, i, 2 / 3)); var s = polynomialCoefficients(t[0], e[0], n[0], i[0]), o = polynomialCoefficients(t[1], e[1], n[1], i[1]); this.a = [s[0], o[0]], this.b = [s[1], o[1]], this.c = [s[2], o[2]], this.d = [s[3], o[3]], this.points = [t, e, n, i] } function extrema(t, e) { var n = t.points[0][e], i = t.points[t.points.length - 1][e]; if (n > i) { var r = i; i = n, n = r } for (var s = quadRoots(3 * t.a[e], 2 * t.b[e], t.c[e]), o = 0; o < s.length; o += 1)if (s[o] > 0 && s[o] < 1) { var a = t.point(s[o])[e]; a < n ? n = a : a > i && (i = a) } return { min: n, max: i } } function intersectData(t, e, n) { var i = t.boundingBox(); return { cx: i.cx, cy: i.cy, width: i.width, height: i.height, bez: t, t: (e + n) / 2, t1: e, t2: n } } function splitData(t) { var e = t.bez.split(.5); return [intersectData(e[0], t.t1, t.t), intersectData(e[1], t.t, t.t2)] } function boxIntersect(t, e) { return 2 * Math.abs(t.cx - e.cx) < t.width + e.width && 2 * Math.abs(t.cy - e.cy) < t.height + e.height } function intersectsImpl(t, e, n, i, r, s) { if (boxIntersect(t, e)) if (n >= s || t.width <= i && t.height <= i && e.width <= i && e.height <= i) r.push([t.t, e.t]); else { var o = splitData(t), a = splitData(e); intersectsImpl(o[0], a[0], n + 1, i, r, s), intersectsImpl(o[0], a[1], n + 1, i, r, s), intersectsImpl(o[1], a[0], n + 1, i, r, s), intersectsImpl(o[1], a[1], n + 1, i, r, s) } } function crossProduct(t, e) { return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]] } function lineIntersection(t, e, n, i) { var r = [t[0], t[1], 1], s = [e[0], e[1], 1], o = [n[0], n[1], 1], a = [i[0], i[1], 1], l = crossProduct(crossProduct(r, s), crossProduct(o, a)); return floatZero(l[2]) ? null : [l[0] / l[2], l[1] / l[2]] } function polarOffset(t, e, n) { return [t[0] + Math.cos(e) * n, t[1] - Math.sin(e) * n] } function pointDistance(t, e) { return Math.hypot(t[0] - e[0], t[1] - e[1]) } function pointEqual(t, e) { return floatEqual(t[0], e[0]) && floatEqual(t[1], e[1]) } function ZigZagModifier() { } function setPoint(t, e, n, i, r, s, o) { var a = n - Math.PI / 2, l = n + Math.PI / 2, h = e[0] + Math.cos(n) * i * r, c = e[1] - Math.sin(n) * i * r; t.setTripleAt(h, c, h + Math.cos(a) * s, c - Math.sin(a) * s, h + Math.cos(l) * o, c - Math.sin(l) * o, t.length()) } function getPerpendicularVector(t, e) { var n = [e[0] - t[0], e[1] - t[1]], i = .5 * -Math.PI; return [Math.cos(i) * n[0] - Math.sin(i) * n[1], Math.sin(i) * n[0] + Math.cos(i) * n[1]] } function getProjectingAngle(t, e) { var n = 0 === e ? t.length() - 1 : e - 1, i = (e + 1) % t.length(), r = getPerpendicularVector(t.v[n], t.v[i]); return Math.atan2(0, 1) - Math.atan2(r[1], r[0]) } function zigZagCorner(t, e, n, i, r, s, o) { var a = getProjectingAngle(e, n), l = e.v[n % e._length], h = e.v[0 === n ? e._length - 1 : n - 1], c = e.v[(n + 1) % e._length], u = 2 === s ? Math.sqrt(Math.pow(l[0] - h[0], 2) + Math.pow(l[1] - h[1], 2)) : 0, d = 2 === s ? Math.sqrt(Math.pow(l[0] - c[0], 2) + Math.pow(l[1] - c[1], 2)) : 0; setPoint(t, e.v[n % e._length], a, o, i, d / (2 * (r + 1)), u / (2 * (r + 1)), s) } function zigZagSegment(t, e, n, i, r, s) { for (var o = 0; o < i; o += 1) { var a = (o + 1) / (i + 1), l = 2 === r ? Math.sqrt(Math.pow(e.points[3][0] - e.points[0][0], 2) + Math.pow(e.points[3][1] - e.points[0][1], 2)) : 0, h = e.normalAngle(a); setPoint(t, e.point(a), h, s, n, l / (2 * (i + 1)), l / (2 * (i + 1)), r), s = -s } return s } function linearOffset(t, e, n) { var i = Math.atan2(e[0] - t[0], e[1] - t[1]); return [polarOffset(t, i, n), polarOffset(e, i, n)] } function offsetSegment(t, e) { var n, i, r, s, o, a, l; n = (l = linearOffset(t.points[0], t.points[1], e))[0], i = l[1], r = (l = linearOffset(t.points[1], t.points[2], e))[0], s = l[1], o = (l = linearOffset(t.points[2], t.points[3], e))[0], a = l[1]; var h = lineIntersection(n, i, r, s); null === h && (h = i); var c = lineIntersection(o, a, r, s); return null === c && (c = o), new PolynomialBezier(n, h, c, a) } function joinLines(t, e, n, i, r) { var s = e.points[3], o = n.points[0]; if (3 === i) return s; if (pointEqual(s, o)) return s; if (2 === i) { var a = -e.tangentAngle(1), l = -n.tangentAngle(0) + Math.PI, h = lineIntersection(s, polarOffset(s, a + Math.PI / 2, 100), o, polarOffset(o, a + Math.PI / 2, 100)), c = h ? pointDistance(h, s) : pointDistance(s, o) / 2, u = polarOffset(s, a, 2 * c * roundCorner); return t.setXYAt(u[0], u[1], "o", t.length() - 1), u = polarOffset(o, l, 2 * c * roundCorner), t.setTripleAt(o[0], o[1], o[0], o[1], u[0], u[1], t.length()), o } var d = lineIntersection(pointEqual(s, e.points[2]) ? e.points[0] : e.points[2], s, o, pointEqual(o, n.points[1]) ? n.points[3] : n.points[1]); return d && pointDistance(d, s) < r ? (t.setTripleAt(d[0], d[1], d[0], d[1], d[0], d[1], t.length()), d) : s } function getIntersection(t, e) { var n = t.intersections(e); return n.length && floatEqual(n[0][0], 1) && n.shift(), n.length ? n[0] : null } function pruneSegmentIntersection(t, e) { var n = t.slice(), i = e.slice(), r = getIntersection(t[t.length - 1], e[0]); return r && (n[t.length - 1] = t[t.length - 1].split(r[0])[0], i[0] = e[0].split(r[1])[1]), t.length > 1 && e.length > 1 && (r = getIntersection(t[0], e[e.length - 1])) ? [[t[0].split(r[0])[0]], [e[e.length - 1].split(r[1])[1]]] : [n, i] } function pruneIntersections(t) { for (var e, n = 1; n < t.length; n += 1)e = pruneSegmentIntersection(t[n - 1], t[n]), t[n - 1] = e[0], t[n] = e[1]; return t.length > 1 && (e = pruneSegmentIntersection(t[t.length - 1], t[0]), t[t.length - 1] = e[0], t[0] = e[1]), t } function offsetSegmentSplit(t, e) { var n, i, r, s, o = t.inflectionPoints(); if (0 === o.length) return [offsetSegment(t, e)]; if (1 === o.length || floatEqual(o[1], 1)) return n = (r = t.split(o[0]))[0], i = r[1], [offsetSegment(n, e), offsetSegment(i, e)]; n = (r = t.split(o[0]))[0]; var a = (o[1] - o[0]) / (1 - o[0]); return s = (r = r[1].split(a))[0], i = r[1], [offsetSegment(n, e), offsetSegment(s, e), offsetSegment(i, e)] } function OffsetPathModifier() { } function getFontProperties(t) { for (var e = t.fStyle ? t.fStyle.split(" ") : [], n = "normal", i = "normal", r = e.length, s = 0; s < r; s += 1)switch (e[s].toLowerCase()) { case "italic": i = "italic"; break; case "bold": n = "700"; break; case "black": n = "900"; break; case "medium": n = "500"; break; case "regular": case "normal": n = "400"; break; case "light": case "thin": n = "200" }return { style: i, weight: t.fWeight || n } } extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (t, e) { this.getValue = this.processKeys, this.c = PropertyFactory.getProp(t, e.c, 0, null, this), this.o = PropertyFactory.getProp(t, e.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(t, e.tr, this), this.so = PropertyFactory.getProp(t, e.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(t, e.tr.eo, 0, .01, this), this.data = e, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix }, RepeaterModifier.prototype.applyTransforms = function (t, e, n, i, r, s) { var o = s ? -1 : 1, a = i.s.v[0] + (1 - i.s.v[0]) * (1 - r), l = i.s.v[1] + (1 - i.s.v[1]) * (1 - r); t.translate(i.p.v[0] * o * r, i.p.v[1] * o * r, i.p.v[2]), e.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), e.rotate(-i.r.v * o * r), e.translate(i.a.v[0], i.a.v[1], i.a.v[2]), n.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), n.scale(s ? 1 / a : a, s ? 1 / l : l), n.translate(i.a.v[0], i.a.v[1], i.a.v[2]) }, RepeaterModifier.prototype.init = function (t, e, n, i) { for (this.elem = t, this.arr = e, this.pos = n, this.elemsData = i, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e[n]); n > 0;)n -= 1, this._elements.unshift(e[n]); this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, RepeaterModifier.prototype.resetElements = function (t) { var e, n = t.length; for (e = 0; e < n; e += 1)t[e]._processed = !1, "gr" === t[e].ty && this.resetElements(t[e].it) }, RepeaterModifier.prototype.cloneElements = function (t) { var e = JSON.parse(JSON.stringify(t)); return this.resetElements(e), e }, RepeaterModifier.prototype.changeGroupRender = function (t, e) { var n, i = t.length; for (n = 0; n < i; n += 1)t[n]._render = e, "gr" === t[n].ty && this.changeGroupRender(t[n].it, e) }, RepeaterModifier.prototype.processShapes = function (t) { var e, n, i, r, s, o = !1; if (this._mdf || t) { var a, l = Math.ceil(this.c.v); if (this._groups.length < l) { for (; this._groups.length < l;) { var h = { it: this.cloneElements(this._elements), ty: "gr" }; h.it.push({ a: { a: 0, ix: 1, k: [0, 0] }, nm: "Transform", o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: "tr" }), this.arr.splice(0, 0, h), this._groups.splice(0, 0, h), this._currentCopies += 1 } this.elem.reloadShapes(), o = !0 } for (s = 0, i = 0; i <= this._groups.length - 1; i += 1) { if (a = s < l, this._groups[i]._render = a, this.changeGroupRender(this._groups[i].it, a), !a) { var c = this.elemsData[i].it, u = c[c.length - 1]; 0 !== u.transform.op.v ? (u.transform.op._mdf = !0, u.transform.op.v = 0) : u.transform.op._mdf = !1 } s += 1 } this._currentCopies = l; var d = this.o.v, p = d % 1, f = d > 0 ? Math.floor(d) : Math.ceil(d), m = this.pMatrix.props, g = this.rMatrix.props, v = this.sMatrix.props; this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset(); var A, b, y = 0; if (d > 0) { for (; y < f;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), y += 1; p && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, p, !1), y += p) } else if (d < 0) { for (; y > f;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), y -= 1; p && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -p, !0), y -= p) } for (i = 1 === this.data.m ? 0 : this._currentCopies - 1, r = 1 === this.data.m ? 1 : -1, s = this._currentCopies; s;) { if (b = (n = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props).length, e[e.length - 1].transform.mProps._mdf = !0, e[e.length - 1].transform.op._mdf = !0, e[e.length - 1].transform.op.v = 1 === this._currentCopies ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1)), 0 !== y) { for ((0 !== i && 1 === r || i !== this._currentCopies - 1 && -1 === r) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]), this.matrix.transform(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]), this.matrix.transform(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]), A = 0; A < b; A += 1)n[A] = this.matrix.props[A]; this.matrix.reset() } else for (this.matrix.reset(), A = 0; A < b; A += 1)n[A] = this.matrix.props[A]; y += 1, s -= 1, i += r } } else for (s = this._currentCopies, i = 0, r = 1; s;)n = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props, e[e.length - 1].transform.mProps._mdf = !1, e[e.length - 1].transform.op._mdf = !1, s -= 1, i += r; return o }, RepeaterModifier.prototype.addShape = function () { }, extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (t, e) { this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(t, e.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length }, RoundCornersModifier.prototype.processPath = function (t, e) { var n, i = shapePool.newElement(); i.c = t.c; var r, s, o, a, l, h, c, u, d, p, f, m, g = t._length, v = 0; for (n = 0; n < g; n += 1)r = t.v[n], o = t.o[n], s = t.i[n], r[0] === o[0] && r[1] === o[1] && r[0] === s[0] && r[1] === s[1] ? 0 !== n && n !== g - 1 || t.c ? (a = 0 === n ? t.v[g - 1] : t.v[n - 1], h = (l = Math.sqrt(Math.pow(r[0] - a[0], 2) + Math.pow(r[1] - a[1], 2))) ? Math.min(l / 2, e) / l : 0, c = f = r[0] + (a[0] - r[0]) * h, u = m = r[1] - (r[1] - a[1]) * h, d = c - (c - r[0]) * roundCorner, p = u - (u - r[1]) * roundCorner, i.setTripleAt(c, u, d, p, f, m, v), v += 1, a = n === g - 1 ? t.v[0] : t.v[n + 1], h = (l = Math.sqrt(Math.pow(r[0] - a[0], 2) + Math.pow(r[1] - a[1], 2))) ? Math.min(l / 2, e) / l : 0, c = d = r[0] + (a[0] - r[0]) * h, u = p = r[1] + (a[1] - r[1]) * h, f = c - (c - r[0]) * roundCorner, m = u - (u - r[1]) * roundCorner, i.setTripleAt(c, u, d, p, f, m, v), v += 1) : (i.setTripleAt(r[0], r[1], o[0], o[1], s[0], s[1], v), v += 1) : (i.setTripleAt(t.v[n][0], t.v[n][1], t.o[n][0], t.o[n][1], t.i[n][0], t.i[n][1], v), v += 1); return i }, RoundCornersModifier.prototype.processShapes = function (t) { var e, n, i, r, s, o, a = this.shapes.length, l = this.rd.v; if (0 !== l) for (n = 0; n < a; n += 1) { if (o = (s = this.shapes[n]).localShapeCollection, s.shape._mdf || this._mdf || t) for (o.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, r = s.shape.paths._length, i = 0; i < r; i += 1)o.addShape(this.processPath(e[i], l)); s.shape.paths = s.localShapeCollection } this.dynamicProperties.length || (this._mdf = !1) }, PolynomialBezier.prototype.point = function (t) { return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]] }, PolynomialBezier.prototype.derivative = function (t) { return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]] }, PolynomialBezier.prototype.tangentAngle = function (t) { var e = this.derivative(t); return Math.atan2(e[1], e[0]) }, PolynomialBezier.prototype.normalAngle = function (t) { var e = this.derivative(t); return Math.atan2(e[0], e[1]) }, PolynomialBezier.prototype.inflectionPoints = function () { var t = this.a[1] * this.b[0] - this.a[0] * this.b[1]; if (floatZero(t)) return []; var e = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / t, n = e * e - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / t; if (n < 0) return []; var i = Math.sqrt(n); return floatZero(i) ? i > 0 && i < 1 ? [e] : [] : [e - i, e + i].filter((function (t) { return t > 0 && t < 1 })) }, PolynomialBezier.prototype.split = function (t) { if (t <= 0) return [singlePoint(this.points[0]), this]; if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])]; var e = lerpPoint(this.points[0], this.points[1], t), n = lerpPoint(this.points[1], this.points[2], t), i = lerpPoint(this.points[2], this.points[3], t), r = lerpPoint(e, n, t), s = lerpPoint(n, i, t), o = lerpPoint(r, s, t); return [new PolynomialBezier(this.points[0], e, r, o, !0), new PolynomialBezier(o, s, i, this.points[3], !0)] }, PolynomialBezier.prototype.bounds = function () { return { x: extrema(this, 0), y: extrema(this, 1) } }, PolynomialBezier.prototype.boundingBox = function () { var t = this.bounds(); return { left: t.x.min, right: t.x.max, top: t.y.min, bottom: t.y.max, width: t.x.max - t.x.min, height: t.y.max - t.y.min, cx: (t.x.max + t.x.min) / 2, cy: (t.y.max + t.y.min) / 2 } }, PolynomialBezier.prototype.intersections = function (t, e, n) { void 0 === e && (e = 2), void 0 === n && (n = 7); var i = []; return intersectsImpl(intersectData(this, 0, 1), intersectData(t, 0, 1), 0, e, i, n), i }, PolynomialBezier.shapeSegment = function (t, e) { var n = (e + 1) % t.length(); return new PolynomialBezier(t.v[e], t.o[e], t.i[n], t.v[n], !0) }, PolynomialBezier.shapeSegmentInverted = function (t, e) { var n = (e + 1) % t.length(); return new PolynomialBezier(t.v[n], t.i[n], t.o[e], t.v[e], !0) }, extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function (t, e) { this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(t, e.s, 0, null, this), this.frequency = PropertyFactory.getProp(t, e.r, 0, null, this), this.pointsType = PropertyFactory.getProp(t, e.pt, 0, null, this), this._isAnimated = 0 !== this.amplitude.effectsSequence.length || 0 !== this.frequency.effectsSequence.length || 0 !== this.pointsType.effectsSequence.length }, ZigZagModifier.prototype.processPath = function (t, e, n, i) { var r = t._length, s = shapePool.newElement(); if (s.c = t.c, t.c || (r -= 1), 0 === r) return s; var o = -1, a = PolynomialBezier.shapeSegment(t, 0); zigZagCorner(s, t, 0, e, n, i, o); for (var l = 0; l < r; l += 1)o = zigZagSegment(s, a, e, n, i, -o), a = l !== r - 1 || t.c ? PolynomialBezier.shapeSegment(t, (l + 1) % r) : null, zigZagCorner(s, t, l + 1, e, n, i, o); return s }, ZigZagModifier.prototype.processShapes = function (t) { var e, n, i, r, s, o, a = this.shapes.length, l = this.amplitude.v, h = Math.max(0, Math.round(this.frequency.v)), c = this.pointsType.v; if (0 !== l) for (n = 0; n < a; n += 1) { if (o = (s = this.shapes[n]).localShapeCollection, s.shape._mdf || this._mdf || t) for (o.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, r = s.shape.paths._length, i = 0; i < r; i += 1)o.addShape(this.processPath(e[i], l, h, c)); s.shape.paths = s.localShapeCollection } this.dynamicProperties.length || (this._mdf = !1) }, extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function (t, e) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(t, e.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(t, e.ml, 0, null, this), this.lineJoin = e.lj, this._isAnimated = 0 !== this.amount.effectsSequence.length }, OffsetPathModifier.prototype.processPath = function (t, e, n, i) { var r = shapePool.newElement(); r.c = t.c; var s, o, a, l = t.length(); t.c || (l -= 1); var h = []; for (s = 0; s < l; s += 1)a = PolynomialBezier.shapeSegment(t, s), h.push(offsetSegmentSplit(a, e)); if (!t.c) for (s = l - 1; s >= 0; s -= 1)a = PolynomialBezier.shapeSegmentInverted(t, s), h.push(offsetSegmentSplit(a, e)); h = pruneIntersections(h); var c = null, u = null; for (s = 0; s < h.length; s += 1) { var d = h[s]; for (u && (c = joinLines(r, u, d[0], n, i)), u = d[d.length - 1], o = 0; o < d.length; o += 1)a = d[o], c && pointEqual(a.points[0], c) ? r.setXYAt(a.points[1][0], a.points[1][1], "o", r.length() - 1) : r.setTripleAt(a.points[0][0], a.points[0][1], a.points[1][0], a.points[1][1], a.points[0][0], a.points[0][1], r.length()), r.setTripleAt(a.points[3][0], a.points[3][1], a.points[3][0], a.points[3][1], a.points[2][0], a.points[2][1], r.length()), c = a.points[3] } return h.length && joinLines(r, u, h[0][0], n, i), r }, OffsetPathModifier.prototype.processShapes = function (t) { var e, n, i, r, s, o, a = this.shapes.length, l = this.amount.v, h = this.miterLimit.v, c = this.lineJoin; if (0 !== l) for (n = 0; n < a; n += 1) { if (o = (s = this.shapes[n]).localShapeCollection, s.shape._mdf || this._mdf || t) for (o.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, r = s.shape.paths._length, i = 0; i < r; i += 1)o.addShape(this.processPath(e[i], l, c, h)); s.shape.paths = s.localShapeCollection } this.dynamicProperties.length || (this._mdf = !1) }; var FontManager = function () { var t = 5e3, e = { w: 0, size: 0, shapes: [], data: { shapes: [] } }, n = []; n = n.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]); var i = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"], r = [65039, 8205]; function s(t, e) { var n = createTag("span"); n.setAttribute("aria-hidden", !0), n.style.fontFamily = e; var i = createTag("span"); i.innerText = "giItT1WQy@!-/#", n.style.position = "absolute", n.style.left = "-10000px", n.style.top = "-10000px", n.style.fontSize = "300px", n.style.fontVariant = "normal", n.style.fontStyle = "normal", n.style.fontWeight = "normal", n.style.letterSpacing = "0", n.appendChild(i), document.body.appendChild(n); var r = i.offsetWidth; return i.style.fontFamily = function (t) { var e, n = t.split(","), i = n.length, r = []; for (e = 0; e < i; e += 1)"sans-serif" !== n[e] && "monospace" !== n[e] && r.push(n[e]); return r.join(",") }(t) + ", " + e, { node: i, w: r, parent: n } } function o(t, e) { var n, i = document.body && e ? "svg" : "canvas", r = getFontProperties(t); if ("svg" === i) { var s = createNS("text"); s.style.fontSize = "100px", s.setAttribute("font-family", t.fFamily), s.setAttribute("font-style", r.style), s.setAttribute("font-weight", r.weight), s.textContent = "1", t.fClass ? (s.style.fontFamily = "inherit", s.setAttribute("class", t.fClass)) : s.style.fontFamily = t.fFamily, e.appendChild(s), n = s } else { var o = new OffscreenCanvas(500, 500).getContext("2d"); o.font = r.style + " " + r.weight + " 100px " + t.fFamily, n = o } return { measureText: function (t) { return "svg" === i ? (n.textContent = t, n.getComputedTextLength()) : n.measureText(t).width } } } var a = function () { this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this) }; a.isModifier = function (t, e) { var n = t.toString(16) + e.toString(16); return -1 !== i.indexOf(n) }, a.isZeroWidthJoiner = function (t, e) { return e ? t === r[0] && e === r[1] : t === r[1] }, a.isCombinedCharacter = function (t) { return -1 !== n.indexOf(t) }; var l = { addChars: function (t) { if (t) { var e; this.chars || (this.chars = []); var n, i, r = t.length, s = this.chars.length; for (e = 0; e < r; e += 1) { for (n = 0, i = !1; n < s;)this.chars[n].style === t[e].style && this.chars[n].fFamily === t[e].fFamily && this.chars[n].ch === t[e].ch && (i = !0), n += 1; i || (this.chars.push(t[e]), s += 1) } } }, addFonts: function (t, e) { if (t) { if (this.chars) return this.isLoaded = !0, void (this.fonts = t.list); if (!document.body) return this.isLoaded = !0, t.list.forEach((function (t) { t.helper = o(t), t.cache = {} })), void (this.fonts = t.list); var n, i = t.list, r = i.length, a = r; for (n = 0; n < r; n += 1) { var l, h, c = !0; if (i[n].loaded = !1, i[n].monoCase = s(i[n].fFamily, "monospace"), i[n].sansCase = s(i[n].fFamily, "sans-serif"), i[n].fPath) { if ("p" === i[n].fOrigin || 3 === i[n].origin) { if ((l = document.querySelectorAll('style[f-forigin="p"][f-family="' + i[n].fFamily + '"], style[f-origin="3"][f-family="' + i[n].fFamily + '"]')).length > 0 && (c = !1), c) { var u = createTag("style"); u.setAttribute("f-forigin", i[n].fOrigin), u.setAttribute("f-origin", i[n].origin), u.setAttribute("f-family", i[n].fFamily), u.type = "text/css", u.innerText = "@font-face {font-family: " + i[n].fFamily + "; font-style: normal; src: url('" + i[n].fPath + "');}", e.appendChild(u) } } else if ("g" === i[n].fOrigin || 1 === i[n].origin) { for (l = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), h = 0; h < l.length; h += 1)-1 !== l[h].href.indexOf(i[n].fPath) && (c = !1); if (c) { var d = createTag("link"); d.setAttribute("f-forigin", i[n].fOrigin), d.setAttribute("f-origin", i[n].origin), d.type = "text/css", d.rel = "stylesheet", d.href = i[n].fPath, document.body.appendChild(d) } } else if ("t" === i[n].fOrigin || 2 === i[n].origin) { for (l = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), h = 0; h < l.length; h += 1)i[n].fPath === l[h].src && (c = !1); if (c) { var p = createTag("link"); p.setAttribute("f-forigin", i[n].fOrigin), p.setAttribute("f-origin", i[n].origin), p.setAttribute("rel", "stylesheet"), p.setAttribute("href", i[n].fPath), e.appendChild(p) } } } else i[n].loaded = !0, a -= 1; i[n].helper = o(i[n], e), i[n].cache = {}, this.fonts.push(i[n]) } 0 === a ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100) } else this.isLoaded = !0 }, getCharData: function (t, n, i) { for (var r = 0, s = this.chars.length; r < s;) { if (this.chars[r].ch === t && this.chars[r].style === n && this.chars[r].fFamily === i) return this.chars[r]; r += 1 } return ("string" == typeof t && 13 !== t.charCodeAt(0) || !t) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", t, n, i)), e }, getFontByName: function (t) { for (var e = 0, n = this.fonts.length; e < n;) { if (this.fonts[e].fName === t) return this.fonts[e]; e += 1 } return this.fonts[0] }, measureText: function (t, e, n) { var i = this.getFontByName(e), r = t.charCodeAt(0); if (!i.cache[r + 1]) { var s = i.helper; if (" " === t) { var o = s.measureText("|" + t + "|"), a = s.measureText("||"); i.cache[r + 1] = (o - a) / 100 } else i.cache[r + 1] = s.measureText(t) / 100 } return i.cache[r + 1] * n }, checkLoadedFonts: function () { var e, n, i, r = this.fonts.length, s = r; for (e = 0; e < r; e += 1)this.fonts[e].loaded ? s -= 1 : "n" === this.fonts[e].fOrigin || 0 === this.fonts[e].origin ? this.fonts[e].loaded = !0 : (n = this.fonts[e].monoCase.node, i = this.fonts[e].monoCase.w, n.offsetWidth !== i ? (s -= 1, this.fonts[e].loaded = !0) : (n = this.fonts[e].sansCase.node, i = this.fonts[e].sansCase.w, n.offsetWidth !== i && (s -= 1, this.fonts[e].loaded = !0)), this.fonts[e].loaded && (this.fonts[e].sansCase.parent.parentNode.removeChild(this.fonts[e].sansCase.parent), this.fonts[e].monoCase.parent.parentNode.removeChild(this.fonts[e].monoCase.parent))); 0 !== s && Date.now() - this.initTime < t ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10) }, setIsLoaded: function () { this.isLoaded = !0 } }; return a.prototype = l, a }(); function RenderableElement() { } RenderableElement.prototype = { initRenderable: function () { this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [] }, addRenderableComponent: function (t) { -1 === this.renderableComponents.indexOf(t) && this.renderableComponents.push(t) }, removeRenderableComponent: function (t) { -1 !== this.renderableComponents.indexOf(t) && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1) }, prepareRenderableFrame: function (t) { this.checkLayerLimits(t) }, checkTransparency: function () { this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show()) }, checkLayerLimits: function (t) { this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide()) }, renderRenderable: function () { var t, e = this.renderableComponents.length; for (t = 0; t < e; t += 1)this.renderableComponents[t].renderFrame(this._isFirstFrame) }, sourceRectAtTime: function () { return { top: 0, left: 0, width: 100, height: 100 } }, getLayerSize: function () { return 5 === this.data.ty ? { w: this.data.textData.width, h: this.data.textData.height } : { w: this.data.width, h: this.data.height } } }; var getBlendMode = (blendModeEnums = { 0: "source-over", 1: "multiply", 2: "screen", 3: "overlay", 4: "darken", 5: "lighten", 6: "color-dodge", 7: "color-burn", 8: "hard-light", 9: "soft-light", 10: "difference", 11: "exclusion", 12: "hue", 13: "saturation", 14: "color", 15: "luminosity" }, function (t) { return blendModeEnums[t] || "" }), blendModeEnums; function SliderEffect(t, e, n) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, n) } function AngleEffect(t, e, n) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, n) } function ColorEffect(t, e, n) { this.p = PropertyFactory.getProp(e, t.v, 1, 0, n) } function PointEffect(t, e, n) { this.p = PropertyFactory.getProp(e, t.v, 1, 0, n) } function LayerIndexEffect(t, e, n) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, n) } function MaskIndexEffect(t, e, n) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, n) } function CheckboxEffect(t, e, n) { this.p = PropertyFactory.getProp(e, t.v, 0, 0, n) } function NoValueEffect() { this.p = {} } function EffectsManager(t, e) { var n, i = t.ef || []; this.effectElements = []; var r, s = i.length; for (n = 0; n < s; n += 1)r = new GroupEffect(i[n], e), this.effectElements.push(r) } function GroupEffect(t, e) { this.init(t, e) } function BaseElement() { } function FrameElement() { } function FootageElement(t, e, n) { this.initFrame(), this.initRenderable(), this.assetData = e.getAssetData(t.refId), this.footageData = e.imageLoader.getAsset(this.assetData), this.initBaseData(t, e, n) } function AudioElement(t, e, n) { this.initFrame(), this.initRenderable(), this.assetData = e.getAssetData(t.refId), this.initBaseData(t, e, n), this._isPlaying = !1, this._canPlay = !1; var i = this.globalData.getAssetsPath(this.assetData); this.audio = this.globalData.audioController.createAudio(i), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : { _placeholder: !0 }, this.lv = PropertyFactory.getProp(this, t.au && t.au.lv ? t.au.lv : { k: [100] }, 1, .01, this) } function BaseRenderer() { } function TransformElement() { } function MaskElement(t, e, n) { this.data = t, this.element = e, this.globalData = n, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null; var i, r, s = this.globalData.defs, o = this.masksProperties ? this.masksProperties.length : 0; this.viewData = createSizedArray(o), this.solidPath = ""; var a, l, h, c, u, d, p = this.masksProperties, f = 0, m = [], g = createElementID(), v = "clipPath", A = "clip-path"; for (i = 0; i < o; i += 1)if (("a" !== p[i].mode && "n" !== p[i].mode || p[i].inv || 100 !== p[i].o.k || p[i].o.x) && (v = "mask", A = "mask"), "s" !== p[i].mode && "i" !== p[i].mode || 0 !== f ? h = null : ((h = createNS("rect")).setAttribute("fill", "#ffffff"), h.setAttribute("width", this.element.comp.data.w || 0), h.setAttribute("height", this.element.comp.data.h || 0), m.push(h)), r = createNS("path"), "n" === p[i].mode) this.viewData[i] = { op: PropertyFactory.getProp(this.element, p[i].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, p[i], 3), elem: r, lastPath: "" }, s.appendChild(r); else { var b; if (f += 1, r.setAttribute("fill", "s" === p[i].mode ? "#000000" : "#ffffff"), r.setAttribute("clip-rule", "nonzero"), 0 !== p[i].x.k ? (v = "mask", A = "mask", d = PropertyFactory.getProp(this.element, p[i].x, 0, null, this.element), b = createElementID(), (c = createNS("filter")).setAttribute("id", b), (u = createNS("feMorphology")).setAttribute("operator", "erode"), u.setAttribute("in", "SourceGraphic"), u.setAttribute("radius", "0"), c.appendChild(u), s.appendChild(c), r.setAttribute("stroke", "s" === p[i].mode ? "#000000" : "#ffffff")) : (u = null, d = null), this.storedData[i] = { elem: r, x: d, expan: u, lastPath: "", lastOperator: "", filterId: b, lastRadius: 0 }, "i" === p[i].mode) { l = m.length; var y = createNS("g"); for (a = 0; a < l; a += 1)y.appendChild(m[a]); var x = createNS("mask"); x.setAttribute("mask-type", "alpha"), x.setAttribute("id", g + "_" + f), x.appendChild(r), s.appendChild(x), y.setAttribute("mask", "url(" + getLocationHref() + "#" + g + "_" + f + ")"), m.length = 0, m.push(y) } else m.push(r); p[i].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[i] = { elem: r, lastPath: "", op: PropertyFactory.getProp(this.element, p[i].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, p[i], 3), invRect: h }, this.viewData[i].prop.k || this.drawPath(p[i], this.viewData[i].prop.v, this.viewData[i]) } for (this.maskElement = createNS(v), o = m.length, i = 0; i < o; i += 1)this.maskElement.appendChild(m[i]); f > 0 && (this.maskElement.setAttribute("id", g), this.element.maskedElement.setAttribute(A, "url(" + getLocationHref() + "#" + g + ")"), s.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this) } extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (t, e) { var n; this.data = t, this.effectElements = [], this.initDynamicPropertyContainer(e); var i, r = this.data.ef.length, s = this.data.ef; for (n = 0; n < r; n += 1) { switch (i = null, s[n].ty) { case 0: i = new SliderEffect(s[n], e, this); break; case 1: i = new AngleEffect(s[n], e, this); break; case 2: i = new ColorEffect(s[n], e, this); break; case 3: i = new PointEffect(s[n], e, this); break; case 4: case 7: i = new CheckboxEffect(s[n], e, this); break; case 10: i = new LayerIndexEffect(s[n], e, this); break; case 11: i = new MaskIndexEffect(s[n], e, this); break; case 5: i = new EffectsManager(s[n], e, this); break; default: i = new NoValueEffect(s[n], e, this) }i && this.effectElements.push(i) } }, BaseElement.prototype = { checkMasks: function () { if (!this.data.hasMask) return !1; for (var t = 0, e = this.data.masksProperties.length; t < e;) { if ("n" !== this.data.masksProperties[t].mode && !1 !== this.data.masksProperties[t].cl) return !0; t += 1 } return !1 }, initExpressions: function () { var t = getExpressionInterfaces(); if (t) { var e = t("layer"), n = t("effects"), i = t("shape"), r = t("text"), s = t("comp"); this.layerInterface = e(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager); var o = n.createEffectsInterface(this, this.layerInterface); this.layerInterface.registerEffectsInterface(o), 0 === this.data.ty || this.data.xt ? this.compInterface = s(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = i(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = r(this), this.layerInterface.text = this.layerInterface.textInterface) } }, setBlendMode: function () { var t = getBlendMode(this.data.bm); (this.baseElement || this.layerElement).style["mix-blend-mode"] = t }, initBaseData: function (t, e, n) { this.globalData = e, this.comp = n, this.data = t, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties) }, getType: function () { return this.type }, sourceRectAtTime: function () { } }, FrameElement.prototype = { initFrame: function () { this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1 }, prepareProperties: function (t, e) { var n, i = this.dynamicProperties.length; for (n = 0; n < i; n += 1)(e || this._isParent && "transform" === this.dynamicProperties[n].propType) && (this.dynamicProperties[n].getValue(), this.dynamicProperties[n]._mdf && (this.globalData._mdf = !0, this._mdf = !0)) }, addDynamicProperty: function (t) { -1 === this.dynamicProperties.indexOf(t) && this.dynamicProperties.push(t) } }, FootageElement.prototype.prepareFrame = function () { }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function () { return null }, FootageElement.prototype.renderFrame = function () { }, FootageElement.prototype.destroy = function () { }, FootageElement.prototype.initExpressions = function () { var t = getExpressionInterfaces(); if (t) { var e = t("footage"); this.layerInterface = e(this) } }, FootageElement.prototype.getFootageData = function () { return this.footageData }, AudioElement.prototype.prepareFrame = function (t) { if (this.prepareRenderableFrame(t, !0), this.prepareProperties(t, !0), this.tm._placeholder) this._currentTime = t / this.data.sr; else { var e = this.tm.v; this._currentTime = e } this._volume = this.lv.v[0]; var n = this._volume * this._volumeMultiplier; this._previousVolume !== n && (this._previousVolume = n, this.audio.volume(n)) }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function () { this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0)) }, AudioElement.prototype.show = function () { }, AudioElement.prototype.hide = function () { this.audio.pause(), this._isPlaying = !1 }, AudioElement.prototype.pause = function () { this.audio.pause(), this._isPlaying = !1, this._canPlay = !1 }, AudioElement.prototype.resume = function () { this._canPlay = !0 }, AudioElement.prototype.setRate = function (t) { this.audio.rate(t) }, AudioElement.prototype.volume = function (t) { this._volumeMultiplier = t, this._previousVolume = t * this._volume, this.audio.volume(this._previousVolume) }, AudioElement.prototype.getBaseElement = function () { return null }, AudioElement.prototype.destroy = function () { }, AudioElement.prototype.sourceRectAtTime = function () { }, AudioElement.prototype.initExpressions = function () { }, BaseRenderer.prototype.checkLayers = function (t) { var e, n, i = this.layers.length; for (this.completeLayers = !0, e = i - 1; e >= 0; e -= 1)this.elements[e] || (n = this.layers[e]).ip - n.st <= t - this.layers[e].st && n.op - n.st > t - this.layers[e].st && this.buildItem(e), this.completeLayers = !!this.elements[e] && this.completeLayers; this.checkPendingElements() }, BaseRenderer.prototype.createItem = function (t) { switch (t.ty) { case 2: return this.createImage(t); case 0: return this.createComp(t); case 1: return this.createSolid(t); case 3: default: return this.createNull(t); case 4: return this.createShape(t); case 5: return this.createText(t); case 6: return this.createAudio(t); case 13: return this.createCamera(t); case 15: return this.createFootage(t) } }, BaseRenderer.prototype.createCamera = function () { throw new Error("You're using a 3d camera. Try the html renderer.") }, BaseRenderer.prototype.createAudio = function (t) { return new AudioElement(t, this.globalData, this) }, BaseRenderer.prototype.createFootage = function (t) { return new FootageElement(t, this.globalData, this) }, BaseRenderer.prototype.buildAllItems = function () { var t, e = this.layers.length; for (t = 0; t < e; t += 1)this.buildItem(t); this.checkPendingElements() }, BaseRenderer.prototype.includeLayers = function (t) { var e; this.completeLayers = !1; var n, i = t.length, r = this.layers.length; for (e = 0; e < i; e += 1)for (n = 0; n < r;) { if (this.layers[n].id === t[e].id) { this.layers[n] = t[e]; break } n += 1 } }, BaseRenderer.prototype.setProjectInterface = function (t) { this.globalData.projectInterface = t }, BaseRenderer.prototype.initItems = function () { this.globalData.progressiveLoad || this.buildAllItems() }, BaseRenderer.prototype.buildElementParenting = function (t, e, n) { for (var i = this.elements, r = this.layers, s = 0, o = r.length; s < o;)r[s].ind == e && (i[s] && !0 !== i[s] ? (n.push(i[s]), i[s].setAsParent(), void 0 !== r[s].parent ? this.buildElementParenting(t, r[s].parent, n) : t.setHierarchy(n)) : (this.buildItem(s), this.addPendingElement(t))), s += 1 }, BaseRenderer.prototype.addPendingElement = function (t) { this.pendingElements.push(t) }, BaseRenderer.prototype.searchExtraCompositions = function (t) { var e, n = t.length; for (e = 0; e < n; e += 1)if (t[e].xt) { var i = this.createComp(t[e]); i.initExpressions(), this.globalData.projectInterface.registerComposition(i) } }, BaseRenderer.prototype.getElementById = function (t) { var e, n = this.elements.length; for (e = 0; e < n; e += 1)if (this.elements[e].data.ind === t) return this.elements[e]; return null }, BaseRenderer.prototype.getElementByPath = function (t) { var e, n = t.shift(); if ("number" == typeof n) e = this.elements[n]; else { var i, r = this.elements.length; for (i = 0; i < r; i += 1)if (this.elements[i].data.nm === n) { e = this.elements[i]; break } } return 0 === t.length ? e : e.getElementByPath(t) }, BaseRenderer.prototype.setupGlobalData = function (t, e) { this.globalData.fontManager = new FontManager, this.globalData.fontManager.addChars(t.chars), this.globalData.fontManager.addFonts(t.fonts, e), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = t.fr, this.globalData.nm = t.nm, this.globalData.compSize = { w: t.w, h: t.h } }, TransformElement.prototype = { initTransform: function () { this.finalTransform = { mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 }, _matMdf: !1, _opMdf: !1, mat: new Matrix }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty }, renderTransform: function () { if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) { var t, e = this.finalTransform.mat, n = 0, i = this.hierarchy.length; if (!this.finalTransform._matMdf) for (; n < i;) { if (this.hierarchy[n].finalTransform.mProp._mdf) { this.finalTransform._matMdf = !0; break } n += 1 } if (this.finalTransform._matMdf) for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), n = 0; n < i; n += 1)t = this.hierarchy[n].finalTransform.mProp.v.props, e.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]) } }, globalToLocal: function (t) { var e = []; e.push(this.finalTransform); for (var n, i = !0, r = this.comp; i;)r.finalTransform ? (r.data.hasMask && e.splice(0, 0, r.finalTransform), r = r.comp) : i = !1; var s, o = e.length; for (n = 0; n < o; n += 1)s = e[n].mat.applyToPointArray(0, 0, 0), t = [t[0] - s[0], t[1] - s[1], 0]; return t }, mHelper: new Matrix }, MaskElement.prototype.getMaskProperty = function (t) { return this.viewData[t].prop }, MaskElement.prototype.renderFrame = function (t) { var e, n = this.element.finalTransform.mat, i = this.masksProperties.length; for (e = 0; e < i; e += 1)if ((this.viewData[e].prop._mdf || t) && this.drawPath(this.masksProperties[e], this.viewData[e].prop.v, this.viewData[e]), (this.viewData[e].op._mdf || t) && this.viewData[e].elem.setAttribute("fill-opacity", this.viewData[e].op.v), "n" !== this.masksProperties[e].mode && (this.viewData[e].invRect && (this.element.finalTransform.mProp._mdf || t) && this.viewData[e].invRect.setAttribute("transform", n.getInverseMatrix().to2dCSS()), this.storedData[e].x && (this.storedData[e].x._mdf || t))) { var r = this.storedData[e].expan; this.storedData[e].x.v < 0 ? ("erode" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "erode", this.storedData[e].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[e].filterId + ")")), r.setAttribute("radius", -this.storedData[e].x.v)) : ("dilate" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "dilate", this.storedData[e].elem.setAttribute("filter", null)), this.storedData[e].elem.setAttribute("stroke-width", 2 * this.storedData[e].x.v)) } }, MaskElement.prototype.getMaskelement = function () { return this.maskElement }, MaskElement.prototype.createLayerSolidPath = function () { var t = "M0,0 "; return t += " h" + this.globalData.compSize.w, t += " v" + this.globalData.compSize.h, t += " h-" + this.globalData.compSize.w, t += " v-" + this.globalData.compSize.h + " " }, MaskElement.prototype.drawPath = function (t, e, n) { var i, r, s = " M" + e.v[0][0] + "," + e.v[0][1]; for (r = e._length, i = 1; i < r; i += 1)s += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[i][0] + "," + e.i[i][1] + " " + e.v[i][0] + "," + e.v[i][1]; if (e.c && r > 1 && (s += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[0][0] + "," + e.i[0][1] + " " + e.v[0][0] + "," + e.v[0][1]), n.lastPath !== s) { var o = ""; n.elem && (e.c && (o = t.inv ? this.solidPath + s : s), n.elem.setAttribute("d", o)), n.lastPath = s } }, MaskElement.prototype.destroy = function () { this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null }; var filtersFactory = function () { var t = { createFilter: function (t, e) { var n = createNS("filter"); return n.setAttribute("id", t), !0 !== e && (n.setAttribute("filterUnits", "objectBoundingBox"), n.setAttribute("x", "0%"), n.setAttribute("y", "0%"), n.setAttribute("width", "100%"), n.setAttribute("height", "100%")), n }, createAlphaToLuminanceFilter: function () { var t = createNS("feColorMatrix"); return t.setAttribute("type", "matrix"), t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), t } }; return t }(), featureSupport = function () { var t = { maskType: !0, svgLumaHidden: !0, offscreenCanvas: "undefined" != typeof OffscreenCanvas }; return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (t.maskType = !1), /firefox/i.test(navigator.userAgent) && (t.svgLumaHidden = !1), t }(), registeredEffects = {}, idPrefix = "filter_result_"; function SVGEffects(t) { var e, n, i = "SourceGraphic", r = t.data.ef ? t.data.ef.length : 0, s = createElementID(), o = filtersFactory.createFilter(s, !0), a = 0; for (this.filters = [], e = 0; e < r; e += 1) { n = null; var l = t.data.ef[e].ty; registeredEffects[l] && (n = new (0, registeredEffects[l].effect)(o, t.effectsManager.effectElements[e], t, idPrefix + a, i), i = idPrefix + a, registeredEffects[l].countsAsEffect && (a += 1)), n && this.filters.push(n) } a && (t.globalData.defs.appendChild(o), t.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + s + ")")), this.filters.length && t.addRenderableComponent(this) } function registerEffect(t, e, n) { registeredEffects[t] = { effect: e, countsAsEffect: n } } function SVGBaseElement() { } function HierarchyElement() { } function RenderableDOMElement() { } function IImageElement(t, e, n) { this.assetData = e.getAssetData(t.refId), this.initElement(t, e, n), this.sourceRect = { top: 0, left: 0, width: this.assetData.w, height: this.assetData.h } } function ProcessedElement(t, e) { this.elem = t, this.pos = e } function IShapeElement() { } SVGEffects.prototype.renderFrame = function (t) { var e, n = this.filters.length; for (e = 0; e < n; e += 1)this.filters[e].renderFrame(t) }, SVGBaseElement.prototype = { initRendererElement: function () { this.layerElement = createNS("g") }, createContainerElements: function () { this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1; var t = null; if (this.data.td) { this.matteMasks = {}; var e = createNS("g"); e.setAttribute("id", this.layerId), e.appendChild(this.layerElement), t = e, this.globalData.defs.appendChild(e) } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), t = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement; if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 === this.data.ty && !this.data.hd) { var n = createNS("clipPath"), i = createNS("path"); i.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z"); var r = createElementID(); if (n.setAttribute("id", r), n.appendChild(i), this.globalData.defs.appendChild(n), this.checkMasks()) { var s = createNS("g"); s.setAttribute("clip-path", "url(" + getLocationHref() + "#" + r + ")"), s.appendChild(this.layerElement), this.transformedElement = s, t ? t.appendChild(this.transformedElement) : this.baseElement = this.transformedElement } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + r + ")") } 0 !== this.data.bm && this.setBlendMode() }, renderElement: function () { this.finalTransform._matMdf && this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v) }, destroyBaseElement: function () { this.layerElement = null, this.matteElement = null, this.maskManager.destroy() }, getBaseElement: function () { return this.data.hd ? null : this.baseElement }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this) }, getMatte: function (t) { if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[t]) { var e, n, i, r, s = this.layerId + "_" + t; if (1 === t || 3 === t) { var o = createNS("mask"); o.setAttribute("id", s), o.setAttribute("mask-type", 3 === t ? "luminance" : "alpha"), (i = createNS("use")).setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), o.appendChild(i), this.globalData.defs.appendChild(o), featureSupport.maskType || 1 !== t || (o.setAttribute("mask-type", "luminance"), e = createElementID(), n = filtersFactory.createFilter(e), this.globalData.defs.appendChild(n), n.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (r = createNS("g")).appendChild(i), o.appendChild(r), r.setAttribute("filter", "url(" + getLocationHref() + "#" + e + ")")) } else if (2 === t) { var a = createNS("mask"); a.setAttribute("id", s), a.setAttribute("mask-type", "alpha"); var l = createNS("g"); a.appendChild(l), e = createElementID(), n = filtersFactory.createFilter(e); var h = createNS("feComponentTransfer"); h.setAttribute("in", "SourceGraphic"), n.appendChild(h); var c = createNS("feFuncA"); c.setAttribute("type", "table"), c.setAttribute("tableValues", "1.0 0.0"), h.appendChild(c), this.globalData.defs.appendChild(n); var u = createNS("rect"); u.setAttribute("width", this.comp.data.w), u.setAttribute("height", this.comp.data.h), u.setAttribute("x", "0"), u.setAttribute("y", "0"), u.setAttribute("fill", "#ffffff"), u.setAttribute("opacity", "0"), l.setAttribute("filter", "url(" + getLocationHref() + "#" + e + ")"), l.appendChild(u), (i = createNS("use")).setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), l.appendChild(i), featureSupport.maskType || (a.setAttribute("mask-type", "luminance"), n.appendChild(filtersFactory.createAlphaToLuminanceFilter()), r = createNS("g"), l.appendChild(u), r.appendChild(this.layerElement), l.appendChild(r)), this.globalData.defs.appendChild(a) } this.matteMasks[t] = s } return this.matteMasks[t] }, setMatte: function (t) { this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + t + ")") } }, HierarchyElement.prototype = { initHierarchy: function () { this.hierarchy = [], this._isParent = !1, this.checkParenting() }, setHierarchy: function (t) { this.hierarchy = t }, setAsParent: function () { this._isParent = !0 }, checkParenting: function () { void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, []) } }, extendPrototype([RenderableElement, createProxyFunction({ initElement: function (t, e, n) { this.initFrame(), this.initBaseData(t, e, n), this.initTransform(t, e, n), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide() }, hide: function () { this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none", this.hidden = !0) }, show: function () { this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"), this.hidden = !1, this._isFirstFrame = !0) }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, renderInnerContent: function () { }, prepareFrame: function (t) { this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.checkTransparency() }, destroy: function () { this.innerElem = null, this.destroyBaseElement() } })], RenderableDOMElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () { var t = this.globalData.getAssetsPath(this.assetData); this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.innerElem) }, IImageElement.prototype.sourceRectAtTime = function () { return this.sourceRect }, IShapeElement.prototype = { addShapeToModifiers: function (t) { var e, n = this.shapeModifiers.length; for (e = 0; e < n; e += 1)this.shapeModifiers[e].addShape(t) }, isShapeInAnimatedModifiers: function (t) { for (var e = this.shapeModifiers.length; 0 < e;)if (this.shapeModifiers[0].isAnimatedWithShape(t)) return !0; return !1 }, renderModifiers: function () { if (this.shapeModifiers.length) { var t, e = this.shapes.length; for (t = 0; t < e; t += 1)this.shapes[t].sh.reset(); for (t = (e = this.shapeModifiers.length) - 1; t >= 0 && !this.shapeModifiers[t].processShapes(this._isFirstFrame); t -= 1); } }, searchProcessedElement: function (t) { for (var e = this.processedElements, n = 0, i = e.length; n < i;) { if (e[n].elem === t) return e[n].pos; n += 1 } return 0 }, addProcessedElement: function (t, e) { for (var n = this.processedElements, i = n.length; i;)if (n[i -= 1].elem === t) return void (n[i].pos = e); n.push(new ProcessedElement(t, e)) }, prepareFrame: function (t) { this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange) } }; var lineCapEnum = { 1: "butt", 2: "round", 3: "square" }, lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" }; function SVGShapeData(t, e, n) { this.caches = [], this.styles = [], this.transformers = t, this.lStr = "", this.sh = n, this.lvl = e, this._isAnimated = !!n.k; for (var i = 0, r = t.length; i < r;) { if (t[i].mProps.dynamicProperties.length) { this._isAnimated = !0; break } i += 1 } } function SVGStyleData(t, e) { this.data = t, this.type = t.ty, this.d = "", this.lvl = e, this._mdf = !1, this.closed = !0 === t.hd, this.pElem = createNS("path"), this.msElem = null } function DashProperty(t, e, n, i) { var r; this.elem = t, this.frameId = -1, this.dataProps = createSizedArray(e.length), this.renderer = n, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", e.length ? e.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(i); var s, o = e.length || 0; for (r = 0; r < o; r += 1)s = PropertyFactory.getProp(t, e[r].v, 0, 0, this), this.k = s.k || this.k, this.dataProps[r] = { n: e[r].n, p: s }; this.k || this.getValue(!0), this._isAnimated = this.k } function SVGStrokeStyleData(t, e, n) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = n, this._isAnimated = !!this._isAnimated } function SVGFillStyleData(t, e, n) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = n } function SVGNoStyleData(t, e, n) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.style = n } function GradientProperty(t, e, n) { this.data = e, this.c = createTypedArray("uint8c", 4 * e.p); var i = e.k.k[0].s ? e.k.k[0].s.length - 4 * e.p : e.k.k.length - 4 * e.p; this.o = createTypedArray("float32", i), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = i, this.initDynamicPropertyContainer(n), this.prop = PropertyFactory.getProp(t, e.k, 1, null, this), this.k = this.prop.k, this.getValue(!0) } function SVGGradientFillStyleData(t, e, n) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.initGradientData(t, e, n) } function SVGGradientStrokeStyleData(t, e, n) { this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.initGradientData(t, e, n), this._isAnimated = !!this._isAnimated } function ShapeGroupData() { this.it = [], this.prevViewData = [], this.gr = createNS("g") } function SVGTransformData(t, e, n) { this.transform = { mProps: t, op: e, container: n }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length } SVGShapeData.prototype.setAsAnimated = function () { this._isAnimated = !0 }, SVGStyleData.prototype.reset = function () { this.d = "", this._mdf = !1 }, DashProperty.prototype.getValue = function (t) { if ((this.elem.globalData.frameId !== this.frameId || t) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || t, this._mdf)) { var e = 0, n = this.dataProps.length; for ("svg" === this.renderer && (this.dashStr = ""), e = 0; e < n; e += 1)"o" !== this.dataProps[e].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[e].p.v : this.dashArray[e] = this.dataProps[e].p.v : this.dashoffset[0] = this.dataProps[e].p.v } }, extendPrototype([DynamicPropertyContainer], DashProperty), extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), extendPrototype([DynamicPropertyContainer], SVGNoStyleData), GradientProperty.prototype.comparePoints = function (t, e) { for (var n = 0, i = this.o.length / 2; n < i;) { if (Math.abs(t[4 * n] - t[4 * e + 2 * n]) > .01) return !1; n += 1 } return !0 }, GradientProperty.prototype.checkCollapsable = function () { if (this.o.length / 2 != this.c.length / 4) return !1; if (this.data.k.k[0].s) for (var t = 0, e = this.data.k.k.length; t < e;) { if (!this.comparePoints(this.data.k.k[t].s, this.data.p)) return !1; t += 1 } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1; return !0 }, GradientProperty.prototype.getValue = function (t) { if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || t) { var e, n, i, r = 4 * this.data.p; for (e = 0; e < r; e += 1)n = e % 4 == 0 ? 100 : 255, i = Math.round(this.prop.v[e] * n), this.c[e] !== i && (this.c[e] = i, this._cmdf = !t); if (this.o.length) for (r = this.prop.v.length, e = 4 * this.data.p; e < r; e += 1)n = e % 2 == 0 ? 100 : 1, i = e % 2 == 0 ? Math.round(100 * this.prop.v[e]) : this.prop.v[e], this.o[e - 4 * this.data.p] !== i && (this.o[e - 4 * this.data.p] = i, this._omdf = !t); this._mdf = !t } }, extendPrototype([DynamicPropertyContainer], GradientProperty), SVGGradientFillStyleData.prototype.initGradientData = function (t, e, n) { this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.s = PropertyFactory.getProp(t, e.s, 1, null, this), this.e = PropertyFactory.getProp(t, e.e, 1, null, this), this.h = PropertyFactory.getProp(t, e.h || { k: 0 }, 0, .01, this), this.a = PropertyFactory.getProp(t, e.a || { k: 0 }, 0, degToRads, this), this.g = new GradientProperty(t, e.g, this), this.style = n, this.stops = [], this.setGradientData(n.pElem, e), this.setGradientOpacity(e, n), this._isAnimated = !!this._isAnimated }, SVGGradientFillStyleData.prototype.setGradientData = function (t, e) { var n = createElementID(), i = createNS(1 === e.t ? "linearGradient" : "radialGradient"); i.setAttribute("id", n), i.setAttribute("spreadMethod", "pad"), i.setAttribute("gradientUnits", "userSpaceOnUse"); var r, s, o, a = []; for (o = 4 * e.g.p, s = 0; s < o; s += 4)r = createNS("stop"), i.appendChild(r), a.push(r); t.setAttribute("gf" === e.ty ? "fill" : "stroke", "url(" + getLocationHref() + "#" + n + ")"), this.gf = i, this.cst = a }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (t, e) { if (this.g._hasOpacity && !this.g._collapsable) { var n, i, r, s = createNS("mask"), o = createNS("path"); s.appendChild(o); var a = createElementID(), l = createElementID(); s.setAttribute("id", l); var h = createNS(1 === t.t ? "linearGradient" : "radialGradient"); h.setAttribute("id", a), h.setAttribute("spreadMethod", "pad"), h.setAttribute("gradientUnits", "userSpaceOnUse"), r = t.g.k.k[0].s ? t.g.k.k[0].s.length : t.g.k.k.length; var c = this.stops; for (i = 4 * t.g.p; i < r; i += 2)(n = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"), h.appendChild(n), c.push(n); o.setAttribute("gf" === t.ty ? "fill" : "stroke", "url(" + getLocationHref() + "#" + a + ")"), "gs" === t.ty && (o.setAttribute("stroke-linecap", lineCapEnum[t.lc || 2]), o.setAttribute("stroke-linejoin", lineJoinEnum[t.lj || 2]), 1 === t.lj && o.setAttribute("stroke-miterlimit", t.ml)), this.of = h, this.ms = s, this.ost = c, this.maskId = l, e.msElem = o } }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData); var buildShapeString = function (t, e, n, i) { if (0 === e) return ""; var r, s = t.o, o = t.i, a = t.v, l = " M" + i.applyToPointStringified(a[0][0], a[0][1]); for (r = 1; r < e; r += 1)l += " C" + i.applyToPointStringified(s[r - 1][0], s[r - 1][1]) + " " + i.applyToPointStringified(o[r][0], o[r][1]) + " " + i.applyToPointStringified(a[r][0], a[r][1]); return n && e && (l += " C" + i.applyToPointStringified(s[r - 1][0], s[r - 1][1]) + " " + i.applyToPointStringified(o[0][0], o[0][1]) + " " + i.applyToPointStringified(a[0][0], a[0][1]), l += "z"), l }, SVGElementsRenderer = function () { var t = new Matrix, e = new Matrix; function n(t, e, n) { (n || e.transform.op._mdf) && e.transform.container.setAttribute("opacity", e.transform.op.v), (n || e.transform.mProps._mdf) && e.transform.container.setAttribute("transform", e.transform.mProps.v.to2dCSS()) } function i() { } function r(n, i, r) { var s, o, a, l, h, c, u, d, p, f, m, g = i.styles.length, v = i.lvl; for (c = 0; c < g; c += 1) { if (l = i.sh._mdf || r, i.styles[c].lvl < v) { for (d = e.reset(), f = v - i.styles[c].lvl, m = i.transformers.length - 1; !l && f > 0;)l = i.transformers[m].mProps._mdf || l, f -= 1, m -= 1; if (l) for (f = v - i.styles[c].lvl, m = i.transformers.length - 1; f > 0;)p = i.transformers[m].mProps.v.props, d.transform(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]), f -= 1, m -= 1 } else d = t; if (o = (u = i.sh.paths)._length, l) { for (a = "", s = 0; s < o; s += 1)(h = u.shapes[s]) && h._length && (a += buildShapeString(h, h._length, h.c, d)); i.caches[c] = a } else a = i.caches[c]; i.styles[c].d += !0 === n.hd ? "" : a, i.styles[c]._mdf = l || i.styles[c]._mdf } } function s(t, e, n) { var i = e.style; (e.c._mdf || n) && i.pElem.setAttribute("fill", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || n) && i.pElem.setAttribute("fill-opacity", e.o.v) } function o(t, e, n) { a(t, e, n), l(0, e, n) } function a(t, e, n) { var i, r, s, o, a, l = e.gf, h = e.g._hasOpacity, c = e.s.v, u = e.e.v; if (e.o._mdf || n) { var d = "gf" === t.ty ? "fill-opacity" : "stroke-opacity"; e.style.pElem.setAttribute(d, e.o.v) } if (e.s._mdf || n) { var p = 1 === t.t ? "x1" : "cx", f = "x1" === p ? "y1" : "cy"; l.setAttribute(p, c[0]), l.setAttribute(f, c[1]), h && !e.g._collapsable && (e.of.setAttribute(p, c[0]), e.of.setAttribute(f, c[1])) } if (e.g._cmdf || n) { i = e.cst; var m = e.g.c; for (s = i.length, r = 0; r < s; r += 1)(o = i[r]).setAttribute("offset", m[4 * r] + "%"), o.setAttribute("stop-color", "rgb(" + m[4 * r + 1] + "," + m[4 * r + 2] + "," + m[4 * r + 3] + ")") } if (h && (e.g._omdf || n)) { var g = e.g.o; for (s = (i = e.g._collapsable ? e.cst : e.ost).length, r = 0; r < s; r += 1)o = i[r], e.g._collapsable || o.setAttribute("offset", g[2 * r] + "%"), o.setAttribute("stop-opacity", g[2 * r + 1]) } if (1 === t.t) (e.e._mdf || n) && (l.setAttribute("x2", u[0]), l.setAttribute("y2", u[1]), h && !e.g._collapsable && (e.of.setAttribute("x2", u[0]), e.of.setAttribute("y2", u[1]))); else if ((e.s._mdf || e.e._mdf || n) && (a = Math.sqrt(Math.pow(c[0] - u[0], 2) + Math.pow(c[1] - u[1], 2)), l.setAttribute("r", a), h && !e.g._collapsable && e.of.setAttribute("r", a)), e.e._mdf || e.h._mdf || e.a._mdf || n) { a || (a = Math.sqrt(Math.pow(c[0] - u[0], 2) + Math.pow(c[1] - u[1], 2))); var v = Math.atan2(u[1] - c[1], u[0] - c[0]), A = e.h.v; A >= 1 ? A = .99 : A <= -1 && (A = -.99); var b = a * A, y = Math.cos(v + e.a.v) * b + c[0], x = Math.sin(v + e.a.v) * b + c[1]; l.setAttribute("fx", y), l.setAttribute("fy", x), h && !e.g._collapsable && (e.of.setAttribute("fx", y), e.of.setAttribute("fy", x)) } } function l(t, e, n) { var i = e.style, r = e.d; r && (r._mdf || n) && r.dashStr && (i.pElem.setAttribute("stroke-dasharray", r.dashStr), i.pElem.setAttribute("stroke-dashoffset", r.dashoffset[0])), e.c && (e.c._mdf || n) && i.pElem.setAttribute("stroke", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || n) && i.pElem.setAttribute("stroke-opacity", e.o.v), (e.w._mdf || n) && (i.pElem.setAttribute("stroke-width", e.w.v), i.msElem && i.msElem.setAttribute("stroke-width", e.w.v)) } return { createRenderFunction: function (t) { switch (t.ty) { case "fl": return s; case "gf": return a; case "gs": return o; case "st": return l; case "sh": case "el": case "rc": case "sr": return r; case "tr": return n; case "no": return i; default: return null } } } }(); function SVGShapeElement(t, e, n) { this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(t, e, n), this.prevViewData = [] } function LetterProps(t, e, n, i, r, s) { this.o = t, this.sw = e, this.sc = n, this.fc = i, this.m = r, this.p = s, this._mdf = { o: !0, sw: !!e, sc: !!n, fc: !!i, m: !0, p: !0 } } function TextProperty(t, e) { this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, this.data = e, this.elem = t, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = { ascent: 0, boxWidth: this.defaultBoxWidth, f: "", fStyle: "", fWeight: "", fc: "", j: "", justifyOffset: "", l: [], lh: 0, lineWidths: [], ls: "", of: "", s: "", sc: "", sw: 0, t: 0, tr: 0, sz: 0, ps: null, fillColorAnim: !1, strokeColorAnim: !1, strokeWidthAnim: !1, yOffset: 0, finalSize: 0, finalText: [], finalLineHeight: 0, __complete: !1 }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData) } extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () { }, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () { }, SVGShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes() }, SVGShapeElement.prototype.filterUniqueShapes = function () { var t, e, n, i, r = this.shapes.length, s = this.stylesList.length, o = [], a = !1; for (n = 0; n < s; n += 1) { for (i = this.stylesList[n], a = !1, o.length = 0, t = 0; t < r; t += 1)-1 !== (e = this.shapes[t]).styles.indexOf(i) && (o.push(e), a = e._isAnimated || a); o.length > 1 && a && this.setShapesAsAnimated(o) } }, SVGShapeElement.prototype.setShapesAsAnimated = function (t) { var e, n = t.length; for (e = 0; e < n; e += 1)t[e].setAsAnimated() }, SVGShapeElement.prototype.createStyleElement = function (t, e) { var n, i = new SVGStyleData(t, e), r = i.pElem; return "st" === t.ty ? n = new SVGStrokeStyleData(this, t, i) : "fl" === t.ty ? n = new SVGFillStyleData(this, t, i) : "gf" === t.ty || "gs" === t.ty ? (n = new ("gf" === t.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, t, i), this.globalData.defs.appendChild(n.gf), n.maskId && (this.globalData.defs.appendChild(n.ms), this.globalData.defs.appendChild(n.of), r.setAttribute("mask", "url(" + getLocationHref() + "#" + n.maskId + ")"))) : "no" === t.ty && (n = new SVGNoStyleData(this, t, i)), "st" !== t.ty && "gs" !== t.ty || (r.setAttribute("stroke-linecap", lineCapEnum[t.lc || 2]), r.setAttribute("stroke-linejoin", lineJoinEnum[t.lj || 2]), r.setAttribute("fill-opacity", "0"), 1 === t.lj && r.setAttribute("stroke-miterlimit", t.ml)), 2 === t.r && r.setAttribute("fill-rule", "evenodd"), t.ln && r.setAttribute("id", t.ln), t.cl && r.setAttribute("class", t.cl), t.bm && (r.style["mix-blend-mode"] = getBlendMode(t.bm)), this.stylesList.push(i), this.addToAnimatedContents(t, n), n }, SVGShapeElement.prototype.createGroupElement = function (t) { var e = new ShapeGroupData; return t.ln && e.gr.setAttribute("id", t.ln), t.cl && e.gr.setAttribute("class", t.cl), t.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(t.bm)), e }, SVGShapeElement.prototype.createTransformElement = function (t, e) { var n = TransformPropertyFactory.getTransformProperty(this, t, this), i = new SVGTransformData(n, n.o, e); return this.addToAnimatedContents(t, i), i }, SVGShapeElement.prototype.createShapeElement = function (t, e, n) { var i = 4; "rc" === t.ty ? i = 5 : "el" === t.ty ? i = 6 : "sr" === t.ty && (i = 7); var r = new SVGShapeData(e, n, ShapePropertyFactory.getShapeProp(this, t, i, this)); return this.shapes.push(r), this.addShapeToModifiers(r), this.addToAnimatedContents(t, r), r }, SVGShapeElement.prototype.addToAnimatedContents = function (t, e) { for (var n = 0, i = this.animatedContents.length; n < i;) { if (this.animatedContents[n].element === e) return; n += 1 } this.animatedContents.push({ fn: SVGElementsRenderer.createRenderFunction(t), element: e, data: t }) }, SVGShapeElement.prototype.setElementStyles = function (t) { var e, n = t.styles, i = this.stylesList.length; for (e = 0; e < i; e += 1)this.stylesList[e].closed || n.push(this.stylesList[e]) }, SVGShapeElement.prototype.reloadShapes = function () { var t; this._isFirstFrame = !0; var e = this.itemsData.length; for (t = 0; t < e; t += 1)this.prevViewData[t] = this.itemsData[t]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), e = this.dynamicProperties.length, t = 0; t < e; t += 1)this.dynamicProperties[t].getValue(); this.renderModifiers() }, SVGShapeElement.prototype.searchShapes = function (t, e, n, i, r, s, o) { var a, l, h, c, u, d, p = [].concat(s), f = t.length - 1, m = [], g = []; for (a = f; a >= 0; a -= 1) { if ((d = this.searchProcessedElement(t[a])) ? e[a] = n[d - 1] : t[a]._render = o, "fl" === t[a].ty || "st" === t[a].ty || "gf" === t[a].ty || "gs" === t[a].ty || "no" === t[a].ty) d ? e[a].style.closed = !1 : e[a] = this.createStyleElement(t[a], r), t[a]._render && e[a].style.pElem.parentNode !== i && i.appendChild(e[a].style.pElem), m.push(e[a].style); else if ("gr" === t[a].ty) { if (d) for (h = e[a].it.length, l = 0; l < h; l += 1)e[a].prevViewData[l] = e[a].it[l]; else e[a] = this.createGroupElement(t[a]); this.searchShapes(t[a].it, e[a].it, e[a].prevViewData, e[a].gr, r + 1, p, o), t[a]._render && e[a].gr.parentNode !== i && i.appendChild(e[a].gr) } else "tr" === t[a].ty ? (d || (e[a] = this.createTransformElement(t[a], i)), c = e[a].transform, p.push(c)) : "sh" === t[a].ty || "rc" === t[a].ty || "el" === t[a].ty || "sr" === t[a].ty ? (d || (e[a] = this.createShapeElement(t[a], p, r)), this.setElementStyles(e[a])) : "tm" === t[a].ty || "rd" === t[a].ty || "ms" === t[a].ty || "pb" === t[a].ty || "zz" === t[a].ty || "op" === t[a].ty ? (d ? (u = e[a]).closed = !1 : ((u = ShapeModifiers.getModifier(t[a].ty)).init(this, t[a]), e[a] = u, this.shapeModifiers.push(u)), g.push(u)) : "rp" === t[a].ty && (d ? (u = e[a]).closed = !0 : (u = ShapeModifiers.getModifier(t[a].ty), e[a] = u, u.init(this, t, a, e), this.shapeModifiers.push(u), o = !1), g.push(u)); this.addProcessedElement(t[a], a + 1) } for (f = m.length, a = 0; a < f; a += 1)m[a].closed = !0; for (f = g.length, a = 0; a < f; a += 1)g[a].closed = !0 }, SVGShapeElement.prototype.renderInnerContent = function () { var t; this.renderModifiers(); var e = this.stylesList.length; for (t = 0; t < e; t += 1)this.stylesList[t].reset(); for (this.renderShape(), t = 0; t < e; t += 1)(this.stylesList[t]._mdf || this._isFirstFrame) && (this.stylesList[t].msElem && (this.stylesList[t].msElem.setAttribute("d", this.stylesList[t].d), this.stylesList[t].d = "M0 0" + this.stylesList[t].d), this.stylesList[t].pElem.setAttribute("d", this.stylesList[t].d || "M0 0")) }, SVGShapeElement.prototype.renderShape = function () { var t, e, n = this.animatedContents.length; for (t = 0; t < n; t += 1)e = this.animatedContents[t], (this._isFirstFrame || e.element._isAnimated) && !0 !== e.data && e.fn(e.data, e.element, this._isFirstFrame) }, SVGShapeElement.prototype.destroy = function () { this.destroyBaseElement(), this.shapesData = null, this.itemsData = null }, LetterProps.prototype.update = function (t, e, n, i, r, s) { this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1; var o = !1; return this.o !== t && (this.o = t, this._mdf.o = !0, o = !0), this.sw !== e && (this.sw = e, this._mdf.sw = !0, o = !0), this.sc !== n && (this.sc = n, this._mdf.sc = !0, o = !0), this.fc !== i && (this.fc = i, this._mdf.fc = !0, o = !0), this.m !== r && (this.m = r, this._mdf.m = !0, o = !0), !s.length || this.p[0] === s[0] && this.p[1] === s[1] && this.p[4] === s[4] && this.p[5] === s[5] && this.p[12] === s[12] && this.p[13] === s[13] || (this.p = s, this._mdf.p = !0, o = !0), o }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (t, e) { for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]); return t }, TextProperty.prototype.setCurrentData = function (t) { t.__complete || this.completeTextData(t), this.currentData = t, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0 }, TextProperty.prototype.searchProperty = function () { return this.searchKeyframes() }, TextProperty.prototype.searchKeyframes = function () { return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf }, TextProperty.prototype.addEffect = function (t) { this.effectsSequence.push(t), this.elem.addDynamicProperty(this) }, TextProperty.prototype.getValue = function (t) { if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || t) { this.currentData.t = this.data.d.k[this.keysIndex].s.t; var e = this.currentData, n = this.keysIndex; if (this.lock) this.setCurrentData(this.currentData); else { var i; this.lock = !0, this._mdf = !1; var r = this.effectsSequence.length, s = t || this.data.d.k[this.keysIndex].s; for (i = 0; i < r; i += 1)s = n !== this.keysIndex ? this.effectsSequence[i](s, s.t) : this.effectsSequence[i](this.currentData, s.t); e !== s && this.setCurrentData(s), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId } } }, TextProperty.prototype.getKeyframeValue = function () { for (var t = this.data.d.k, e = this.elem.comp.renderedFrame, n = 0, i = t.length; n <= i - 1 && !(n === i - 1 || t[n + 1].t > e);)n += 1; return this.keysIndex !== n && (this.keysIndex = n), this.data.d.k[this.keysIndex].s }, TextProperty.prototype.buildFinalText = function (t) { for (var e, n, i = [], r = 0, s = t.length, o = !1; r < s;)e = t.charCodeAt(r), FontManager.isCombinedCharacter(e) ? i[i.length - 1] += t.charAt(r) : e >= 55296 && e <= 56319 ? (n = t.charCodeAt(r + 1)) >= 56320 && n <= 57343 ? (o || FontManager.isModifier(e, n) ? (i[i.length - 1] += t.substr(r, 2), o = !1) : i.push(t.substr(r, 2)), r += 1) : i.push(t.charAt(r)) : e > 56319 ? (n = t.charCodeAt(r + 1), FontManager.isZeroWidthJoiner(e, n) ? (o = !0, i[i.length - 1] += t.substr(r, 2), r += 1) : i.push(t.charAt(r))) : FontManager.isZeroWidthJoiner(e) ? (i[i.length - 1] += t.charAt(r), o = !0) : i.push(t.charAt(r)), r += 1; return i }, TextProperty.prototype.completeTextData = function (t) { t.__complete = !0; var e, n, i, r, s, o, a, l = this.elem.globalData.fontManager, h = this.data, c = [], u = 0, d = h.m.g, p = 0, f = 0, m = 0, g = [], v = 0, A = 0, b = l.getFontByName(t.f), y = 0, x = getFontProperties(b); t.fWeight = x.weight, t.fStyle = x.style, t.finalSize = t.s, t.finalText = this.buildFinalText(t.t), n = t.finalText.length, t.finalLineHeight = t.lh; var _, w = t.tr / 1e3 * t.finalSize; if (t.sz) for (var E, C, S = !0, M = t.sz[0], P = t.sz[1]; S;) { E = 0, v = 0, n = (C = this.buildFinalText(t.t)).length, w = t.tr / 1e3 * t.finalSize; var I = -1; for (e = 0; e < n; e += 1)_ = C[e].charCodeAt(0), i = !1, " " === C[e] ? I = e : 13 !== _ && 3 !== _ || (v = 0, i = !0, E += t.finalLineHeight || 1.2 * t.finalSize), l.chars ? (a = l.getCharData(C[e], b.fStyle, b.fFamily), y = i ? 0 : a.w * t.finalSize / 100) : y = l.measureText(C[e], t.f, t.finalSize), v + y > M && " " !== C[e] ? (-1 === I ? n += 1 : e = I, E += t.finalLineHeight || 1.2 * t.finalSize, C.splice(e, I === e ? 1 : 0, "\r"), I = -1, v = 0) : (v += y, v += w); E += b.ascent * t.finalSize / 100, this.canResize && t.finalSize > this.minimumFontSize && P < E ? (t.finalSize -= 1, t.finalLineHeight = t.finalSize * t.lh / t.s) : (t.finalText = C, n = t.finalText.length, S = !1) } v = -w, y = 0; var T, D = 0; for (e = 0; e < n; e += 1)if (i = !1, 13 === (_ = (T = t.finalText[e]).charCodeAt(0)) || 3 === _ ? (D = 0, g.push(v), A = v > A ? v : A, v = -2 * w, r = "", i = !0, m += 1) : r = T, l.chars ? (a = l.getCharData(T, b.fStyle, l.getFontByName(t.f).fFamily), y = i ? 0 : a.w * t.finalSize / 100) : y = l.measureText(r, t.f, t.finalSize), " " === T ? D += y + w : (v += y + w + D, D = 0), c.push({ l: y, an: y, add: p, n: i, anIndexes: [], val: r, line: m, animatorJustifyOffset: 0 }), 2 == d) { if (p += y, "" === r || " " === r || e === n - 1) { for ("" !== r && " " !== r || (p -= y); f <= e;)c[f].an = p, c[f].ind = u, c[f].extra = y, f += 1; u += 1, p = 0 } } else if (3 == d) { if (p += y, "" === r || e === n - 1) { for ("" === r && (p -= y); f <= e;)c[f].an = p, c[f].ind = u, c[f].extra = y, f += 1; p = 0, u += 1 } } else c[u].ind = u, c[u].extra = 0, u += 1; if (t.l = c, A = v > A ? v : A, g.push(v), t.sz) t.boxWidth = t.sz[0], t.justifyOffset = 0; else switch (t.boxWidth = A, t.j) { case 1: t.justifyOffset = -t.boxWidth; break; case 2: t.justifyOffset = -t.boxWidth / 2; break; default: t.justifyOffset = 0 }t.lineWidths = g; var B, L, F, k, R = h.a; o = R.length; var O = []; for (s = 0; s < o; s += 1) { for ((B = R[s]).a.sc && (t.strokeColorAnim = !0), B.a.sw && (t.strokeWidthAnim = !0), (B.a.fc || B.a.fh || B.a.fs || B.a.fb) && (t.fillColorAnim = !0), k = 0, F = B.s.b, e = 0; e < n; e += 1)(L = c[e]).anIndexes[s] = k, (1 == F && "" !== L.val || 2 == F && "" !== L.val && " " !== L.val || 3 == F && (L.n || " " == L.val || e == n - 1) || 4 == F && (L.n || e == n - 1)) && (1 === B.s.rn && O.push(k), k += 1); h.a[s].s.totalChars = k; var N, U = -1; if (1 === B.s.rn) for (e = 0; e < n; e += 1)U != (L = c[e]).anIndexes[s] && (U = L.anIndexes[s], N = O.splice(Math.floor(Math.random() * O.length), 1)[0]), L.anIndexes[s] = N } t.yOffset = t.finalLineHeight || 1.2 * t.finalSize, t.ls = t.ls || 0, t.ascent = b.ascent * t.finalSize / 100 }, TextProperty.prototype.updateDocumentData = function (t, e) { e = void 0 === e ? this.keysIndex : e; var n = this.copyData({}, this.data.d.k[e].s); n = this.copyData(n, t), this.data.d.k[e].s = n, this.recalculate(e), this.elem.addDynamicProperty(this) }, TextProperty.prototype.recalculate = function (t) { var e = this.data.d.k[t].s; e.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(e) }, TextProperty.prototype.canResizeFont = function (t) { this.canResize = t, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }, TextProperty.prototype.setMinimumFontSize = function (t) { this.minimumFontSize = Math.floor(t) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }; var TextSelectorProp = function () { var t = Math.max, e = Math.min, n = Math.floor; function i(t, e) { this._currentTextLength = -1, this.k = !1, this.data = e, this.elem = t, this.comp = t.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(t), this.s = PropertyFactory.getProp(t, e.s || { k: 0 }, 0, 0, this), this.e = "e" in e ? PropertyFactory.getProp(t, e.e, 0, 0, this) : { v: 100 }, this.o = PropertyFactory.getProp(t, e.o || { k: 0 }, 0, 0, this), this.xe = PropertyFactory.getProp(t, e.xe || { k: 0 }, 0, 0, this), this.ne = PropertyFactory.getProp(t, e.ne || { k: 0 }, 0, 0, this), this.sm = PropertyFactory.getProp(t, e.sm || { k: 100 }, 0, 0, this), this.a = PropertyFactory.getProp(t, e.a, 0, .01, this), this.dynamicProperties.length || this.getValue() } return i.prototype = { getMult: function (i) { this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue(); var r = 0, s = 0, o = 1, a = 1; this.ne.v > 0 ? r = this.ne.v / 100 : s = -this.ne.v / 100, this.xe.v > 0 ? o = 1 - this.xe.v / 100 : a = 1 + this.xe.v / 100; var l = BezierFactory.getBezierEasing(r, s, o, a).get, h = 0, c = this.finalS, u = this.finalE, d = this.data.sh; if (2 === d) h = l(h = u === c ? i >= u ? 1 : 0 : t(0, e(.5 / (u - c) + (i - c) / (u - c), 1))); else if (3 === d) h = l(h = u === c ? i >= u ? 0 : 1 : 1 - t(0, e(.5 / (u - c) + (i - c) / (u - c), 1))); else if (4 === d) u === c ? h = 0 : (h = t(0, e(.5 / (u - c) + (i - c) / (u - c), 1))) < .5 ? h *= 2 : h = 1 - 2 * (h - .5), h = l(h); else if (5 === d) { if (u === c) h = 0; else { var p = u - c, f = -p / 2 + (i = e(t(0, i + .5 - c), u - c)), m = p / 2; h = Math.sqrt(1 - f * f / (m * m)) } h = l(h) } else 6 === d ? (u === c ? h = 0 : (i = e(t(0, i + .5 - c), u - c), h = (1 + Math.cos(Math.PI + 2 * Math.PI * i / (u - c))) / 2), h = l(h)) : (i >= n(c) && (h = t(0, e(i - c < 0 ? e(u, 1) - (c - i) : u - i, 1))), h = l(h)); if (100 !== this.sm.v) { var g = .01 * this.sm.v; 0 === g && (g = 1e-8); var v = .5 - .5 * g; h < v ? h = 0 : (h = (h - v) / g) > 1 && (h = 1) } return h * this.a.v }, getValue: function (t) { this.iterateDynamicProperties(), this._mdf = t || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, t && 2 === this.data.r && (this.e.v = this._currentTextLength); var e = 2 === this.data.r ? 1 : 100 / this.data.totalChars, n = this.o.v / e, i = this.s.v / e + n, r = this.e.v / e + n; if (i > r) { var s = i; i = r, r = s } this.finalS = i, this.finalE = r } }, extendPrototype([DynamicPropertyContainer], i), { getTextSelectorProp: function (t, e, n) { return new i(t, e, n) } } }(); function TextAnimatorDataProperty(t, e, n) { var i = { propType: !1 }, r = PropertyFactory.getProp, s = e.a; this.a = { r: s.r ? r(t, s.r, 0, degToRads, n) : i, rx: s.rx ? r(t, s.rx, 0, degToRads, n) : i, ry: s.ry ? r(t, s.ry, 0, degToRads, n) : i, sk: s.sk ? r(t, s.sk, 0, degToRads, n) : i, sa: s.sa ? r(t, s.sa, 0, degToRads, n) : i, s: s.s ? r(t, s.s, 1, .01, n) : i, a: s.a ? r(t, s.a, 1, 0, n) : i, o: s.o ? r(t, s.o, 0, .01, n) : i, p: s.p ? r(t, s.p, 1, 0, n) : i, sw: s.sw ? r(t, s.sw, 0, 0, n) : i, sc: s.sc ? r(t, s.sc, 1, 0, n) : i, fc: s.fc ? r(t, s.fc, 1, 0, n) : i, fh: s.fh ? r(t, s.fh, 0, 0, n) : i, fs: s.fs ? r(t, s.fs, 0, .01, n) : i, fb: s.fb ? r(t, s.fb, 0, .01, n) : i, t: s.t ? r(t, s.t, 0, 0, n) : i }, this.s = TextSelectorProp.getTextSelectorProp(t, e.s, n), this.s.t = e.s.t } function TextAnimatorProperty(t, e, n) { this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = t, this._renderType = e, this._elem = n, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = { alignment: {} }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(n) } function ITextElement() { } TextAnimatorProperty.prototype.searchProperties = function () { var t, e, n = this._textData.a.length, i = PropertyFactory.getProp; for (t = 0; t < n; t += 1)e = this._textData.a[t], this._animatorsData[t] = new TextAnimatorDataProperty(this._elem, e, this); this._textData.p && "m" in this._textData.p ? (this._pathData = { a: i(this._elem, this._textData.p.a, 0, 0, this), f: i(this._elem, this._textData.p.f, 0, 0, this), l: i(this._elem, this._textData.p.l, 0, 0, this), r: i(this._elem, this._textData.p.r, 0, 0, this), p: i(this._elem, this._textData.p.p, 0, 0, this), m: this._elem.maskManager.getMaskProperty(this._textData.p.m) }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = i(this._elem, this._textData.m.a, 1, 0, this) }, TextAnimatorProperty.prototype.getMeasures = function (t, e) { if (this.lettersChangedFlag = e, this._mdf || this._isFirstFrame || e || this._hasMaskedPath && this._pathData.m._mdf) { this._isFirstFrame = !1; var n, i, r, s, o, a, l, h, c, u, d, p, f, m, g, v, A, b, y, x = this._moreOptions.alignment.v, _ = this._animatorsData, w = this._textData, E = this.mHelper, C = this._renderType, S = this.renderedLetters.length, M = t.l; if (this._hasMaskedPath) { if (y = this._pathData.m, !this._pathData.n || this._pathData._mdf) { var P, I = y.v; for (this._pathData.r.v && (I = I.reverse()), o = { tLength: 0, segments: [] }, s = I._length - 1, v = 0, r = 0; r < s; r += 1)P = bez.buildBezierData(I.v[r], I.v[r + 1], [I.o[r][0] - I.v[r][0], I.o[r][1] - I.v[r][1]], [I.i[r + 1][0] - I.v[r + 1][0], I.i[r + 1][1] - I.v[r + 1][1]]), o.tLength += P.segmentLength, o.segments.push(P), v += P.segmentLength; r = s, y.v.c && (P = bez.buildBezierData(I.v[r], I.v[0], [I.o[r][0] - I.v[r][0], I.o[r][1] - I.v[r][1]], [I.i[0][0] - I.v[0][0], I.i[0][1] - I.v[0][1]]), o.tLength += P.segmentLength, o.segments.push(P), v += P.segmentLength), this._pathData.pi = o } if (o = this._pathData.pi, a = this._pathData.f.v, d = 0, u = 1, h = 0, c = !0, m = o.segments, a < 0 && y.v.c) for (o.tLength < Math.abs(a) && (a = -Math.abs(a) % o.tLength), u = (f = m[d = m.length - 1].points).length - 1; a < 0;)a += f[u].partialLength, (u -= 1) < 0 && (u = (f = m[d -= 1].points).length - 1); p = (f = m[d].points)[u - 1], g = (l = f[u]).partialLength } s = M.length, n = 0, i = 0; var T, D, B, L, F, k = 1.2 * t.finalSize * .714, R = !0; B = _.length; var O, N, U, z, V, Q, G, H, j, W, q, Y, X = -1, K = a, J = d, Z = u, $ = -1, tt = "", et = this.defaultPropsArray; if (2 === t.j || 1 === t.j) { var nt = 0, it = 0, rt = 2 === t.j ? -.5 : -1, st = 0, ot = !0; for (r = 0; r < s; r += 1)if (M[r].n) { for (nt && (nt += it); st < r;)M[st].animatorJustifyOffset = nt, st += 1; nt = 0, ot = !0 } else { for (D = 0; D < B; D += 1)(T = _[D].a).t.propType && (ot && 2 === t.j && (it += T.t.v * rt), (F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars)).length ? nt += T.t.v * F[0] * rt : nt += T.t.v * F * rt); ot = !1 } for (nt && (nt += it); st < r;)M[st].animatorJustifyOffset = nt, st += 1 } for (r = 0; r < s; r += 1) { if (E.reset(), z = 1, M[r].n) n = 0, i += t.yOffset, i += R ? 1 : 0, a = K, R = !1, this._hasMaskedPath && (u = Z, p = (f = m[d = J].points)[u - 1], g = (l = f[u]).partialLength, h = 0), tt = "", q = "", j = "", Y = "", et = this.defaultPropsArray; else { if (this._hasMaskedPath) { if ($ !== M[r].line) { switch (t.j) { case 1: a += v - t.lineWidths[M[r].line]; break; case 2: a += (v - t.lineWidths[M[r].line]) / 2 }$ = M[r].line } X !== M[r].ind && (M[X] && (a += M[X].extra), a += M[r].an / 2, X = M[r].ind), a += x[0] * M[r].an * .005; var at = 0; for (D = 0; D < B; D += 1)(T = _[D].a).p.propType && ((F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars)).length ? at += T.p.v[0] * F[0] : at += T.p.v[0] * F), T.a.propType && ((F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars)).length ? at += T.a.v[0] * F[0] : at += T.a.v[0] * F); for (c = !0, this._pathData.a.v && (a = .5 * M[0].an + (v - this._pathData.f.v - .5 * M[0].an - .5 * M[M.length - 1].an) * X / (s - 1), a += this._pathData.f.v); c;)h + g >= a + at || !f ? (A = (a + at - h) / l.partialLength, N = p.point[0] + (l.point[0] - p.point[0]) * A, U = p.point[1] + (l.point[1] - p.point[1]) * A, E.translate(-x[0] * M[r].an * .005, -x[1] * k * .01), c = !1) : f && (h += l.partialLength, (u += 1) >= f.length && (u = 0, m[d += 1] ? f = m[d].points : y.v.c ? (u = 0, f = m[d = 0].points) : (h -= l.partialLength, f = null)), f && (p = l, g = (l = f[u]).partialLength)); O = M[r].an / 2 - M[r].add, E.translate(-O, 0, 0) } else O = M[r].an / 2 - M[r].add, E.translate(-O, 0, 0), E.translate(-x[0] * M[r].an * .005, -x[1] * k * .01, 0); for (D = 0; D < B; D += 1)(T = _[D].a).t.propType && (F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars), 0 === n && 0 === t.j || (this._hasMaskedPath ? F.length ? a += T.t.v * F[0] : a += T.t.v * F : F.length ? n += T.t.v * F[0] : n += T.t.v * F)); for (t.strokeWidthAnim && (Q = t.sw || 0), t.strokeColorAnim && (V = t.sc ? [t.sc[0], t.sc[1], t.sc[2]] : [0, 0, 0]), t.fillColorAnim && t.fc && (G = [t.fc[0], t.fc[1], t.fc[2]]), D = 0; D < B; D += 1)(T = _[D].a).a.propType && ((F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars)).length ? E.translate(-T.a.v[0] * F[0], -T.a.v[1] * F[1], T.a.v[2] * F[2]) : E.translate(-T.a.v[0] * F, -T.a.v[1] * F, T.a.v[2] * F)); for (D = 0; D < B; D += 1)(T = _[D].a).s.propType && ((F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars)).length ? E.scale(1 + (T.s.v[0] - 1) * F[0], 1 + (T.s.v[1] - 1) * F[1], 1) : E.scale(1 + (T.s.v[0] - 1) * F, 1 + (T.s.v[1] - 1) * F, 1)); for (D = 0; D < B; D += 1) { if (T = _[D].a, F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars), T.sk.propType && (F.length ? E.skewFromAxis(-T.sk.v * F[0], T.sa.v * F[1]) : E.skewFromAxis(-T.sk.v * F, T.sa.v * F)), T.r.propType && (F.length ? E.rotateZ(-T.r.v * F[2]) : E.rotateZ(-T.r.v * F)), T.ry.propType && (F.length ? E.rotateY(T.ry.v * F[1]) : E.rotateY(T.ry.v * F)), T.rx.propType && (F.length ? E.rotateX(T.rx.v * F[0]) : E.rotateX(T.rx.v * F)), T.o.propType && (F.length ? z += (T.o.v * F[0] - z) * F[0] : z += (T.o.v * F - z) * F), t.strokeWidthAnim && T.sw.propType && (F.length ? Q += T.sw.v * F[0] : Q += T.sw.v * F), t.strokeColorAnim && T.sc.propType) for (H = 0; H < 3; H += 1)F.length ? V[H] += (T.sc.v[H] - V[H]) * F[0] : V[H] += (T.sc.v[H] - V[H]) * F; if (t.fillColorAnim && t.fc) { if (T.fc.propType) for (H = 0; H < 3; H += 1)F.length ? G[H] += (T.fc.v[H] - G[H]) * F[0] : G[H] += (T.fc.v[H] - G[H]) * F; T.fh.propType && (G = F.length ? addHueToRGB(G, T.fh.v * F[0]) : addHueToRGB(G, T.fh.v * F)), T.fs.propType && (G = F.length ? addSaturationToRGB(G, T.fs.v * F[0]) : addSaturationToRGB(G, T.fs.v * F)), T.fb.propType && (G = F.length ? addBrightnessToRGB(G, T.fb.v * F[0]) : addBrightnessToRGB(G, T.fb.v * F)) } } for (D = 0; D < B; D += 1)(T = _[D].a).p.propType && (F = _[D].s.getMult(M[r].anIndexes[D], w.a[D].s.totalChars), this._hasMaskedPath ? F.length ? E.translate(0, T.p.v[1] * F[0], -T.p.v[2] * F[1]) : E.translate(0, T.p.v[1] * F, -T.p.v[2] * F) : F.length ? E.translate(T.p.v[0] * F[0], T.p.v[1] * F[1], -T.p.v[2] * F[2]) : E.translate(T.p.v[0] * F, T.p.v[1] * F, -T.p.v[2] * F)); if (t.strokeWidthAnim && (j = Q < 0 ? 0 : Q), t.strokeColorAnim && (W = "rgb(" + Math.round(255 * V[0]) + "," + Math.round(255 * V[1]) + "," + Math.round(255 * V[2]) + ")"), t.fillColorAnim && t.fc && (q = "rgb(" + Math.round(255 * G[0]) + "," + Math.round(255 * G[1]) + "," + Math.round(255 * G[2]) + ")"), this._hasMaskedPath) { if (E.translate(0, -t.ls), E.translate(0, x[1] * k * .01 + i, 0), this._pathData.p.v) { b = (l.point[1] - p.point[1]) / (l.point[0] - p.point[0]); var lt = 180 * Math.atan(b) / Math.PI; l.point[0] < p.point[0] && (lt += 180), E.rotate(-lt * Math.PI / 180) } E.translate(N, U, 0), a -= x[0] * M[r].an * .005, M[r + 1] && X !== M[r + 1].ind && (a += M[r].an / 2, a += .001 * t.tr * t.finalSize) } else { switch (E.translate(n, i, 0), t.ps && E.translate(t.ps[0], t.ps[1] + t.ascent, 0), t.j) { case 1: E.translate(M[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[M[r].line]), 0, 0); break; case 2: E.translate(M[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[M[r].line]) / 2, 0, 0) }E.translate(0, -t.ls), E.translate(O, 0, 0), E.translate(x[0] * M[r].an * .005, x[1] * k * .01, 0), n += M[r].l + .001 * t.tr * t.finalSize } "html" === C ? tt = E.toCSS() : "svg" === C ? tt = E.to2dCSS() : et = [E.props[0], E.props[1], E.props[2], E.props[3], E.props[4], E.props[5], E.props[6], E.props[7], E.props[8], E.props[9], E.props[10], E.props[11], E.props[12], E.props[13], E.props[14], E.props[15]], Y = z } S <= r ? (L = new LetterProps(Y, j, W, q, tt, et), this.renderedLetters.push(L), S += 1, this.lettersChangedFlag = !0) : (L = this.renderedLetters[r], this.lettersChangedFlag = L.update(Y, j, W, q, tt, et) || this.lettersChangedFlag) } } }, TextAnimatorProperty.prototype.getValue = function () { this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties()) }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), ITextElement.prototype.initElement = function (t, e, n) { this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(t, e, n), this.textProperty = new TextProperty(this, t.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(t.t, this.renderType, this), this.initTransform(t, e, n), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties) }, ITextElement.prototype.prepareFrame = function (t) { this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1) }, ITextElement.prototype.createPathShape = function (t, e) { var n, i, r = e.length, s = ""; for (n = 0; n < r; n += 1)"sh" === e[n].ty && (i = e[n].ks.k, s += buildShapeString(i, i.i.length, !0, t)); return s }, ITextElement.prototype.updateDocumentData = function (t, e) { this.textProperty.updateDocumentData(t, e) }, ITextElement.prototype.canResizeFont = function (t) { this.textProperty.canResizeFont(t) }, ITextElement.prototype.setMinimumFontSize = function (t) { this.textProperty.setMinimumFontSize(t) }, ITextElement.prototype.applyTextPropertiesToMatrix = function (t, e, n, i, r) { switch (t.ps && e.translate(t.ps[0], t.ps[1] + t.ascent, 0), e.translate(0, -t.ls, 0), t.j) { case 1: e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[n]), 0, 0); break; case 2: e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[n]) / 2, 0, 0) }e.translate(i, r, 0) }, ITextElement.prototype.buildColor = function (t) { return "rgb(" + Math.round(255 * t[0]) + "," + Math.round(255 * t[1]) + "," + Math.round(255 * t[2]) + ")" }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () { }; var emptyShapeData = { shapes: [] }; function SVGTextLottieElement(t, e, n) { this.textSpans = [], this.renderType = "svg", this.initElement(t, e, n) } function ISolidElement(t, e, n) { this.initElement(t, e, n) } function NullElement(t, e, n) { this.initFrame(), this.initBaseData(t, e, n), this.initFrame(), this.initTransform(t, e, n), this.initHierarchy() } function SVGRendererBase() { } function ICompElement() { } function SVGCompElement(t, e, n) { this.layers = t.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : { _placeholder: !0 } } function SVGRenderer(t, e) { this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg"); var n = ""; if (e && e.title) { var i = createNS("title"), r = createElementID(); i.setAttribute("id", r), i.textContent = e.title, this.svgElement.appendChild(i), n += r } if (e && e.description) { var s = createNS("desc"), o = createElementID(); s.setAttribute("id", o), s.textContent = e.description, this.svgElement.appendChild(s), n += " " + o } n && this.svgElement.setAttribute("aria-labelledby", n); var a = createNS("defs"); this.svgElement.appendChild(a); var l = createNS("g"); this.svgElement.appendChild(l), this.layerElement = l, this.renderConfig = { preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: e && e.contentVisibility || "visible", progressiveLoad: e && e.progressiveLoad || !1, hideOnTransparent: !(e && !1 === e.hideOnTransparent), viewBoxOnly: e && e.viewBoxOnly || !1, viewBoxSize: e && e.viewBoxSize || !1, className: e && e.className || "", id: e && e.id || "", focusable: e && e.focusable, filterSize: { width: e && e.filterSize && e.filterSize.width || "100%", height: e && e.filterSize && e.filterSize.height || "100%", x: e && e.filterSize && e.filterSize.x || "0%", y: e && e.filterSize && e.filterSize.y || "0%" }, width: e && e.width, height: e && e.height, runExpressions: !e || void 0 === e.runExpressions || e.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, defs: a, renderConfig: this.renderConfig }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg" } function CVContextData() { var t; for (this.saved = [], this.cArrPos = 0, this.cTr = new Matrix, this.cO = 1, this.savedOp = createTypedArray("float32", 15), t = 0; t < 15; t += 1)this.saved[t] = createTypedArray("float32", 16); this._length = 15 } function ShapeTransformManager() { this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0 } extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function () { this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text")) }, SVGTextLottieElement.prototype.buildTextContents = function (t) { for (var e = 0, n = t.length, i = [], r = ""; e < n;)t[e] === String.fromCharCode(13) || t[e] === String.fromCharCode(3) ? (i.push(r), r = "") : r += t[e], e += 1; return i.push(r), i }, SVGTextLottieElement.prototype.buildShapeData = function (t, e) { if (t.shapes && t.shapes.length) { var n = t.shapes[0]; if (n.it) { var i = n.it[n.it.length - 1]; i.s && (i.s.k[0] = e, i.s.k[1] = e) } } return t }, SVGTextLottieElement.prototype.buildNewText = function () { var t, e; this.addDynamicProperty(this); var n = this.textProperty.currentData; this.renderedLetters = createSizedArray(n ? n.l.length : 0), n.fc ? this.layerElement.setAttribute("fill", this.buildColor(n.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), n.sc && (this.layerElement.setAttribute("stroke", this.buildColor(n.sc)), this.layerElement.setAttribute("stroke-width", n.sw)), this.layerElement.setAttribute("font-size", n.finalSize); var i = this.globalData.fontManager.getFontByName(n.f); if (i.fClass) this.layerElement.setAttribute("class", i.fClass); else { this.layerElement.setAttribute("font-family", i.fFamily); var r = n.fWeight, s = n.fStyle; this.layerElement.setAttribute("font-style", s), this.layerElement.setAttribute("font-weight", r) } this.layerElement.setAttribute("aria-label", n.t); var o, a = n.l || [], l = !!this.globalData.fontManager.chars; e = a.length; var h = this.mHelper, c = this.data.singleShape, u = 0, d = 0, p = !0, f = .001 * n.tr * n.finalSize; if (!c || l || n.sz) { var m, g = this.textSpans.length; for (t = 0; t < e; t += 1) { if (this.textSpans[t] || (this.textSpans[t] = { span: null, childSpan: null, glyph: null }), !l || !c || 0 === t) { if (o = g > t ? this.textSpans[t].span : createNS(l ? "g" : "text"), g <= t) { if (o.setAttribute("stroke-linecap", "butt"), o.setAttribute("stroke-linejoin", "round"), o.setAttribute("stroke-miterlimit", "4"), this.textSpans[t].span = o, l) { var v = createNS("g"); o.appendChild(v), this.textSpans[t].childSpan = v } this.textSpans[t].span = o, this.layerElement.appendChild(o) } o.style.display = "inherit" } if (h.reset(), c && (a[t].n && (u = -f, d += n.yOffset, d += p ? 1 : 0, p = !1), this.applyTextPropertiesToMatrix(n, h, a[t].line, u, d), u += a[t].l || 0, u += f), l) { var A; if (1 === (m = this.globalData.fontManager.getCharData(n.finalText[t], i.fStyle, this.globalData.fontManager.getFontByName(n.f).fFamily)).t) A = new SVGCompElement(m.data, this.globalData, this); else { var b = emptyShapeData; m.data && m.data.shapes && (b = this.buildShapeData(m.data, n.finalSize)), A = new SVGShapeElement(b, this.globalData, this) } if (this.textSpans[t].glyph) { var y = this.textSpans[t].glyph; this.textSpans[t].childSpan.removeChild(y.layerElement), y.destroy() } this.textSpans[t].glyph = A, A._debug = !0, A.prepareFrame(0), A.renderFrame(), this.textSpans[t].childSpan.appendChild(A.layerElement), 1 === m.t && this.textSpans[t].childSpan.setAttribute("transform", "scale(" + n.finalSize / 100 + "," + n.finalSize / 100 + ")") } else c && o.setAttribute("transform", "translate(" + h.props[12] + "," + h.props[13] + ")"), o.textContent = a[t].val, o.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve") } c && o && o.setAttribute("d", "") } else { var x = this.textContainer, _ = "start"; switch (n.j) { case 1: _ = "end"; break; case 2: _ = "middle"; break; default: _ = "start" }x.setAttribute("text-anchor", _), x.setAttribute("letter-spacing", f); var w = this.buildTextContents(n.finalText); for (e = w.length, d = n.ps ? n.ps[1] + n.ascent : 0, t = 0; t < e; t += 1)(o = this.textSpans[t].span || createNS("tspan")).textContent = w[t], o.setAttribute("x", 0), o.setAttribute("y", d), o.style.display = "inherit", x.appendChild(o), this.textSpans[t] || (this.textSpans[t] = { span: null, glyph: null }), this.textSpans[t].span = o, d += n.finalLineHeight; this.layerElement.appendChild(x) } for (; t < this.textSpans.length;)this.textSpans[t].span.style.display = "none", t += 1; this._sizeChanged = !0 }, SVGTextLottieElement.prototype.sourceRectAtTime = function () { if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) { this._sizeChanged = !1; var t = this.layerElement.getBBox(); this.bbox = { top: t.y, left: t.x, width: t.width, height: t.height } } return this.bbox }, SVGTextLottieElement.prototype.getValue = function () { var t, e, n = this.textSpans.length; for (this.renderedFrame = this.comp.renderedFrame, t = 0; t < n; t += 1)(e = this.textSpans[t].glyph) && (e.prepareFrame(this.comp.renderedFrame - this.data.st), e._mdf && (this._mdf = !0)) }, SVGTextLottieElement.prototype.renderInnerContent = function () { if ((!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) { var t, e; this._sizeChanged = !0; var n, i, r, s = this.textAnimator.renderedLetters, o = this.textProperty.currentData.l; for (e = o.length, t = 0; t < e; t += 1)o[t].n || (n = s[t], i = this.textSpans[t].span, (r = this.textSpans[t].glyph) && r.renderFrame(), n._mdf.m && i.setAttribute("transform", n.m), n._mdf.o && i.setAttribute("opacity", n.o), n._mdf.sw && i.setAttribute("stroke-width", n.sw), n._mdf.sc && i.setAttribute("stroke", n.sc), n._mdf.fc && i.setAttribute("fill", n.fc)) } }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () { var t = createNS("rect"); t.setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.layerElement.appendChild(t) }, NullElement.prototype.prepareFrame = function (t) { this.prepareProperties(t, !0) }, NullElement.prototype.renderFrame = function () { }, NullElement.prototype.getBaseElement = function () { return null }, NullElement.prototype.destroy = function () { }, NullElement.prototype.sourceRectAtTime = function () { }, NullElement.prototype.hide = function () { }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function (t) { return new NullElement(t, this.globalData, this) }, SVGRendererBase.prototype.createShape = function (t) { return new SVGShapeElement(t, this.globalData, this) }, SVGRendererBase.prototype.createText = function (t) { return new SVGTextLottieElement(t, this.globalData, this) }, SVGRendererBase.prototype.createImage = function (t) { return new IImageElement(t, this.globalData, this) }, SVGRendererBase.prototype.createSolid = function (t) { return new ISolidElement(t, this.globalData, this) }, SVGRendererBase.prototype.configAnimation = function (t) { this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + t.w + " " + t.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", t.w), this.svgElement.setAttribute("height", t.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement); var e = this.globalData.defs; this.setupGlobalData(t, e), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = t; var n = createNS("clipPath"), i = createNS("rect"); i.setAttribute("width", t.w), i.setAttribute("height", t.h), i.setAttribute("x", 0), i.setAttribute("y", 0); var r = createElementID(); n.setAttribute("id", r), n.appendChild(i), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + r + ")"), e.appendChild(n), this.layers = t.layers, this.elements = createSizedArray(t.layers.length) }, SVGRendererBase.prototype.destroy = function () { var t; this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null; var e = this.layers ? this.layers.length : 0; for (t = 0; t < e; t += 1)this.elements[t] && this.elements[t].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, SVGRendererBase.prototype.updateContainerSize = function () { }, SVGRendererBase.prototype.findIndexByInd = function (t) { var e = 0, n = this.layers.length; for (e = 0; e < n; e += 1)if (this.layers[e].ind === t) return e; return -1 }, SVGRendererBase.prototype.buildItem = function (t) { var e = this.elements; if (!e[t] && 99 !== this.layers[t].ty) { e[t] = !0; var n = this.createItem(this.layers[t]); if (e[t] = n, getExpressionsPlugin() && (0 === this.layers[t].ty && this.globalData.projectInterface.registerComposition(n), n.initExpressions()), this.appendElementInPos(n, t), this.layers[t].tt) { var i = "tp" in this.layers[t] ? this.findIndexByInd(this.layers[t].tp) : t - 1; if (-1 === i) return; if (this.elements[i] && !0 !== this.elements[i]) { var r = e[i].getMatte(this.layers[t].tt); n.setMatte(r) } else this.buildItem(i), this.addPendingElement(n) } } }, SVGRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var t = this.pendingElements.pop(); if (t.checkParenting(), t.data.tt) for (var e = 0, n = this.elements.length; e < n;) { if (this.elements[e] === t) { var i = "tp" in t.data ? this.findIndexByInd(t.data.tp) : e - 1, r = this.elements[i].getMatte(this.layers[e].tt); t.setMatte(r); break } e += 1 } } }, SVGRendererBase.prototype.renderFrame = function (t) { if (this.renderedFrame !== t && !this.destroyed) { var e; null === t ? t = this.renderedFrame : this.renderedFrame = t, this.globalData.frameNum = t, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = t, this.globalData._mdf = !1; var n = this.layers.length; for (this.completeLayers || this.checkLayers(t), e = n - 1; e >= 0; e -= 1)(this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(t - this.layers[e].st); if (this.globalData._mdf) for (e = 0; e < n; e += 1)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame() } }, SVGRendererBase.prototype.appendElementInPos = function (t, e) { var n = t.getBaseElement(); if (n) { for (var i, r = 0; r < e;)this.elements[r] && !0 !== this.elements[r] && this.elements[r].getBaseElement() && (i = this.elements[r].getBaseElement()), r += 1; i ? this.layerElement.insertBefore(n, i) : this.layerElement.appendChild(n) } }, SVGRendererBase.prototype.hide = function () { this.layerElement.style.display = "none" }, SVGRendererBase.prototype.show = function () { this.layerElement.style.display = "block" }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (t, e, n) { this.initFrame(), this.initBaseData(t, e, n), this.initTransform(t, e, n), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && e.progressiveLoad || this.buildAllItems(), this.hide() }, ICompElement.prototype.prepareFrame = function (t) { if (this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.isInRange || this.data.xt) { if (this.tm._placeholder) this.renderedFrame = t / this.data.sr; else { var e = this.tm.v; e === this.data.op && (e = this.data.op - 1), this.renderedFrame = e } var n, i = this.elements.length; for (this.completeLayers || this.checkLayers(this.renderedFrame), n = i - 1; n >= 0; n -= 1)(this.completeLayers || this.elements[n]) && (this.elements[n].prepareFrame(this.renderedFrame - this.layers[n].st), this.elements[n]._mdf && (this._mdf = !0)) } }, ICompElement.prototype.renderInnerContent = function () { var t, e = this.layers.length; for (t = 0; t < e; t += 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame() }, ICompElement.prototype.setElements = function (t) { this.elements = t }, ICompElement.prototype.getElements = function () { return this.elements }, ICompElement.prototype.destroyElements = function () { var t, e = this.layers.length; for (t = 0; t < e; t += 1)this.elements[t] && this.elements[t].destroy() }, ICompElement.prototype.destroy = function () { this.destroyElements(), this.destroyBaseElement() }, extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function (t) { return new SVGCompElement(t, this.globalData, this) }, extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function (t) { return new SVGCompElement(t, this.globalData, this) }, CVContextData.prototype.duplicate = function () { var t = 2 * this._length, e = this.savedOp; this.savedOp = createTypedArray("float32", t), this.savedOp.set(e); var n = 0; for (n = this._length; n < t; n += 1)this.saved[n] = createTypedArray("float32", 16); this._length = t }, CVContextData.prototype.reset = function () { this.cArrPos = 0, this.cTr.reset(), this.cO = 1 }, CVContextData.prototype.popTransform = function () { var t, e = this.saved[this.cArrPos], n = this.cTr.props; for (t = 0; t < 16; t += 1)n[t] = e[t]; return e }, CVContextData.prototype.popOpacity = function () { var t = this.savedOp[this.cArrPos]; return this.cO = t, t }, CVContextData.prototype.pop = function () { return this.cArrPos -= 1, { transform: this.popTransform(), opacity: this.popOpacity() } }, CVContextData.prototype.push = function () { var t, e = this.cTr.props; this._length <= this.cArrPos && this.duplicate(); var n = this.saved[this.cArrPos]; for (t = 0; t < 16; t += 1)n[t] = e[t]; this.savedOp[this.cArrPos] = this.cO, this.cArrPos += 1 }, CVContextData.prototype.getTransform = function () { return this.cTr }, CVContextData.prototype.getOpacity = function () { return this.cO }, CVContextData.prototype.setOpacity = function (t) { this.cO = t }, ShapeTransformManager.prototype = { addTransformSequence: function (t) { var e, n = t.length, i = "_"; for (e = 0; e < n; e += 1)i += t[e].transform.key + "_"; var r = this.sequences[i]; return r || (r = { transforms: [].concat(t), finalTransform: new Matrix, _mdf: !1 }, this.sequences[i] = r, this.sequenceList.push(r)), r }, processSequence: function (t, e) { for (var n, i = 0, r = t.transforms.length, s = e; i < r && !e;) { if (t.transforms[i].transform.mProps._mdf) { s = !0; break } i += 1 } if (s) for (t.finalTransform.reset(), i = r - 1; i >= 0; i -= 1)n = t.transforms[i].transform.mProps.v.props, t.finalTransform.transform(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]); t._mdf = s }, processSequences: function (t) { var e, n = this.sequenceList.length; for (e = 0; e < n; e += 1)this.processSequence(this.sequenceList[e], t) }, getNewKey: function () { return this.transform_key_count += 1, "_" + this.transform_key_count } }; var lumaLoader = function () { var t = "__lottie_element_luma_buffer", e = null, n = null, i = null; function r() { var r, s, o; e || (r = createNS("svg"), s = createNS("filter"), o = createNS("feColorMatrix"), s.setAttribute("id", t), o.setAttribute("type", "matrix"), o.setAttribute("color-interpolation-filters", "sRGB"), o.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), s.appendChild(o), r.appendChild(s), r.setAttribute("id", t + "_svg"), featureSupport.svgLumaHidden && (r.style.display = "none"), i = r, document.body.appendChild(i), e = createTag("canvas"), (n = e.getContext("2d")).filter = "url(#" + t + ")", n.fillStyle = "rgba(0,0,0,0)", n.fillRect(0, 0, 1, 1)) } return { load: r, get: function (i) { return e || r(), e.width = i.width, e.height = i.height, n.filter = "url(#" + t + ")", e } } }; function createCanvas(t, e) { if (featureSupport.offscreenCanvas) return new OffscreenCanvas(t, e); var n = createTag("canvas"); return n.width = t, n.height = e, n } var assetLoader = { loadLumaCanvas: lumaLoader.load, getLumaCanvas: lumaLoader.get, createCanvas: createCanvas }; function CVEffects() { } function CVMaskElement(t, e) { var n; this.data = t, this.element = e, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length); var i = this.masksProperties.length, r = !1; for (n = 0; n < i; n += 1)"n" !== this.masksProperties[n].mode && (r = !0), this.viewData[n] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[n], 3); this.hasMasks = r, r && this.element.addRenderableComponent(this) } function CVBaseElement() { } CVEffects.prototype.renderFrame = function () { }, CVMaskElement.prototype.renderFrame = function () { if (this.hasMasks) { var t, e, n, i, r = this.element.finalTransform.mat, s = this.element.canvasContext, o = this.masksProperties.length; for (s.beginPath(), t = 0; t < o; t += 1)if ("n" !== this.masksProperties[t].mode) { var a; this.masksProperties[t].inv && (s.moveTo(0, 0), s.lineTo(this.element.globalData.compSize.w, 0), s.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), s.lineTo(0, this.element.globalData.compSize.h), s.lineTo(0, 0)), i = this.viewData[t].v, e = r.applyToPointArray(i.v[0][0], i.v[0][1], 0), s.moveTo(e[0], e[1]); var l = i._length; for (a = 1; a < l; a += 1)n = r.applyToTriplePoints(i.o[a - 1], i.i[a], i.v[a]), s.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5]); n = r.applyToTriplePoints(i.o[a - 1], i.i[0], i.v[0]), s.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5]) } this.element.globalData.renderer.save(!0), s.clip() } }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () { this.element = null }; var operationsMap = { 1: "source-in", 2: "source-out", 3: "source-in", 4: "source-out" }; function CVShapeData(t, e, n, i) { this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0]; var r, s = 4; "rc" === e.ty ? s = 5 : "el" === e.ty ? s = 6 : "sr" === e.ty && (s = 7), this.sh = ShapePropertyFactory.getShapeProp(t, e, s, t); var o, a = n.length; for (r = 0; r < a; r += 1)n[r].closed || (o = { transforms: i.addTransformSequence(n[r].transforms), trNodes: [] }, this.styledShapes.push(o), n[r].elements.push(o)) } function CVShapeElement(t, e, n) { this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(t, e, n) } function CVTextElement(t, e, n) { this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = { fill: "rgba(0,0,0,0)", stroke: "rgba(0,0,0,0)", sWidth: 0, fValue: "" }, this.initElement(t, e, n) } function CVImageElement(t, e, n) { this.assetData = e.getAssetData(t.refId), this.img = e.imageLoader.getAsset(this.assetData), this.initElement(t, e, n) } function CVSolidElement(t, e, n) { this.initElement(t, e, n) } function CanvasRendererBase(t, e) { this.animationItem = t, this.renderConfig = { clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas, context: e && e.context || null, progressiveLoad: e && e.progressiveLoad || !1, preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: e && e.contentVisibility || "visible", className: e && e.className || "", id: e && e.id || "" }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = { frameNum: -1, _mdf: !1, renderConfig: this.renderConfig, currentGlobalAlpha: -1 }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas" } function CVCompElement(t, e, n) { this.completeLayers = !1, this.layers = t.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : { _placeholder: !0 } } function CanvasRenderer(t, e) { this.animationItem = t, this.renderConfig = { clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas, context: e && e.context || null, progressiveLoad: e && e.progressiveLoad || !1, preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: e && e.contentVisibility || "visible", className: e && e.className || "", id: e && e.id || "", runExpressions: !e || void 0 === e.runExpressions || e.runExpressions }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = { frameNum: -1, _mdf: !1, renderConfig: this.renderConfig, currentGlobalAlpha: -1 }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas" } function HBaseElement() { } function HSolidElement(t, e, n) { this.initElement(t, e, n) } function HShapeElement(t, e, n) { this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(t, e, n), this.prevViewData = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 } } function HTextElement(t, e, n) { this.textSpans = [], this.textPaths = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }, this.renderType = "svg", this.isMasked = !1, this.initElement(t, e, n) } function HCameraElement(t, e, n) { this.initFrame(), this.initBaseData(t, e, n), this.initHierarchy(); var i = PropertyFactory.getProp; if (this.pe = i(this, t.pe, 0, 0, this), t.ks.p.s ? (this.px = i(this, t.ks.p.x, 1, 0, this), this.py = i(this, t.ks.p.y, 1, 0, this), this.pz = i(this, t.ks.p.z, 1, 0, this)) : this.p = i(this, t.ks.p, 1, 0, this), t.ks.a && (this.a = i(this, t.ks.a, 1, 0, this)), t.ks.or.k.length && t.ks.or.k[0].to) { var r, s = t.ks.or.k.length; for (r = 0; r < s; r += 1)t.ks.or.k[r].to = null, t.ks.or.k[r].ti = null } this.or = i(this, t.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = i(this, t.ks.rx, 0, degToRads, this), this.ry = i(this, t.ks.ry, 0, degToRads, this), this.rz = i(this, t.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = { mProp: this } } function HImageElement(t, e, n) { this.assetData = e.getAssetData(t.refId), this.initElement(t, e, n) } function HybridRendererBase(t, e) { this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: e && e.className || "", imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(e && !1 === e.hideOnTransparent), filterSize: { width: e && e.filterSize && e.filterSize.width || "400%", height: e && e.filterSize && e.filterSize.height || "400%", x: e && e.filterSize && e.filterSize.x || "-100%", y: e && e.filterSize && e.filterSize.y || "-100%" } }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } function HCompElement(t, e, n) { this.layers = t.layers, this.supports3d = !t.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : { _placeholder: !0 } } function HybridRenderer(t, e) { this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: e && e.className || "", imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(e && !1 === e.hideOnTransparent), filterSize: { width: e && e.filterSize && e.filterSize.width || "400%", height: e && e.filterSize && e.filterSize.height || "400%", x: e && e.filterSize && e.filterSize.x || "-100%", y: e && e.filterSize && e.filterSize.y || "-100%" }, runExpressions: !e || void 0 === e.runExpressions || e.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } CVBaseElement.prototype = { createElements: function () { }, initRendererElement: function () { }, createContainerElements: function () { if (this.data.tt >= 1) { this.buffers = []; var t = this.globalData.canvasContext, e = assetLoader.createCanvas(t.canvas.width, t.canvas.height); this.buffers.push(e); var n = assetLoader.createCanvas(t.canvas.width, t.canvas.height); this.buffers.push(n), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas() } this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this) }, createContent: function () { }, setBlendMode: function () { var t = this.globalData; if (t.blendMode !== this.data.bm) { t.blendMode = this.data.bm; var e = getBlendMode(this.data.bm); t.canvasContext.globalCompositeOperation = e } }, createRenderableComponents: function () { this.maskManager = new CVMaskElement(this.data, this) }, hideElement: function () { this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0) }, showElement: function () { this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0) }, clearCanvas: function (t) { t.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy) }, prepareLayer: function () { if (this.data.tt >= 1) { var t = this.buffers[0].getContext("2d"); this.clearCanvas(t), t.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform) } }, exitLayer: function () { if (this.data.tt >= 1) { var t = this.buffers[1], e = t.getContext("2d"); if (this.clearCanvas(e), e.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform), this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1).renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) { var n = assetLoader.getLumaCanvas(this.canvasContext.canvas); n.getContext("2d").drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(n, 0, 0) } this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(t, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over" } }, renderFrame: function (t) { if (!this.hidden && !this.data.hd && (1 !== this.data.td || t)) { this.renderTransform(), this.renderRenderable(), this.setBlendMode(); var e = 0 === this.data.ty; this.prepareLayer(), this.globalData.renderer.save(e), this.globalData.renderer.ctxTransform(this.finalTransform.mat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v), this.renderInnerContent(), this.globalData.renderer.restore(e), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1) } }, destroy: function () { this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy() }, mHelper: new Matrix }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []) }, CVShapeElement.prototype.createStyleElement = function (t, e) { var n = { data: t, type: t.ty, preTransforms: this.transformsManager.addTransformSequence(e), transforms: [], elements: [], closed: !0 === t.hd }, i = {}; if ("fl" === t.ty || "st" === t.ty ? (i.c = PropertyFactory.getProp(this, t.c, 1, 255, this), i.c.k || (n.co = "rgb(" + bmFloor(i.c.v[0]) + "," + bmFloor(i.c.v[1]) + "," + bmFloor(i.c.v[2]) + ")")) : "gf" !== t.ty && "gs" !== t.ty || (i.s = PropertyFactory.getProp(this, t.s, 1, null, this), i.e = PropertyFactory.getProp(this, t.e, 1, null, this), i.h = PropertyFactory.getProp(this, t.h || { k: 0 }, 0, .01, this), i.a = PropertyFactory.getProp(this, t.a || { k: 0 }, 0, degToRads, this), i.g = new GradientProperty(this, t.g, this)), i.o = PropertyFactory.getProp(this, t.o, 0, .01, this), "st" === t.ty || "gs" === t.ty) { if (n.lc = lineCapEnum[t.lc || 2], n.lj = lineJoinEnum[t.lj || 2], 1 == t.lj && (n.ml = t.ml), i.w = PropertyFactory.getProp(this, t.w, 0, null, this), i.w.k || (n.wi = i.w.v), t.d) { var r = new DashProperty(this, t.d, "canvas", this); i.d = r, i.d.k || (n.da = i.d.dashArray, n.do = i.d.dashoffset[0]) } } else n.r = 2 === t.r ? "evenodd" : "nonzero"; return this.stylesList.push(n), i.style = n, i }, CVShapeElement.prototype.createGroupElement = function () { return { it: [], prevViewData: [] } }, CVShapeElement.prototype.createTransformElement = function (t) { return { transform: { opacity: 1, _opMdf: !1, key: this.transformsManager.getNewKey(), op: PropertyFactory.getProp(this, t.o, 0, .01, this), mProps: TransformPropertyFactory.getTransformProperty(this, t, this) } } }, CVShapeElement.prototype.createShapeElement = function (t) { var e = new CVShapeData(this, t, this.stylesList, this.transformsManager); return this.shapes.push(e), this.addShapeToModifiers(e), e }, CVShapeElement.prototype.reloadShapes = function () { var t; this._isFirstFrame = !0; var e = this.itemsData.length; for (t = 0; t < e; t += 1)this.prevViewData[t] = this.itemsData[t]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), e = this.dynamicProperties.length, t = 0; t < e; t += 1)this.dynamicProperties[t].getValue(); this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame) }, CVShapeElement.prototype.addTransformToStyleList = function (t) { var e, n = this.stylesList.length; for (e = 0; e < n; e += 1)this.stylesList[e].closed || this.stylesList[e].transforms.push(t) }, CVShapeElement.prototype.removeTransformFromStyleList = function () { var t, e = this.stylesList.length; for (t = 0; t < e; t += 1)this.stylesList[t].closed || this.stylesList[t].transforms.pop() }, CVShapeElement.prototype.closeStyles = function (t) { var e, n = t.length; for (e = 0; e < n; e += 1)t[e].closed = !0 }, CVShapeElement.prototype.searchShapes = function (t, e, n, i, r) { var s, o, a, l, h, c, u = t.length - 1, d = [], p = [], f = [].concat(r); for (s = u; s >= 0; s -= 1) { if ((l = this.searchProcessedElement(t[s])) ? e[s] = n[l - 1] : t[s]._shouldRender = i, "fl" === t[s].ty || "st" === t[s].ty || "gf" === t[s].ty || "gs" === t[s].ty) l ? e[s].style.closed = !1 : e[s] = this.createStyleElement(t[s], f), d.push(e[s].style); else if ("gr" === t[s].ty) { if (l) for (a = e[s].it.length, o = 0; o < a; o += 1)e[s].prevViewData[o] = e[s].it[o]; else e[s] = this.createGroupElement(t[s]); this.searchShapes(t[s].it, e[s].it, e[s].prevViewData, i, f) } else "tr" === t[s].ty ? (l || (c = this.createTransformElement(t[s]), e[s] = c), f.push(e[s]), this.addTransformToStyleList(e[s])) : "sh" === t[s].ty || "rc" === t[s].ty || "el" === t[s].ty || "sr" === t[s].ty ? l || (e[s] = this.createShapeElement(t[s])) : "tm" === t[s].ty || "rd" === t[s].ty || "pb" === t[s].ty || "zz" === t[s].ty || "op" === t[s].ty ? (l ? (h = e[s]).closed = !1 : ((h = ShapeModifiers.getModifier(t[s].ty)).init(this, t[s]), e[s] = h, this.shapeModifiers.push(h)), p.push(h)) : "rp" === t[s].ty && (l ? (h = e[s]).closed = !0 : (h = ShapeModifiers.getModifier(t[s].ty), e[s] = h, h.init(this, t, s, e), this.shapeModifiers.push(h), i = !1), p.push(h)); this.addProcessedElement(t[s], s + 1) } for (this.removeTransformFromStyleList(), this.closeStyles(d), u = p.length, s = 0; s < u; s += 1)p[s].closed = !0 }, CVShapeElement.prototype.renderInnerContent = function () { this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0) }, CVShapeElement.prototype.renderShapeTransform = function (t, e) { (t._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = t.opacity, e.opacity *= e.op.v, e._opMdf = !0) }, CVShapeElement.prototype.drawLayer = function () { var t, e, n, i, r, s, o, a, l, h = this.stylesList.length, c = this.globalData.renderer, u = this.globalData.canvasContext; for (t = 0; t < h; t += 1)if (("st" !== (a = (l = this.stylesList[t]).type) && "gs" !== a || 0 !== l.wi) && l.data._shouldRender && 0 !== l.coOp && 0 !== this.globalData.currentGlobalAlpha) { for (c.save(), s = l.elements, "st" === a || "gs" === a ? (u.strokeStyle = "st" === a ? l.co : l.grd, u.lineWidth = l.wi, u.lineCap = l.lc, u.lineJoin = l.lj, u.miterLimit = l.ml || 0) : u.fillStyle = "fl" === a ? l.co : l.grd, c.ctxOpacity(l.coOp), "st" !== a && "gs" !== a && u.beginPath(), c.ctxTransform(l.preTransforms.finalTransform.props), n = s.length, e = 0; e < n; e += 1) { for ("st" !== a && "gs" !== a || (u.beginPath(), l.da && (u.setLineDash(l.da), u.lineDashOffset = l.do)), r = (o = s[e].trNodes).length, i = 0; i < r; i += 1)"m" === o[i].t ? u.moveTo(o[i].p[0], o[i].p[1]) : "c" === o[i].t ? u.bezierCurveTo(o[i].pts[0], o[i].pts[1], o[i].pts[2], o[i].pts[3], o[i].pts[4], o[i].pts[5]) : u.closePath(); "st" !== a && "gs" !== a || (u.stroke(), l.da && u.setLineDash(this.dashResetter)) } "st" !== a && "gs" !== a && u.fill(l.r), c.restore() } }, CVShapeElement.prototype.renderShape = function (t, e, n, i) { var r, s; for (s = t, r = e.length - 1; r >= 0; r -= 1)"tr" === e[r].ty ? (s = n[r].transform, this.renderShapeTransform(t, s)) : "sh" === e[r].ty || "el" === e[r].ty || "rc" === e[r].ty || "sr" === e[r].ty ? this.renderPath(e[r], n[r]) : "fl" === e[r].ty ? this.renderFill(e[r], n[r], s) : "st" === e[r].ty ? this.renderStroke(e[r], n[r], s) : "gf" === e[r].ty || "gs" === e[r].ty ? this.renderGradientFill(e[r], n[r], s) : "gr" === e[r].ty ? this.renderShape(s, e[r].it, n[r].it) : e[r].ty; i && this.drawLayer() }, CVShapeElement.prototype.renderStyledShape = function (t, e) { if (this._isFirstFrame || e._mdf || t.transforms._mdf) { var n, i, r, s = t.trNodes, o = e.paths, a = o._length; s.length = 0; var l = t.transforms.finalTransform; for (r = 0; r < a; r += 1) { var h = o.shapes[r]; if (h && h.v) { for (i = h._length, n = 1; n < i; n += 1)1 === n && s.push({ t: "m", p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0) }), s.push({ t: "c", pts: l.applyToTriplePoints(h.o[n - 1], h.i[n], h.v[n]) }); 1 === i && s.push({ t: "m", p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0) }), h.c && i && (s.push({ t: "c", pts: l.applyToTriplePoints(h.o[n - 1], h.i[0], h.v[0]) }), s.push({ t: "z" })) } } t.trNodes = s } }, CVShapeElement.prototype.renderPath = function (t, e) { if (!0 !== t.hd && t._shouldRender) { var n, i = e.styledShapes.length; for (n = 0; n < i; n += 1)this.renderStyledShape(e.styledShapes[n], e.sh) } }, CVShapeElement.prototype.renderFill = function (t, e, n) { var i = e.style; (e.c._mdf || this._isFirstFrame) && (i.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || n._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * n.opacity) }, CVShapeElement.prototype.renderGradientFill = function (t, e, n) { var i, r = e.style; if (!r.grd || e.g._mdf || e.s._mdf || e.e._mdf || 1 !== t.t && (e.h._mdf || e.a._mdf)) { var s, o = this.globalData.canvasContext, a = e.s.v, l = e.e.v; if (1 === t.t) i = o.createLinearGradient(a[0], a[1], l[0], l[1]); else { var h = Math.sqrt(Math.pow(a[0] - l[0], 2) + Math.pow(a[1] - l[1], 2)), c = Math.atan2(l[1] - a[1], l[0] - a[0]), u = e.h.v; u >= 1 ? u = .99 : u <= -1 && (u = -.99); var d = h * u, p = Math.cos(c + e.a.v) * d + a[0], f = Math.sin(c + e.a.v) * d + a[1]; i = o.createRadialGradient(p, f, 0, a[0], a[1], h) } var m = t.g.p, g = e.g.c, v = 1; for (s = 0; s < m; s += 1)e.g._hasOpacity && e.g._collapsable && (v = e.g.o[2 * s + 1]), i.addColorStop(g[4 * s] / 100, "rgba(" + g[4 * s + 1] + "," + g[4 * s + 2] + "," + g[4 * s + 3] + "," + v + ")"); r.grd = i } r.coOp = e.o.v * n.opacity }, CVShapeElement.prototype.renderStroke = function (t, e, n) { var i = e.style, r = e.d; r && (r._mdf || this._isFirstFrame) && (i.da = r.dashArray, i.do = r.dashoffset[0]), (e.c._mdf || this._isFirstFrame) && (i.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || n._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * n.opacity), (e.w._mdf || this._isFirstFrame) && (i.wi = e.w.v) }, CVShapeElement.prototype.destroy = function () { this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0 }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () { var t = this.textProperty.currentData; this.renderedLetters = createSizedArray(t.l ? t.l.length : 0); var e = !1; t.fc ? (e = !0, this.values.fill = this.buildColor(t.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = e; var n = !1; t.sc && (n = !0, this.values.stroke = this.buildColor(t.sc), this.values.sWidth = t.sw); var i, r, s, o, a, l, h, c, u, d, p, f, m = this.globalData.fontManager.getFontByName(t.f), g = t.l, v = this.mHelper; this.stroke = n, this.values.fValue = t.finalSize + "px " + this.globalData.fontManager.getFontByName(t.f).fFamily, r = t.finalText.length; var A = this.data.singleShape, b = .001 * t.tr * t.finalSize, y = 0, x = 0, _ = !0, w = 0; for (i = 0; i < r; i += 1) { o = (s = this.globalData.fontManager.getCharData(t.finalText[i], m.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && s.data || {}, v.reset(), A && g[i].n && (y = -b, x += t.yOffset, x += _ ? 1 : 0, _ = !1), u = (h = o.shapes ? o.shapes[0].it : []).length, v.scale(t.finalSize / 100, t.finalSize / 100), A && this.applyTextPropertiesToMatrix(t, v, g[i].line, y, x), p = createSizedArray(u - 1); var E = 0; for (c = 0; c < u; c += 1)if ("sh" === h[c].ty) { for (l = h[c].ks.k.i.length, d = h[c].ks.k, f = [], a = 1; a < l; a += 1)1 === a && f.push(v.applyToX(d.v[0][0], d.v[0][1], 0), v.applyToY(d.v[0][0], d.v[0][1], 0)), f.push(v.applyToX(d.o[a - 1][0], d.o[a - 1][1], 0), v.applyToY(d.o[a - 1][0], d.o[a - 1][1], 0), v.applyToX(d.i[a][0], d.i[a][1], 0), v.applyToY(d.i[a][0], d.i[a][1], 0), v.applyToX(d.v[a][0], d.v[a][1], 0), v.applyToY(d.v[a][0], d.v[a][1], 0)); f.push(v.applyToX(d.o[a - 1][0], d.o[a - 1][1], 0), v.applyToY(d.o[a - 1][0], d.o[a - 1][1], 0), v.applyToX(d.i[0][0], d.i[0][1], 0), v.applyToY(d.i[0][0], d.i[0][1], 0), v.applyToX(d.v[0][0], d.v[0][1], 0), v.applyToY(d.v[0][0], d.v[0][1], 0)), p[E] = f, E += 1 } A && (y += g[i].l, y += b), this.textSpans[w] ? this.textSpans[w].elem = p : this.textSpans[w] = { elem: p }, w += 1 } }, CVTextElement.prototype.renderInnerContent = function () { var t, e, n, i, r, s, o = this.canvasContext; o.font = this.values.fValue, o.lineCap = "butt", o.lineJoin = "miter", o.miterLimit = 4, this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag); var a, l = this.textAnimator.renderedLetters, h = this.textProperty.currentData.l; e = h.length; var c, u, d = null, p = null, f = null; for (t = 0; t < e; t += 1)if (!h[t].n) { if ((a = l[t]) && (this.globalData.renderer.save(), this.globalData.renderer.ctxTransform(a.p), this.globalData.renderer.ctxOpacity(a.o)), this.fill) { for (a && a.fc ? d !== a.fc && (d = a.fc, o.fillStyle = a.fc) : d !== this.values.fill && (d = this.values.fill, o.fillStyle = this.values.fill), i = (c = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), n = 0; n < i; n += 1)for (s = (u = c[n]).length, this.globalData.canvasContext.moveTo(u[0], u[1]), r = 2; r < s; r += 6)this.globalData.canvasContext.bezierCurveTo(u[r], u[r + 1], u[r + 2], u[r + 3], u[r + 4], u[r + 5]); this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill() } if (this.stroke) { for (a && a.sw ? f !== a.sw && (f = a.sw, o.lineWidth = a.sw) : f !== this.values.sWidth && (f = this.values.sWidth, o.lineWidth = this.values.sWidth), a && a.sc ? p !== a.sc && (p = a.sc, o.strokeStyle = a.sc) : p !== this.values.stroke && (p = this.values.stroke, o.strokeStyle = this.values.stroke), i = (c = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), n = 0; n < i; n += 1)for (s = (u = c[n]).length, this.globalData.canvasContext.moveTo(u[0], u[1]), r = 2; r < s; r += 6)this.globalData.canvasContext.bezierCurveTo(u[r], u[r + 1], u[r + 2], u[r + 3], u[r + 4], u[r + 5]); this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke() } a && this.globalData.renderer.restore() } }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () { if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) { var t = createTag("canvas"); t.width = this.assetData.w, t.height = this.assetData.h; var e, n, i = t.getContext("2d"), r = this.img.width, s = this.img.height, o = r / s, a = this.assetData.w / this.assetData.h, l = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio; o > a && "xMidYMid slice" === l || o < a && "xMidYMid slice" !== l ? e = (n = s) * a : n = (e = r) / a, i.drawImage(this.img, (r - e) / 2, (s - n) / 2, e, n, 0, 0, this.assetData.w, this.assetData.h), this.img = t } }, CVImageElement.prototype.renderInnerContent = function () { this.canvasContext.drawImage(this.img, 0, 0) }, CVImageElement.prototype.destroy = function () { this.img = null }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () { var t = this.canvasContext; t.fillStyle = this.data.sc, t.fillRect(0, 0, this.data.sw, this.data.sh) }, extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function (t) { return new CVShapeElement(t, this.globalData, this) }, CanvasRendererBase.prototype.createText = function (t) { return new CVTextElement(t, this.globalData, this) }, CanvasRendererBase.prototype.createImage = function (t) { return new CVImageElement(t, this.globalData, this) }, CanvasRendererBase.prototype.createSolid = function (t) { return new CVSolidElement(t, this.globalData, this) }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function (t) { if (1 !== t[0] || 0 !== t[1] || 0 !== t[4] || 1 !== t[5] || 0 !== t[12] || 0 !== t[13]) if (this.renderConfig.clearCanvas) { this.transformMat.cloneFromProps(t); var e = this.contextData.getTransform(), n = e.props; this.transformMat.transform(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]), e.cloneFromProps(this.transformMat.props); var i = e.props; this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13]) } else this.canvasContext.transform(t[0], t[1], t[4], t[5], t[12], t[13]) }, CanvasRendererBase.prototype.ctxOpacity = function (t) { var e = this.contextData.getOpacity(); if (!this.renderConfig.clearCanvas) return this.canvasContext.globalAlpha *= t < 0 ? 0 : t, void (this.globalData.currentGlobalAlpha = e); e *= t < 0 ? 0 : t, this.contextData.setOpacity(e), this.globalData.currentGlobalAlpha !== e && (this.canvasContext.globalAlpha = e, this.globalData.currentGlobalAlpha = e) }, CanvasRendererBase.prototype.reset = function () { this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore() }, CanvasRendererBase.prototype.save = function (t) { this.renderConfig.clearCanvas ? (t && this.canvasContext.save(), this.contextData.push()) : this.canvasContext.save() }, CanvasRendererBase.prototype.restore = function (t) { if (this.renderConfig.clearCanvas) { t && (this.canvasContext.restore(), this.globalData.blendMode = "source-over"); var e = this.contextData.pop(), n = e.transform, i = e.opacity; this.canvasContext.setTransform(n[0], n[1], n[4], n[5], n[12], n[13]), this.globalData.currentGlobalAlpha !== i && (this.canvasContext.globalAlpha = i, this.globalData.currentGlobalAlpha = i) } else this.canvasContext.restore() }, CanvasRendererBase.prototype.configAnimation = function (t) { if (this.animationItem.wrapper) { this.animationItem.container = createTag("canvas"); var e = this.animationItem.container.style; e.width = "100%", e.height = "100%"; var n = "0px 0px 0px"; e.transformOrigin = n, e.mozTransformOrigin = n, e.webkitTransformOrigin = n, e["-webkit-transform"] = n, e.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id) } else this.canvasContext = this.renderConfig.context; this.data = t, this.layers = t.layers, this.transformCanvas = { w: t.w, h: t.h, sx: 0, sy: 0, tx: 0, ty: 0 }, this.setupGlobalData(t, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(t.layers.length), this.updateContainerSize() }, CanvasRendererBase.prototype.updateContainerSize = function (t, e) { var n, i, r, s; if (this.reset(), t ? (n = t, i = e, this.canvasContext.canvas.width = n, this.canvasContext.canvas.height = i) : (this.animationItem.wrapper && this.animationItem.container ? (n = this.animationItem.wrapper.offsetWidth, i = this.animationItem.wrapper.offsetHeight) : (n = this.canvasContext.canvas.width, i = this.canvasContext.canvas.height), this.canvasContext.canvas.width = n * this.renderConfig.dpr, this.canvasContext.canvas.height = i * this.renderConfig.dpr), -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice")) { var o = this.renderConfig.preserveAspectRatio.split(" "), a = o[1] || "meet", l = o[0] || "xMidYMid", h = l.substr(0, 4), c = l.substr(4); r = n / i, (s = this.transformCanvas.w / this.transformCanvas.h) > r && "meet" === a || s < r && "slice" === a ? (this.transformCanvas.sx = n / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = n / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = i / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = i / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = "xMid" === h && (s < r && "meet" === a || s > r && "slice" === a) ? (n - this.transformCanvas.w * (i / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === h && (s < r && "meet" === a || s > r && "slice" === a) ? (n - this.transformCanvas.w * (i / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = "YMid" === c && (s > r && "meet" === a || s < r && "slice" === a) ? (i - this.transformCanvas.h * (n / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === c && (s > r && "meet" === a || s < r && "slice" === a) ? (i - this.transformCanvas.h * (n / this.transformCanvas.w)) * this.renderConfig.dpr : 0 } else "none" === this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = n / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = i / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0); this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0) }, CanvasRendererBase.prototype.destroy = function () { var t; for (this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), t = (this.layers ? this.layers.length : 0) - 1; t >= 0; t -= 1)this.elements[t] && this.elements[t].destroy(); this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0 }, CanvasRendererBase.prototype.renderFrame = function (t, e) { if ((this.renderedFrame !== t || !0 !== this.renderConfig.clearCanvas || e) && !this.destroyed && -1 !== t) { var n; this.renderedFrame = t, this.globalData.frameNum = t - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || e, this.globalData.projectInterface.currentFrame = t; var i = this.layers.length; for (this.completeLayers || this.checkLayers(t), n = 0; n < i; n += 1)(this.completeLayers || this.elements[n]) && this.elements[n].prepareFrame(t - this.layers[n].st); if (this.globalData._mdf) { for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), n = i - 1; n >= 0; n -= 1)(this.completeLayers || this.elements[n]) && this.elements[n].renderFrame(); !0 !== this.renderConfig.clearCanvas && this.restore() } } }, CanvasRendererBase.prototype.buildItem = function (t) { var e = this.elements; if (!e[t] && 99 !== this.layers[t].ty) { var n = this.createItem(this.layers[t], this, this.globalData); e[t] = n, n.initExpressions() } }, CanvasRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;)this.pendingElements.pop().checkParenting() }, CanvasRendererBase.prototype.hide = function () { this.animationItem.container.style.display = "none" }, CanvasRendererBase.prototype.show = function () { this.animationItem.container.style.display = "block" }, extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () { var t, e = this.canvasContext; for (e.beginPath(), e.moveTo(0, 0), e.lineTo(this.data.w, 0), e.lineTo(this.data.w, this.data.h), e.lineTo(0, this.data.h), e.lineTo(0, 0), e.clip(), t = this.layers.length - 1; t >= 0; t -= 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame() }, CVCompElement.prototype.destroy = function () { var t; for (t = this.layers.length - 1; t >= 0; t -= 1)this.elements[t] && this.elements[t].destroy(); this.layers = null, this.elements = null }, CVCompElement.prototype.createComp = function (t) { return new CVCompElement(t, this.globalData, this) }, extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function (t) { return new CVCompElement(t, this.globalData, this) }, HBaseElement.prototype = { checkBlendMode: function () { }, initRendererElement: function () { this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement) }, createContainerElements: function () { this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.bm && this.setBlendMode() }, renderElement: function () { var t = this.transformedElement ? this.transformedElement.style : {}; if (this.finalTransform._matMdf) { var e = this.finalTransform.mat.toCSS(); t.transform = e, t.webkitTransform = e } this.finalTransform._opMdf && (t.opacity = this.finalTransform.mProp.o.v) }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, destroy: function () { this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null) }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData) }, addEffects: function () { }, setMatte: function () { } }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () { var t; this.data.hasMask ? ((t = createNS("rect")).setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : ((t = createTag("div")).style.width = this.data.sw + "px", t.style.height = this.data.sh + "px", t.style.backgroundColor = this.data.sc), this.layerElement.appendChild(t) }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () { var t; if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), t = this.svgElement; else { t = createNS("svg"); var e = this.comp.data ? this.comp.data : this.globalData.compSize; t.setAttribute("width", e.w), t.setAttribute("height", e.h), t.appendChild(this.shapesContainer), this.layerElement.appendChild(t) } this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = t }, HShapeElement.prototype.getTransformedPoint = function (t, e) { var n, i = t.length; for (n = 0; n < i; n += 1)e = t[n].mProps.v.applyToPointArray(e[0], e[1], 0); return e }, HShapeElement.prototype.calculateShapeBoundingBox = function (t, e) { var n, i, r, s, o, a = t.sh.v, l = t.transformers, h = a._length; if (!(h <= 1)) { for (n = 0; n < h - 1; n += 1)i = this.getTransformedPoint(l, a.v[n]), r = this.getTransformedPoint(l, a.o[n]), s = this.getTransformedPoint(l, a.i[n + 1]), o = this.getTransformedPoint(l, a.v[n + 1]), this.checkBounds(i, r, s, o, e); a.c && (i = this.getTransformedPoint(l, a.v[n]), r = this.getTransformedPoint(l, a.o[n]), s = this.getTransformedPoint(l, a.i[0]), o = this.getTransformedPoint(l, a.v[0]), this.checkBounds(i, r, s, o, e)) } }, HShapeElement.prototype.checkBounds = function (t, e, n, i, r) { this.getBoundsOfCurve(t, e, n, i); var s = this.shapeBoundingBox; r.x = bmMin(s.left, r.x), r.xMax = bmMax(s.right, r.xMax), r.y = bmMin(s.top, r.y), r.yMax = bmMax(s.bottom, r.yMax) }, HShapeElement.prototype.shapeBoundingBox = { left: 0, right: 0, top: 0, bottom: 0 }, HShapeElement.prototype.tempBoundingBox = { x: 0, xMax: 0, y: 0, yMax: 0, width: 0, height: 0 }, HShapeElement.prototype.getBoundsOfCurve = function (t, e, n, i) { for (var r, s, o, a, l, h, c, u = [[t[0], i[0]], [t[1], i[1]]], d = 0; d < 2; ++d)s = 6 * t[d] - 12 * e[d] + 6 * n[d], r = -3 * t[d] + 9 * e[d] - 9 * n[d] + 3 * i[d], o = 3 * e[d] - 3 * t[d], s |= 0, o |= 0, 0 == (r |= 0) && 0 === s || (0 === r ? (a = -o / s) > 0 && a < 1 && u[d].push(this.calculateF(a, t, e, n, i, d)) : (l = s * s - 4 * o * r) >= 0 && ((h = (-s + bmSqrt(l)) / (2 * r)) > 0 && h < 1 && u[d].push(this.calculateF(h, t, e, n, i, d)), (c = (-s - bmSqrt(l)) / (2 * r)) > 0 && c < 1 && u[d].push(this.calculateF(c, t, e, n, i, d)))); this.shapeBoundingBox.left = bmMin.apply(null, u[0]), this.shapeBoundingBox.top = bmMin.apply(null, u[1]), this.shapeBoundingBox.right = bmMax.apply(null, u[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, u[1]) }, HShapeElement.prototype.calculateF = function (t, e, n, i, r, s) { return bmPow(1 - t, 3) * e[s] + 3 * bmPow(1 - t, 2) * t * n[s] + 3 * (1 - t) * bmPow(t, 2) * i[s] + bmPow(t, 3) * r[s] }, HShapeElement.prototype.calculateBoundingBox = function (t, e) { var n, i = t.length; for (n = 0; n < i; n += 1)t[n] && t[n].sh ? this.calculateShapeBoundingBox(t[n], e) : t[n] && t[n].it ? this.calculateBoundingBox(t[n].it, e) : t[n] && t[n].style && t[n].w && this.expandStrokeBoundingBox(t[n].w, e) }, HShapeElement.prototype.expandStrokeBoundingBox = function (t, e) { var n = 0; if (t.keyframes) { for (var i = 0; i < t.keyframes.length; i += 1) { var r = t.keyframes[i].s; r > n && (n = r) } n *= t.mult } else n = t.v * t.mult; e.x -= n, e.xMax += n, e.y -= n, e.yMax += n }, HShapeElement.prototype.currentBoxContains = function (t) { return this.currentBBox.x <= t.x && this.currentBBox.y <= t.y && this.currentBBox.width + this.currentBBox.x >= t.x + t.width && this.currentBBox.height + this.currentBBox.y >= t.y + t.height }, HShapeElement.prototype.renderInnerContent = function () { if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) { var t = this.tempBoundingBox, e = 999999; if (t.x = e, t.xMax = -e, t.y = e, t.yMax = -e, this.calculateBoundingBox(this.itemsData, t), t.width = t.xMax < t.x ? 0 : t.xMax - t.x, t.height = t.yMax < t.y ? 0 : t.yMax - t.y, this.currentBoxContains(t)) return; var n = !1; if (this.currentBBox.w !== t.width && (this.currentBBox.w = t.width, this.shapeCont.setAttribute("width", t.width), n = !0), this.currentBBox.h !== t.height && (this.currentBBox.h = t.height, this.shapeCont.setAttribute("height", t.height), n = !0), n || this.currentBBox.x !== t.x || this.currentBBox.y !== t.y) { this.currentBBox.w = t.width, this.currentBBox.h = t.height, this.currentBBox.x = t.x, this.currentBBox.y = t.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h); var i = this.shapeCont.style, r = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; i.transform = r, i.webkitTransform = r } } }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () { if (this.isMasked = this.checkMasks(), this.isMasked) { this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH); var t = createNS("g"); this.maskedElement.appendChild(t), this.innerElem = t } else this.renderType = "html", this.innerElem = this.layerElement; this.checkParenting() }, HTextElement.prototype.buildNewText = function () { var t = this.textProperty.currentData; this.renderedLetters = createSizedArray(t.l ? t.l.length : 0); var e = this.innerElem.style, n = t.fc ? this.buildColor(t.fc) : "rgba(0,0,0,0)"; e.fill = n, e.color = n, t.sc && (e.stroke = this.buildColor(t.sc), e.strokeWidth = t.sw + "px"); var i, r, s = this.globalData.fontManager.getFontByName(t.f); if (!this.globalData.fontManager.chars) if (e.fontSize = t.finalSize + "px", e.lineHeight = t.finalSize + "px", s.fClass) this.innerElem.className = s.fClass; else { e.fontFamily = s.fFamily; var o = t.fWeight, a = t.fStyle; e.fontStyle = a, e.fontWeight = o } var l, h, c, u = t.l; r = u.length; var d, p = this.mHelper, f = "", m = 0; for (i = 0; i < r; i += 1) { if (this.globalData.fontManager.chars ? (this.textPaths[m] ? l = this.textPaths[m] : ((l = createNS("path")).setAttribute("stroke-linecap", lineCapEnum[1]), l.setAttribute("stroke-linejoin", lineJoinEnum[2]), l.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[m] ? c = (h = this.textSpans[m]).children[0] : ((h = createTag("div")).style.lineHeight = 0, (c = createNS("svg")).appendChild(l), styleDiv(h)))) : this.isMasked ? l = this.textPaths[m] ? this.textPaths[m] : createNS("text") : this.textSpans[m] ? (h = this.textSpans[m], l = this.textPaths[m]) : (styleDiv(h = createTag("span")), styleDiv(l = createTag("span")), h.appendChild(l)), this.globalData.fontManager.chars) { var g, v = this.globalData.fontManager.getCharData(t.finalText[i], s.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily); if (g = v ? v.data : null, p.reset(), g && g.shapes && g.shapes.length && (d = g.shapes[0].it, p.scale(t.finalSize / 100, t.finalSize / 100), f = this.createPathShape(p, d), l.setAttribute("d", f)), this.isMasked) this.innerElem.appendChild(l); else { if (this.innerElem.appendChild(h), g && g.shapes) { document.body.appendChild(c); var A = c.getBBox(); c.setAttribute("width", A.width + 2), c.setAttribute("height", A.height + 2), c.setAttribute("viewBox", A.x - 1 + " " + (A.y - 1) + " " + (A.width + 2) + " " + (A.height + 2)); var b = c.style, y = "translate(" + (A.x - 1) + "px," + (A.y - 1) + "px)"; b.transform = y, b.webkitTransform = y, u[i].yOffset = A.y - 1 } else c.setAttribute("width", 1), c.setAttribute("height", 1); h.appendChild(c) } } else if (l.textContent = u[i].val, l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(l); else { this.innerElem.appendChild(h); var x = l.style, _ = "translate3d(0," + -t.finalSize / 1.2 + "px,0)"; x.transform = _, x.webkitTransform = _ } this.isMasked ? this.textSpans[m] = l : this.textSpans[m] = h, this.textSpans[m].style.display = "block", this.textPaths[m] = l, m += 1 } for (; m < this.textSpans.length;)this.textSpans[m].style.display = "none", m += 1 }, HTextElement.prototype.renderInnerContent = function () { var t; if (this.data.singleShape) { if (!this._isFirstFrame && !this.lettersChangedFlag) return; if (this.isMasked && this.finalTransform._matMdf) { this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), t = this.svgElement.style; var e = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)"; t.transform = e, t.webkitTransform = e } } if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) { var n, i, r, s, o, a = 0, l = this.textAnimator.renderedLetters, h = this.textProperty.currentData.l; for (i = h.length, n = 0; n < i; n += 1)h[n].n ? a += 1 : (s = this.textSpans[n], o = this.textPaths[n], r = l[a], a += 1, r._mdf.m && (this.isMasked ? s.setAttribute("transform", r.m) : (s.style.webkitTransform = r.m, s.style.transform = r.m)), s.style.opacity = r.o, r.sw && r._mdf.sw && o.setAttribute("stroke-width", r.sw), r.sc && r._mdf.sc && o.setAttribute("stroke", r.sc), r.fc && r._mdf.fc && (o.setAttribute("fill", r.fc), o.style.color = r.fc)); if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) { var c = this.innerElem.getBBox(); if (this.currentBBox.w !== c.width && (this.currentBBox.w = c.width, this.svgElement.setAttribute("width", c.width)), this.currentBBox.h !== c.height && (this.currentBBox.h = c.height, this.svgElement.setAttribute("height", c.height)), this.currentBBox.w !== c.width + 2 || this.currentBBox.h !== c.height + 2 || this.currentBBox.x !== c.x - 1 || this.currentBBox.y !== c.y - 1) { this.currentBBox.w = c.width + 2, this.currentBBox.h = c.height + 2, this.currentBBox.x = c.x - 1, this.currentBBox.y = c.y - 1, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), t = this.svgElement.style; var u = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; t.transform = u, t.webkitTransform = u } } } }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () { var t, e, n, i, r = this.comp.threeDElements.length; for (t = 0; t < r; t += 1)if ("3d" === (e = this.comp.threeDElements[t]).type) { n = e.perspectiveElem.style, i = e.container.style; var s = this.pe.v + "px", o = "0px 0px 0px", a = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; n.perspective = s, n.webkitPerspective = s, i.transformOrigin = o, i.mozTransformOrigin = o, i.webkitTransformOrigin = o, n.transform = a, n.webkitTransform = a } }, HCameraElement.prototype.createElements = function () { }, HCameraElement.prototype.hide = function () { }, HCameraElement.prototype.renderFrame = function () { var t, e, n = this._isFirstFrame; if (this.hierarchy) for (e = this.hierarchy.length, t = 0; t < e; t += 1)n = this.hierarchy[t].finalTransform.mProp._mdf || n; if (n || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) { if (this.mat.reset(), this.hierarchy) for (t = e = this.hierarchy.length - 1; t >= 0; t -= 1) { var i = this.hierarchy[t].finalTransform.mProp; this.mat.translate(-i.p.v[0], -i.p.v[1], i.p.v[2]), this.mat.rotateX(-i.or.v[0]).rotateY(-i.or.v[1]).rotateZ(i.or.v[2]), this.mat.rotateX(-i.rx.v).rotateY(-i.ry.v).rotateZ(i.rz.v), this.mat.scale(1 / i.s.v[0], 1 / i.s.v[1], 1 / i.s.v[2]), this.mat.translate(i.a.v[0], i.a.v[1], i.a.v[2]) } if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) { var r; r = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]]; var s = Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2)), o = [r[0] / s, r[1] / s, r[2] / s], a = Math.sqrt(o[2] * o[2] + o[0] * o[0]), l = Math.atan2(o[1], a), h = Math.atan2(o[0], -o[2]); this.mat.rotateY(h).rotateX(-l) } this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v); var c = !this._prevMat.equals(this.mat); if ((c || this.pe._mdf) && this.comp.threeDElements) { var u, d, p; for (e = this.comp.threeDElements.length, t = 0; t < e; t += 1)if ("3d" === (u = this.comp.threeDElements[t]).type) { if (c) { var f = this.mat.toCSS(); (p = u.container.style).transform = f, p.webkitTransform = f } this.pe._mdf && ((d = u.perspectiveElem.style).perspective = this.pe.v + "px", d.webkitPerspective = this.pe.v + "px") } this.mat.clone(this._prevMat) } } this._isFirstFrame = !1 }, HCameraElement.prototype.prepareFrame = function (t) { this.prepareProperties(t, !0) }, HCameraElement.prototype.destroy = function () { }, HCameraElement.prototype.getBaseElement = function () { return null }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () { var t = this.globalData.getAssetsPath(this.assetData), e = new Image; this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(e), e.crossOrigin = "anonymous", e.src = t, this.data.ln && this.baseElement.setAttribute("id", this.data.ln) }, extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;)this.pendingElements.pop().checkParenting() }, HybridRendererBase.prototype.appendElementInPos = function (t, e) { var n = t.getBaseElement(); if (n) { var i = this.layers[e]; if (i.ddd && this.supports3d) this.addTo3dContainer(n, e); else if (this.threeDElements) this.addTo3dContainer(n, e); else { for (var r, s, o = 0; o < e;)this.elements[o] && !0 !== this.elements[o] && this.elements[o].getBaseElement && (s = this.elements[o], r = (this.layers[o].ddd ? this.getThreeDContainerByPos(o) : s.getBaseElement()) || r), o += 1; r ? i.ddd && this.supports3d || this.layerElement.insertBefore(n, r) : i.ddd && this.supports3d || this.layerElement.appendChild(n) } } }, HybridRendererBase.prototype.createShape = function (t) { return this.supports3d ? new HShapeElement(t, this.globalData, this) : new SVGShapeElement(t, this.globalData, this) }, HybridRendererBase.prototype.createText = function (t) { return this.supports3d ? new HTextElement(t, this.globalData, this) : new SVGTextLottieElement(t, this.globalData, this) }, HybridRendererBase.prototype.createCamera = function (t) { return this.camera = new HCameraElement(t, this.globalData, this), this.camera }, HybridRendererBase.prototype.createImage = function (t) { return this.supports3d ? new HImageElement(t, this.globalData, this) : new IImageElement(t, this.globalData, this) }, HybridRendererBase.prototype.createSolid = function (t) { return this.supports3d ? new HSolidElement(t, this.globalData, this) : new ISolidElement(t, this.globalData, this) }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function (t) { for (var e = 0, n = this.threeDElements.length; e < n;) { if (this.threeDElements[e].startPos <= t && this.threeDElements[e].endPos >= t) return this.threeDElements[e].perspectiveElem; e += 1 } return null }, HybridRendererBase.prototype.createThreeDContainer = function (t, e) { var n, i, r = createTag("div"); styleDiv(r); var s = createTag("div"); if (styleDiv(s), "3d" === e) { (n = r.style).width = this.globalData.compSize.w + "px", n.height = this.globalData.compSize.h + "px"; var o = "50% 50%"; n.webkitTransformOrigin = o, n.mozTransformOrigin = o, n.transformOrigin = o; var a = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; (i = s.style).transform = a, i.webkitTransform = a } r.appendChild(s); var l = { container: s, perspectiveElem: r, startPos: t, endPos: t, type: e }; return this.threeDElements.push(l), l }, HybridRendererBase.prototype.build3dContainers = function () { var t, e, n = this.layers.length, i = ""; for (t = 0; t < n; t += 1)this.layers[t].ddd && 3 !== this.layers[t].ty ? ("3d" !== i && (i = "3d", e = this.createThreeDContainer(t, "3d")), e.endPos = Math.max(e.endPos, t)) : ("2d" !== i && (i = "2d", e = this.createThreeDContainer(t, "2d")), e.endPos = Math.max(e.endPos, t)); for (t = (n = this.threeDElements.length) - 1; t >= 0; t -= 1)this.resizerElem.appendChild(this.threeDElements[t].perspectiveElem) }, HybridRendererBase.prototype.addTo3dContainer = function (t, e) { for (var n = 0, i = this.threeDElements.length; n < i;) { if (e <= this.threeDElements[n].endPos) { for (var r, s = this.threeDElements[n].startPos; s < e;)this.elements[s] && this.elements[s].getBaseElement && (r = this.elements[s].getBaseElement()), s += 1; r ? this.threeDElements[n].container.insertBefore(t, r) : this.threeDElements[n].container.appendChild(t); break } n += 1 } }, HybridRendererBase.prototype.configAnimation = function (t) { var e = createTag("div"), n = this.animationItem.wrapper, i = e.style; i.width = t.w + "px", i.height = t.h + "px", this.resizerElem = e, styleDiv(e), i.transformStyle = "flat", i.mozTransformStyle = "flat", i.webkitTransformStyle = "flat", this.renderConfig.className && e.setAttribute("class", this.renderConfig.className), n.appendChild(e), i.overflow = "hidden"; var r = createNS("svg"); r.setAttribute("width", "1"), r.setAttribute("height", "1"), styleDiv(r), this.resizerElem.appendChild(r); var s = createNS("defs"); r.appendChild(s), this.data = t, this.setupGlobalData(t, r), this.globalData.defs = s, this.layers = t.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize() }, HybridRendererBase.prototype.destroy = function () { var t; this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null; var e = this.layers ? this.layers.length : 0; for (t = 0; t < e; t += 1)this.elements[t].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, HybridRendererBase.prototype.updateContainerSize = function () { var t, e, n, i, r = this.animationItem.wrapper.offsetWidth, s = this.animationItem.wrapper.offsetHeight, o = r / s; this.globalData.compSize.w / this.globalData.compSize.h > o ? (t = r / this.globalData.compSize.w, e = r / this.globalData.compSize.w, n = 0, i = (s - this.globalData.compSize.h * (r / this.globalData.compSize.w)) / 2) : (t = s / this.globalData.compSize.h, e = s / this.globalData.compSize.h, n = (r - this.globalData.compSize.w * (s / this.globalData.compSize.h)) / 2, i = 0); var a = this.resizerElem.style; a.webkitTransform = "matrix3d(" + t + ",0,0,0,0," + e + ",0,0,0,0,1,0," + n + "," + i + ",0,1)", a.transform = a.webkitTransform }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function () { this.resizerElem.style.display = "none" }, HybridRendererBase.prototype.show = function () { this.resizerElem.style.display = "block" }, HybridRendererBase.prototype.initItems = function () { if (this.buildAllItems(), this.camera) this.camera.setup(); else { var t, e = this.globalData.compSize.w, n = this.globalData.compSize.h, i = this.threeDElements.length; for (t = 0; t < i; t += 1) { var r = this.threeDElements[t].perspectiveElem.style; r.webkitPerspective = Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2)) + "px", r.perspective = r.webkitPerspective } } }, HybridRendererBase.prototype.searchExtraCompositions = function (t) { var e, n = t.length, i = createTag("div"); for (e = 0; e < n; e += 1)if (t[e].xt) { var r = this.createComp(t[e], i, this.globalData.comp, null); r.initExpressions(), this.globalData.projectInterface.registerComposition(r) } }, extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () { this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement }, HCompElement.prototype.addTo3dContainer = function (t, e) { for (var n, i = 0; i < e;)this.elements[i] && this.elements[i].getBaseElement && (n = this.elements[i].getBaseElement()), i += 1; n ? this.layerElement.insertBefore(t, n) : this.layerElement.appendChild(t) }, HCompElement.prototype.createComp = function (t) { return this.supports3d ? new HCompElement(t, this.globalData, this) : new SVGCompElement(t, this.globalData, this) }, extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function (t) { return this.supports3d ? new HCompElement(t, this.globalData, this) : new SVGCompElement(t, this.globalData, this) }; var CompExpressionInterface = function (t) { function e(e) { for (var n = 0, i = t.layers.length; n < i;) { if (t.layers[n].nm === e || t.layers[n].ind === e) return t.elements[n].layerInterface; n += 1 } return null } return Object.defineProperty(e, "_name", { value: t.data.nm }), e.layer = e, e.pixelAspect = 1, e.height = t.data.h || t.globalData.compSize.h, e.width = t.data.w || t.globalData.compSize.w, e.pixelAspect = 1, e.frameDuration = 1 / t.globalData.frameRate, e.displayStartTime = 0, e.numLayers = t.layers.length, e }, Expressions = function () { var t = { initExpressions: function (t) { var e = 0, n = []; t.renderer.compInterface = CompExpressionInterface(t.renderer), t.renderer.globalData.projectInterface.registerComposition(t.renderer), t.renderer.globalData.pushExpression = function () { e += 1 }, t.renderer.globalData.popExpression = function () { 0 == (e -= 1) && function () { var t, e = n.length; for (t = 0; t < e; t += 1)n[t].release(); n.length = 0 }() }, t.renderer.globalData.registerExpressionProperty = function (t) { -1 === n.indexOf(t) && n.push(t) } } }; return t }(), MaskManagerInterface = function () { function t(t, e) { this._mask = t, this._data = e } return Object.defineProperty(t.prototype, "maskPath", { get: function () { return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop } }), Object.defineProperty(t.prototype, "maskOpacity", { get: function () { return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v } }), function (e) { var n, i = createSizedArray(e.viewData.length), r = e.viewData.length; for (n = 0; n < r; n += 1)i[n] = new t(e.viewData[n], e.masksProperties[n]); return function (t) { for (n = 0; n < r;) { if (e.masksProperties[n].nm === t) return i[n]; n += 1 } return null } } }(), ExpressionPropertyInterface = function () { var t = { pv: 0, v: 0, mult: 1 }, e = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }; function n(t, e, n) { Object.defineProperty(t, "velocity", { get: function () { return e.getVelocityAtTime(e.comp.currentFrame) } }), t.numKeys = e.keyframes ? e.keyframes.length : 0, t.key = function (i) { if (!t.numKeys) return 0; var r = ""; r = "s" in e.keyframes[i - 1] ? e.keyframes[i - 1].s : "e" in e.keyframes[i - 2] ? e.keyframes[i - 2].e : e.keyframes[i - 2].s; var s = "unidimensional" === n ? new Number(r) : Object.assign({}, r); return s.time = e.keyframes[i - 1].t / e.elem.comp.globalData.frameRate, s.value = "unidimensional" === n ? r[0] : r, s }, t.valueAtTime = e.getValueAtTime, t.speedAtTime = e.getSpeedAtTime, t.velocityAtTime = e.getVelocityAtTime, t.propertyGroup = e.propertyGroup } function i() { return t } return function (r) { return r ? "unidimensional" === r.propType ? function (e) { e && "pv" in e || (e = t); var i = 1 / e.mult, r = e.pv * i, s = new Number(r); return s.value = r, n(s, e, "unidimensional"), function () { return e.k && e.getValue(), r = e.v * i, s.value !== r && ((s = new Number(r)).value = r, n(s, e, "unidimensional")), s } }(r) : function (t) { t && "pv" in t || (t = e); var i = 1 / t.mult, r = t.data && t.data.l || t.pv.length, s = createTypedArray("float32", r), o = createTypedArray("float32", r); return s.value = o, n(s, t, "multidimensional"), function () { t.k && t.getValue(); for (var e = 0; e < r; e += 1)o[e] = t.v[e] * i, s[e] = o[e]; return s } }(r) : i } }(), TransformExpressionInterface = function (t) { function e(t) { switch (t) { case "scale": case "Scale": case "ADBE Scale": case 6: return e.scale; case "rotation": case "Rotation": case "ADBE Rotation": case "ADBE Rotate Z": case 10: return e.rotation; case "ADBE Rotate X": return e.xRotation; case "ADBE Rotate Y": return e.yRotation; case "position": case "Position": case "ADBE Position": case 2: return e.position; case "ADBE Position_0": return e.xPosition; case "ADBE Position_1": return e.yPosition; case "ADBE Position_2": return e.zPosition; case "anchorPoint": case "AnchorPoint": case "Anchor Point": case "ADBE AnchorPoint": case 1: return e.anchorPoint; case "opacity": case "Opacity": case 11: return e.opacity; default: return null } } var n, i, r, s; return Object.defineProperty(e, "rotation", { get: ExpressionPropertyInterface(t.r || t.rz) }), Object.defineProperty(e, "zRotation", { get: ExpressionPropertyInterface(t.rz || t.r) }), Object.defineProperty(e, "xRotation", { get: ExpressionPropertyInterface(t.rx) }), Object.defineProperty(e, "yRotation", { get: ExpressionPropertyInterface(t.ry) }), Object.defineProperty(e, "scale", { get: ExpressionPropertyInterface(t.s) }), t.p ? s = ExpressionPropertyInterface(t.p) : (n = ExpressionPropertyInterface(t.px), i = ExpressionPropertyInterface(t.py), t.pz && (r = ExpressionPropertyInterface(t.pz))), Object.defineProperty(e, "position", { get: function () { return t.p ? s() : [n(), i(), r ? r() : 0] } }), Object.defineProperty(e, "xPosition", { get: ExpressionPropertyInterface(t.px) }), Object.defineProperty(e, "yPosition", { get: ExpressionPropertyInterface(t.py) }), Object.defineProperty(e, "zPosition", { get: ExpressionPropertyInterface(t.pz) }), Object.defineProperty(e, "anchorPoint", { get: ExpressionPropertyInterface(t.a) }), Object.defineProperty(e, "opacity", { get: ExpressionPropertyInterface(t.o) }), Object.defineProperty(e, "skew", { get: ExpressionPropertyInterface(t.sk) }), Object.defineProperty(e, "skewAxis", { get: ExpressionPropertyInterface(t.sa) }), Object.defineProperty(e, "orientation", { get: ExpressionPropertyInterface(t.or) }), e }, LayerExpressionInterface = function () { function t(t) { var e = new Matrix; return void 0 !== t ? this._elem.finalTransform.mProp.getValueAtTime(t).clone(e) : this._elem.finalTransform.mProp.applyToMatrix(e), e } function e(t, e) { var n = this.getMatrix(e); return n.props[12] = 0, n.props[13] = 0, n.props[14] = 0, this.applyPoint(n, t) } function n(t, e) { var n = this.getMatrix(e); return this.applyPoint(n, t) } function i(t, e) { var n = this.getMatrix(e); return n.props[12] = 0, n.props[13] = 0, n.props[14] = 0, this.invertPoint(n, t) } function r(t, e) { var n = this.getMatrix(e); return this.invertPoint(n, t) } function s(t, e) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var n, i = this._elem.hierarchy.length; for (n = 0; n < i; n += 1)this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(t) } return t.applyToPointArray(e[0], e[1], e[2] || 0) } function o(t, e) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var n, i = this._elem.hierarchy.length; for (n = 0; n < i; n += 1)this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(t) } return t.inversePoint(e) } function a(t) { var e = new Matrix; if (e.reset(), this._elem.finalTransform.mProp.applyToMatrix(e), this._elem.hierarchy && this._elem.hierarchy.length) { var n, i = this._elem.hierarchy.length; for (n = 0; n < i; n += 1)this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(e); return e.inversePoint(t) } return e.inversePoint(t) } function l() { return [1, 1, 1, 1] } return function (h) { var c; function u(t) { switch (t) { case "ADBE Root Vectors Group": case "Contents": case 2: return u.shapeInterface; case 1: case 6: case "Transform": case "transform": case "ADBE Transform Group": return c; case 4: case "ADBE Effect Parade": case "effects": case "Effects": return u.effect; case "ADBE Text Properties": return u.textInterface; default: return null } } u.getMatrix = t, u.invertPoint = o, u.applyPoint = s, u.toWorld = n, u.toWorldVec = e, u.fromWorld = r, u.fromWorldVec = i, u.toComp = n, u.fromComp = a, u.sampleImage = l, u.sourceRectAtTime = h.sourceRectAtTime.bind(h), u._elem = h; var d = getDescriptor(c = TransformExpressionInterface(h.finalTransform.mProp), "anchorPoint"); return Object.defineProperties(u, { hasParent: { get: function () { return h.hierarchy.length } }, parent: { get: function () { return h.hierarchy[0].layerInterface } }, rotation: getDescriptor(c, "rotation"), scale: getDescriptor(c, "scale"), position: getDescriptor(c, "position"), opacity: getDescriptor(c, "opacity"), anchorPoint: d, anchor_point: d, transform: { get: function () { return c } }, active: { get: function () { return h.isInRange } } }), u.startTime = h.data.st, u.index = h.data.ind, u.source = h.data.refId, u.height = 0 === h.data.ty ? h.data.h : 100, u.width = 0 === h.data.ty ? h.data.w : 100, u.inPoint = h.data.ip / h.comp.globalData.frameRate, u.outPoint = h.data.op / h.comp.globalData.frameRate, u._name = h.data.nm, u.registerMaskInterface = function (t) { u.mask = new MaskManagerInterface(t, h) }, u.registerEffectsInterface = function (t) { u.effect = t }, u } }(), propertyGroupFactory = function (t, e) { return function (n) { return (n = void 0 === n ? 1 : n) <= 0 ? t : e(n - 1) } }, PropertyInterface = function (t, e) { var n = { _name: t }; return function (t) { return (t = void 0 === t ? 1 : t) <= 0 ? n : e(t - 1) } }, EffectsExpressionInterface = function () { function t(n, i, r, s) { function o(t) { for (var e = n.ef, i = 0, r = e.length; i < r;) { if (t === e[i].nm || t === e[i].mn || t === e[i].ix) return 5 === e[i].ty ? h[i] : h[i](); i += 1 } throw new Error } var a, l = propertyGroupFactory(o, r), h = [], c = n.ef.length; for (a = 0; a < c; a += 1)5 === n.ef[a].ty ? h.push(t(n.ef[a], i.effectElements[a], i.effectElements[a].propertyGroup, s)) : h.push(e(i.effectElements[a], n.ef[a].ty, s, l)); return "ADBE Color Control" === n.mn && Object.defineProperty(o, "color", { get: function () { return h[0]() } }), Object.defineProperties(o, { numProperties: { get: function () { return n.np } }, _name: { value: n.nm }, propertyGroup: { value: l } }), o.enabled = 0 !== n.en, o.active = o.enabled, o } function e(t, e, n, i) { var r = ExpressionPropertyInterface(t.p); return t.p.setGroupProperty && t.p.setGroupProperty(PropertyInterface("", i)), function () { return 10 === e ? n.comp.compInterface(t.p.v) : r() } } return { createEffectsInterface: function (e, n) { if (e.effectsManager) { var i, r = [], s = e.data.ef, o = e.effectsManager.effectElements.length; for (i = 0; i < o; i += 1)r.push(t(s[i], e.effectsManager.effectElements[i], n, e)); var a = e.data.ef || [], l = function (t) { for (i = 0, o = a.length; i < o;) { if (t === a[i].nm || t === a[i].mn || t === a[i].ix) return r[i]; i += 1 } return null }; return Object.defineProperty(l, "numProperties", { get: function () { return a.length } }), l } return null } } }(), ShapePathInterface = function (t, e, n) { var i = e.sh; function r(t) { return "Shape" === t || "shape" === t || "Path" === t || "path" === t || "ADBE Vector Shape" === t || 2 === t ? r.path : null } var s = propertyGroupFactory(r, n); return i.setGroupProperty(PropertyInterface("Path", s)), Object.defineProperties(r, { path: { get: function () { return i.k && i.getValue(), i } }, shape: { get: function () { return i.k && i.getValue(), i } }, _name: { value: t.nm }, ix: { value: t.ix }, propertyIndex: { value: t.ix }, mn: { value: t.mn }, propertyGroup: { value: n } }), r }, ShapeExpressionInterface = function () { function t(t, o, d) { var p, f = [], m = t ? t.length : 0; for (p = 0; p < m; p += 1)"gr" === t[p].ty ? f.push(e(t[p], o[p], d)) : "fl" === t[p].ty ? f.push(n(t[p], o[p], d)) : "st" === t[p].ty ? f.push(r(t[p], o[p], d)) : "tm" === t[p].ty ? f.push(s(t[p], o[p], d)) : "tr" === t[p].ty || ("el" === t[p].ty ? f.push(a(t[p], o[p], d)) : "sr" === t[p].ty ? f.push(l(t[p], o[p], d)) : "sh" === t[p].ty ? f.push(ShapePathInterface(t[p], o[p], d)) : "rc" === t[p].ty ? f.push(h(t[p], o[p], d)) : "rd" === t[p].ty ? f.push(c(t[p], o[p], d)) : "rp" === t[p].ty ? f.push(u(t[p], o[p], d)) : "gf" === t[p].ty ? f.push(i(t[p], o[p], d)) : f.push((t[p], o[p], function () { return null }))); return f } function e(e, n, i) { var r = function (t) { switch (t) { case "ADBE Vectors Group": case "Contents": case 2: return r.content; default: return r.transform } }; r.propertyGroup = propertyGroupFactory(r, i); var s = function (e, n, i) { var r, s = function (t) { for (var e = 0, n = r.length; e < n;) { if (r[e]._name === t || r[e].mn === t || r[e].propertyIndex === t || r[e].ix === t || r[e].ind === t) return r[e]; e += 1 } return "number" == typeof t ? r[t - 1] : null }; s.propertyGroup = propertyGroupFactory(s, i), r = t(e.it, n.it, s.propertyGroup), s.numProperties = r.length; var a = o(e.it[e.it.length - 1], n.it[n.it.length - 1], s.propertyGroup); return s.transform = a, s.propertyIndex = e.cix, s._name = e.nm, s }(e, n, r.propertyGroup), a = o(e.it[e.it.length - 1], n.it[n.it.length - 1], r.propertyGroup); return r.content = s, r.transform = a, Object.defineProperty(r, "_name", { get: function () { return e.nm } }), r.numProperties = e.np, r.propertyIndex = e.ix, r.nm = e.nm, r.mn = e.mn, r } function n(t, e, n) { function i(t) { return "Color" === t || "color" === t ? i.color : "Opacity" === t || "opacity" === t ? i.opacity : null } return Object.defineProperties(i, { color: { get: ExpressionPropertyInterface(e.c) }, opacity: { get: ExpressionPropertyInterface(e.o) }, _name: { value: t.nm }, mn: { value: t.mn } }), e.c.setGroupProperty(PropertyInterface("Color", n)), e.o.setGroupProperty(PropertyInterface("Opacity", n)), i } function i(t, e, n) { function i(t) { return "Start Point" === t || "start point" === t ? i.startPoint : "End Point" === t || "end point" === t ? i.endPoint : "Opacity" === t || "opacity" === t ? i.opacity : null } return Object.defineProperties(i, { startPoint: { get: ExpressionPropertyInterface(e.s) }, endPoint: { get: ExpressionPropertyInterface(e.e) }, opacity: { get: ExpressionPropertyInterface(e.o) }, type: { get: function () { return "a" } }, _name: { value: t.nm }, mn: { value: t.mn } }), e.s.setGroupProperty(PropertyInterface("Start Point", n)), e.e.setGroupProperty(PropertyInterface("End Point", n)), e.o.setGroupProperty(PropertyInterface("Opacity", n)), i } function r(t, e, n) { var i, r = propertyGroupFactory(h, n), s = propertyGroupFactory(l, r); function o(n) { Object.defineProperty(l, t.d[n].nm, { get: ExpressionPropertyInterface(e.d.dataProps[n].p) }) } var a = t.d ? t.d.length : 0, l = {}; for (i = 0; i < a; i += 1)o(i), e.d.dataProps[i].p.setGroupProperty(s); function h(t) { return "Color" === t || "color" === t ? h.color : "Opacity" === t || "opacity" === t ? h.opacity : "Stroke Width" === t || "stroke width" === t ? h.strokeWidth : null } return Object.defineProperties(h, { color: { get: ExpressionPropertyInterface(e.c) }, opacity: { get: ExpressionPropertyInterface(e.o) }, strokeWidth: { get: ExpressionPropertyInterface(e.w) }, dash: { get: function () { return l } }, _name: { value: t.nm }, mn: { value: t.mn } }), e.c.setGroupProperty(PropertyInterface("Color", r)), e.o.setGroupProperty(PropertyInterface("Opacity", r)), e.w.setGroupProperty(PropertyInterface("Stroke Width", r)), h } function s(t, e, n) { function i(e) { return e === t.e.ix || "End" === e || "end" === e ? i.end : e === t.s.ix ? i.start : e === t.o.ix ? i.offset : null } var r = propertyGroupFactory(i, n); return i.propertyIndex = t.ix, e.s.setGroupProperty(PropertyInterface("Start", r)), e.e.setGroupProperty(PropertyInterface("End", r)), e.o.setGroupProperty(PropertyInterface("Offset", r)), i.propertyIndex = t.ix, i.propertyGroup = n, Object.defineProperties(i, { start: { get: ExpressionPropertyInterface(e.s) }, end: { get: ExpressionPropertyInterface(e.e) }, offset: { get: ExpressionPropertyInterface(e.o) }, _name: { value: t.nm } }), i.mn = t.mn, i } function o(t, e, n) { function i(e) { return t.a.ix === e || "Anchor Point" === e ? i.anchorPoint : t.o.ix === e || "Opacity" === e ? i.opacity : t.p.ix === e || "Position" === e ? i.position : t.r.ix === e || "Rotation" === e || "ADBE Vector Rotation" === e ? i.rotation : t.s.ix === e || "Scale" === e ? i.scale : t.sk && t.sk.ix === e || "Skew" === e ? i.skew : t.sa && t.sa.ix === e || "Skew Axis" === e ? i.skewAxis : null } var r = propertyGroupFactory(i, n); return e.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", r)), e.transform.mProps.p.setGroupProperty(PropertyInterface("Position", r)), e.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", r)), e.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", r)), e.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", r)), e.transform.mProps.sk && (e.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", r)), e.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", r))), e.transform.op.setGroupProperty(PropertyInterface("Opacity", r)), Object.defineProperties(i, { opacity: { get: ExpressionPropertyInterface(e.transform.mProps.o) }, position: { get: ExpressionPropertyInterface(e.transform.mProps.p) }, anchorPoint: { get: ExpressionPropertyInterface(e.transform.mProps.a) }, scale: { get: ExpressionPropertyInterface(e.transform.mProps.s) }, rotation: { get: ExpressionPropertyInterface(e.transform.mProps.r) }, skew: { get: ExpressionPropertyInterface(e.transform.mProps.sk) }, skewAxis: { get: ExpressionPropertyInterface(e.transform.mProps.sa) }, _name: { value: t.nm } }), i.ty = "tr", i.mn = t.mn, i.propertyGroup = n, i } function a(t, e, n) { function i(e) { return t.p.ix === e ? i.position : t.s.ix === e ? i.size : null } var r = propertyGroupFactory(i, n); i.propertyIndex = t.ix; var s = "tm" === e.sh.ty ? e.sh.prop : e.sh; return s.s.setGroupProperty(PropertyInterface("Size", r)), s.p.setGroupProperty(PropertyInterface("Position", r)), Object.defineProperties(i, { size: { get: ExpressionPropertyInterface(s.s) }, position: { get: ExpressionPropertyInterface(s.p) }, _name: { value: t.nm } }), i.mn = t.mn, i } function l(t, e, n) { function i(e) { return t.p.ix === e ? i.position : t.r.ix === e ? i.rotation : t.pt.ix === e ? i.points : t.or.ix === e || "ADBE Vector Star Outer Radius" === e ? i.outerRadius : t.os.ix === e ? i.outerRoundness : !t.ir || t.ir.ix !== e && "ADBE Vector Star Inner Radius" !== e ? t.is && t.is.ix === e ? i.innerRoundness : null : i.innerRadius } var r = propertyGroupFactory(i, n), s = "tm" === e.sh.ty ? e.sh.prop : e.sh; return i.propertyIndex = t.ix, s.or.setGroupProperty(PropertyInterface("Outer Radius", r)), s.os.setGroupProperty(PropertyInterface("Outer Roundness", r)), s.pt.setGroupProperty(PropertyInterface("Points", r)), s.p.setGroupProperty(PropertyInterface("Position", r)), s.r.setGroupProperty(PropertyInterface("Rotation", r)), t.ir && (s.ir.setGroupProperty(PropertyInterface("Inner Radius", r)), s.is.setGroupProperty(PropertyInterface("Inner Roundness", r))), Object.defineProperties(i, { position: { get: ExpressionPropertyInterface(s.p) }, rotation: { get: ExpressionPropertyInterface(s.r) }, points: { get: ExpressionPropertyInterface(s.pt) }, outerRadius: { get: ExpressionPropertyInterface(s.or) }, outerRoundness: { get: ExpressionPropertyInterface(s.os) }, innerRadius: { get: ExpressionPropertyInterface(s.ir) }, innerRoundness: { get: ExpressionPropertyInterface(s.is) }, _name: { value: t.nm } }), i.mn = t.mn, i } function h(t, e, n) { function i(e) { return t.p.ix === e ? i.position : t.r.ix === e ? i.roundness : t.s.ix === e || "Size" === e || "ADBE Vector Rect Size" === e ? i.size : null } var r = propertyGroupFactory(i, n), s = "tm" === e.sh.ty ? e.sh.prop : e.sh; return i.propertyIndex = t.ix, s.p.setGroupProperty(PropertyInterface("Position", r)), s.s.setGroupProperty(PropertyInterface("Size", r)), s.r.setGroupProperty(PropertyInterface("Rotation", r)), Object.defineProperties(i, { position: { get: ExpressionPropertyInterface(s.p) }, roundness: { get: ExpressionPropertyInterface(s.r) }, size: { get: ExpressionPropertyInterface(s.s) }, _name: { value: t.nm } }), i.mn = t.mn, i } function c(t, e, n) { function i(e) { return t.r.ix === e || "Round Corners 1" === e ? i.radius : null } var r = propertyGroupFactory(i, n), s = e; return i.propertyIndex = t.ix, s.rd.setGroupProperty(PropertyInterface("Radius", r)), Object.defineProperties(i, { radius: { get: ExpressionPropertyInterface(s.rd) }, _name: { value: t.nm } }), i.mn = t.mn, i } function u(t, e, n) { function i(e) { return t.c.ix === e || "Copies" === e ? i.copies : t.o.ix === e || "Offset" === e ? i.offset : null } var r = propertyGroupFactory(i, n), s = e; return i.propertyIndex = t.ix, s.c.setGroupProperty(PropertyInterface("Copies", r)), s.o.setGroupProperty(PropertyInterface("Offset", r)), Object.defineProperties(i, { copies: { get: ExpressionPropertyInterface(s.c) }, offset: { get: ExpressionPropertyInterface(s.o) }, _name: { value: t.nm } }), i.mn = t.mn, i } return function (e, n, i) { var r; function s(t) { if ("number" == typeof t) return 0 === (t = void 0 === t ? 1 : t) ? i : r[t - 1]; for (var e = 0, n = r.length; e < n;) { if (r[e]._name === t) return r[e]; e += 1 } return null } return s.propertyGroup = propertyGroupFactory(s, (function () { return i })), r = t(e, n, s.propertyGroup), s.numProperties = r.length, s._name = "Contents", s } }(), TextExpressionInterface = function (t) { var e, n; function i(t) { return "ADBE Text Document" === t ? i.sourceText : null } return Object.defineProperty(i, "sourceText", { get: function () { t.textProperty.getValue(); var i = t.textProperty.currentData.t; return i !== e && (e = t.textProperty.currentData.t, (n = new String(i)).value = i || new String(i), Object.defineProperty(n, "style", { get: function () { return { fillColor: t.textProperty.currentData.fc } } })), n } }), i }; function _typeof$2(t) { return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof$2(t) } var FootageInterface = (dataInterfaceFactory = function (t) { function e(t) { return "Outline" === t ? e.outlineInterface() : null } return e._name = "Outline", e.outlineInterface = function (t) { var e = "", n = t.getFootageData(); function i(t) { if (n[t]) return e = t, "object" === _typeof$2(n = n[t]) ? i : n; var r = t.indexOf(e); if (-1 !== r) { var s = parseInt(t.substr(r + e.length), 10); return "object" === _typeof$2(n = n[s]) ? i : n } return "" } return function () { return e = "", n = t.getFootageData(), i } }(t), e }, function (t) { function e(t) { return "Data" === t ? e.dataInterface : null } return e._name = "Data", e.dataInterface = dataInterfaceFactory(t), e }), dataInterfaceFactory, interfaces = { layer: LayerExpressionInterface, effects: EffectsExpressionInterface, comp: CompExpressionInterface, shape: ShapeExpressionInterface, text: TextExpressionInterface, footage: FootageInterface }; function getInterface(t) { return interfaces[t] || null } function _typeof$1(t) { return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof$1(t) } function seedRandom(t, e) { var n, i = this, r = 256, s = 6, o = "random", a = e.pow(r, s), l = e.pow(2, 52), h = 2 * l, c = r - 1; function u(t) { var e, n = t.length, i = this, s = 0, o = i.i = i.j = 0, a = i.S = []; for (n || (t = [n++]); s < r;)a[s] = s++; for (s = 0; s < r; s++)a[s] = a[o = c & o + t[s % n] + (e = a[s])], a[o] = e; i.g = function (t) { for (var e, n = 0, s = i.i, o = i.j, a = i.S; t--;)e = a[s = c & s + 1], n = n * r + a[c & (a[s] = a[o = c & o + e]) + (a[o] = e)]; return i.i = s, i.j = o, n } } function d(t, e) { return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e } function p(t, e) { var n, i = [], r = _typeof$1(t); if (e && "object" == r) for (n in t) try { i.push(p(t[n], e - 1)) } catch (t) { } return i.length ? i : "string" == r ? t : t + "\0" } function f(t, e) { for (var n, i = t + "", r = 0; r < i.length;)e[c & r] = c & (n ^= 19 * e[c & r]) + i.charCodeAt(r++); return m(e) } function m(t) { return String.fromCharCode.apply(0, t) } e["seed" + o] = function (c, g, v) { var A = [], b = f(p((g = !0 === g ? { entropy: !0 } : g || {}).entropy ? [c, m(t)] : null === c ? function () { try { if (n) return m(n.randomBytes(r)); var e = new Uint8Array(r); return (i.crypto || i.msCrypto).getRandomValues(e), m(e) } catch (e) { var s = i.navigator, o = s && s.plugins; return [+new Date, i, o, i.screen, m(t)] } }() : c, 3), A), y = new u(A), x = function () { for (var t = y.g(s), e = a, n = 0; t < l;)t = (t + n) * r, e *= r, n = y.g(1); for (; t >= h;)t /= 2, e /= 2, n >>>= 1; return (t + n) / e }; return x.int32 = function () { return 0 | y.g(4) }, x.quick = function () { return y.g(4) / 4294967296 }, x.double = x, f(m(y.S), t), (g.pass || v || function (t, n, i, r) { return r && (r.S && d(r, y), t.state = function () { return d(y, {}) }), i ? (e[o] = t, n) : t })(x, b, "global" in g ? g.global : this == e, g.state) }, f(e.random(), t) } function initialize$2(t) { seedRandom([], t) } var propTypes = { SHAPE: "shape" }; function _typeof(t) { return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof(t) } var ExpressionManager = function () { var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null, frames = null; function $bm_isInstanceOfArray(t) { return t.constructor === Array || t.constructor === Float32Array } function isNumerable(t, e) { return "number" === t || "boolean" === t || "string" === t || e instanceof Number } function $bm_neg(t) { var e = _typeof(t); if ("number" === e || "boolean" === e || t instanceof Number) return -t; if ($bm_isInstanceOfArray(t)) { var n, i = t.length, r = []; for (n = 0; n < i; n += 1)r[n] = -t[n]; return r } return t.propType ? t.v : -t } initialize$2(BMMath); var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get, easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get, easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get; function sum(t, e) { var n = _typeof(t), i = _typeof(e); if ("string" === n || "string" === i) return t + e; if (isNumerable(n, t) && isNumerable(i, e)) return t + e; if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] += e, t; if (isNumerable(n, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t + e[0], e; if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) { for (var r = 0, s = t.length, o = e.length, a = []; r < s || r < o;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? a[r] = t[r] + e[r] : a[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1; return a } return 0 } var add = sum; function sub(t, e) { var n = _typeof(t), i = _typeof(e); if (isNumerable(n, t) && isNumerable(i, e)) return "string" === n && (t = parseInt(t, 10)), "string" === i && (e = parseInt(e, 10)), t - e; if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] -= e, t; if (isNumerable(n, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t - e[0], e; if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) { for (var r = 0, s = t.length, o = e.length, a = []; r < s || r < o;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? a[r] = t[r] - e[r] : a[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1; return a } return 0 } function mul(t, e) { var n, i, r, s = _typeof(t), o = _typeof(e); if (isNumerable(s, t) && isNumerable(o, e)) return t * e; if ($bm_isInstanceOfArray(t) && isNumerable(o, e)) { for (r = t.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1)n[i] = t[i] * e; return n } if (isNumerable(s, t) && $bm_isInstanceOfArray(e)) { for (r = e.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1)n[i] = t * e[i]; return n } return 0 } function div(t, e) { var n, i, r, s = _typeof(t), o = _typeof(e); if (isNumerable(s, t) && isNumerable(o, e)) return t / e; if ($bm_isInstanceOfArray(t) && isNumerable(o, e)) { for (r = t.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1)n[i] = t[i] / e; return n } if (isNumerable(s, t) && $bm_isInstanceOfArray(e)) { for (r = e.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1)n[i] = t / e[i]; return n } return 0 } function mod(t, e) { return "string" == typeof t && (t = parseInt(t, 10)), "string" == typeof e && (e = parseInt(e, 10)), t % e } var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod; function clamp(t, e, n) { if (e > n) { var i = n; n = e, e = i } return Math.min(Math.max(t, e), n) } function radiansToDegrees(t) { return t / degToRads } var radians_to_degrees = radiansToDegrees; function degreesToRadians(t) { return t * degToRads } var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0]; function length(t, e) { if ("number" == typeof t || t instanceof Number) return e = e || 0, Math.abs(t - e); var n; e || (e = helperLengthArray); var i = Math.min(t.length, e.length), r = 0; for (n = 0; n < i; n += 1)r += Math.pow(e[n] - t[n], 2); return Math.sqrt(r) } function normalize(t) { return div(t, length(t)) } function rgbToHsl(t) { var e, n, i = t[0], r = t[1], s = t[2], o = Math.max(i, r, s), a = Math.min(i, r, s), l = (o + a) / 2; if (o === a) e = 0, n = 0; else { var h = o - a; switch (n = l > .5 ? h / (2 - o - a) : h / (o + a), o) { case i: e = (r - s) / h + (r < s ? 6 : 0); break; case r: e = (s - i) / h + 2; break; case s: e = (i - r) / h + 4 }e /= 6 } return [e, n, l, t[3]] } function hue2rgb(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } function hslToRgb(t) { var e, n, i, r = t[0], s = t[1], o = t[2]; if (0 === s) e = o, i = o, n = o; else { var a = o < .5 ? o * (1 + s) : o + s - o * s, l = 2 * o - a; e = hue2rgb(l, a, r + 1 / 3), n = hue2rgb(l, a, r), i = hue2rgb(l, a, r - 1 / 3) } return [e, n, i, t[3]] } function linear(t, e, n, i, r) { if (void 0 !== i && void 0 !== r || (i = e, r = n, e = 0, n = 1), n < e) { var s = n; n = e, e = s } if (t <= e) return i; if (t >= n) return r; var o, a = n === e ? 0 : (t - e) / (n - e); if (!i.length) return i + (r - i) * a; var l = i.length, h = createTypedArray("float32", l); for (o = 0; o < l; o += 1)h[o] = i[o] + (r[o] - i[o]) * a; return h } function random(t, e) { if (void 0 === e && (void 0 === t ? (t = 0, e = 1) : (e = t, t = void 0)), e.length) { var n, i = e.length; t || (t = createTypedArray("float32", i)); var r = createTypedArray("float32", i), s = BMMath.random(); for (n = 0; n < i; n += 1)r[n] = t[n] + s * (e[n] - t[n]); return r } return void 0 === t && (t = 0), t + BMMath.random() * (e - t) } function createPath(t, e, n, i) { var r, s = t.length, o = shapePool.newElement(); o.setPathData(!!i, s); var a, l, h = [0, 0]; for (r = 0; r < s; r += 1)a = e && e[r] ? e[r] : h, l = n && n[r] ? n[r] : h, o.setTripleAt(t[r][0], t[r][1], l[0] + t[r][0], l[1] + t[r][1], a[0] + t[r][0], a[1] + t[r][1], r, !0); return o } function initiateExpression(elem, data, property) { function noOp(t) { return t } if (!elem.globalData.renderConfig.runExpressions) return noOp; var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = -1 !== val.indexOf("random"), elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property; thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", { get: function () { return thisProperty.v } }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0; var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || !0 !== this.data.hd, wiggle = function (t, e) { var n, i, r = this.pv.length ? this.pv.length : 1, s = createTypedArray("float32", r), o = Math.floor(5 * time); for (n = 0, i = 0; n < o;) { for (i = 0; i < r; i += 1)s[i] += -e + 2 * e * BMMath.random(); n += 1 } var a = 5 * time, l = a - Math.floor(a), h = createTypedArray("float32", r); if (r > 1) { for (i = 0; i < r; i += 1)h[i] = this.pv[i] + s[i] + (-e + 2 * e * BMMath.random()) * l; return h } return this.pv + s[0] + (-e + 2 * e * BMMath.random()) * l }.bind(this); function loopInDuration(t, e) { return loopIn(t, e, !0) } function loopOutDuration(t, e) { return loopOut(t, e, !0) } thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this)); var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface), time, velocity, value, text, textIndex, textTotal, selectorValue; function lookAt(t, e) { var n = [e[0] - t[0], e[1] - t[1], e[2] - t[2]], i = Math.atan2(n[0], Math.sqrt(n[1] * n[1] + n[2] * n[2])) / degToRads; return [-Math.atan2(n[1], n[2]) / degToRads, i, 0] } function easeOut(t, e, n, i, r) { return applyEase(easeOutBez, t, e, n, i, r) } function easeIn(t, e, n, i, r) { return applyEase(easeInBez, t, e, n, i, r) } function ease(t, e, n, i, r) { return applyEase(easeInOutBez, t, e, n, i, r) } function applyEase(t, e, n, i, r, s) { void 0 === r ? (r = n, s = i) : e = (e - n) / (i - n), e > 1 ? e = 1 : e < 0 && (e = 0); var o = t(e); if ($bm_isInstanceOfArray(r)) { var a, l = r.length, h = createTypedArray("float32", l); for (a = 0; a < l; a += 1)h[a] = (s[a] - r[a]) * o + r[a]; return h } return (s - r) * o + r } function nearestKey(t) { var e, n, i, r = data.k.length; if (data.k.length && "number" != typeof data.k[0]) if (n = -1, (t *= elem.comp.globalData.frameRate) < data.k[0].t) n = 1, i = data.k[0].t; else { for (e = 0; e < r - 1; e += 1) { if (t === data.k[e].t) { n = e + 1, i = data.k[e].t; break } if (t > data.k[e].t && t < data.k[e + 1].t) { t - data.k[e].t > data.k[e + 1].t - t ? (n = e + 2, i = data.k[e + 1].t) : (n = e + 1, i = data.k[e].t); break } } -1 === n && (n = e + 1, i = data.k[e].t) } else n = 0, i = 0; var s = {}; return s.index = n, s.time = i / elem.comp.globalData.frameRate, s } function key(t) { var e, n, i; if (!data.k.length || "number" == typeof data.k[0]) throw new Error("The property has no keyframe at index " + t); t -= 1, e = { time: data.k[t].t / elem.comp.globalData.frameRate, value: [] }; var r = Object.prototype.hasOwnProperty.call(data.k[t], "s") ? data.k[t].s : data.k[t - 1].e; for (i = r.length, n = 0; n < i; n += 1)e[n] = r[n], e.value[n] = r[n]; return e } function framesToTime(t, e) { return e || (e = elem.comp.globalData.frameRate), t / e } function timeToFrames(t, e) { return t || 0 === t || (t = time), e || (e = elem.comp.globalData.frameRate), t * e } function seedRandom(t) { BMMath.seedrandom(randSeed + t) } function sourceRectAtTime() { return elem.sourceRectAtTime() } function substring(t, e) { return "string" == typeof value ? void 0 === e ? value.substring(t) : value.substring(t, e) : "" } function substr(t, e) { return "string" == typeof value ? void 0 === e ? value.substr(t) : value.substr(t, e) : "" } function posterizeTime(t) { time = 0 === t ? 0 : Math.floor(time * t) / t, value = valueAtTime(time) } var index = elem.data.ind, hasParent = !(!elem.hierarchy || !elem.hierarchy.length), parent, randSeed = Math.floor(1e6 * Math.random()), globalData = elem.globalData; function executeExpression(t) { return value = t, this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), 4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt) } return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression } return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath], ob }(), expressionHelpers = { searchExpressions: function (t, e, n) { e.x && (n.k = !0, n.x = !0, n.initiateExpression = ExpressionManager.initiateExpression, n.effectsSequence.push(n.initiateExpression(t, e, n).bind(n))) }, getSpeedAtTime: function (t) { var e = this.getValueAtTime(t), n = this.getValueAtTime(t + -.01), i = 0; if (e.length) { var r; for (r = 0; r < e.length; r += 1)i += Math.pow(n[r] - e[r], 2); i = 100 * Math.sqrt(i) } else i = 0; return i }, getVelocityAtTime: function (t) { if (void 0 !== this.vel) return this.vel; var e, n, i = -.001, r = this.getValueAtTime(t), s = this.getValueAtTime(t + i); if (r.length) for (e = createTypedArray("float32", r.length), n = 0; n < r.length; n += 1)e[n] = (s[n] - r[n]) / i; else e = (s - r) / i; return e }, getValueAtTime: function (t) { return t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < t ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(t, this._cachingAtTime), this._cachingAtTime.lastFrame = t), this._cachingAtTime.value }, getStaticValueAtTime: function () { return this.pv }, setGroupProperty: function (t) { this.propertyGroup = t } }; function addPropertyDecorator() { function t(t, e, n) { if (!this.k || !this.keyframes) return this.pv; t = t ? t.toLowerCase() : ""; var i, r, s, o, a, l = this.comp.renderedFrame, h = this.keyframes, c = h[h.length - 1].t; if (l <= c) return this.pv; if (n ? r = c - (i = e ? Math.abs(c - this.elem.comp.globalData.frameRate * e) : Math.max(0, c - this.elem.data.ip)) : ((!e || e > h.length - 1) && (e = h.length - 1), i = c - (r = h[h.length - 1 - e].t)), "pingpong" === t) { if (Math.floor((l - r) / i) % 2 != 0) return this.getValueAtTime((i - (l - r) % i + r) / this.comp.globalData.frameRate, 0) } else { if ("offset" === t) { var u = this.getValueAtTime(r / this.comp.globalData.frameRate, 0), d = this.getValueAtTime(c / this.comp.globalData.frameRate, 0), p = this.getValueAtTime(((l - r) % i + r) / this.comp.globalData.frameRate, 0), f = Math.floor((l - r) / i); if (this.pv.length) { for (o = (a = new Array(u.length)).length, s = 0; s < o; s += 1)a[s] = (d[s] - u[s]) * f + p[s]; return a } return (d - u) * f + p } if ("continue" === t) { var m = this.getValueAtTime(c / this.comp.globalData.frameRate, 0), g = this.getValueAtTime((c - .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (o = (a = new Array(m.length)).length, s = 0; s < o; s += 1)a[s] = m[s] + (m[s] - g[s]) * ((l - c) / this.comp.globalData.frameRate) / 5e-4; return a } return m + (l - c) / .001 * (m - g) } } return this.getValueAtTime(((l - r) % i + r) / this.comp.globalData.frameRate, 0) } function e(t, e, n) { if (!this.k) return this.pv; t = t ? t.toLowerCase() : ""; var i, r, s, o, a, l = this.comp.renderedFrame, h = this.keyframes, c = h[0].t; if (l >= c) return this.pv; if (n ? r = c + (i = e ? Math.abs(this.elem.comp.globalData.frameRate * e) : Math.max(0, this.elem.data.op - c)) : ((!e || e > h.length - 1) && (e = h.length - 1), i = (r = h[e].t) - c), "pingpong" === t) { if (Math.floor((c - l) / i) % 2 == 0) return this.getValueAtTime(((c - l) % i + c) / this.comp.globalData.frameRate, 0) } else { if ("offset" === t) { var u = this.getValueAtTime(c / this.comp.globalData.frameRate, 0), d = this.getValueAtTime(r / this.comp.globalData.frameRate, 0), p = this.getValueAtTime((i - (c - l) % i + c) / this.comp.globalData.frameRate, 0), f = Math.floor((c - l) / i) + 1; if (this.pv.length) { for (o = (a = new Array(u.length)).length, s = 0; s < o; s += 1)a[s] = p[s] - (d[s] - u[s]) * f; return a } return p - (d - u) * f } if ("continue" === t) { var m = this.getValueAtTime(c / this.comp.globalData.frameRate, 0), g = this.getValueAtTime((c + .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (o = (a = new Array(m.length)).length, s = 0; s < o; s += 1)a[s] = m[s] + (m[s] - g[s]) * (c - l) / .001; return a } return m + (m - g) * (c - l) / .001 } } return this.getValueAtTime((i - ((c - l) % i + c)) / this.comp.globalData.frameRate, 0) } function n(t, e) { if (!this.k) return this.pv; if (t = .5 * (t || .4), (e = Math.floor(e || 5)) <= 1) return this.pv; var n, i, r = this.comp.renderedFrame / this.comp.globalData.frameRate, s = r - t, o = e > 1 ? (r + t - s) / (e - 1) : 1, a = 0, l = 0; for (n = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; a < e;) { if (i = this.getValueAtTime(s + a * o), this.pv.length) for (l = 0; l < this.pv.length; l += 1)n[l] += i[l]; else n += i; a += 1 } if (this.pv.length) for (l = 0; l < this.pv.length; l += 1)n[l] /= e; else n /= e; return n } function i(t) { this._transformCachingAtTime || (this._transformCachingAtTime = { v: new Matrix }); var e = this._transformCachingAtTime.v; if (e.cloneFromProps(this.pre.props), this.appliedTransformations < 1) { var n = this.a.getValueAtTime(t); e.translate(-n[0] * this.a.mult, -n[1] * this.a.mult, n[2] * this.a.mult) } if (this.appliedTransformations < 2) { var i = this.s.getValueAtTime(t); e.scale(i[0] * this.s.mult, i[1] * this.s.mult, i[2] * this.s.mult) } if (this.sk && this.appliedTransformations < 3) { var r = this.sk.getValueAtTime(t), s = this.sa.getValueAtTime(t); e.skewFromAxis(-r * this.sk.mult, s * this.sa.mult) } if (this.r && this.appliedTransformations < 4) { var o = this.r.getValueAtTime(t); e.rotate(-o * this.r.mult) } else if (!this.r && this.appliedTransformations < 4) { var a = this.rz.getValueAtTime(t), l = this.ry.getValueAtTime(t), h = this.rx.getValueAtTime(t), c = this.or.getValueAtTime(t); e.rotateZ(-a * this.rz.mult).rotateY(l * this.ry.mult).rotateX(h * this.rx.mult).rotateZ(-c[2] * this.or.mult).rotateY(c[1] * this.or.mult).rotateX(c[0] * this.or.mult) } if (this.data.p && this.data.p.s) { var u = this.px.getValueAtTime(t), d = this.py.getValueAtTime(t); if (this.data.p.z) { var p = this.pz.getValueAtTime(t); e.translate(u * this.px.mult, d * this.py.mult, -p * this.pz.mult) } else e.translate(u * this.px.mult, d * this.py.mult, 0) } else { var f = this.p.getValueAtTime(t); e.translate(f[0] * this.p.mult, f[1] * this.p.mult, -f[2] * this.p.mult) } return e } function r() { return this.v.clone(new Matrix) } var s = TransformPropertyFactory.getTransformProperty; TransformPropertyFactory.getTransformProperty = function (t, e, n) { var o = s(t, e, n); return o.dynamicProperties.length ? o.getValueAtTime = i.bind(o) : o.getValueAtTime = r.bind(o), o.setGroupProperty = expressionHelpers.setGroupProperty, o }; var o = PropertyFactory.getProp; PropertyFactory.getProp = function (i, r, s, a, l) { var h = o(i, r, s, a, l); h.kf ? h.getValueAtTime = expressionHelpers.getValueAtTime.bind(h) : h.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(h), h.setGroupProperty = expressionHelpers.setGroupProperty, h.loopOut = t, h.loopIn = e, h.smooth = n, h.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(h), h.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(h), h.numKeys = 1 === r.a ? r.k.length : 0, h.propertyIndex = r.ix; var c = 0; return 0 !== s && (c = createTypedArray("float32", 1 === r.a ? r.k[0].s.length : r.k.length)), h._cachingAtTime = { lastFrame: initialDefaultFrame, lastIndex: 0, value: c }, expressionHelpers.searchExpressions(i, r, h), h.k && l.addDynamicProperty(h), h }; var a = ShapePropertyFactory.getConstructorFunction(), l = ShapePropertyFactory.getKeyframedConstructorFunction(); function h() { } h.prototype = { vertices: function (t, e) { this.k && this.getValue(); var n, i = this.v; void 0 !== e && (i = this.getValueAtTime(e, 0)); var r = i._length, s = i[t], o = i.v, a = createSizedArray(r); for (n = 0; n < r; n += 1)a[n] = "i" === t || "o" === t ? [s[n][0] - o[n][0], s[n][1] - o[n][1]] : [s[n][0], s[n][1]]; return a }, points: function (t) { return this.vertices("v", t) }, inTangents: function (t) { return this.vertices("i", t) }, outTangents: function (t) { return this.vertices("o", t) }, isClosed: function () { return this.v.c }, pointOnPath: function (t, e) { var n = this.v; void 0 !== e && (n = this.getValueAtTime(e, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(n)); for (var i, r = this._segmentsLength, s = r.lengths, o = r.totalLength * t, a = 0, l = s.length, h = 0; a < l;) { if (h + s[a].addedLength > o) { var c = a, u = n.c && a === l - 1 ? 0 : a + 1, d = (o - h) / s[a].addedLength; i = bez.getPointInSegment(n.v[c], n.v[u], n.o[c], n.i[u], d, s[a]); break } h += s[a].addedLength, a += 1 } return i || (i = n.c ? [n.v[0][0], n.v[0][1]] : [n.v[n._length - 1][0], n.v[n._length - 1][1]]), i }, vectorOnPath: function (t, e, n) { 1 == t ? t = this.v.c : 0 == t && (t = .999); var i = this.pointOnPath(t, e), r = this.pointOnPath(t + .001, e), s = r[0] - i[0], o = r[1] - i[1], a = Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)); return 0 === a ? [0, 0] : "tangent" === n ? [s / a, o / a] : [-o / a, s / a] }, tangentOnPath: function (t, e) { return this.vectorOnPath(t, e, "tangent") }, normalOnPath: function (t, e) { return this.vectorOnPath(t, e, "normal") }, setGroupProperty: expressionHelpers.setGroupProperty, getValueAtTime: expressionHelpers.getStaticValueAtTime }, extendPrototype([h], a), extendPrototype([h], l), l.prototype.getValueAtTime = function (t) { return this._cachingAtTime || (this._cachingAtTime = { shapeValue: shapePool.clone(this.pv), lastIndex: 0, lastTime: initialDefaultFrame }), t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < t ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = t, this.interpolateShape(t, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue }, l.prototype.initiateExpression = ExpressionManager.initiateExpression; var c = ShapePropertyFactory.getShapeProp; ShapePropertyFactory.getShapeProp = function (t, e, n, i, r) { var s = c(t, e, n, i, r); return s.propertyIndex = e.ix, s.lock = !1, 3 === n ? expressionHelpers.searchExpressions(t, e.pt, s) : 4 === n && expressionHelpers.searchExpressions(t, e.ks, s), s.k && t.addDynamicProperty(s), s } } function initialize$1() { addPropertyDecorator() } function addDecorator() { TextProperty.prototype.getExpressionValue = function (t, e) { var n = this.calculateExpression(e); if (t.t !== n) { var i = {}; return this.copyData(i, t), i.t = n.toString(), i.__complete = !1, i } return t }, TextProperty.prototype.searchProperty = function () { var t = this.searchKeyframes(), e = this.searchExpressions(); return this.kf = t || e, this.kf }, TextProperty.prototype.searchExpressions = function () { return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null } } function initialize() { addDecorator() } function SVGComposableEffect() { } SVGComposableEffect.prototype = { createMergeNode: function (t, e) { var n, i, r = createNS("feMerge"); for (r.setAttribute("result", t), i = 0; i < e.length; i += 1)(n = createNS("feMergeNode")).setAttribute("in", e[i]), r.appendChild(n), r.appendChild(n); return r } }; var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0"; function SVGTintFilter(t, e, n, i, r) { this.filterManager = e; var s = createNS("feColorMatrix"); s.setAttribute("type", "matrix"), s.setAttribute("color-interpolation-filters", "linearRGB"), s.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = s, s.setAttribute("result", i + "_tint_1"), t.appendChild(s), (s = createNS("feColorMatrix")).setAttribute("type", "matrix"), s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), s.setAttribute("result", i + "_tint_2"), t.appendChild(s), this.matrixFilter = s; var o = this.createMergeNode(i, [r, i + "_tint_1", i + "_tint_2"]); t.appendChild(o) } function SVGFillFilter(t, e, n, i) { this.filterManager = e; var r = createNS("feColorMatrix"); r.setAttribute("type", "matrix"), r.setAttribute("color-interpolation-filters", "sRGB"), r.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), r.setAttribute("result", i), t.appendChild(r), this.matrixFilter = r } function SVGStrokeEffect(t, e, n) { this.initialized = !1, this.filterManager = e, this.elem = n, this.paths = [] } function SVGTritoneFilter(t, e, n, i) { this.filterManager = e; var r = createNS("feColorMatrix"); r.setAttribute("type", "matrix"), r.setAttribute("color-interpolation-filters", "linearRGB"), r.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), t.appendChild(r); var s = createNS("feComponentTransfer"); s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("result", i), this.matrixFilter = s; var o = createNS("feFuncR"); o.setAttribute("type", "table"), s.appendChild(o), this.feFuncR = o; var a = createNS("feFuncG"); a.setAttribute("type", "table"), s.appendChild(a), this.feFuncG = a; var l = createNS("feFuncB"); l.setAttribute("type", "table"), s.appendChild(l), this.feFuncB = l, t.appendChild(s) } function SVGProLevelsFilter(t, e, n, i) { this.filterManager = e; var r = this.filterManager.effectElements, s = createNS("feComponentTransfer"); (r[10].p.k || 0 !== r[10].p.v || r[11].p.k || 1 !== r[11].p.v || r[12].p.k || 1 !== r[12].p.v || r[13].p.k || 0 !== r[13].p.v || r[14].p.k || 1 !== r[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", s)), (r[17].p.k || 0 !== r[17].p.v || r[18].p.k || 1 !== r[18].p.v || r[19].p.k || 1 !== r[19].p.v || r[20].p.k || 0 !== r[20].p.v || r[21].p.k || 1 !== r[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", s)), (r[24].p.k || 0 !== r[24].p.v || r[25].p.k || 1 !== r[25].p.v || r[26].p.k || 1 !== r[26].p.v || r[27].p.k || 0 !== r[27].p.v || r[28].p.k || 1 !== r[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", s)), (r[31].p.k || 0 !== r[31].p.v || r[32].p.k || 1 !== r[32].p.v || r[33].p.k || 1 !== r[33].p.v || r[34].p.k || 0 !== r[34].p.v || r[35].p.k || 1 !== r[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", s)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (s.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(s)), (r[3].p.k || 0 !== r[3].p.v || r[4].p.k || 1 !== r[4].p.v || r[5].p.k || 1 !== r[5].p.v || r[6].p.k || 0 !== r[6].p.v || r[7].p.k || 1 !== r[7].p.v) && ((s = createNS("feComponentTransfer")).setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("result", i), t.appendChild(s), this.feFuncRComposed = this.createFeFunc("feFuncR", s), this.feFuncGComposed = this.createFeFunc("feFuncG", s), this.feFuncBComposed = this.createFeFunc("feFuncB", s)) } function SVGDropShadowEffect(t, e, n, i, r) { var s = e.container.globalData.renderConfig.filterSize, o = e.data.fs || s; t.setAttribute("x", o.x || s.x), t.setAttribute("y", o.y || s.y), t.setAttribute("width", o.width || s.width), t.setAttribute("height", o.height || s.height), this.filterManager = e; var a = createNS("feGaussianBlur"); a.setAttribute("in", "SourceAlpha"), a.setAttribute("result", i + "_drop_shadow_1"), a.setAttribute("stdDeviation", "0"), this.feGaussianBlur = a, t.appendChild(a); var l = createNS("feOffset"); l.setAttribute("dx", "25"), l.setAttribute("dy", "0"), l.setAttribute("in", i + "_drop_shadow_1"), l.setAttribute("result", i + "_drop_shadow_2"), this.feOffset = l, t.appendChild(l); var h = createNS("feFlood"); h.setAttribute("flood-color", "#00ff00"), h.setAttribute("flood-opacity", "1"), h.setAttribute("result", i + "_drop_shadow_3"), this.feFlood = h, t.appendChild(h); var c = createNS("feComposite"); c.setAttribute("in", i + "_drop_shadow_3"), c.setAttribute("in2", i + "_drop_shadow_2"), c.setAttribute("operator", "in"), c.setAttribute("result", i + "_drop_shadow_4"), t.appendChild(c); var u = this.createMergeNode(i, [i + "_drop_shadow_4", r]); t.appendChild(u) } extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { var e = this.filterManager.effectElements[0].p.v, n = this.filterManager.effectElements[1].p.v, i = this.filterManager.effectElements[2].p.v / 100; this.linearFilter.setAttribute("values", linearFilterValue + " " + i + " 0"), this.matrixFilter.setAttribute("values", n[0] - e[0] + " 0 0 0 " + e[0] + " " + (n[1] - e[1]) + " 0 0 0 " + e[1] + " " + (n[2] - e[2]) + " 0 0 0 " + e[2] + " 0 0 0 1 0") } }, SVGFillFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { var e = this.filterManager.effectElements[2].p.v, n = this.filterManager.effectElements[6].p.v; this.matrixFilter.setAttribute("values", "0 0 0 0 " + e[0] + " 0 0 0 0 " + e[1] + " 0 0 0 0 " + e[2] + " 0 0 0 " + n + " 0") } }, SVGStrokeEffect.prototype.initialize = function () { var t, e, n, i, r = this.elem.layerElement.children || this.elem.layerElement.childNodes; for (1 === this.filterManager.effectElements[1].p.v ? (i = this.elem.maskManager.masksProperties.length, n = 0) : i = 1 + (n = this.filterManager.effectElements[0].p.v - 1), (e = createNS("g")).setAttribute("fill", "none"), e.setAttribute("stroke-linecap", "round"), e.setAttribute("stroke-dashoffset", 1); n < i; n += 1)t = createNS("path"), e.appendChild(t), this.paths.push({ p: t, m: n }); if (3 === this.filterManager.effectElements[10].p.v) { var s = createNS("mask"), o = createElementID(); s.setAttribute("id", o), s.setAttribute("mask-type", "alpha"), s.appendChild(e), this.elem.globalData.defs.appendChild(s); var a = createNS("g"); for (a.setAttribute("mask", "url(" + getLocationHref() + "#" + o + ")"); r[0];)a.appendChild(r[0]); this.elem.layerElement.appendChild(a), this.masker = s, e.setAttribute("stroke", "#fff") } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) { if (2 === this.filterManager.effectElements[10].p.v) for (r = this.elem.layerElement.children || this.elem.layerElement.childNodes; r.length;)this.elem.layerElement.removeChild(r[0]); this.elem.layerElement.appendChild(e), this.elem.layerElement.removeAttribute("mask"), e.setAttribute("stroke", "#fff") } this.initialized = !0, this.pathMasker = e }, SVGStrokeEffect.prototype.renderFrame = function (t) { var e; this.initialized || this.initialize(); var n, i, r = this.paths.length; for (e = 0; e < r; e += 1)if (-1 !== this.paths[e].m && (n = this.elem.maskManager.viewData[this.paths[e].m], i = this.paths[e].p, (t || this.filterManager._mdf || n.prop._mdf) && i.setAttribute("d", n.lastPath), t || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || n.prop._mdf)) { var s; if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) { var o = .01 * Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v), a = .01 * Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v), l = i.getTotalLength(); s = "0 0 0 " + l * o + " "; var h, c = l * (a - o), u = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01, d = Math.floor(c / u); for (h = 0; h < d; h += 1)s += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01 + " "; s += "0 " + 10 * l + " 0 0" } else s = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01; i.setAttribute("stroke-dasharray", s) } if ((t || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v), (t || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) && (t || this.filterManager.effectElements[3].p._mdf)) { var p = this.filterManager.effectElements[3].p.v; this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(255 * p[0]) + "," + bmFloor(255 * p[1]) + "," + bmFloor(255 * p[2]) + ")") } }, SVGTritoneFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { var e = this.filterManager.effectElements[0].p.v, n = this.filterManager.effectElements[1].p.v, i = this.filterManager.effectElements[2].p.v, r = i[0] + " " + n[0] + " " + e[0], s = i[1] + " " + n[1] + " " + e[1], o = i[2] + " " + n[2] + " " + e[2]; this.feFuncR.setAttribute("tableValues", r), this.feFuncG.setAttribute("tableValues", s), this.feFuncB.setAttribute("tableValues", o) } }, SVGProLevelsFilter.prototype.createFeFunc = function (t, e) { var n = createNS(t); return n.setAttribute("type", "table"), e.appendChild(n), n }, SVGProLevelsFilter.prototype.getTableValue = function (t, e, n, i, r) { for (var s, o, a = 0, l = Math.min(t, e), h = Math.max(t, e), c = Array.call(null, { length: 256 }), u = 0, d = r - i, p = e - t; a <= 256;)o = (s = a / 256) <= l ? p < 0 ? r : i : s >= h ? p < 0 ? i : r : i + d * Math.pow((s - t) / p, 1 / n), c[u] = o, u += 1, a += 256 / 255; return c.join(" ") }, SVGProLevelsFilter.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { var e, n = this.filterManager.effectElements; this.feFuncRComposed && (t || n[3].p._mdf || n[4].p._mdf || n[5].p._mdf || n[6].p._mdf || n[7].p._mdf) && (e = this.getTableValue(n[3].p.v, n[4].p.v, n[5].p.v, n[6].p.v, n[7].p.v), this.feFuncRComposed.setAttribute("tableValues", e), this.feFuncGComposed.setAttribute("tableValues", e), this.feFuncBComposed.setAttribute("tableValues", e)), this.feFuncR && (t || n[10].p._mdf || n[11].p._mdf || n[12].p._mdf || n[13].p._mdf || n[14].p._mdf) && (e = this.getTableValue(n[10].p.v, n[11].p.v, n[12].p.v, n[13].p.v, n[14].p.v), this.feFuncR.setAttribute("tableValues", e)), this.feFuncG && (t || n[17].p._mdf || n[18].p._mdf || n[19].p._mdf || n[20].p._mdf || n[21].p._mdf) && (e = this.getTableValue(n[17].p.v, n[18].p.v, n[19].p.v, n[20].p.v, n[21].p.v), this.feFuncG.setAttribute("tableValues", e)), this.feFuncB && (t || n[24].p._mdf || n[25].p._mdf || n[26].p._mdf || n[27].p._mdf || n[28].p._mdf) && (e = this.getTableValue(n[24].p.v, n[25].p.v, n[26].p.v, n[27].p.v, n[28].p.v), this.feFuncB.setAttribute("tableValues", e)), this.feFuncA && (t || n[31].p._mdf || n[32].p._mdf || n[33].p._mdf || n[34].p._mdf || n[35].p._mdf) && (e = this.getTableValue(n[31].p.v, n[32].p.v, n[33].p.v, n[34].p.v, n[35].p.v), this.feFuncA.setAttribute("tableValues", e)) } }, extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { if ((t || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), t || this.filterManager.effectElements[0].p._mdf) { var e = this.filterManager.effectElements[0].p.v; this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * e[0]), Math.round(255 * e[1]), Math.round(255 * e[2]))) } if ((t || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), t || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) { var n = this.filterManager.effectElements[3].p.v, i = (this.filterManager.effectElements[2].p.v - 90) * degToRads, r = n * Math.cos(i), s = n * Math.sin(i); this.feOffset.setAttribute("dx", r), this.feOffset.setAttribute("dy", s) } } }; var _svgMatteSymbols = []; function SVGMatte3Effect(t, e, n) { this.initialized = !1, this.filterManager = e, this.filterElem = t, this.elem = n, n.matteElement = createNS("g"), n.matteElement.appendChild(n.layerElement), n.matteElement.appendChild(n.transformedElement), n.baseElement = n.matteElement } function SVGGaussianBlurEffect(t, e, n, i) { t.setAttribute("x", "-100%"), t.setAttribute("y", "-100%"), t.setAttribute("width", "300%"), t.setAttribute("height", "300%"), this.filterManager = e; var r = createNS("feGaussianBlur"); r.setAttribute("result", i), t.appendChild(r), this.feGaussianBlur = r } return SVGMatte3Effect.prototype.findSymbol = function (t) { for (var e = 0, n = _svgMatteSymbols.length; e < n;) { if (_svgMatteSymbols[e] === t) return _svgMatteSymbols[e]; e += 1 } return null }, SVGMatte3Effect.prototype.replaceInParent = function (t, e) { var n = t.layerElement.parentNode; if (n) { for (var i, r = n.children, s = 0, o = r.length; s < o && r[s] !== t.layerElement;)s += 1; s <= o - 2 && (i = r[s + 1]); var a = createNS("use"); a.setAttribute("href", "#" + e), i ? n.insertBefore(a, i) : n.appendChild(a) } }, SVGMatte3Effect.prototype.setElementAsMask = function (t, e) { if (!this.findSymbol(e)) { var n = createElementID(), i = createNS("mask"); i.setAttribute("id", e.layerId), i.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(e); var r = t.globalData.defs; r.appendChild(i); var s = createNS("symbol"); s.setAttribute("id", n), this.replaceInParent(e, n), s.appendChild(e.layerElement), r.appendChild(s); var o = createNS("use"); o.setAttribute("href", "#" + n), i.appendChild(o), e.data.hd = !1, e.show() } t.setMatte(e.layerId) }, SVGMatte3Effect.prototype.initialize = function () { for (var t = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, n = 0, i = e.length; n < i;)e[n] && e[n].data.ind === t && this.setElementAsMask(this.elem, e[n]), n += 1; this.initialized = !0 }, SVGMatte3Effect.prototype.renderFrame = function () { this.initialized || this.initialize() }, SVGGaussianBlurEffect.prototype.renderFrame = function (t) { if (t || this.filterManager._mdf) { var e = .3 * this.filterManager.effectElements[0].p.v, n = this.filterManager.effectElements[1].p.v, i = 3 == n ? 0 : e, r = 2 == n ? 0 : e; this.feGaussianBlur.setAttribute("stdDeviation", i + " " + r); var s = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate"; this.feGaussianBlur.setAttribute("edgeMode", s) } }, registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect(20, SVGTintFilter, !0), registerEffect(21, SVGFillFilter, !0), registerEffect(22, SVGStrokeEffect, !1), registerEffect(23, SVGTritoneFilter, !0), registerEffect(24, SVGProLevelsFilter, !0), registerEffect(25, SVGDropShadowEffect, !0), registerEffect(28, SVGMatte3Effect, !1), registerEffect(29, SVGGaussianBlurEffect, !0), lottie }, module.exports = factory()) }, 6587: function () { }, 2899: function () { }, 4279: function (t) { function e() { } e.prototype = { on: function (t, e, n) { var i = this.e || (this.e = {}); return (i[t] || (i[t] = [])).push({ fn: e, ctx: n }), this }, once: function (t, e, n) { var i = this; function r() { i.off(t, r), e.apply(n, arguments) } return r._ = e, this.on(t, r, n) }, emit: function (t) { for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++)n[i].fn.apply(n[i].ctx, e); return this }, off: function (t, e) { var n = this.e || (this.e = {}), i = n[t], r = []; if (i && e) for (var s = 0, o = i.length; s < o; s++)i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]); return r.length ? n[t] = r : delete n[t], this } }, t.exports = e, t.exports.TinyEmitter = e }, 6498: function (t, e) { !function (t) { "use strict"; class e { constructor(t) { const [e, n] = t.split("-"), i = e.split("."); this.major = parseInt(i[0], 10), this.minor = parseInt(i[1], 10), this.patch = parseInt(i[2], 10), this.prerelease = null != n ? n : null } toString() { const t = [this.major, this.minor, this.patch].join("."); return null !== this.prerelease ? [t, this.prerelease].join("-") : t } } class n { constructor(t) { this.controller_ = t } get element() { return this.controller_.view.element } get disabled() { return this.controller_.viewProps.get("disabled") } set disabled(t) { this.controller_.viewProps.set("disabled", t) } get hidden() { return this.controller_.viewProps.get("hidden") } set hidden(t) { this.controller_.viewProps.set("hidden", t) } dispose() { this.controller_.viewProps.set("disposed", !0) } } class i { constructor(t) { this.target = t } } class r extends i { constructor(t, e, n, i) { super(t), this.value = e, this.presetKey = n, this.last = null == i || i } } class s extends i { constructor(t, e, n) { super(t), this.value = e, this.presetKey = n } } class o extends i { constructor(t, e) { super(t), this.expanded = e } } class a extends i { constructor(t, e) { super(t), this.index = e } } function l(t) { return t } function h(t) { return null == t } function c(t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1; return !0 } function u(t, e) { let n = t; do { const t = Object.getOwnPropertyDescriptor(n, e); if (t && (void 0 !== t.set || !0 === t.writable)) return !0; n = Object.getPrototypeOf(n) } while (null !== n); return !1 } const d = { alreadydisposed: () => "View has been already disposed", invalidparams: t => `Invalid parameters for '${t.name}'`, nomatchingcontroller: t => `No matching controller for '${t.key}'`, nomatchingview: t => `No matching view for '${JSON.stringify(t.params)}'`, notbindable: () => "Value is not bindable", propertynotfound: t => `Property '${t.name}' not found`, shouldneverhappen: () => "This error should never happen" }; class p { static alreadyDisposed() { return new p({ type: "alreadydisposed" }) } static notBindable() { return new p({ type: "notbindable" }) } static propertyNotFound(t) { return new p({ type: "propertynotfound", context: { name: t } }) } static shouldNeverHappen() { return new p({ type: "shouldneverhappen" }) } constructor(t) { var e; this.message = null !== (e = d[t.type](l(t.context))) && void 0 !== e ? e : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = t.type } } class f { constructor(t, e, n) { this.obj_ = t, this.key_ = e, this.presetKey_ = null != n ? n : e } static isBindable(t) { return null !== t && "object" == typeof t } get key() { return this.key_ } get presetKey() { return this.presetKey_ } read() { return this.obj_[this.key_] } write(t) { this.obj_[this.key_] = t } writeProperty(t, e) { const n = this.read(); if (!f.isBindable(n)) throw p.notBindable(); if (!(t in n)) throw p.propertyNotFound(t); n[t] = e } } class m extends n { get label() { return this.controller_.props.get("label") } set label(t) { this.controller_.props.set("label", t) } get title() { var t; return null !== (t = this.controller_.valueController.props.get("title")) && void 0 !== t ? t : "" } set title(t) { this.controller_.valueController.props.set("title", t) } on(t, e) { const n = e.bind(this); return this.controller_.valueController.emitter.on(t, (() => { n(new i(this)) })), this } } class g { constructor() { this.observers_ = {} } on(t, e) { let n = this.observers_[t]; return n || (n = this.observers_[t] = []), n.push({ handler: e }), this } off(t, e) { const n = this.observers_[t]; return n && (this.observers_[t] = n.filter((t => t.handler !== e))), this } emit(t, e) { const n = this.observers_[t]; n && n.forEach((t => { t.handler(e) })) } } const v = "tp"; function A(t) { return (e, n) => [v, "-", t, "v", e ? `_${e}` : "", n ? `-${n}` : ""].join("") } function b(t, e) { return n => e(t(n)) } function y(t) { return t.rawValue } function x(t, e) { t.emitter.on("change", b(y, e)), e(t.rawValue) } function _(t, e, n) { x(t.value(e), n) } function w(t, e, n) { n ? t.classList.add(e) : t.classList.remove(e) } function E(t, e) { return n => { w(t, e, n) } } function C(t, e) { x(t, (t => { e.textContent = null != t ? t : "" })) } const S = A("btn"); class M { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(S()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("button"); n.classList.add(S("b")), e.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n; const i = t.createElement("div"); i.classList.add(S("t")), C(e.props.value("title"), i), this.buttonElement.appendChild(i) } } class P { constructor(t, e) { this.emitter = new g, this.onClick_ = this.onClick_.bind(this), this.props = e.props, this.viewProps = e.viewProps, this.view = new M(t, { props: this.props, viewProps: this.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_) } onClick_() { this.emitter.emit("click", { sender: this }) } } class I { constructor(t, e) { var n; this.constraint_ = null == e ? void 0 : e.constraint, this.equals_ = null !== (n = null == e ? void 0 : e.equals) && void 0 !== n ? n : (t, e) => t === e, this.emitter = new g, this.rawValue_ = t } get constraint() { return this.constraint_ } get rawValue() { return this.rawValue_ } set rawValue(t) { this.setRawValue(t, { forceEmit: !1, last: !0 }) } setRawValue(t, e) { const n = null != e ? e : { forceEmit: !1, last: !0 }, i = this.constraint_ ? this.constraint_.constrain(t) : t, r = this.rawValue_; (!this.equals_(r, i) || n.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.rawValue_ = i, this.emitter.emit("change", { options: n, previousRawValue: r, rawValue: i, sender: this })) } } class T { constructor(t) { this.emitter = new g, this.value_ = t } get rawValue() { return this.value_ } set rawValue(t) { this.setRawValue(t, { forceEmit: !1, last: !0 }) } setRawValue(t, e) { const n = null != e ? e : { forceEmit: !1, last: !0 }, i = this.value_; (i !== t || n.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.value_ = t, this.emitter.emit("change", { options: n, previousRawValue: i, rawValue: this.value_, sender: this })) } } function D(t, e) { const n = null == e ? void 0 : e.constraint, i = null == e ? void 0 : e.equals; return n || i ? new I(t, e) : new T(t) } class B { constructor(t) { this.emitter = new g, this.valMap_ = t; for (const t in this.valMap_) this.valMap_[t].emitter.on("change", (() => { this.emitter.emit("change", { key: t, sender: this }) })) } static createCore(t) { return Object.keys(t).reduce(((e, n) => Object.assign(e, { [n]: D(t[n]) })), {}) } static fromObject(t) { const e = this.createCore(t); return new B(e) } get(t) { return this.valMap_[t].rawValue } set(t, e) { this.valMap_[t].rawValue = e } value(t) { return this.valMap_[t] } } function L(t, e) { return l(Object.keys(e).reduce(((n, i) => { if (void 0 === n) return; const r = (0, e[i])(t[i]); return r.succeeded ? Object.assign(Object.assign({}, n), { [i]: r.value }) : void 0 }), {})) } function F(t, e) { return t.reduce(((t, n) => { if (void 0 === t) return; const i = e(n); return i.succeeded && void 0 !== i.value ? [...t, i.value] : void 0 }), []) } function k(t) { return null !== t && "object" == typeof t } function R(t) { return e => n => { if (!e && void 0 === n) return { succeeded: !1, value: void 0 }; if (e && void 0 === n) return { succeeded: !0, value: void 0 }; const i = t(n); return void 0 !== i ? { succeeded: !0, value: i } : { succeeded: !1, value: void 0 } } } function O(t) { return { custom: e => R(e)(t), boolean: R((t => "boolean" == typeof t ? t : void 0))(t), number: R((t => "number" == typeof t ? t : void 0))(t), string: R((t => "string" == typeof t ? t : void 0))(t), function: R((t => "function" == typeof t ? t : void 0))(t), constant: e => R((t => t === e ? e : void 0))(t), raw: R((t => t))(t), object: e => R((t => { if (k(t)) return L(t, e) }))(t), array: e => R((t => { if (Array.isArray(t)) return F(t, e) }))(t) } } const N = { optional: O(!0), required: O(!1) }; function U(t, e) { const n = N.required.object(e)(t); return n.succeeded ? n.value : void 0 } function z(t) { console.warn([`Missing '${t.key}' of ${t.target} in ${t.place}.`, "Please rebuild plugins with the latest core package."].join(" ")) } function V(t) { return t && t.parentElement && t.parentElement.removeChild(t), null } class Q { constructor(t) { this.value_ = t } static create(t) { return [new Q(t), (e, n) => { t.setRawValue(e, n) }] } get emitter() { return this.value_.emitter } get rawValue() { return this.value_.rawValue } } const G = A(""); function H(t, e) { return E(t, G(void 0, e)) } class j extends B { constructor(t) { var e; super(t), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = Q.create(D(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), null === (e = this.get("parent")) || void 0 === e || e.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_) } static create(t) { var e, n, i; const r = null != t ? t : {}; return new j(B.createCore({ disabled: null !== (e = r.disabled) && void 0 !== e && e, disposed: !1, hidden: null !== (n = r.hidden) && void 0 !== n && n, parent: null !== (i = r.parent) && void 0 !== i ? i : null })) } get globalDisabled() { return this.globalDisabled_ } bindClassModifiers(t) { x(this.globalDisabled_, H(t, "disabled")), _(this, "hidden", H(t, "hidden")) } bindDisabled(t) { x(this.globalDisabled_, (e => { t.disabled = e })) } bindTabIndex(t) { x(this.globalDisabled_, (e => { t.tabIndex = e ? -1 : 0 })) } handleDispose(t) { this.value("disposed").emitter.on("change", (e => { e && t() })) } getGlobalDisabled_() { const t = this.get("parent"); return !!t && t.globalDisabled.rawValue || this.get("disabled") } updateGlobalDisabled_() { this.setGlobalDisabled_(this.getGlobalDisabled_()) } onDisabledChange_() { this.updateGlobalDisabled_() } onParentGlobalDisabledChange_() { this.updateGlobalDisabled_() } onParentChange_(t) { var e; const n = t.previousRawValue; null == n || n.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), null === (e = this.get("parent")) || void 0 === e || e.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_() } } function W() { return ["veryfirst", "first", "last", "verylast"] } const q = A(""), Y = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" }; class X { constructor(t) { this.parent_ = null, this.blade = t.blade, this.view = t.view, this.viewProps = t.viewProps; const e = this.view.element; this.blade.value("positions").emitter.on("change", (() => { W().forEach((t => { e.classList.remove(q(void 0, Y[t])) })), this.blade.get("positions").forEach((t => { e.classList.add(q(void 0, Y[t])) })) })), this.viewProps.handleDispose((() => { V(e) })) } get parent() { return this.parent_ } set parent(t) { this.parent_ = t, "parent" in this.viewProps.valMap_ ? this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null) : z({ key: "parent", target: j.name, place: "BladeController.parent" }) } } const K = "http://www.w3.org/2000/svg"; function J(t) { t.offsetHeight } function Z(t, e) { const n = t.style.transition; t.style.transition = "none", e(), t.style.transition = n } function $(t) { return void 0 !== t.ontouchstart } function tt() { return globalThis } function et() { return l(tt()).document } function nt(t) { const e = t.ownerDocument.defaultView; return e && "document" in e ? t.getContext("2d", { willReadFrequently: !0 }) : null } const it = { check: '<path d="M2 8l4 4l8 -8"/>', dropdown: '<path d="M5 7h6l-3 3 z"/>', p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>' }; function rt(t, e) { const n = t.createElementNS(K, "svg"); return n.innerHTML = it[e], n } function st(t, e, n) { t.insertBefore(e, t.children[n]) } function ot(t) { t.parentElement && t.parentElement.removeChild(t) } function at(t) { for (; t.children.length > 0;)t.removeChild(t.children[0]) } function lt(t) { for (; t.childNodes.length > 0;)t.removeChild(t.childNodes[0]) } function ht(t) { return t.relatedTarget ? l(t.relatedTarget) : "explicitOriginalTarget" in t ? t.explicitOriginalTarget : null } const ct = A("lbl"); function ut(t, e) { const n = t.createDocumentFragment(); return e.split("\n").map((e => t.createTextNode(e))).forEach(((e, i) => { i > 0 && n.appendChild(t.createElement("br")), n.appendChild(e) })), n } class dt { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(ct()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(ct("l")), _(e.props, "label", (e => { h(e) ? this.element.classList.add(ct(void 0, "nol")) : (this.element.classList.remove(ct(void 0, "nol")), lt(n), n.appendChild(ut(t, e))) })), this.element.appendChild(n), this.labelElement = n; const i = t.createElement("div"); i.classList.add(ct("v")), this.element.appendChild(i), this.valueElement = i } } class pt extends X { constructor(t, e) { const n = e.valueController.viewProps; super(Object.assign(Object.assign({}, e), { view: new dt(t, { props: e.props, viewProps: n }), viewProps: n })), this.props = e.props, this.valueController = e.valueController, this.view.valueElement.appendChild(this.valueController.view.element) } } const ft = { id: "button", type: "blade", accept(t) { const e = N, n = U(t, { title: e.required.string, view: e.required.constant("button"), label: e.optional.string }); return n ? { params: n } : null }, controller(t) { return new pt(t.document, { blade: t.blade, props: B.fromObject({ label: t.params.label }), valueController: new P(t.document, { props: B.fromObject({ title: t.params.title }), viewProps: t.viewProps }) }) }, api(t) { return t.controller instanceof pt && t.controller.valueController instanceof P ? new m(t.controller) : null } }; class mt extends X { constructor(t) { super(t), this.value = t.value } } function gt() { return new B({ positions: D([], { equals: c }) }) } class vt extends B { constructor(t) { super(t) } static create(t) { const e = { completed: !0, expanded: t, expandedHeight: null, shouldFixHeight: !1, temporaryExpanded: null }, n = B.createCore(e); return new vt(n) } get styleExpanded() { var t; return null !== (t = this.get("temporaryExpanded")) && void 0 !== t ? t : this.get("expanded") } get styleHeight() { if (!this.styleExpanded) return "0"; const t = this.get("expandedHeight"); return this.get("shouldFixHeight") && !h(t) ? `${t}px` : "auto" } bindExpandedClass(t, e) { const n = () => { this.styleExpanded ? t.classList.add(e) : t.classList.remove(e) }; _(this, "expanded", n), _(this, "temporaryExpanded", n) } cleanUpTransition() { this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0) } } function At(t, e) { let n = 0; return Z(e, (() => { t.set("expandedHeight", null), t.set("temporaryExpanded", !0), J(e), n = e.clientHeight, t.set("temporaryExpanded", null), J(e) })), n } function bt(t, e) { e.style.height = t.styleHeight } function yt(t, e) { t.value("expanded").emitter.on("beforechange", (() => { if (t.set("completed", !1), h(t.get("expandedHeight"))) { const n = At(t, e); n > 0 && t.set("expandedHeight", n) } t.set("shouldFixHeight", !0), J(e) })), t.emitter.on("change", (() => { bt(t, e) })), bt(t, e), e.addEventListener("transitionend", (e => { "height" === e.propertyName && t.cleanUpTransition() })) } class xt extends n { constructor(t, e) { super(t), this.rackApi_ = e } } function _t(t, e) { return t.addBlade(Object.assign(Object.assign({}, e), { view: "button" })) } function wt(t, e) { return t.addBlade(Object.assign(Object.assign({}, e), { view: "folder" })) } function Et(t, e) { const n = null != e ? e : {}; return t.addBlade(Object.assign(Object.assign({}, n), { view: "separator" })) } function Ct(t, e) { return t.addBlade(Object.assign(Object.assign({}, e), { view: "tab" })) } class St { constructor(t) { this.emitter = new g, this.items_ = [], this.cache_ = new Set, this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = t } get items() { return this.items_ } allItems() { return Array.from(this.cache_) } find(t) { for (const e of this.allItems()) if (t(e)) return e; return null } includes(t) { return this.cache_.has(t) } add(t, e) { if (this.includes(t)) throw p.shouldNeverHappen(); const n = void 0 !== e ? e : this.items_.length; this.items_.splice(n, 0, t), this.cache_.add(t); const i = this.extract_(t); i && (i.emitter.on("add", this.onSubListAdd_), i.emitter.on("remove", this.onSubListRemove_), i.allItems().forEach((t => { this.cache_.add(t) }))), this.emitter.emit("add", { index: n, item: t, root: this, target: this }) } remove(t) { const e = this.items_.indexOf(t); if (e < 0) return; this.items_.splice(e, 1), this.cache_.delete(t); const n = this.extract_(t); n && (n.emitter.off("add", this.onSubListAdd_), n.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", { index: e, item: t, root: this, target: this }) } onSubListAdd_(t) { this.cache_.add(t.item), this.emitter.emit("add", { index: t.index, item: t.item, root: this, target: t.target }) } onSubListRemove_(t) { this.cache_.delete(t.item), this.emitter.emit("remove", { index: t.index, item: t.item, root: this, target: t.target }) } } class Mt extends n { constructor(t) { super(t), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new g, this.controller_.binding.emitter.on("change", this.onBindingChange_) } get label() { return this.controller_.props.get("label") } set label(t) { this.controller_.props.set("label", t) } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } refresh() { this.controller_.binding.read() } onBindingChange_(t) { const e = t.sender.target.read(); this.emitter_.emit("change", { event: new r(this, l(e), this.controller_.binding.target.presetKey, t.options.last) }) } } class Pt extends pt { constructor(t, e) { super(t, e), this.binding = e.binding } } class It extends n { constructor(t) { super(t), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new g, this.controller_.binding.emitter.on("update", this.onBindingUpdate_) } get label() { return this.controller_.props.get("label") } set label(t) { this.controller_.props.set("label", t) } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } refresh() { this.controller_.binding.read() } onBindingUpdate_(t) { const e = t.sender.target.read(); this.emitter_.emit("update", { event: new s(this, l(e), this.controller_.binding.target.presetKey) }) } } class Tt extends pt { constructor(t, e) { super(t, e), this.binding = e.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose((() => { this.binding.dispose() })) } } function Dt(t) { return t instanceof Ft ? t.apiSet_ : t instanceof xt ? t.rackApi_.apiSet_ : null } function Bt(t, e) { const n = t.find((t => t.controller_ === e)); if (!n) throw p.shouldNeverHappen(); return n } function Lt(t, e, n) { if (!f.isBindable(t)) throw p.notBindable(); return new f(t, e, n) } class Ft extends n { constructor(t, e) { super(t), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new g, this.apiSet_ = new St(Dt), this.pool_ = e; const n = this.controller_.rack; n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), n.emitter.on("inputchange", this.onRackInputChange_), n.emitter.on("monitorupdate", this.onRackMonitorUpdate_), n.children.forEach((t => { this.setUpApi_(t) })) } get children() { return this.controller_.rack.children.map((t => Bt(this.apiSet_, t))) } addInput(t, e, n) { const i = null != n ? n : {}, r = this.controller_.view.element.ownerDocument, s = this.pool_.createInput(r, Lt(t, e, i.presetKey), i), o = new Mt(s); return this.add(o, i.index) } addMonitor(t, e, n) { const i = null != n ? n : {}, r = this.controller_.view.element.ownerDocument, s = this.pool_.createMonitor(r, Lt(t, e), i), o = new It(s); return l(this.add(o, i.index)) } addFolder(t) { return wt(this, t) } addButton(t) { return _t(this, t) } addSeparator(t) { return Et(this, t) } addTab(t) { return Ct(this, t) } add(t, e) { this.controller_.rack.add(t.controller_, e); const n = this.apiSet_.find((e => e.controller_ === t.controller_)); return n && this.apiSet_.remove(n), this.apiSet_.add(t), t } remove(t) { this.controller_.rack.remove(t.controller_) } addBlade(t) { const e = this.controller_.view.element.ownerDocument, n = this.pool_.createBlade(e, t), i = this.pool_.createBladeApi(n); return this.add(i, t.index) } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } setUpApi_(t) { this.apiSet_.find((e => e.controller_ === t)) || this.apiSet_.add(this.pool_.createBladeApi(t)) } onRackAdd_(t) { this.setUpApi_(t.bladeController) } onRackRemove_(t) { if (t.isRoot) { const e = Bt(this.apiSet_, t.bladeController); this.apiSet_.remove(e) } } onRackInputChange_(t) { const e = t.bladeController; if (e instanceof Pt) { const n = Bt(this.apiSet_, e), i = e.binding; this.emitter_.emit("change", { event: new r(n, l(i.target.read()), i.target.presetKey, t.options.last) }) } else if (e instanceof mt) { const n = Bt(this.apiSet_, e); this.emitter_.emit("change", { event: new r(n, e.value.rawValue, void 0, t.options.last) }) } } onRackMonitorUpdate_(t) { if (!(t.bladeController instanceof Tt)) throw p.shouldNeverHappen(); const e = Bt(this.apiSet_, t.bladeController), n = t.bladeController.binding; this.emitter_.emit("update", { event: new s(e, l(n.target.read()), n.target.presetKey) }) } } class kt extends xt { constructor(t, e) { super(t, new Ft(t.rackController, e)), this.emitter_ = new g, this.controller_.foldable.value("expanded").emitter.on("change", (t => { this.emitter_.emit("fold", { event: new o(this, t.sender.rawValue) }) })), this.rackApi_.on("change", (t => { this.emitter_.emit("change", { event: t }) })), this.rackApi_.on("update", (t => { this.emitter_.emit("update", { event: t }) })) } get expanded() { return this.controller_.foldable.get("expanded") } set expanded(t) { this.controller_.foldable.set("expanded", t) } get title() { return this.controller_.props.get("title") } set title(t) { this.controller_.props.set("title", t) } get children() { return this.rackApi_.children } addInput(t, e, n) { return this.rackApi_.addInput(t, e, n) } addMonitor(t, e, n) { return this.rackApi_.addMonitor(t, e, n) } addFolder(t) { return this.rackApi_.addFolder(t) } addButton(t) { return this.rackApi_.addButton(t) } addSeparator(t) { return this.rackApi_.addSeparator(t) } addTab(t) { return this.rackApi_.addTab(t) } add(t, e) { return this.rackApi_.add(t, e) } remove(t) { this.rackApi_.remove(t) } addBlade(t) { return this.rackApi_.addBlade(t) } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } } class Rt extends X { constructor(t) { super({ blade: t.blade, view: t.view, viewProps: t.rackController.viewProps }), this.rackController = t.rackController } } class Ot { constructor(t, e) { const n = A(e.viewName); this.element = t.createElement("div"), this.element.classList.add(n()), e.viewProps.bindClassModifiers(this.element) } } function Nt(t, e) { for (let n = 0; n < t.length; n++) { const i = t[n]; if (i instanceof Pt && i.binding === e) return i } return null } function Ut(t, e) { for (let n = 0; n < t.length; n++) { const i = t[n]; if (i instanceof Tt && i.binding === e) return i } return null } function zt(t, e) { for (let n = 0; n < t.length; n++) { const i = t[n]; if (i instanceof mt && i.value === e) return i } return null } function Vt(t) { return t instanceof Ht ? t.rack : t instanceof Rt ? t.rackController.rack : null } function Qt(t) { const e = Vt(t); return e ? e.bcSet_ : null } class Gt { constructor(t) { var e, n; this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new g, this.blade_ = null !== (e = t.blade) && void 0 !== e ? e : null, null === (n = this.blade_) || void 0 === n || n.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = t.viewProps, this.bcSet_ = new St(Qt), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_) } get children() { return this.bcSet_.items } add(t, e) { var n; null === (n = t.parent) || void 0 === n || n.remove(t), u(t, "parent") ? t.parent = this : (t.parent_ = this, z({ key: "parent", target: "BladeController", place: "BladeRack.add" })), this.bcSet_.add(t, e) } remove(t) { u(t, "parent") ? t.parent = null : (t.parent_ = null, z({ key: "parent", target: "BladeController", place: "BladeRack.remove" })), this.bcSet_.remove(t) } find(t) { return l(this.bcSet_.allItems().filter((e => e instanceof t))) } onSetAdd_(t) { this.updatePositions_(); const e = t.target === t.root; if (this.emitter.emit("add", { bladeController: t.item, index: t.index, isRoot: e, sender: this }), !e) return; const n = t.item; if (n.viewProps.emitter.on("change", this.onChildViewPropsChange_), n.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), n.viewProps.handleDispose(this.onChildDispose_), n instanceof Pt) n.binding.emitter.on("change", this.onChildInputChange_); else if (n instanceof Tt) n.binding.emitter.on("update", this.onChildMonitorUpdate_); else if (n instanceof mt) n.value.emitter.on("change", this.onChildValueChange_); else { const t = Vt(n); if (t) { const e = t.emitter; e.on("layout", this.onDescendantLayout_), e.on("inputchange", this.onDescendantInputChange_), e.on("monitorupdate", this.onDescendantMonitorUpdate_) } } } onSetRemove_(t) { this.updatePositions_(); const e = t.target === t.root; if (this.emitter.emit("remove", { bladeController: t.item, isRoot: e, sender: this }), !e) return; const n = t.item; if (n instanceof Pt) n.binding.emitter.off("change", this.onChildInputChange_); else if (n instanceof Tt) n.binding.emitter.off("update", this.onChildMonitorUpdate_); else if (n instanceof mt) n.value.emitter.off("change", this.onChildValueChange_); else { const t = Vt(n); if (t) { const e = t.emitter; e.off("layout", this.onDescendantLayout_), e.off("inputchange", this.onDescendantInputChange_), e.off("monitorupdate", this.onDescendantMonitorUpdate_) } } } updatePositions_() { const t = this.bcSet_.items.filter((t => !t.viewProps.get("hidden"))), e = t[0], n = t[t.length - 1]; this.bcSet_.items.forEach((t => { const i = []; t === e && (i.push("first"), this.blade_ && !this.blade_.get("positions").includes("veryfirst") || i.push("veryfirst")), t === n && (i.push("last"), this.blade_ && !this.blade_.get("positions").includes("verylast") || i.push("verylast")), t.blade.set("positions", i) })) } onChildPositionsChange_() { this.updatePositions_(), this.emitter.emit("layout", { sender: this }) } onChildViewPropsChange_(t) { this.updatePositions_(), this.emitter.emit("layout", { sender: this }) } onChildDispose_() { this.bcSet_.items.filter((t => t.viewProps.get("disposed"))).forEach((t => { this.bcSet_.remove(t) })) } onChildInputChange_(t) { const e = Nt(this.find(Pt), t.sender); if (!e) throw p.alreadyDisposed(); this.emitter.emit("inputchange", { bladeController: e, options: t.options, sender: this }) } onChildMonitorUpdate_(t) { const e = Ut(this.find(Tt), t.sender); if (!e) throw p.alreadyDisposed(); this.emitter.emit("monitorupdate", { bladeController: e, sender: this }) } onChildValueChange_(t) { const e = zt(this.find(mt), t.sender); if (!e) throw p.alreadyDisposed(); this.emitter.emit("inputchange", { bladeController: e, options: t.options, sender: this }) } onDescendantLayout_(t) { this.updatePositions_(), this.emitter.emit("layout", { sender: this }) } onDescendantInputChange_(t) { this.emitter.emit("inputchange", { bladeController: t.bladeController, options: t.options, sender: this }) } onDescendantMonitorUpdate_(t) { this.emitter.emit("monitorupdate", { bladeController: t.bladeController, sender: this }) } onBladePositionsChange_() { this.updatePositions_() } } class Ht extends X { constructor(t, e) { super(Object.assign(Object.assign({}, e), { view: new Ot(t, { viewName: "brk", viewProps: e.viewProps }) })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this); const n = new Gt({ blade: e.root ? void 0 : e.blade, viewProps: e.viewProps }); n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), this.rack = n, this.viewProps.handleDispose((() => { for (let t = this.rack.children.length - 1; t >= 0; t--)this.rack.children[t].viewProps.set("disposed", !0) })) } onRackAdd_(t) { t.isRoot && st(this.view.element, t.bladeController.view.element, t.index) } onRackRemove_(t) { t.isRoot && ot(t.bladeController.view.element) } } const jt = A("cnt"); class Wt { constructor(t, e) { var n; this.className_ = A(null !== (n = e.viewName) && void 0 !== n ? n : "fld"), this.element = t.createElement("div"), this.element.classList.add(this.className_(), jt()), e.viewProps.bindClassModifiers(this.element), this.foldable_ = e.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), _(this.foldable_, "completed", E(this.element, this.className_(void 0, "cpl"))); const i = t.createElement("button"); i.classList.add(this.className_("b")), _(e.props, "title", (t => { h(t) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not")) })), e.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i; const r = t.createElement("div"); r.classList.add(this.className_("i")), this.element.appendChild(r); const s = t.createElement("div"); s.classList.add(this.className_("t")), C(e.props.value("title"), s), this.buttonElement.appendChild(s), this.titleElement = s; const o = t.createElement("div"); o.classList.add(this.className_("m")), this.buttonElement.appendChild(o); const a = e.containerElement; a.classList.add(this.className_("c")), this.element.appendChild(a), this.containerElement = a } } class qt extends Rt { constructor(t, e) { var n; const i = vt.create(null === (n = e.expanded) || void 0 === n || n), r = new Ht(t, { blade: e.blade, root: e.root, viewProps: e.viewProps }); super(Object.assign(Object.assign({}, e), { rackController: r, view: new Wt(t, { containerElement: r.view.element, foldable: i, props: e.props, viewName: e.root ? "rot" : void 0, viewProps: e.viewProps }) })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = e.props, this.foldable = i, yt(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", (() => { this.foldable.cleanUpTransition() })), this.rackController.rack.emitter.on("remove", (() => { this.foldable.cleanUpTransition() })), this.view.buttonElement.addEventListener("click", this.onTitleClick_) } get document() { return this.view.element.ownerDocument } onTitleClick_() { this.foldable.set("expanded", !this.foldable.get("expanded")) } } const Yt = { id: "folder", type: "blade", accept(t) { const e = N, n = U(t, { title: e.required.string, view: e.required.constant("folder"), expanded: e.optional.boolean }); return n ? { params: n } : null }, controller(t) { return new qt(t.document, { blade: t.blade, expanded: t.params.expanded, props: B.fromObject({ title: t.params.title }), viewProps: t.viewProps }) }, api(t) { return t.controller instanceof qt ? new kt(t.controller, t.pool) : null } }; class Xt extends mt { constructor(t, e) { const n = e.valueController.viewProps; super(Object.assign(Object.assign({}, e), { value: e.valueController.value, view: new dt(t, { props: e.props, viewProps: n }), viewProps: n })), this.props = e.props, this.valueController = e.valueController, this.view.valueElement.appendChild(this.valueController.view.element) } } class Kt extends n { } const Jt = A("spr"); class Zt { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(Jt()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("hr"); n.classList.add(Jt("r")), this.element.appendChild(n) } } class $t extends X { constructor(t, e) { super(Object.assign(Object.assign({}, e), { view: new Zt(t, { viewProps: e.viewProps }) })) } } const te = { id: "separator", type: "blade", accept(t) { const e = U(t, { view: N.required.constant("separator") }); return e ? { params: e } : null }, controller(t) { return new $t(t.document, { blade: t.blade, viewProps: t.viewProps }) }, api(t) { return t.controller instanceof $t ? new Kt(t.controller) : null } }, ee = A("tbi"); class ne { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(ee()), e.viewProps.bindClassModifiers(this.element), _(e.props, "selected", (t => { t ? this.element.classList.add(ee(void 0, "sel")) : this.element.classList.remove(ee(void 0, "sel")) })); const n = t.createElement("button"); n.classList.add(ee("b")), e.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n; const i = t.createElement("div"); i.classList.add(ee("t")), C(e.props.value("title"), i), this.buttonElement.appendChild(i), this.titleElement = i } } class ie { constructor(t, e) { this.emitter = new g, this.onClick_ = this.onClick_.bind(this), this.props = e.props, this.viewProps = e.viewProps, this.view = new ne(t, { props: e.props, viewProps: e.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_) } onClick_() { this.emitter.emit("click", { sender: this }) } } class re { constructor(t, e) { this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new ie(t, { props: e.itemProps, viewProps: j.create() }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new Ht(t, { blade: gt(), viewProps: j.create() }), this.props = e.props, _(this.props, "selected", (t => { this.itemController.props.set("selected", t), this.contentController.viewProps.set("hidden", !t) })) } get itemController() { return this.ic_ } get contentController() { return this.cc_ } onItemClick_() { this.props.set("selected", !0) } } class se { constructor(t, e) { this.controller_ = t, this.rackApi_ = e } get title() { var t; return null !== (t = this.controller_.itemController.props.get("title")) && void 0 !== t ? t : "" } set title(t) { this.controller_.itemController.props.set("title", t) } get selected() { return this.controller_.props.get("selected") } set selected(t) { this.controller_.props.set("selected", t) } get children() { return this.rackApi_.children } addButton(t) { return this.rackApi_.addButton(t) } addFolder(t) { return this.rackApi_.addFolder(t) } addSeparator(t) { return this.rackApi_.addSeparator(t) } addTab(t) { return this.rackApi_.addTab(t) } add(t, e) { this.rackApi_.add(t, e) } remove(t) { this.rackApi_.remove(t) } addInput(t, e, n) { return this.rackApi_.addInput(t, e, n) } addMonitor(t, e, n) { return this.rackApi_.addMonitor(t, e, n) } addBlade(t) { return this.rackApi_.addBlade(t) } } class oe extends xt { constructor(t, e) { super(t, new Ft(t.rackController, e)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new g, this.pageApiMap_ = new Map, this.rackApi_.on("change", (t => { this.emitter_.emit("change", { event: t }) })), this.rackApi_.on("update", (t => { this.emitter_.emit("update", { event: t }) })), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((t => { this.setUpPageApi_(t) })) } get pages() { return this.controller_.pageSet.items.map((t => { const e = this.pageApiMap_.get(t); if (!e) throw p.shouldNeverHappen(); return e })) } addPage(t) { const e = this.controller_.view.element.ownerDocument, n = new re(e, { itemProps: B.fromObject({ selected: !1, title: t.title }), props: B.fromObject({ selected: !1 }) }); this.controller_.add(n, t.index); const i = this.pageApiMap_.get(n); if (!i) throw p.shouldNeverHappen(); return i } removePage(t) { this.controller_.remove(t) } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } setUpPageApi_(t) { const e = this.rackApi_.apiSet_.find((e => e.controller_ === t.contentController)); if (!e) throw p.shouldNeverHappen(); const n = new se(t, e); this.pageApiMap_.set(t, n) } onPageAdd_(t) { this.setUpPageApi_(t.item) } onPageRemove_(t) { if (!this.pageApiMap_.get(t.item)) throw p.shouldNeverHappen(); this.pageApiMap_.delete(t.item) } onSelect_(t) { this.emitter_.emit("select", { event: new a(this, t.rawValue) }) } } const ae = -1; class le { constructor() { this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = D(!0), this.selectedIndex = D(ae), this.items_ = [] } add(t, e) { const n = null != e ? e : this.items_.length; this.items_.splice(n, 0, t), t.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_() } remove(t) { const e = this.items_.indexOf(t); e < 0 || (this.items_.splice(e, 1), t.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_()) } keepSelection_() { if (0 === this.items_.length) return this.selectedIndex.rawValue = ae, void (this.empty.rawValue = !0); const t = this.items_.findIndex((t => t.rawValue)); t < 0 ? (this.items_.forEach(((t, e) => { t.rawValue = 0 === e })), this.selectedIndex.rawValue = 0) : (this.items_.forEach(((e, n) => { e.rawValue = n === t })), this.selectedIndex.rawValue = t), this.empty.rawValue = !1 } onItemSelectedChange_(t) { if (t.rawValue) { const e = this.items_.findIndex((e => e === t.sender)); this.items_.forEach(((t, n) => { t.rawValue = n === e })), this.selectedIndex.rawValue = e } else this.keepSelection_() } } const he = A("tab"); class ce { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(he(), jt()), e.viewProps.bindClassModifiers(this.element), x(e.empty, E(this.element, he(void 0, "nop"))); const n = t.createElement("div"); n.classList.add(he("t")), this.element.appendChild(n), this.itemsElement = n; const i = t.createElement("div"); i.classList.add(he("i")), this.element.appendChild(i); const r = e.contentsElement; r.classList.add(he("c")), this.element.appendChild(r), this.contentsElement = r } } class ue extends Rt { constructor(t, e) { const n = new Ht(t, { blade: e.blade, viewProps: e.viewProps }), i = new le; super({ blade: e.blade, rackController: n, view: new ce(t, { contentsElement: n.view.element, empty: i.empty, viewProps: e.viewProps }) }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new St((() => null)), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = i } get pageSet() { return this.pageSet_ } add(t, e) { this.pageSet_.add(t, e) } remove(t) { this.pageSet_.remove(this.pageSet_.items[t]) } onPageAdd_(t) { const e = t.item; st(this.view.itemsElement, e.itemController.view.element, t.index), e.itemController.viewProps.set("parent", this.viewProps), this.rackController.rack.add(e.contentController, t.index), this.tab.add(e.props.value("selected")) } onPageRemove_(t) { const e = t.item; ot(e.itemController.view.element), e.itemController.viewProps.set("parent", null), this.rackController.rack.remove(e.contentController), this.tab.remove(e.props.value("selected")) } } const de = { id: "tab", type: "blade", accept(t) { const e = N, n = U(t, { pages: e.required.array(e.required.object({ title: e.required.string })), view: e.required.constant("tab") }); return n && 0 !== n.pages.length ? { params: n } : null }, controller(t) { const e = new ue(t.document, { blade: t.blade, viewProps: t.viewProps }); return t.params.pages.forEach((n => { const i = new re(t.document, { itemProps: B.fromObject({ selected: !1, title: n.title }), props: B.fromObject({ selected: !1 }) }); e.add(i) })), e }, api(t) { return t.controller instanceof ue ? new oe(t.controller, t.pool) : null } }; function pe(t, e) { const n = t.accept(e.params); if (!n) return null; const i = N.optional.boolean(e.params.disabled).value, r = N.optional.boolean(e.params.hidden).value; return t.controller({ blade: gt(), document: e.document, params: l(Object.assign(Object.assign({}, n.params), { disabled: i, hidden: r })), viewProps: j.create({ disabled: i, hidden: r }) }) } class fe { constructor() { this.disabled = !1, this.emitter = new g } dispose() { } tick() { this.disabled || this.emitter.emit("tick", { sender: this }) } } class me { constructor(t, e) { this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = t, this.emitter = new g, this.interval_ = e, this.setTimer_() } get disabled() { return this.disabled_ } set disabled(t) { this.disabled_ = t, this.disabled_ ? this.clearTimer_() : this.setTimer_() } dispose() { this.clearTimer_() } clearTimer_() { if (null === this.timerId_) return; const t = this.doc_.defaultView; t && t.clearInterval(this.timerId_), this.timerId_ = null } setTimer_() { if (this.clearTimer_(), this.interval_ <= 0) return; const t = this.doc_.defaultView; t && (this.timerId_ = t.setInterval(this.onTick_, this.interval_)) } onTick_() { this.disabled_ || this.emitter.emit("tick", { sender: this }) } } class ge { constructor(t) { this.onValueChange_ = this.onValueChange_.bind(this), this.reader = t.reader, this.writer = t.writer, this.emitter = new g, this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.target = t.target, this.read() } read() { const t = this.target.read(); void 0 !== t && (this.value.rawValue = this.reader(t)) } write_(t) { this.writer(this.target, t) } onValueChange_(t) { this.write_(t.rawValue), this.emitter.emit("change", { options: t.options, rawValue: t.rawValue, sender: this }) } } function ve(t, e) { for (; t.length < e;)t.push(void 0) } function Ae(t) { const e = []; return ve(e, t), D(e) } function be(t) { const e = t.indexOf(void 0); return l(e < 0 ? t : t.slice(0, e)) } function ye(t, e) { const n = [...be(t), e]; return n.length > t.length ? n.splice(0, n.length - t.length) : ve(n, t.length), n } class xe { constructor(t) { this.onTick_ = this.onTick_.bind(this), this.reader_ = t.reader, this.target = t.target, this.emitter = new g, this.value = t.value, this.ticker = t.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read() } dispose() { this.ticker.dispose() } read() { const t = this.target.read(); if (void 0 === t) return; const e = this.value.rawValue, n = this.reader_(t); this.value.rawValue = ye(e, n), this.emitter.emit("update", { rawValue: n, sender: this }) } onTick_(t) { this.read() } } class _e { constructor(t) { this.constraints = t } constrain(t) { return this.constraints.reduce(((t, e) => e.constrain(t)), t) } } function we(t, e) { if (t instanceof e) return t; if (t instanceof _e) { const n = t.constraints.reduce(((t, n) => t || (n instanceof e ? n : null)), null); if (n) return n } return null } class Ee { constructor(t) { this.values = B.fromObject({ max: t.max, min: t.min }) } constrain(t) { const e = this.values.get("max"), n = this.values.get("min"); return Math.min(Math.max(t, n), e) } } class Ce { constructor(t) { this.values = B.fromObject({ options: t }) } get options() { return this.values.get("options") } constrain(t) { const e = this.values.get("options"); return 0 === e.length || e.filter((e => e.value === t)).length > 0 ? t : e[0].value } } class Se { constructor(t) { this.values = B.fromObject({ max: t.max, min: t.min }) } get maxValue() { return this.values.get("max") } get minValue() { return this.values.get("min") } constrain(t) { const e = this.values.get("max"), n = this.values.get("min"); let i = t; return h(n) || (i = Math.max(i, n)), h(e) || (i = Math.min(i, e)), i } } class Me { constructor(t, e = 0) { this.step = t, this.origin = e } constrain(t) { const e = this.origin % this.step; return e + Math.round((t - e) / this.step) * this.step } } const Pe = A("lst"); class Ie { constructor(t, e) { this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = e.props, this.element = t.createElement("div"), this.element.classList.add(Pe()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("select"); n.classList.add(Pe("s")), _(this.props_, "options", (e => { at(n), e.forEach(((e, i) => { const r = t.createElement("option"); r.dataset.index = String(i), r.textContent = e.text, r.value = String(e.value), n.appendChild(r) })) })), e.viewProps.bindDisabled(n), this.element.appendChild(n), this.selectElement = n; const i = t.createElement("div"); i.classList.add(Pe("m")), i.appendChild(rt(t, "dropdown")), this.element.appendChild(i), e.value.emitter.on("change", this.onValueChange_), this.value_ = e.value, this.update_() } update_() { this.selectElement.value = String(this.value_.rawValue) } onValueChange_() { this.update_() } } class Te { constructor(t, e) { this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = e.props, this.value = e.value, this.viewProps = e.viewProps, this.view = new Ie(t, { props: this.props, value: this.value, viewProps: this.viewProps }), this.view.selectElement.addEventListener("change", this.onSelectChange_) } onSelectChange_(t) { const e = l(t.currentTarget).selectedOptions.item(0); if (!e) return; const n = Number(e.dataset.index); this.value.rawValue = this.props.get("options")[n].value } } const De = A("pop"); class Be { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(De()), e.viewProps.bindClassModifiers(this.element), x(e.shows, E(this.element, De(void 0, "v"))) } } class Le { constructor(t, e) { this.shows = D(!1), this.viewProps = e.viewProps, this.view = new Be(t, { shows: this.shows, viewProps: this.viewProps }) } } const Fe = A("txt"); class ke { constructor(t, e) { this.onChange_ = this.onChange_.bind(this), this.element = t.createElement("div"), this.element.classList.add(Fe()), e.viewProps.bindClassModifiers(this.element), this.props_ = e.props, this.props_.emitter.on("change", this.onChange_); const n = t.createElement("input"); n.classList.add(Fe("i")), n.type = "text", e.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, e.value.emitter.on("change", this.onChange_), this.value_ = e.value, this.refresh() } refresh() { const t = this.props_.get("formatter"); this.inputElement.value = t(this.value_.rawValue) } onChange_() { this.refresh() } } class Re { constructor(t, e) { this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = e.parser, this.props = e.props, this.value = e.value, this.viewProps = e.viewProps, this.view = new ke(t, { props: e.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_) } onInputChange_(t) { const e = l(t.currentTarget).value, n = this.parser_(e); h(n) || (this.value.rawValue = n), this.view.refresh() } } function Oe(t) { return String(t) } function Ne(t) { return "false" !== t && !!t } function Ue(t) { return Oe(t) } class ze { constructor(t) { this.text = t } evaluate() { return Number(this.text) } toString() { return this.text } } const Ve = { "**": (t, e) => Math.pow(t, e), "*": (t, e) => t * e, "/": (t, e) => t / e, "%": (t, e) => t % e, "+": (t, e) => t + e, "-": (t, e) => t - e, "<<": (t, e) => t << e, ">>": (t, e) => t >> e, ">>>": (t, e) => t >>> e, "&": (t, e) => t & e, "^": (t, e) => t ^ e, "|": (t, e) => t | e }; class Qe { constructor(t, e, n) { this.left = e, this.operator = t, this.right = n } evaluate() { const t = Ve[this.operator]; if (!t) throw new Error(`unexpected binary operator: '${this.operator}`); return t(this.left.evaluate(), this.right.evaluate()) } toString() { return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ") } } const Ge = { "+": t => t, "-": t => -t, "~": t => ~t }; class He { constructor(t, e) { this.operator = t, this.expression = e } evaluate() { const t = Ge[this.operator]; if (!t) throw new Error(`unexpected unary operator: '${this.operator}`); return t(this.expression.evaluate()) } toString() { return ["u(", this.operator, this.expression.toString(), ")"].join(" ") } } function je(t) { return (e, n) => { for (let i = 0; i < t.length; i++) { const r = t[i](e, n); if ("" !== r) return r } return "" } } function We(t, e) { var n; const i = t.substr(e).match(/^\s+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function qe(t, e) { const n = t.substr(e, 1); return n.match(/^[1-9]$/) ? n : "" } function Ye(t, e) { var n; const i = t.substr(e).match(/^[0-9]+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function Xe(t, e) { const n = Ye(t, e); if ("" !== n) return n; const i = t.substr(e, 1); if ("-" !== i && "+" !== i) return ""; const r = Ye(t, e += 1); return "" === r ? "" : i + r } function Ke(t, e) { const n = t.substr(e, 1); if (e += 1, "e" !== n.toLowerCase()) return ""; const i = Xe(t, e); return "" === i ? "" : n + i } function Je(t, e) { const n = t.substr(e, 1); if ("0" === n) return n; const i = qe(t, e); return e += i.length, "" === i ? "" : i + Ye(t, e) } function Ze(t, e) { const n = Je(t, e); if (e += n.length, "" === n) return ""; const i = t.substr(e, 1); if (e += i.length, "." !== i) return ""; const r = Ye(t, e); return n + i + r + Ke(t, e += r.length) } function $e(t, e) { const n = t.substr(e, 1); if (e += n.length, "." !== n) return ""; const i = Ye(t, e); return e += i.length, "" === i ? "" : n + i + Ke(t, e) } function tn(t, e) { const n = Je(t, e); return e += n.length, "" === n ? "" : n + Ke(t, e) } const en = je([Ze, $e, tn]); function nn(t, e) { var n; const i = t.substr(e).match(/^[01]+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function rn(t, e) { const n = t.substr(e, 2); if (e += n.length, "0b" !== n.toLowerCase()) return ""; const i = nn(t, e); return "" === i ? "" : n + i } function sn(t, e) { var n; const i = t.substr(e).match(/^[0-7]+/); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function on(t, e) { const n = t.substr(e, 2); if (e += n.length, "0o" !== n.toLowerCase()) return ""; const i = sn(t, e); return "" === i ? "" : n + i } function an(t, e) { var n; const i = t.substr(e).match(/^[0-9a-f]+/i); return null !== (n = i && i[0]) && void 0 !== n ? n : "" } function ln(t, e) { const n = t.substr(e, 2); if (e += n.length, "0x" !== n.toLowerCase()) return ""; const i = an(t, e); return "" === i ? "" : n + i } const hn = je([rn, on, ln]), cn = je([hn, en]); function un(t, e) { const n = cn(t, e); return e += n.length, "" === n ? null : { evaluable: new ze(n), cursor: e } } function dn(t, e) { const n = t.substr(e, 1); if (e += n.length, "(" !== n) return null; const i = An(t, e); if (!i) return null; e = i.cursor, e += We(t, e).length; const r = t.substr(e, 1); return e += r.length, ")" !== r ? null : { evaluable: i.evaluable, cursor: e } } function pn(t, e) { var n; return null !== (n = un(t, e)) && void 0 !== n ? n : dn(t, e) } function fn(t, e) { const n = pn(t, e); if (n) return n; const i = t.substr(e, 1); if (e += i.length, "+" !== i && "-" !== i && "~" !== i) return null; const r = fn(t, e); return r ? { cursor: e = r.cursor, evaluable: new He(i, r.evaluable) } : null } function mn(t, e, n) { n += We(e, n).length; const i = t.filter((t => e.startsWith(t, n)))[0]; return i ? (n += i.length, { cursor: n += We(e, n).length, operator: i }) : null } function gn(t, e) { return (n, i) => { const r = t(n, i); if (!r) return null; i = r.cursor; let s = r.evaluable; for (; ;) { const r = mn(e, n, i); if (!r) break; i = r.cursor; const o = t(n, i); if (!o) return null; i = o.cursor, s = new Qe(r.operator, s, o.evaluable) } return s ? { cursor: i, evaluable: s } : null } } const vn = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce(((t, e) => gn(t, e)), fn); function An(t, e) { return e += We(t, e).length, vn(t, e) } function bn(t) { const e = An(t, 0); return e ? e.cursor + We(t, e.cursor).length !== t.length ? null : e.evaluable : null } function yn(t) { var e; const n = bn(t); return null !== (e = null == n ? void 0 : n.evaluate()) && void 0 !== e ? e : null } function xn(t) { if ("number" == typeof t) return t; if ("string" == typeof t) { const e = yn(t); if (!h(e)) return e } return 0 } function _n(t) { return String(t) } function wn(t) { return e => e.toFixed(Math.max(Math.min(t, 20), 0)) } const En = wn(0); function Cn(t) { return En(t) + "%" } function Sn(t) { return String(t) } function Mn(t) { return t } function Pn({ primary: t, secondary: e, forward: n, backward: i }) { let r = !1; function s(t) { r || (r = !0, t(), r = !1) } t.emitter.on("change", (i => { s((() => { e.setRawValue(n(t, e), i.options) })) })), e.emitter.on("change", (r => { s((() => { t.setRawValue(i(t, e), r.options) })), s((() => { e.setRawValue(n(t, e), r.options) })) })), s((() => { e.setRawValue(n(t, e), { forceEmit: !1, last: !0 }) })) } function In(t, e) { const n = t * (e.altKey ? .1 : 1) * (e.shiftKey ? 10 : 1); return e.upKey ? +n : e.downKey ? -n : 0 } function Tn(t) { return { altKey: t.altKey, downKey: "ArrowDown" === t.key, shiftKey: t.shiftKey, upKey: "ArrowUp" === t.key } } function Dn(t) { return { altKey: t.altKey, downKey: "ArrowLeft" === t.key, shiftKey: t.shiftKey, upKey: "ArrowRight" === t.key } } function Bn(t) { return "ArrowUp" === t || "ArrowDown" === t } function Ln(t) { return Bn(t) || "ArrowLeft" === t || "ArrowRight" === t } function Fn(t, e) { var n, i; const r = e.ownerDocument.defaultView, s = e.getBoundingClientRect(); return { x: t.pageX - ((null !== (n = r && r.scrollX) && void 0 !== n ? n : 0) + s.left), y: t.pageY - ((null !== (i = r && r.scrollY) && void 0 !== i ? i : 0) + s.top) } } class kn { constructor(t) { this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = t, this.emitter = new g, t.addEventListener("touchstart", this.onTouchStart_, { passive: !1 }), t.addEventListener("touchmove", this.onTouchMove_, { passive: !0 }), t.addEventListener("touchend", this.onTouchEnd_), t.addEventListener("mousedown", this.onMouseDown_) } computePosition_(t) { const e = this.elem_.getBoundingClientRect(); return { bounds: { width: e.width, height: e.height }, point: t ? { x: t.x, y: t.y } : null } } onMouseDown_(t) { var e; t.preventDefault(), null === (e = t.currentTarget) || void 0 === e || e.focus(); const n = this.elem_.ownerDocument; n.addEventListener("mousemove", this.onDocumentMouseMove_), n.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", { altKey: t.altKey, data: this.computePosition_(Fn(t, this.elem_)), sender: this, shiftKey: t.shiftKey }) } onDocumentMouseMove_(t) { this.emitter.emit("move", { altKey: t.altKey, data: this.computePosition_(Fn(t, this.elem_)), sender: this, shiftKey: t.shiftKey }) } onDocumentMouseUp_(t) { const e = this.elem_.ownerDocument; e.removeEventListener("mousemove", this.onDocumentMouseMove_), e.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", { altKey: t.altKey, data: this.computePosition_(Fn(t, this.elem_)), sender: this, shiftKey: t.shiftKey }) } onTouchStart_(t) { t.preventDefault(); const e = t.targetTouches.item(0), n = this.elem_.getBoundingClientRect(); this.emitter.emit("down", { altKey: t.altKey, data: this.computePosition_(e ? { x: e.clientX - n.left, y: e.clientY - n.top } : void 0), sender: this, shiftKey: t.shiftKey }), this.lastTouch_ = e } onTouchMove_(t) { const e = t.targetTouches.item(0), n = this.elem_.getBoundingClientRect(); this.emitter.emit("move", { altKey: t.altKey, data: this.computePosition_(e ? { x: e.clientX - n.left, y: e.clientY - n.top } : void 0), sender: this, shiftKey: t.shiftKey }), this.lastTouch_ = e } onTouchEnd_(t) { var e; const n = null !== (e = t.targetTouches.item(0)) && void 0 !== e ? e : this.lastTouch_, i = this.elem_.getBoundingClientRect(); this.emitter.emit("up", { altKey: t.altKey, data: this.computePosition_(n ? { x: n.clientX - i.left, y: n.clientY - i.top } : void 0), sender: this, shiftKey: t.shiftKey }) } } function Rn(t, e, n, i, r) { return i + (t - e) / (n - e) * (r - i) } function On(t) { return String(t.toFixed(10)).split(".")[1].replace(/0+$/, "").length } function Nn(t, e, n) { return Math.min(Math.max(t, e), n) } function Un(t, e) { return (t % e + e) % e } const zn = A("txt"); class Vn { constructor(t, e) { this.onChange_ = this.onChange_.bind(this), this.props_ = e.props, this.props_.emitter.on("change", this.onChange_), this.element = t.createElement("div"), this.element.classList.add(zn(), zn(void 0, "num")), e.arrayPosition && this.element.classList.add(zn(void 0, e.arrayPosition)), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("input"); n.classList.add(zn("i")), n.type = "text", e.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = e.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(zn()), this.inputElement.classList.add(zn("i")); const i = t.createElement("div"); i.classList.add(zn("k")), this.element.appendChild(i), this.knobElement = i; const r = t.createElementNS(K, "svg"); r.classList.add(zn("g")), this.knobElement.appendChild(r); const s = t.createElementNS(K, "path"); s.classList.add(zn("gb")), r.appendChild(s), this.guideBodyElem_ = s; const o = t.createElementNS(K, "path"); o.classList.add(zn("gh")), r.appendChild(o), this.guideHeadElem_ = o; const a = t.createElement("div"); a.classList.add(A("tt")()), this.knobElement.appendChild(a), this.tooltipElem_ = a, e.value.emitter.on("change", this.onChange_), this.value = e.value, this.refresh() } onDraggingChange_(t) { if (null === t.rawValue) return void this.element.classList.remove(zn(void 0, "drg")); this.element.classList.add(zn(void 0, "drg")); const e = t.rawValue / this.props_.get("draggingScale"), n = e + (e > 0 ? -1 : e < 0 ? 1 : 0), i = Nn(-n, -4, 4); this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n + i},0 L${n},4 L${n + i},8`, `M ${e},-1 L${e},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${e},4`); const r = this.props_.get("formatter"); this.tooltipElem_.textContent = r(this.value.rawValue), this.tooltipElem_.style.left = `${e}px` } refresh() { const t = this.props_.get("formatter"); this.inputElement.value = t(this.value.rawValue) } onChange_() { this.refresh() } } class Qn { constructor(t, e) { var n; this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = e.baseStep, this.parser_ = e.parser, this.props = e.props, this.sliderProps_ = null !== (n = e.sliderProps) && void 0 !== n ? n : null, this.value = e.value, this.viewProps = e.viewProps, this.dragging_ = D(null), this.view = new Vn(t, { arrayPosition: e.arrayPosition, dragging: this.dragging_, props: this.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_); const i = new kn(this.view.knobElement); i.emitter.on("down", this.onPointerDown_), i.emitter.on("move", this.onPointerMove_), i.emitter.on("up", this.onPointerUp_) } constrainValue_(t) { var e, n; const i = null === (e = this.sliderProps_) || void 0 === e ? void 0 : e.get("minValue"), r = null === (n = this.sliderProps_) || void 0 === n ? void 0 : n.get("maxValue"); let s = t; return void 0 !== i && (s = Math.max(s, i)), void 0 !== r && (s = Math.min(s, r)), s } onInputChange_(t) { const e = l(t.currentTarget).value, n = this.parser_(e); h(n) || (this.value.rawValue = this.constrainValue_(n)), this.view.refresh() } onInputKeyDown_(t) { const e = In(this.baseStep_, Tn(t)); 0 !== e && this.value.setRawValue(this.constrainValue_(this.value.rawValue + e), { forceEmit: !1, last: !1 }) } onInputKeyUp_(t) { 0 !== In(this.baseStep_, Tn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } onPointerDown_() { this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0 } computeDraggingValue_(t) { if (!t.point) return null; const e = t.point.x - t.bounds.width / 2; return this.constrainValue_(this.originRawValue_ + e * this.props.get("draggingScale")) } onPointerMove_(t) { const e = this.computeDraggingValue_(t.data); null !== e && (this.value.setRawValue(e, { forceEmit: !1, last: !1 }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_) } onPointerUp_(t) { const e = this.computeDraggingValue_(t.data); null !== e && (this.value.setRawValue(e, { forceEmit: !0, last: !0 }), this.dragging_.rawValue = null) } } const Gn = A("sld"); class Hn { constructor(t, e) { this.onChange_ = this.onChange_.bind(this), this.props_ = e.props, this.props_.emitter.on("change", this.onChange_), this.element = t.createElement("div"), this.element.classList.add(Gn()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(Gn("t")), e.viewProps.bindTabIndex(n), this.element.appendChild(n), this.trackElement = n; const i = t.createElement("div"); i.classList.add(Gn("k")), this.trackElement.appendChild(i), this.knobElement = i, e.value.emitter.on("change", this.onChange_), this.value = e.value, this.update_() } update_() { const t = Nn(Rn(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100); this.knobElement.style.width = `${t}%` } onChange_() { this.update_() } } class jn { constructor(t, e) { this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = e.baseStep, this.value = e.value, this.viewProps = e.viewProps, this.props = e.props, this.view = new Hn(t, { props: this.props, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new kn(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_) } handlePointerEvent_(t, e) { t.point && this.value.setRawValue(Rn(Nn(t.point.x, 0, t.bounds.width), 0, t.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), e) } onPointerDownOrMove_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerUp_(t) { this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 }) } onKeyDown_(t) { const e = In(this.baseStep_, Dn(t)); 0 !== e && this.value.setRawValue(this.value.rawValue + e, { forceEmit: !1, last: !1 }) } onKeyUp_(t) { 0 !== In(this.baseStep_, Dn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } } const Wn = A("sldtxt"); class qn { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(Wn()); const n = t.createElement("div"); n.classList.add(Wn("s")), this.sliderView_ = e.sliderView, n.appendChild(this.sliderView_.element), this.element.appendChild(n); const i = t.createElement("div"); i.classList.add(Wn("t")), this.textView_ = e.textView, i.appendChild(this.textView_.element), this.element.appendChild(i) } } class Yn { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.sliderC_ = new jn(t, { baseStep: e.baseStep, props: e.sliderProps, value: e.value, viewProps: this.viewProps }), this.textC_ = new Qn(t, { baseStep: e.baseStep, parser: e.parser, props: e.textProps, sliderProps: e.sliderProps, value: e.value, viewProps: e.viewProps }), this.view = new qn(t, { sliderView: this.sliderC_.view, textView: this.textC_.view }) } get sliderController() { return this.sliderC_ } get textController() { return this.textC_ } } function Xn(t, e) { t.write(e) } function Kn(t) { const e = N; return Array.isArray(t) ? e.required.array(e.required.object({ text: e.required.string, value: e.required.raw }))(t).value : "object" == typeof t ? e.required.raw(t).value : void 0 } function Jn(t) { if ("inline" === t || "popup" === t) return t } function Zn(t) { const e = N; return e.required.object({ max: e.optional.number, min: e.optional.number, step: e.optional.number })(t).value } function $n(t) { if (Array.isArray(t)) return t; const e = []; return Object.keys(t).forEach((n => { e.push({ text: n, value: t[n] }) })), e } function ti(t) { return h(t) ? null : new Ce($n(l(t))) } function ei(t) { const e = t ? we(t, Me) : null; return e ? e.step : null } function ni(t, e) { const n = t && we(t, Me); return n ? On(n.step) : Math.max(On(e), 2) } function ii(t) { const e = ei(t); return null != e ? e : 1 } function ri(t, e) { var n; const i = t && we(t, Me), r = Math.abs(null !== (n = null == i ? void 0 : i.step) && void 0 !== n ? n : e); return 0 === r ? .1 : Math.pow(10, Math.floor(Math.log10(r)) - 1) } const si = A("ckb"); class oi { constructor(t, e) { this.onValueChange_ = this.onValueChange_.bind(this), this.element = t.createElement("div"), this.element.classList.add(si()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("label"); n.classList.add(si("l")), this.element.appendChild(n); const i = t.createElement("input"); i.classList.add(si("i")), i.type = "checkbox", n.appendChild(i), this.inputElement = i, e.viewProps.bindDisabled(this.inputElement); const r = t.createElement("div"); r.classList.add(si("w")), n.appendChild(r); const s = rt(t, "check"); r.appendChild(s), e.value.emitter.on("change", this.onValueChange_), this.value = e.value, this.update_() } update_() { this.inputElement.checked = this.value.rawValue } onValueChange_() { this.update_() } } class ai { constructor(t, e) { this.onInputChange_ = this.onInputChange_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.view = new oi(t, { value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_) } onInputChange_(t) { const e = l(t.currentTarget); this.value.rawValue = e.checked } } function li(t) { const e = [], n = ti(t.options); return n && e.push(n), new _e(e) } const hi = { id: "input-bool", type: "input", accept: (t, e) => { if ("boolean" != typeof t) return null; const n = U(e, { options: N.optional.custom(Kn) }); return n ? { initialValue: t, params: n } : null }, binding: { reader: t => Ne, constraint: t => li(t.params), writer: t => Xn }, controller: t => { const e = t.document, n = t.value, i = t.constraint, r = i && we(i, Ce); return r ? new Te(e, { props: new B({ options: r.values.value("options") }), value: n, viewProps: t.viewProps }) : new ai(e, { value: n, viewProps: t.viewProps }) } }, ci = A("col"); class ui { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(ci()), e.foldable.bindExpandedClass(this.element, ci(void 0, "expanded")), _(e.foldable, "completed", E(this.element, ci(void 0, "cpl"))); const n = t.createElement("div"); n.classList.add(ci("h")), this.element.appendChild(n); const i = t.createElement("div"); i.classList.add(ci("s")), n.appendChild(i), this.swatchElement = i; const r = t.createElement("div"); if (r.classList.add(ci("t")), n.appendChild(r), this.textElement = r, "inline" === e.pickerLayout) { const e = t.createElement("div"); e.classList.add(ci("p")), this.element.appendChild(e), this.pickerElement = e } else this.pickerElement = null } } function di(t, e, n) { const i = Nn(t / 255, 0, 1), r = Nn(e / 255, 0, 1), s = Nn(n / 255, 0, 1), o = Math.max(i, r, s), a = Math.min(i, r, s), l = o - a; let h = 0, c = 0; const u = (a + o) / 2; return 0 !== l && (c = l / (1 - Math.abs(o + a - 1)), h = i === o ? (r - s) / l : r === o ? 2 + (s - i) / l : 4 + (i - r) / l, h = h / 6 + (h < 0 ? 1 : 0)), [360 * h, 100 * c, 100 * u] } function pi(t, e, n) { const i = (t % 360 + 360) % 360, r = Nn(e / 100, 0, 1), s = Nn(n / 100, 0, 1), o = (1 - Math.abs(2 * s - 1)) * r, a = o * (1 - Math.abs(i / 60 % 2 - 1)), l = s - o / 2; let h, c, u; return [h, c, u] = i >= 0 && i < 60 ? [o, a, 0] : i >= 60 && i < 120 ? [a, o, 0] : i >= 120 && i < 180 ? [0, o, a] : i >= 180 && i < 240 ? [0, a, o] : i >= 240 && i < 300 ? [a, 0, o] : [o, 0, a], [255 * (h + l), 255 * (c + l), 255 * (u + l)] } function fi(t, e, n) { const i = Nn(t / 255, 0, 1), r = Nn(e / 255, 0, 1), s = Nn(n / 255, 0, 1), o = Math.max(i, r, s), a = o - Math.min(i, r, s); let l; return l = 0 === a ? 0 : o === i ? ((r - s) / a % 6 + 6) % 6 * 60 : o === r ? 60 * ((s - i) / a + 2) : 60 * ((i - r) / a + 4), [l, 100 * (0 === o ? 0 : a / o), 100 * o] } function mi(t, e, n) { const i = Un(t, 360), r = Nn(e / 100, 0, 1), s = Nn(n / 100, 0, 1), o = s * r, a = o * (1 - Math.abs(i / 60 % 2 - 1)), l = s - o; let h, c, u; return [h, c, u] = i >= 0 && i < 60 ? [o, a, 0] : i >= 60 && i < 120 ? [a, o, 0] : i >= 120 && i < 180 ? [0, o, a] : i >= 180 && i < 240 ? [0, a, o] : i >= 240 && i < 300 ? [a, 0, o] : [o, 0, a], [255 * (h + l), 255 * (c + l), 255 * (u + l)] } function gi(t, e, n) { const i = n + e * (100 - Math.abs(2 * n - 100)) / 200; return [t, 0 !== i ? e * (100 - Math.abs(2 * n - 100)) / i : 0, n + e * (100 - Math.abs(2 * n - 100)) / 200] } function vi(t, e, n) { const i = 100 - Math.abs(n * (200 - e) / 100 - 100); return [t, 0 !== i ? e * n / i : 0, n * (200 - e) / 200] } function Ai(t) { return [t[0], t[1], t[2]] } function bi(t, e) { return [t[0], t[1], t[2], e] } const yi = { hsl: { hsl: (t, e, n) => [t, e, n], hsv: gi, rgb: pi }, hsv: { hsl: vi, hsv: (t, e, n) => [t, e, n], rgb: mi }, rgb: { hsl: di, hsv: fi, rgb: (t, e, n) => [t, e, n] } }; function xi(t, e) { return ["float" === e ? 1 : "rgb" === t ? 255 : 360, "float" === e ? 1 : "rgb" === t ? 255 : 100, "float" === e ? 1 : "rgb" === t ? 255 : 100] } function _i(t, e) { return t === e ? e : Un(t, e) } function wi(t, e, n) { var i; const r = xi(e, n); return ["rgb" === e ? Nn(t[0], 0, r[0]) : _i(t[0], r[0]), Nn(t[1], 0, r[1]), Nn(t[2], 0, r[2]), Nn(null !== (i = t[3]) && void 0 !== i ? i : 1, 0, 1)] } function Ei(t, e, n, i) { const r = xi(e, n), s = xi(e, i); return t.map(((t, e) => t / r[e] * s[e])) } function Ci(t, e, n) { const i = Ei(t, e.mode, e.type, "int"); return Ei(yi[e.mode][n.mode](...i), n.mode, "int", n.type) } function Si(t, e) { return "object" == typeof t && !h(t) && e in t && "number" == typeof t[e] } class Mi { static black(t = "int") { return new Mi([0, 0, 0], "rgb", t) } static fromObject(t, e = "int") { const n = "a" in t ? [t.r, t.g, t.b, t.a] : [t.r, t.g, t.b]; return new Mi(n, "rgb", e) } static toRgbaObject(t, e = "int") { return t.toRgbaObject(e) } static isRgbColorObject(t) { return Si(t, "r") && Si(t, "g") && Si(t, "b") } static isRgbaColorObject(t) { return this.isRgbColorObject(t) && Si(t, "a") } static isColorObject(t) { return this.isRgbColorObject(t) } static equals(t, e) { if (t.mode !== e.mode) return !1; const n = t.comps_, i = e.comps_; for (let t = 0; t < n.length; t++)if (n[t] !== i[t]) return !1; return !0 } constructor(t, e, n = "int") { this.mode = e, this.type = n, this.comps_ = wi(t, e, n) } getComponents(t, e = "int") { return bi(Ci(Ai(this.comps_), { mode: this.mode, type: this.type }, { mode: null != t ? t : this.mode, type: e }), this.comps_[3]) } toRgbaObject(t = "int") { const e = this.getComponents("rgb", t); return { r: e[0], g: e[1], b: e[2], a: e[3] } } } const Pi = A("colp"); class Ii { constructor(t, e) { this.alphaViews_ = null, this.element = t.createElement("div"), this.element.classList.add(Pi()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(Pi("hsv")); const i = t.createElement("div"); i.classList.add(Pi("sv")), this.svPaletteView_ = e.svPaletteView, i.appendChild(this.svPaletteView_.element), n.appendChild(i); const r = t.createElement("div"); r.classList.add(Pi("h")), this.hPaletteView_ = e.hPaletteView, r.appendChild(this.hPaletteView_.element), n.appendChild(r), this.element.appendChild(n); const s = t.createElement("div"); if (s.classList.add(Pi("rgb")), this.textView_ = e.textView, s.appendChild(this.textView_.element), this.element.appendChild(s), e.alphaViews) { this.alphaViews_ = { palette: e.alphaViews.palette, text: e.alphaViews.text }; const n = t.createElement("div"); n.classList.add(Pi("a")); const i = t.createElement("div"); i.classList.add(Pi("ap")), i.appendChild(this.alphaViews_.palette.element), n.appendChild(i); const r = t.createElement("div"); r.classList.add(Pi("at")), r.appendChild(this.alphaViews_.text.element), n.appendChild(r), this.element.appendChild(n) } } get allFocusableElements() { const t = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map((t => t.inputElement))]; return this.alphaViews_ && t.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), t } } function Ti(t) { return "int" === t ? "int" : "float" === t ? "float" : void 0 } function Di(t) { const e = N; return U(t, { alpha: e.optional.boolean, color: e.optional.object({ alpha: e.optional.boolean, type: e.optional.custom(Ti) }), expanded: e.optional.boolean, picker: e.optional.custom(Jn) }) } function Bi(t) { return t ? .1 : 1 } function Li(t) { var e; return null === (e = t.color) || void 0 === e ? void 0 : e.type } function Fi(t, e) { return t.alpha === e.alpha && t.mode === e.mode && t.notation === e.notation && t.type === e.type } function ki(t, e) { const n = t.match(/^(.+)%$/); return n ? Math.min(.01 * parseFloat(n[1]) * e, e) : Math.min(parseFloat(t), e) } const Ri = { deg: t => t, grad: t => 360 * t / 400, rad: t => 360 * t / (2 * Math.PI), turn: t => 360 * t }; function Oi(t) { const e = t.match(/^([0-9.]+?)(deg|grad|rad|turn)$/); if (!e) return parseFloat(t); const n = parseFloat(e[1]), i = e[2]; return Ri[i](n) } function Ni(t) { const e = t.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/); if (!e) return null; const n = [ki(e[1], 255), ki(e[2], 255), ki(e[3], 255)]; return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n } function Ui(t) { return e => { const n = Ni(e); return n ? new Mi(n, "rgb", t) : null } } function zi(t) { const e = t.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/); if (!e) return null; const n = [ki(e[1], 255), ki(e[2], 255), ki(e[3], 255), ki(e[4], 1)]; return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n } function Vi(t) { return e => { const n = zi(e); return n ? new Mi(n, "rgb", t) : null } } function Qi(t) { const e = t.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/); if (!e) return null; const n = [Oi(e[1]), ki(e[2], 100), ki(e[3], 100)]; return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n } function Gi(t) { return e => { const n = Qi(e); return n ? new Mi(n, "hsl", t) : null } } function Hi(t) { const e = t.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/); if (!e) return null; const n = [Oi(e[1]), ki(e[2], 100), ki(e[3], 100), ki(e[4], 1)]; return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n } function ji(t) { return e => { const n = Hi(e); return n ? new Mi(n, "hsl", t) : null } } function Wi(t) { const e = t.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/); if (e) return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)]; const n = t.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/); return n ? [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16)] : null } function qi(t) { const e = Wi(t); return e ? new Mi(e, "rgb", "int") : null } function Yi(t) { const e = t.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/); if (e) return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16), Rn(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)]; const n = t.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/); return n ? [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16), Rn(parseInt(n[4], 16), 0, 255, 0, 1)] : null } function Xi(t) { const e = Yi(t); return e ? new Mi(e, "rgb", "int") : null } function Ki(t) { const e = t.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/); if (!e) return null; const n = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])]; return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n } function Ji(t) { return e => { const n = Ki(e); return n ? new Mi(n, "rgb", t) : null } } function Zi(t) { const e = t.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/); if (!e) return null; const n = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]), parseFloat(e[4])]; return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n } function $i(t) { return e => { const n = Zi(e); return n ? new Mi(n, "rgb", t) : null } } const tr = [{ parser: Wi, result: { alpha: !1, mode: "rgb", notation: "hex" } }, { parser: Yi, result: { alpha: !0, mode: "rgb", notation: "hex" } }, { parser: Ni, result: { alpha: !1, mode: "rgb", notation: "func" } }, { parser: zi, result: { alpha: !0, mode: "rgb", notation: "func" } }, { parser: Qi, result: { alpha: !1, mode: "hsl", notation: "func" } }, { parser: Hi, result: { alpha: !0, mode: "hsl", notation: "func" } }, { parser: Ki, result: { alpha: !1, mode: "rgb", notation: "object" } }, { parser: Zi, result: { alpha: !0, mode: "rgb", notation: "object" } }]; function er(t) { return tr.reduce(((e, { parser: n, result: i }) => e || (n(t) ? i : null)), null) } function nr(t, e = "int") { const n = er(t); return n ? "hex" === n.notation && "float" !== e ? Object.assign(Object.assign({}, n), { type: "int" }) : "func" === n.notation ? Object.assign(Object.assign({}, n), { type: e }) : null : null } const ir = { int: [qi, Xi, Ui("int"), Vi("int"), Gi("int"), ji("int"), Ji("int"), $i("int")], float: [Ui("float"), Vi("float"), Gi("float"), ji("float"), Ji("float"), $i("float")] }; function rr(t) { const e = ir[t]; return n => { if ("string" != typeof n) return Mi.black(t); const i = e.reduce(((t, e) => t || e(n)), null); return null != i ? i : Mi.black(t) } } function sr(t) { const e = ir[t]; return t => e.reduce(((e, n) => e || n(t)), null) } function or(t) { const e = Nn(Math.floor(t), 0, 255).toString(16); return 1 === e.length ? `0${e}` : e } function ar(t, e = "#") { return `${e}${Ai(t.getComponents("rgb")).map(or).join("")}` } function lr(t, e = "#") { const n = t.getComponents("rgb"); return `${e}${[n[0], n[1], n[2], 255 * n[3]].map(or).join("")}` } function hr(t, e) { const n = wn("float" === e ? 2 : 0); return `rgb(${Ai(t.getComponents("rgb", e)).map((t => n(t))).join(", ")})` } function cr(t) { return e => hr(e, t) } function ur(t, e) { const n = wn(2), i = wn("float" === e ? 2 : 0); return `rgba(${t.getComponents("rgb", e).map(((t, e) => (3 === e ? n : i)(t))).join(", ")})` } function dr(t) { return e => ur(e, t) } function pr(t) { const e = [wn(0), Cn, Cn]; return `hsl(${Ai(t.getComponents("hsl")).map(((t, n) => e[n](t))).join(", ")})` } function fr(t) { const e = [wn(0), Cn, Cn, wn(2)]; return `hsla(${t.getComponents("hsl").map(((t, n) => e[n](t))).join(", ")})` } function mr(t, e) { const n = wn("float" === e ? 2 : 0), i = ["r", "g", "b"]; return `{${Ai(t.getComponents("rgb", e)).map(((t, e) => `${i[e]}: ${n(t)}`)).join(", ")}}` } function gr(t) { return e => mr(e, t) } function vr(t, e) { const n = wn(2), i = wn("float" === e ? 2 : 0), r = ["r", "g", "b", "a"]; return `{${t.getComponents("rgb", e).map(((t, e) => { const s = 3 === e ? n : i; return `${r[e]}: ${s(t)}` })).join(", ")}}` } function Ar(t) { return e => vr(e, t) } const br = [{ format: { alpha: !1, mode: "rgb", notation: "hex", type: "int" }, stringifier: ar }, { format: { alpha: !0, mode: "rgb", notation: "hex", type: "int" }, stringifier: lr }, { format: { alpha: !1, mode: "hsl", notation: "func", type: "int" }, stringifier: pr }, { format: { alpha: !0, mode: "hsl", notation: "func", type: "int" }, stringifier: fr }, ...["int", "float"].reduce(((t, e) => [...t, { format: { alpha: !1, mode: "rgb", notation: "func", type: e }, stringifier: cr(e) }, { format: { alpha: !0, mode: "rgb", notation: "func", type: e }, stringifier: dr(e) }, { format: { alpha: !1, mode: "rgb", notation: "object", type: e }, stringifier: gr(e) }, { format: { alpha: !0, mode: "rgb", notation: "object", type: e }, stringifier: Ar(e) }]), [])]; function yr(t) { return br.reduce(((e, n) => e || (Fi(n.format, t) ? n.stringifier : null)), null) } const xr = A("apl"); class _r { constructor(t, e) { this.onValueChange_ = this.onValueChange_.bind(this), this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.element = t.createElement("div"), this.element.classList.add(xr()), e.viewProps.bindClassModifiers(this.element), e.viewProps.bindTabIndex(this.element); const n = t.createElement("div"); n.classList.add(xr("b")), this.element.appendChild(n); const i = t.createElement("div"); i.classList.add(xr("c")), n.appendChild(i), this.colorElem_ = i; const r = t.createElement("div"); r.classList.add(xr("m")), this.element.appendChild(r), this.markerElem_ = r; const s = t.createElement("div"); s.classList.add(xr("p")), this.markerElem_.appendChild(s), this.previewElem_ = s, this.update_() } update_() { const t = this.value.rawValue, e = t.getComponents("rgb"), n = new Mi([e[0], e[1], e[2], 0], "rgb"), i = new Mi([e[0], e[1], e[2], 255], "rgb"), r = ["to right", ur(n), ur(i)]; this.colorElem_.style.background = `linear-gradient(${r.join(",")})`, this.previewElem_.style.backgroundColor = ur(t); const s = Rn(e[3], 0, 1, 0, 100); this.markerElem_.style.left = `${s}%` } onValueChange_() { this.update_() } } class wr { constructor(t, e) { this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.view = new _r(t, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new kn(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_) } handlePointerEvent_(t, e) { if (!t.point) return; const n = t.point.x / t.bounds.width, i = this.value.rawValue, [r, s, o] = i.getComponents("hsv"); this.value.setRawValue(new Mi([r, s, o, n], "hsv"), e) } onPointerDown_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerMove_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerUp_(t) { this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 }) } onKeyDown_(t) { const e = In(Bi(!0), Dn(t)); if (0 === e) return; const n = this.value.rawValue, [i, r, s, o] = n.getComponents("hsv"); this.value.setRawValue(new Mi([i, r, s, o + e], "hsv"), { forceEmit: !1, last: !1 }) } onKeyUp_(t) { 0 !== In(Bi(!0), Dn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } } const Er = A("coltxt"); function Cr(t) { const e = t.createElement("select"), n = [{ text: "RGB", value: "rgb" }, { text: "HSL", value: "hsl" }, { text: "HSV", value: "hsv" }]; return e.appendChild(n.reduce(((e, n) => { const i = t.createElement("option"); return i.textContent = n.text, i.value = n.value, e.appendChild(i), e }), t.createDocumentFragment())), e } class Sr { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(Er()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(Er("m")), this.modeElem_ = Cr(t), this.modeElem_.classList.add(Er("ms")), n.appendChild(this.modeSelectElement), e.viewProps.bindDisabled(this.modeElem_); const i = t.createElement("div"); i.classList.add(Er("mm")), i.appendChild(rt(t, "dropdown")), n.appendChild(i), this.element.appendChild(n); const r = t.createElement("div"); r.classList.add(Er("w")), this.element.appendChild(r), this.textsElem_ = r, this.textViews_ = e.textViews, this.applyTextViews_(), x(e.colorMode, (t => { this.modeElem_.value = t })) } get modeSelectElement() { return this.modeElem_ } get textViews() { return this.textViews_ } set textViews(t) { this.textViews_ = t, this.applyTextViews_() } applyTextViews_() { at(this.textsElem_); const t = this.element.ownerDocument; this.textViews_.forEach((e => { const n = t.createElement("div"); n.classList.add(Er("c")), n.appendChild(e.element), this.textsElem_.appendChild(n) })) } } function Mr(t) { return wn("float" === t ? 2 : 0) } function Pr(t, e, n) { const i = xi(t, e)[n]; return new Ee({ min: 0, max: i }) } function Ir(t, e, n) { return new Qn(t, { arrayPosition: 0 === n ? "fst" : 2 === n ? "lst" : "mid", baseStep: Bi(!1), parser: e.parser, props: B.fromObject({ draggingScale: "float" === e.colorType ? .01 : 1, formatter: Mr(e.colorType) }), value: D(0, { constraint: Pr(e.colorMode, e.colorType, n) }), viewProps: e.viewProps }) } class Tr { constructor(t, e) { this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = e.colorType, this.parser_ = e.parser, this.value = e.value, this.viewProps = e.viewProps, this.colorMode = D(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(t), this.view = new Sr(t, { colorMode: this.colorMode, textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view], viewProps: this.viewProps }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_) } createComponentControllers_(t) { const e = { colorMode: this.colorMode.rawValue, colorType: this.colorType_, parser: this.parser_, viewProps: this.viewProps }, n = [Ir(t, e, 0), Ir(t, e, 1), Ir(t, e, 2)]; return n.forEach(((t, e) => { Pn({ primary: this.value, secondary: t.value, forward: t => t.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[e], backward: (t, n) => { const i = this.colorMode.rawValue, r = t.rawValue.getComponents(i, this.colorType_); return r[e] = n.rawValue, new Mi(bi(Ai(r), r[3]), i, this.colorType_) } }) })), n } onModeSelectChange_(t) { const e = t.currentTarget; this.colorMode.rawValue = e.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view] } } const Dr = A("hpl"); class Br { constructor(t, e) { this.onValueChange_ = this.onValueChange_.bind(this), this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.element = t.createElement("div"), this.element.classList.add(Dr()), e.viewProps.bindClassModifiers(this.element), e.viewProps.bindTabIndex(this.element); const n = t.createElement("div"); n.classList.add(Dr("c")), this.element.appendChild(n); const i = t.createElement("div"); i.classList.add(Dr("m")), this.element.appendChild(i), this.markerElem_ = i, this.update_() } update_() { const t = this.value.rawValue, [e] = t.getComponents("hsv"); this.markerElem_.style.backgroundColor = hr(new Mi([e, 100, 100], "hsv")); const n = Rn(e, 0, 360, 0, 100); this.markerElem_.style.left = `${n}%` } onValueChange_() { this.update_() } } class Lr { constructor(t, e) { this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.view = new Br(t, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new kn(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_) } handlePointerEvent_(t, e) { if (!t.point) return; const n = Rn(Nn(t.point.x, 0, t.bounds.width), 0, t.bounds.width, 0, 360), i = this.value.rawValue, [, r, s, o] = i.getComponents("hsv"); this.value.setRawValue(new Mi([n, r, s, o], "hsv"), e) } onPointerDown_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerMove_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerUp_(t) { this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 }) } onKeyDown_(t) { const e = In(Bi(!1), Dn(t)); if (0 === e) return; const n = this.value.rawValue, [i, r, s, o] = n.getComponents("hsv"); this.value.setRawValue(new Mi([i + e, r, s, o], "hsv"), { forceEmit: !1, last: !1 }) } onKeyUp_(t) { 0 !== In(Bi(!1), Dn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } } const Fr = A("svp"), kr = 64; class Rr { constructor(t, e) { this.onValueChange_ = this.onValueChange_.bind(this), this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.element = t.createElement("div"), this.element.classList.add(Fr()), e.viewProps.bindClassModifiers(this.element), e.viewProps.bindTabIndex(this.element); const n = t.createElement("canvas"); n.height = kr, n.width = kr, n.classList.add(Fr("c")), this.element.appendChild(n), this.canvasElement = n; const i = t.createElement("div"); i.classList.add(Fr("m")), this.element.appendChild(i), this.markerElem_ = i, this.update_() } update_() { const t = nt(this.canvasElement); if (!t) return; const e = this.value.rawValue.getComponents("hsv"), n = this.canvasElement.width, i = this.canvasElement.height, r = t.getImageData(0, 0, n, i), s = r.data; for (let t = 0; t < i; t++)for (let r = 0; r < n; r++) { const o = Rn(r, 0, n, 0, 100), a = Rn(t, 0, i, 100, 0), l = mi(e[0], o, a), h = 4 * (t * n + r); s[h] = l[0], s[h + 1] = l[1], s[h + 2] = l[2], s[h + 3] = 255 } t.putImageData(r, 0, 0); const o = Rn(e[1], 0, 100, 0, 100); this.markerElem_.style.left = `${o}%`; const a = Rn(e[2], 0, 100, 100, 0); this.markerElem_.style.top = `${a}%` } onValueChange_() { this.update_() } } class Or { constructor(t, e) { this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.view = new Rr(t, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new kn(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_) } handlePointerEvent_(t, e) { if (!t.point) return; const n = Rn(t.point.x, 0, t.bounds.width, 0, 100), i = Rn(t.point.y, 0, t.bounds.height, 100, 0), [r, , , s] = this.value.rawValue.getComponents("hsv"); this.value.setRawValue(new Mi([r, n, i, s], "hsv"), e) } onPointerDown_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerMove_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerUp_(t) { this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 }) } onKeyDown_(t) { Ln(t.key) && t.preventDefault(); const [e, n, i, r] = this.value.rawValue.getComponents("hsv"), s = Bi(!1), o = In(s, Dn(t)), a = In(s, Tn(t)); 0 === o && 0 === a || this.value.setRawValue(new Mi([e, n + o, i + a, r], "hsv"), { forceEmit: !1, last: !1 }) } onKeyUp_(t) { const e = Bi(!1), n = In(e, Dn(t)), i = In(e, Tn(t)); 0 === n && 0 === i || this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } } class Nr { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.hPaletteC_ = new Lr(t, { value: this.value, viewProps: this.viewProps }), this.svPaletteC_ = new Or(t, { value: this.value, viewProps: this.viewProps }), this.alphaIcs_ = e.supportsAlpha ? { palette: new wr(t, { value: this.value, viewProps: this.viewProps }), text: new Qn(t, { parser: yn, baseStep: .1, props: B.fromObject({ draggingScale: .01, formatter: wn(2) }), value: D(0, { constraint: new Ee({ min: 0, max: 1 }) }), viewProps: this.viewProps }) } : null, this.alphaIcs_ && Pn({ primary: this.value, secondary: this.alphaIcs_.text.value, forward: t => t.rawValue.getComponents()[3], backward: (t, e) => { const n = t.rawValue.getComponents(); return n[3] = e.rawValue, new Mi(n, t.rawValue.mode) } }), this.textC_ = new Tr(t, { colorType: e.colorType, parser: yn, value: this.value, viewProps: this.viewProps }), this.view = new Ii(t, { alphaViews: this.alphaIcs_ ? { palette: this.alphaIcs_.palette.view, text: this.alphaIcs_.text.view } : null, hPaletteView: this.hPaletteC_.view, supportsAlpha: e.supportsAlpha, svPaletteView: this.svPaletteC_.view, textView: this.textC_.view, viewProps: this.viewProps }) } get textController() { return this.textC_ } } const Ur = A("colsw"); class zr { constructor(t, e) { this.onValueChange_ = this.onValueChange_.bind(this), e.value.emitter.on("change", this.onValueChange_), this.value = e.value, this.element = t.createElement("div"), this.element.classList.add(Ur()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(Ur("sw")), this.element.appendChild(n), this.swatchElem_ = n; const i = t.createElement("button"); i.classList.add(Ur("b")), e.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i, this.update_() } update_() { const t = this.value.rawValue; this.swatchElem_.style.backgroundColor = lr(t) } onValueChange_() { this.update_() } } class Vr { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.view = new zr(t, { value: this.value, viewProps: this.viewProps }) } } class Qr { constructor(t, e) { this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.foldable_ = vt.create(e.expanded), this.swatchC_ = new Vr(t, { value: this.value, viewProps: this.viewProps }); const n = this.swatchC_.view.buttonElement; n.addEventListener("blur", this.onButtonBlur_), n.addEventListener("click", this.onButtonClick_), this.textC_ = new Re(t, { parser: e.parser, props: B.fromObject({ formatter: e.formatter }), value: this.value, viewProps: this.viewProps }), this.view = new ui(t, { foldable: this.foldable_, pickerLayout: e.pickerLayout }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = "popup" === e.pickerLayout ? new Le(t, { viewProps: this.viewProps }) : null; const i = new Nr(t, { colorType: e.colorType, supportsAlpha: e.supportsAlpha, value: this.value, viewProps: this.viewProps }); i.view.allFocusableElements.forEach((t => { t.addEventListener("blur", this.onPopupChildBlur_), t.addEventListener("keydown", this.onPopupChildKeydown_) })), this.pickerC_ = i, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(i.view.element), Pn({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: t => t.rawValue, backward: (t, e) => e.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), yt(this.foldable_, this.view.pickerElement)) } get textController() { return this.textC_ } onButtonBlur_(t) { if (!this.popC_) return; const e = this.view.element, n = l(t.relatedTarget); n && e.contains(n) || (this.popC_.shows.rawValue = !1) } onButtonClick_() { this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus() } onPopupChildBlur_(t) { if (!this.popC_) return; const e = this.popC_.view.element, n = ht(t); n && e.contains(n) || n && n === this.swatchC_.view.buttonElement && !$(e.ownerDocument) || (this.popC_.shows.rawValue = !1) } onPopupChildKeydown_(t) { this.popC_ ? "Escape" === t.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === t.key && this.swatchC_.view.buttonElement.focus() } } function Gr(t, e) { return Mi.isColorObject(t) ? Mi.fromObject(t, e) : Mi.black(e) } function Hr(t) { return Ai(t.getComponents("rgb")).reduce(((t, e) => t << 8 | 255 & Math.floor(e)), 0) } function jr(t) { return t.getComponents("rgb").reduce(((t, e, n) => t << 8 | 255 & Math.floor(3 === n ? 255 * e : e)), 0) >>> 0 } function Wr(t) { return new Mi([t >> 16 & 255, t >> 8 & 255, 255 & t], "rgb") } function qr(t) { return new Mi([t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, Rn(255 & t, 0, 255, 0, 1)], "rgb") } function Yr(t) { return "number" != typeof t ? Mi.black() : Wr(t) } function Xr(t) { return "number" != typeof t ? Mi.black() : qr(t) } function Kr(t) { const e = yr(t); return e ? (t, n) => { Xn(t, e(n)) } : null } function Jr(t) { const e = t ? jr : Hr; return (t, n) => { Xn(t, e(n)) } } function Zr(t, e, n) { const i = e.toRgbaObject(n); t.writeProperty("r", i.r), t.writeProperty("g", i.g), t.writeProperty("b", i.b), t.writeProperty("a", i.a) } function $r(t, e, n) { const i = e.toRgbaObject(n); t.writeProperty("r", i.r), t.writeProperty("g", i.g), t.writeProperty("b", i.b) } function ts(t, e) { return (n, i) => { t ? Zr(n, i, e) : $r(n, i, e) } } function es(t) { var e; return !(!(null == t ? void 0 : t.alpha) && !(null === (e = null == t ? void 0 : t.color) || void 0 === e ? void 0 : e.alpha)) } function ns(t) { return t ? t => lr(t, "0x") : t => ar(t, "0x") } function is(t) { return "color" in t || "view" in t && "color" === t.view } const rs = { id: "input-color-number", type: "input", accept: (t, e) => { if ("number" != typeof t) return null; if (!is(e)) return null; const n = Di(e); return n ? { initialValue: t, params: n } : null }, binding: { reader: t => es(t.params) ? Xr : Yr, equals: Mi.equals, writer: t => Jr(es(t.params)) }, controller: t => { const e = es(t.params), n = "expanded" in t.params ? t.params.expanded : void 0, i = "picker" in t.params ? t.params.picker : void 0; return new Qr(t.document, { colorType: "int", expanded: null != n && n, formatter: ns(e), parser: sr("int"), pickerLayout: null != i ? i : "popup", supportsAlpha: e, value: t.value, viewProps: t.viewProps }) } }; function ss(t) { return Mi.isRgbaColorObject(t) } function os(t) { return e => Gr(e, t) } function as(t, e) { return n => t ? vr(n, e) : mr(n, e) } const ls = { id: "input-color-object", type: "input", accept: (t, e) => { if (!Mi.isColorObject(t)) return null; const n = Di(e); return n ? { initialValue: t, params: n } : null }, binding: { reader: t => os(Li(t.params)), equals: Mi.equals, writer: t => ts(ss(t.initialValue), Li(t.params)) }, controller: t => { var e; const n = Mi.isRgbaColorObject(t.initialValue), i = "expanded" in t.params ? t.params.expanded : void 0, r = "picker" in t.params ? t.params.picker : void 0, s = null !== (e = Li(t.params)) && void 0 !== e ? e : "int"; return new Qr(t.document, { colorType: s, expanded: null != i && i, formatter: as(n, s), parser: sr(s), pickerLayout: null != r ? r : "popup", supportsAlpha: n, value: t.value, viewProps: t.viewProps }) } }, hs = { id: "input-color-string", type: "input", accept: (t, e) => { if ("string" != typeof t) return null; if ("view" in e && "text" === e.view) return null; const n = nr(t, Li(e)); if (!n) return null; if (!yr(n)) return null; const i = Di(e); return i ? { initialValue: t, params: i } : null }, binding: { reader: t => { var e; return rr(null !== (e = Li(t.params)) && void 0 !== e ? e : "int") }, equals: Mi.equals, writer: t => { const e = nr(t.initialValue, Li(t.params)); if (!e) throw p.shouldNeverHappen(); const n = Kr(e); if (!n) throw p.notBindable(); return n } }, controller: t => { const e = nr(t.initialValue, Li(t.params)); if (!e) throw p.shouldNeverHappen(); const n = yr(e); if (!n) throw p.shouldNeverHappen(); const i = "expanded" in t.params ? t.params.expanded : void 0, r = "picker" in t.params ? t.params.picker : void 0; return new Qr(t.document, { colorType: e.type, expanded: null != i && i, formatter: n, parser: sr(e.type), pickerLayout: null != r ? r : "popup", supportsAlpha: e.alpha, value: t.value, viewProps: t.viewProps }) } }; class cs { constructor(t) { this.components = t.components, this.asm_ = t.assembly } constrain(t) { const e = this.asm_.toComponents(t).map(((t, e) => { var n, i; return null !== (i = null === (n = this.components[e]) || void 0 === n ? void 0 : n.constrain(t)) && void 0 !== i ? i : t })); return this.asm_.fromComponents(e) } } const us = A("pndtxt"); class ds { constructor(t, e) { this.textViews = e.textViews, this.element = t.createElement("div"), this.element.classList.add(us()), this.textViews.forEach((e => { const n = t.createElement("div"); n.classList.add(us("a")), n.appendChild(e.element), this.element.appendChild(n) })) } } function ps(t, e, n) { return new Qn(t, { arrayPosition: 0 === n ? "fst" : n === e.axes.length - 1 ? "lst" : "mid", baseStep: e.axes[n].baseStep, parser: e.parser, props: e.axes[n].textProps, value: D(0, { constraint: e.axes[n].constraint }), viewProps: e.viewProps }) } class fs { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.acs_ = e.axes.map(((n, i) => ps(t, e, i))), this.acs_.forEach(((t, n) => { Pn({ primary: this.value, secondary: t.value, forward: t => e.assembly.toComponents(t.rawValue)[n], backward: (t, i) => { const r = e.assembly.toComponents(t.rawValue); return r[n] = i.rawValue, e.assembly.fromComponents(r) } }) })), this.view = new ds(t, { textViews: this.acs_.map((t => t.view)) }) } } function ms(t, e) { return "step" in t && !h(t.step) ? new Me(t.step, e) : null } function gs(t) { return h(t.max) || h(t.min) ? h(t.max) && h(t.min) ? null : new Se({ max: t.max, min: t.min }) : new Ee({ max: t.max, min: t.min }) } function vs(t) { const e = we(t, Ee); if (e) return [e.values.get("min"), e.values.get("max")]; const n = we(t, Se); return n ? [n.minValue, n.maxValue] : [void 0, void 0] } function As(t, e) { const n = [], i = ms(t, e); i && n.push(i); const r = gs(t); r && n.push(r); const s = ti(t.options); return s && n.push(s), new _e(n) } const bs = { id: "input-number", type: "input", accept: (t, e) => { if ("number" != typeof t) return null; const n = N, i = U(e, { format: n.optional.function, max: n.optional.number, min: n.optional.number, options: n.optional.custom(Kn), step: n.optional.number }); return i ? { initialValue: t, params: i } : null }, binding: { reader: t => xn, constraint: t => As(t.params, t.initialValue), writer: t => Xn }, controller: t => { var e; const n = t.value, i = t.constraint, r = i && we(i, Ce); if (r) return new Te(t.document, { props: new B({ options: r.values.value("options") }), value: n, viewProps: t.viewProps }); const s = null !== (e = "format" in t.params ? t.params.format : void 0) && void 0 !== e ? e : wn(ni(i, n.rawValue)), o = i && we(i, Ee); return o ? new Yn(t.document, { baseStep: ii(i), parser: yn, sliderProps: new B({ maxValue: o.values.value("max"), minValue: o.values.value("min") }), textProps: B.fromObject({ draggingScale: ri(i, n.rawValue), formatter: s }), value: n, viewProps: t.viewProps }) : new Qn(t.document, { baseStep: ii(i), parser: yn, props: B.fromObject({ draggingScale: ri(i, n.rawValue), formatter: s }), value: n, viewProps: t.viewProps }) } }; class ys { constructor(t = 0, e = 0) { this.x = t, this.y = e } getComponents() { return [this.x, this.y] } static isObject(t) { if (h(t)) return !1; const e = t.x, n = t.y; return "number" == typeof e && "number" == typeof n } static equals(t, e) { return t.x === e.x && t.y === e.y } toObject() { return { x: this.x, y: this.y } } } const xs = { toComponents: t => t.getComponents(), fromComponents: t => new ys(...t) }, _s = A("p2d"); class ws { constructor(t, e) { this.element = t.createElement("div"), this.element.classList.add(_s()), e.viewProps.bindClassModifiers(this.element), x(e.expanded, E(this.element, _s(void 0, "expanded"))); const n = t.createElement("div"); n.classList.add(_s("h")), this.element.appendChild(n); const i = t.createElement("button"); i.classList.add(_s("b")), i.appendChild(rt(t, "p2dpad")), e.viewProps.bindDisabled(i), n.appendChild(i), this.buttonElement = i; const r = t.createElement("div"); if (r.classList.add(_s("t")), n.appendChild(r), this.textElement = r, "inline" === e.pickerLayout) { const e = t.createElement("div"); e.classList.add(_s("p")), this.element.appendChild(e), this.pickerElement = e } else this.pickerElement = null } } const Es = A("p2dp"); class Cs { constructor(t, e) { this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = e.invertsY, this.maxValue_ = e.maxValue, this.element = t.createElement("div"), this.element.classList.add(Es()), "popup" === e.layout && this.element.classList.add(Es(void 0, "p")), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("div"); n.classList.add(Es("p")), e.viewProps.bindTabIndex(n), this.element.appendChild(n), this.padElement = n; const i = t.createElementNS(K, "svg"); i.classList.add(Es("g")), this.padElement.appendChild(i), this.svgElem_ = i; const r = t.createElementNS(K, "line"); r.classList.add(Es("ax")), r.setAttributeNS(null, "x1", "0"), r.setAttributeNS(null, "y1", "50%"), r.setAttributeNS(null, "x2", "100%"), r.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(r); const s = t.createElementNS(K, "line"); s.classList.add(Es("ax")), s.setAttributeNS(null, "x1", "50%"), s.setAttributeNS(null, "y1", "0"), s.setAttributeNS(null, "x2", "50%"), s.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(s); const o = t.createElementNS(K, "line"); o.classList.add(Es("l")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(o), this.lineElem_ = o; const a = t.createElement("div"); a.classList.add(Es("m")), this.padElement.appendChild(a), this.markerElem_ = a, e.value.emitter.on("change", this.onValueChange_), this.value = e.value, this.update_() } get allFocusableElements() { return [this.padElement] } update_() { const [t, e] = this.value.rawValue.getComponents(), n = this.maxValue_, i = Rn(t, -n, +n, 0, 100), r = Rn(e, -n, +n, 0, 100), s = this.invertsY_ ? 100 - r : r; this.lineElem_.setAttributeNS(null, "x2", `${i}%`), this.lineElem_.setAttributeNS(null, "y2", `${s}%`), this.markerElem_.style.left = `${i}%`, this.markerElem_.style.top = `${s}%` } onValueChange_() { this.update_() } onFoldableChange_() { this.update_() } } function Ss(t, e, n) { return [In(e[0], Dn(t)), In(e[1], Tn(t)) * (n ? 1 : -1)] } class Ms { constructor(t, e) { this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.baseSteps_ = e.baseSteps, this.maxValue_ = e.maxValue, this.invertsY_ = e.invertsY, this.view = new Cs(t, { invertsY: this.invertsY_, layout: e.layout, maxValue: this.maxValue_, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new kn(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_) } handlePointerEvent_(t, e) { if (!t.point) return; const n = this.maxValue_, i = Rn(t.point.x, 0, t.bounds.width, -n, +n), r = Rn(this.invertsY_ ? t.bounds.height - t.point.y : t.point.y, 0, t.bounds.height, -n, +n); this.value.setRawValue(new ys(i, r), e) } onPointerDown_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerMove_(t) { this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 }) } onPointerUp_(t) { this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 }) } onPadKeyDown_(t) { Ln(t.key) && t.preventDefault(); const [e, n] = Ss(t, this.baseSteps_, this.invertsY_); 0 === e && 0 === n || this.value.setRawValue(new ys(this.value.rawValue.x + e, this.value.rawValue.y + n), { forceEmit: !1, last: !1 }) } onPadKeyUp_(t) { const [e, n] = Ss(t, this.baseSteps_, this.invertsY_); 0 === e && 0 === n || this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 }) } } class Ps { constructor(t, e) { var n, i; this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = e.value, this.viewProps = e.viewProps, this.foldable_ = vt.create(e.expanded), this.popC_ = "popup" === e.pickerLayout ? new Le(t, { viewProps: this.viewProps }) : null; const r = new Ms(t, { baseSteps: [e.axes[0].baseStep, e.axes[1].baseStep], invertsY: e.invertsY, layout: e.pickerLayout, maxValue: e.maxValue, value: this.value, viewProps: this.viewProps }); r.view.allFocusableElements.forEach((t => { t.addEventListener("blur", this.onPopupChildBlur_), t.addEventListener("keydown", this.onPopupChildKeydown_) })), this.pickerC_ = r, this.textC_ = new fs(t, { assembly: xs, axes: e.axes, parser: e.parser, value: this.value, viewProps: this.viewProps }), this.view = new ws(t, { expanded: this.foldable_.value("expanded"), pickerLayout: e.pickerLayout, viewProps: this.viewProps }), this.view.textElement.appendChild(this.textC_.view.element), null === (n = this.view.buttonElement) || void 0 === n || n.addEventListener("blur", this.onPadButtonBlur_), null === (i = this.view.buttonElement) || void 0 === i || i.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Pn({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: t => t.rawValue, backward: (t, e) => e.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), yt(this.foldable_, this.view.pickerElement)) } onPadButtonBlur_(t) { if (!this.popC_) return; const e = this.view.element, n = l(t.relatedTarget); n && e.contains(n) || (this.popC_.shows.rawValue = !1) } onPadButtonClick_() { this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus() } onPopupChildBlur_(t) { if (!this.popC_) return; const e = this.popC_.view.element, n = ht(t); n && e.contains(n) || n && n === this.view.buttonElement && !$(e.ownerDocument) || (this.popC_.shows.rawValue = !1) } onPopupChildKeydown_(t) { this.popC_ ? "Escape" === t.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === t.key && this.view.buttonElement.focus() } } class Is { constructor(t = 0, e = 0, n = 0) { this.x = t, this.y = e, this.z = n } getComponents() { return [this.x, this.y, this.z] } static isObject(t) { if (h(t)) return !1; const e = t.x, n = t.y, i = t.z; return "number" == typeof e && "number" == typeof n && "number" == typeof i } static equals(t, e) { return t.x === e.x && t.y === e.y && t.z === e.z } toObject() { return { x: this.x, y: this.y, z: this.z } } } const Ts = { toComponents: t => t.getComponents(), fromComponents: t => new Is(...t) }; function Ds(t) { return Is.isObject(t) ? new Is(t.x, t.y, t.z) : new Is } function Bs(t, e) { t.writeProperty("x", e.x), t.writeProperty("y", e.y), t.writeProperty("z", e.z) } function Ls(t, e) { return new cs({ assembly: Ts, components: [go("x" in t ? t.x : void 0, e.x), go("y" in t ? t.y : void 0, e.y), go("z" in t ? t.z : void 0, e.z)] }) } function Fs(t, e) { return { baseStep: ii(e), constraint: e, textProps: B.fromObject({ draggingScale: ri(e, t), formatter: wn(ni(e, t)) }) } } const ks = { id: "input-point3d", type: "input", accept: (t, e) => { if (!Is.isObject(t)) return null; const n = N, i = U(e, { x: n.optional.custom(Zn), y: n.optional.custom(Zn), z: n.optional.custom(Zn) }); return i ? { initialValue: t, params: i } : null }, binding: { reader: t => Ds, constraint: t => Ls(t.params, t.initialValue), equals: Is.equals, writer: t => Bs }, controller: t => { const e = t.value, n = t.constraint; if (!(n instanceof cs)) throw p.shouldNeverHappen(); return new fs(t.document, { assembly: Ts, axes: [Fs(e.rawValue.x, n.components[0]), Fs(e.rawValue.y, n.components[1]), Fs(e.rawValue.z, n.components[2])], parser: yn, value: e, viewProps: t.viewProps }) } }; class Rs { constructor(t = 0, e = 0, n = 0, i = 0) { this.x = t, this.y = e, this.z = n, this.w = i } getComponents() { return [this.x, this.y, this.z, this.w] } static isObject(t) { if (h(t)) return !1; const e = t.x, n = t.y, i = t.z, r = t.w; return "number" == typeof e && "number" == typeof n && "number" == typeof i && "number" == typeof r } static equals(t, e) { return t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w } toObject() { return { x: this.x, y: this.y, z: this.z, w: this.w } } } const Os = { toComponents: t => t.getComponents(), fromComponents: t => new Rs(...t) }; function Ns(t) { return Rs.isObject(t) ? new Rs(t.x, t.y, t.z, t.w) : new Rs } function Us(t, e) { t.writeProperty("x", e.x), t.writeProperty("y", e.y), t.writeProperty("z", e.z), t.writeProperty("w", e.w) } function zs(t, e) { return new cs({ assembly: Os, components: [go("x" in t ? t.x : void 0, e.x), go("y" in t ? t.y : void 0, e.y), go("z" in t ? t.z : void 0, e.z), go("w" in t ? t.w : void 0, e.w)] }) } function Vs(t, e) { return { baseStep: ii(e), constraint: e, textProps: B.fromObject({ draggingScale: ri(e, t), formatter: wn(ni(e, t)) }) } } const Qs = { id: "input-point4d", type: "input", accept: (t, e) => { if (!Rs.isObject(t)) return null; const n = N, i = U(e, { x: n.optional.custom(Zn), y: n.optional.custom(Zn), z: n.optional.custom(Zn), w: n.optional.custom(Zn) }); return i ? { initialValue: t, params: i } : null }, binding: { reader: t => Ns, constraint: t => zs(t.params, t.initialValue), equals: Rs.equals, writer: t => Us }, controller: t => { const e = t.value, n = t.constraint; if (!(n instanceof cs)) throw p.shouldNeverHappen(); return new fs(t.document, { assembly: Os, axes: e.rawValue.getComponents().map(((t, e) => Vs(t, n.components[e]))), parser: yn, value: e, viewProps: t.viewProps }) } }; function Gs(t) { const e = [], n = ti(t.options); return n && e.push(n), new _e(e) } const Hs = { id: "input-string", type: "input", accept: (t, e) => { if ("string" != typeof t) return null; const n = U(e, { options: N.optional.custom(Kn) }); return n ? { initialValue: t, params: n } : null }, binding: { reader: t => Sn, constraint: t => Gs(t.params), writer: t => Xn }, controller: t => { const e = t.document, n = t.value, i = t.constraint, r = i && we(i, Ce); return r ? new Te(e, { props: new B({ options: r.values.value("options") }), value: n, viewProps: t.viewProps }) : new Re(e, { parser: t => t, props: B.fromObject({ formatter: Mn }), value: n, viewProps: t.viewProps }) } }, js = { monitor: { defaultInterval: 200, defaultLineCount: 3 } }, Ws = A("mll"); class qs { constructor(t, e) { this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = e.formatter, this.element = t.createElement("div"), this.element.classList.add(Ws()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("textarea"); n.classList.add(Ws("i")), n.style.height = `calc(var(--bld-us) * ${e.lineCount})`, n.readOnly = !0, e.viewProps.bindDisabled(n), this.element.appendChild(n), this.textareaElem_ = n, e.value.emitter.on("change", this.onValueUpdate_), this.value = e.value, this.update_() } update_() { const t = this.textareaElem_, e = t.scrollTop === t.scrollHeight - t.clientHeight, n = []; this.value.rawValue.forEach((t => { void 0 !== t && n.push(this.formatter_(t)) })), t.textContent = n.join("\n"), e && (t.scrollTop = t.scrollHeight) } onValueUpdate_() { this.update_() } } class Ys { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.view = new qs(t, { formatter: e.formatter, lineCount: e.lineCount, value: this.value, viewProps: this.viewProps }) } } const Xs = A("sgl"); class Ks { constructor(t, e) { this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = e.formatter, this.element = t.createElement("div"), this.element.classList.add(Xs()), e.viewProps.bindClassModifiers(this.element); const n = t.createElement("input"); n.classList.add(Xs("i")), n.readOnly = !0, n.type = "text", e.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, e.value.emitter.on("change", this.onValueUpdate_), this.value = e.value, this.update_() } update_() { const t = this.value.rawValue, e = t[t.length - 1]; this.inputElement.value = void 0 !== e ? this.formatter_(e) : "" } onValueUpdate_() { this.update_() } } class Js { constructor(t, e) { this.value = e.value, this.viewProps = e.viewProps, this.view = new Ks(t, { formatter: e.formatter, value: this.value, viewProps: this.viewProps }) } } const Zs = { id: "monitor-bool", type: "monitor", accept: (t, e) => { if ("boolean" != typeof t) return null; const n = U(e, { lineCount: N.optional.number }); return n ? { initialValue: t, params: n } : null }, binding: { reader: t => Ne }, controller: t => { var e; return 1 === t.value.rawValue.length ? new Js(t.document, { formatter: Ue, value: t.value, viewProps: t.viewProps }) : new Ys(t.document, { formatter: Ue, lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : js.monitor.defaultLineCount, value: t.value, viewProps: t.viewProps }) } }, $s = A("grl"); class to { constructor(t, e) { this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = t.createElement("div"), this.element.classList.add($s()), e.viewProps.bindClassModifiers(this.element), this.formatter_ = e.formatter, this.props_ = e.props, this.cursor_ = e.cursor, this.cursor_.emitter.on("change", this.onCursorChange_); const n = t.createElementNS(K, "svg"); n.classList.add($s("g")), n.style.height = `calc(var(--bld-us) * ${e.lineCount})`, this.element.appendChild(n), this.svgElem_ = n; const i = t.createElementNS(K, "polyline"); this.svgElem_.appendChild(i), this.lineElem_ = i; const r = t.createElement("div"); r.classList.add($s("t"), A("tt")()), this.element.appendChild(r), this.tooltipElem_ = r, e.value.emitter.on("change", this.onValueUpdate_), this.value = e.value, this.update_() } get graphElement() { return this.svgElem_ } update_() { const t = this.svgElem_.getBoundingClientRect(), e = this.value.rawValue.length - 1, n = this.props_.get("minValue"), i = this.props_.get("maxValue"), r = []; this.value.rawValue.forEach(((s, o) => { if (void 0 === s) return; const a = Rn(o, 0, e, 0, t.width), l = Rn(s, n, i, t.height, 0); r.push([a, l].join(",")) })), this.lineElem_.setAttributeNS(null, "points", r.join(" ")); const s = this.tooltipElem_, o = this.value.rawValue[this.cursor_.rawValue]; if (void 0 === o) return void s.classList.remove($s("t", "a")); const a = Rn(this.cursor_.rawValue, 0, e, 0, t.width), l = Rn(o, n, i, t.height, 0); s.style.left = `${a}px`, s.style.top = `${l}px`, s.textContent = `${this.formatter_(o)}`, s.classList.contains($s("t", "a")) || (s.classList.add($s("t", "a"), $s("t", "in")), J(s), s.classList.remove($s("t", "in"))) } onValueUpdate_() { this.update_() } onCursorChange_() { this.update_() } } class eo { constructor(t, e) { if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = e.props, this.value = e.value, this.viewProps = e.viewProps, this.cursor_ = D(-1), this.view = new to(t, { cursor: this.cursor_, formatter: e.formatter, lineCount: e.lineCount, props: this.props_, value: this.value, viewProps: this.viewProps }), $(t)) { const t = new kn(this.view.element); t.emitter.on("down", this.onGraphPointerDown_), t.emitter.on("move", this.onGraphPointerMove_), t.emitter.on("up", this.onGraphPointerUp_) } else this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_) } onGraphMouseLeave_() { this.cursor_.rawValue = -1 } onGraphMouseMove_(t) { const e = this.view.element.getBoundingClientRect(); this.cursor_.rawValue = Math.floor(Rn(t.offsetX, 0, e.width, 0, this.value.rawValue.length)) } onGraphPointerDown_(t) { this.onGraphPointerMove_(t) } onGraphPointerMove_(t) { t.data.point ? this.cursor_.rawValue = Math.floor(Rn(t.data.point.x, 0, t.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.rawValue = -1 } onGraphPointerUp_() { this.cursor_.rawValue = -1 } } function no(t) { return "format" in t && !h(t.format) ? t.format : wn(2) } function io(t) { var e; return 1 === t.value.rawValue.length ? new Js(t.document, { formatter: no(t.params), value: t.value, viewProps: t.viewProps }) : new Ys(t.document, { formatter: no(t.params), lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : js.monitor.defaultLineCount, value: t.value, viewProps: t.viewProps }) } function ro(t) { var e, n, i; return new eo(t.document, { formatter: no(t.params), lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : js.monitor.defaultLineCount, props: B.fromObject({ maxValue: null !== (n = "max" in t.params ? t.params.max : null) && void 0 !== n ? n : 100, minValue: null !== (i = "min" in t.params ? t.params.min : null) && void 0 !== i ? i : 0 }), value: t.value, viewProps: t.viewProps }) } function so(t) { return "view" in t && "graph" === t.view } const oo = { id: "monitor-number", type: "monitor", accept: (t, e) => { if ("number" != typeof t) return null; const n = N, i = U(e, { format: n.optional.function, lineCount: n.optional.number, max: n.optional.number, min: n.optional.number, view: n.optional.string }); return i ? { initialValue: t, params: i } : null }, binding: { defaultBufferSize: t => so(t) ? 64 : 1, reader: t => xn }, controller: t => so(t.params) ? ro(t) : io(t) }, ao = { id: "monitor-string", type: "monitor", accept: (t, e) => { if ("string" != typeof t) return null; const n = N, i = U(e, { lineCount: n.optional.number, multiline: n.optional.boolean }); return i ? { initialValue: t, params: i } : null }, binding: { reader: t => Sn }, controller: t => { var e; const n = t.value; return n.rawValue.length > 1 || "multiline" in t.params && t.params.multiline ? new Ys(t.document, { formatter: Mn, lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : js.monitor.defaultLineCount, value: n, viewProps: t.viewProps }) : new Js(t.document, { formatter: Mn, value: n, viewProps: t.viewProps }) } }; function lo(t, e) { const n = t.accept(e.target.read(), e.params); if (h(n)) return null; const i = N, r = { target: e.target, initialValue: n.initialValue, params: n.params }, s = t.binding.reader(r), o = t.binding.constraint ? t.binding.constraint(r) : void 0, a = D(s(n.initialValue), { constraint: o, equals: t.binding.equals }), l = new ge({ reader: s, target: e.target, value: a, writer: t.binding.writer(r) }), c = i.optional.boolean(e.params.disabled).value, u = i.optional.boolean(e.params.hidden).value, d = t.controller({ constraint: o, document: e.document, initialValue: n.initialValue, params: n.params, value: l.value, viewProps: j.create({ disabled: c, hidden: u }) }), p = i.optional.string(e.params.label).value; return new Pt(e.document, { binding: l, blade: gt(), props: B.fromObject({ label: null != p ? p : e.target.key }), valueController: d }) } function ho(t, e) { return 0 === e ? new fe : new me(t, null != e ? e : js.monitor.defaultInterval) } function co(t, e) { var n, i, r; const s = N, o = t.accept(e.target.read(), e.params); if (h(o)) return null; const a = { target: e.target, initialValue: o.initialValue, params: o.params }, l = t.binding.reader(a), c = null !== (i = null !== (n = s.optional.number(e.params.bufferSize).value) && void 0 !== n ? n : t.binding.defaultBufferSize && t.binding.defaultBufferSize(o.params)) && void 0 !== i ? i : 1, u = s.optional.number(e.params.interval).value, d = new xe({ reader: l, target: e.target, ticker: ho(e.document, u), value: Ae(c) }), p = s.optional.boolean(e.params.disabled).value, f = s.optional.boolean(e.params.hidden).value, m = t.controller({ document: e.document, params: o.params, value: d.value, viewProps: j.create({ disabled: p, hidden: f }) }), g = null !== (r = s.optional.string(e.params.label).value) && void 0 !== r ? r : e.target.key; return new Tt(e.document, { binding: d, blade: gt(), props: B.fromObject({ label: g }), valueController: m }) } class uo { constructor() { this.pluginsMap_ = { blades: [], inputs: [], monitors: [] } } getAll() { return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors] } register(t) { "blade" === t.type ? this.pluginsMap_.blades.unshift(t) : "input" === t.type ? this.pluginsMap_.inputs.unshift(t) : "monitor" === t.type && this.pluginsMap_.monitors.unshift(t) } createInput(t, e, n) { if (h(e.read())) throw new p({ context: { key: e.key }, type: "nomatchingcontroller" }); const i = this.pluginsMap_.inputs.reduce(((i, r) => null != i ? i : lo(r, { document: t, target: e, params: n })), null); if (i) return i; throw new p({ context: { key: e.key }, type: "nomatchingcontroller" }) } createMonitor(t, e, n) { const i = this.pluginsMap_.monitors.reduce(((i, r) => null != i ? i : co(r, { document: t, params: n, target: e })), null); if (i) return i; throw new p({ context: { key: e.key }, type: "nomatchingcontroller" }) } createBlade(t, e) { const n = this.pluginsMap_.blades.reduce(((n, i) => null != n ? n : pe(i, { document: t, params: e })), null); if (!n) throw new p({ type: "nomatchingview", context: { params: e } }); return n } createBladeApi(t) { if (t instanceof Pt) return new Mt(t); if (t instanceof Tt) return new It(t); if (t instanceof Ht) return new Ft(t, this); const e = this.pluginsMap_.blades.reduce(((e, n) => null != e ? e : n.api({ controller: t, pool: this })), null); if (!e) throw p.shouldNeverHappen(); return e } } function po() { const t = new uo; return [_o, ks, Qs, Hs, bs, hs, ls, rs, hi, Zs, ao, oo, ft, Yt, te, de].forEach((e => { t.register(e) })), t } function fo(t) { return ys.isObject(t) ? new ys(t.x, t.y) : new ys } function mo(t, e) { t.writeProperty("x", e.x), t.writeProperty("y", e.y) } function go(t, e) { if (!t) return; const n = [], i = ms(t, e); i && n.push(i); const r = gs(t); return r && n.push(r), new _e(n) } function vo(t, e) { return new cs({ assembly: xs, components: [go("x" in t ? t.x : void 0, e.x), go("y" in t ? t.y : void 0, e.y)] }) } function Ao(t, e) { const [n, i] = t ? vs(t) : []; if (!h(n) || !h(i)) return Math.max(Math.abs(null != n ? n : 0), Math.abs(null != i ? i : 0)); const r = ii(t); return Math.max(10 * Math.abs(r), 10 * Math.abs(e)) } function bo(t, e) { const n = e instanceof cs ? e.components[0] : void 0, i = e instanceof cs ? e.components[1] : void 0, r = Ao(n, t.x), s = Ao(i, t.y); return Math.max(r, s) } function yo(t, e) { return { baseStep: ii(e), constraint: e, textProps: B.fromObject({ draggingScale: ri(e, t), formatter: wn(ni(e, t)) }) } } function xo(t) { if (!("y" in t)) return !1; const e = t.y; return !!e && "inverted" in e && !!e.inverted } const _o = { id: "input-point2d", type: "input", accept: (t, e) => { if (!ys.isObject(t)) return null; const n = N, i = U(e, { expanded: n.optional.boolean, picker: n.optional.custom(Jn), x: n.optional.custom(Zn), y: n.optional.object({ inverted: n.optional.boolean, max: n.optional.number, min: n.optional.number, step: n.optional.number }) }); return i ? { initialValue: t, params: i } : null }, binding: { reader: t => fo, constraint: t => vo(t.params, t.initialValue), equals: ys.equals, writer: t => mo }, controller: t => { const e = t.document, n = t.value, i = t.constraint; if (!(i instanceof cs)) throw p.shouldNeverHappen(); const r = "expanded" in t.params ? t.params.expanded : void 0, s = "picker" in t.params ? t.params.picker : void 0; return new Ps(e, { axes: [yo(n.rawValue.x, i.components[0]), yo(n.rawValue.y, i.components[1])], expanded: null != r && r, invertsY: xo(t.params), maxValue: bo(n.rawValue, i), parser: yn, pickerLayout: null != s ? s : "popup", value: n, viewProps: t.viewProps }) } }; class wo extends n { constructor(t) { super(t), this.emitter_ = new g, this.controller_.valueController.value.emitter.on("change", (t => { this.emitter_.emit("change", { event: new r(this, t.rawValue) }) })) } get label() { return this.controller_.props.get("label") } set label(t) { this.controller_.props.set("label", t) } get options() { return this.controller_.valueController.props.get("options") } set options(t) { this.controller_.valueController.props.set("options", t) } get value() { return this.controller_.valueController.value.rawValue } set value(t) { this.controller_.valueController.value.rawValue = t } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } } class Eo extends n { constructor(t) { super(t), this.emitter_ = new g, this.controller_.valueController.value.emitter.on("change", (t => { this.emitter_.emit("change", { event: new r(this, t.rawValue) }) })) } get label() { return this.controller_.props.get("label") } set label(t) { this.controller_.props.set("label", t) } get maxValue() { return this.controller_.valueController.sliderController.props.get("maxValue") } set maxValue(t) { this.controller_.valueController.sliderController.props.set("maxValue", t) } get minValue() { return this.controller_.valueController.sliderController.props.get("minValue") } set minValue(t) { this.controller_.valueController.sliderController.props.set("minValue", t) } get value() { return this.controller_.valueController.value.rawValue } set value(t) { this.controller_.valueController.value.rawValue = t } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } } class Co extends n { constructor(t) { super(t), this.emitter_ = new g, this.controller_.valueController.value.emitter.on("change", (t => { this.emitter_.emit("change", { event: new r(this, t.rawValue) }) })) } get label() { return this.controller_.props.get("label") } set label(t) { this.controller_.props.set("label", t) } get formatter() { return this.controller_.valueController.props.get("formatter") } set formatter(t) { this.controller_.valueController.props.set("formatter", t) } get value() { return this.controller_.valueController.value.rawValue } set value(t) { this.controller_.valueController.value.rawValue = t } on(t, e) { const n = e.bind(this); return this.emitter_.on(t, (t => { n(t.event) })), this } } const So = { id: "list", type: "blade", accept(t) { const e = N, n = U(t, { options: e.required.custom(Kn), value: e.required.raw, view: e.required.constant("list"), label: e.optional.string }); return n ? { params: n } : null }, controller(t) { const e = new Ce($n(t.params.options)), n = D(t.params.value, { constraint: e }), i = new Te(t.document, { props: new B({ options: e.values.value("options") }), value: n, viewProps: t.viewProps }); return new Xt(t.document, { blade: t.blade, props: B.fromObject({ label: t.params.label }), valueController: i }) }, api(t) { return t.controller instanceof Xt && t.controller.valueController instanceof Te ? new wo(t.controller) : null } }; function Mo(t) { return t.reduce(((t, e) => Object.assign(t, { [e.presetKey]: e.read() })), {}) } function Po(t, e) { t.forEach((t => { const n = e[t.target.presetKey]; void 0 !== n && t.writer(t.target, t.reader(n)) })) } class Io extends kt { constructor(t, e) { super(t, e) } get element() { return this.controller_.view.element } importPreset(t) { Po(this.controller_.rackController.rack.find(Pt).map((t => t.binding)), t), this.refresh() } exportPreset() { return Mo(this.controller_.rackController.rack.find(Pt).map((t => t.binding.target))) } refresh() { this.controller_.rackController.rack.find(Pt).forEach((t => { t.binding.read() })), this.controller_.rackController.rack.find(Tt).forEach((t => { t.binding.read() })) } } class To extends qt { constructor(t, e) { super(t, { expanded: e.expanded, blade: e.blade, props: e.props, root: !0, viewProps: e.viewProps }) } } const Do = { id: "slider", type: "blade", accept(t) { const e = N, n = U(t, { max: e.required.number, min: e.required.number, view: e.required.constant("slider"), format: e.optional.function, label: e.optional.string, value: e.optional.number }); return n ? { params: n } : null }, controller(t) { var e, n; const i = null !== (e = t.params.value) && void 0 !== e ? e : 0, r = new Ee({ max: t.params.max, min: t.params.min }), s = new Yn(t.document, { baseStep: 1, parser: yn, sliderProps: new B({ maxValue: r.values.value("max"), minValue: r.values.value("min") }), textProps: B.fromObject({ draggingScale: ri(void 0, i), formatter: null !== (n = t.params.format) && void 0 !== n ? n : _n }), value: D(i, { constraint: r }), viewProps: t.viewProps }); return new Xt(t.document, { blade: t.blade, props: B.fromObject({ label: t.params.label }), valueController: s }) }, api(t) { return t.controller instanceof Xt && t.controller.valueController instanceof Yn ? new Eo(t.controller) : null } }, Bo = { id: "text", type: "blade", accept(t) { const e = N, n = U(t, { parse: e.required.function, value: e.required.raw, view: e.required.constant("text"), format: e.optional.function, label: e.optional.string }); return n ? { params: n } : null }, controller(t) { var e; const n = new Re(t.document, { parser: t.params.parse, props: B.fromObject({ formatter: null !== (e = t.params.format) && void 0 !== e ? e : t => String(t) }), value: D(t.params.value), viewProps: t.viewProps }); return new Xt(t.document, { blade: t.blade, props: B.fromObject({ label: t.params.label }), valueController: n }) }, api(t) { return t.controller instanceof Xt && t.controller.valueController instanceof Re ? new Co(t.controller) : null } }; function Lo(t) { const e = t.createElement("div"); return e.classList.add(A("dfw")()), t.body && t.body.appendChild(e), e } function Fo(t, e, n) { if (t.querySelector(`style[data-tp-style=${e}]`)) return; const i = t.createElement("style"); i.dataset.tpStyle = e, i.textContent = n, t.head.appendChild(i) } class ko extends Io { constructor(t) { var e, n; const i = null != t ? t : {}, r = null !== (e = i.document) && void 0 !== e ? e : et(), s = po(); super(new To(r, { expanded: i.expanded, blade: gt(), props: B.fromObject({ title: i.title }), viewProps: j.create() }), s), this.pool_ = s, this.containerElem_ = null !== (n = i.container) && void 0 !== n ? n : Lo(r), this.containerElem_.appendChild(this.element), this.doc_ = r, this.usesDefaultWrapper_ = !i.container, this.setUpDefaultPlugins_() } get document() { if (!this.doc_) throw p.alreadyDisposed(); return this.doc_ } dispose() { const t = this.containerElem_; if (!t) throw p.alreadyDisposed(); if (this.usesDefaultWrapper_) { const e = t.parentElement; e && e.removeChild(t) } this.containerElem_ = null, this.doc_ = null, super.dispose() } registerPlugin(t) { ("plugin" in t ? [t.plugin] : "plugins" in t ? t.plugins : []).forEach((t => { this.pool_.register(t), this.embedPluginStyle_(t) })) } embedPluginStyle_(t) { t.css && Fo(this.document, `plugin-${t.id}`, t.css) } setUpDefaultPlugins_() { Fo(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((t => { this.embedPluginStyle_(t) })), this.registerPlugin({ plugins: [Do, So, de, Bo] }) } } const Ro = new e("3.1.6"); t.BladeApi = n, t.ButtonApi = m, t.FolderApi = kt, t.InputBindingApi = Mt, t.ListApi = wo, t.MonitorBindingApi = It, t.Pane = ko, t.SeparatorApi = Kt, t.SliderApi = Eo, t.TabApi = oe, t.TabPageApi = se, t.TextApi = Co, t.TpChangeEvent = r, t.VERSION = Ro, Object.defineProperty(t, "__esModule", { value: !0 }) }(e) }, 9389: function (t) { t.exports = function () { var t = 0; function e(e) { return "__private_" + t++ + "_" + e } function n(t, e) { if (!Object.prototype.hasOwnProperty.call(t, e)) throw new TypeError("attempted to use private field on non-instance"); return t } function i() { } i.prototype = { on: function (t, e, n) { var i = this.e || (this.e = {}); return (i[t] || (i[t] = [])).push({ fn: e, ctx: n }), this }, once: function (t, e, n) { var i = this; function r() { i.off(t, r), e.apply(n, arguments) } return r._ = e, this.on(t, r, n) }, emit: function (t) { for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++)n[i].fn.apply(n[i].ctx, e); return this }, off: function (t, e) { var n = this.e || (this.e = {}), i = n[t], r = []; if (i && e) for (var s = 0, o = i.length; s < o; s++)i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]); return r.length ? n[t] = r : delete n[t], this } }; var r = i; r.TinyEmitter = i; var s, o = "virtualscroll", a = e("options"), l = e("el"), h = e("emitter"), c = e("event"), u = e("touchStart"), d = e("bodyTouchAction"); return function () { function t(t) { var e = this; Object.defineProperty(this, a, { writable: !0, value: void 0 }), Object.defineProperty(this, l, { writable: !0, value: void 0 }), Object.defineProperty(this, h, { writable: !0, value: void 0 }), Object.defineProperty(this, c, { writable: !0, value: void 0 }), Object.defineProperty(this, u, { writable: !0, value: void 0 }), Object.defineProperty(this, d, { writable: !0, value: void 0 }), this._onWheel = function (t) { var i = n(e, a)[a], r = n(e, c)[c]; r.deltaX = t.wheelDeltaX || -1 * t.deltaX, r.deltaY = t.wheelDeltaY || -1 * t.deltaY, s.isFirefox && 1 === t.deltaMode && (r.deltaX *= i.firefoxMultiplier, r.deltaY *= i.firefoxMultiplier), r.deltaX *= i.mouseMultiplier, r.deltaY *= i.mouseMultiplier, e._notify(t) }, this._onMouseWheel = function (t) { var i = n(e, c)[c]; i.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0, i.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta, e._notify(t) }, this._onTouchStart = function (t) { var i = t.targetTouches ? t.targetTouches[0] : t; n(e, u)[u].x = i.pageX, n(e, u)[u].y = i.pageY }, this._onTouchMove = function (t) { var i = n(e, a)[a]; i.preventTouch && !t.target.classList.contains(i.unpreventTouchClass) && t.preventDefault(); var r = n(e, c)[c], s = t.targetTouches ? t.targetTouches[0] : t; r.deltaX = (s.pageX - n(e, u)[u].x) * i.touchMultiplier, r.deltaY = (s.pageY - n(e, u)[u].y) * i.touchMultiplier, n(e, u)[u].x = s.pageX, n(e, u)[u].y = s.pageY, e._notify(t) }, this._onKeyDown = function (t) { var i = n(e, c)[c]; i.deltaX = i.deltaY = 0; var r = window.innerHeight - 40; switch (t.keyCode) { case 37: case 38: i.deltaY = n(e, a)[a].keyStep; break; case 39: case 40: i.deltaY = -n(e, a)[a].keyStep; break; case 32: i.deltaY = r * (t.shiftKey ? 1 : -1); break; default: return }e._notify(t) }, n(this, l)[l] = window, t && t.el && (n(this, l)[l] = t.el, delete t.el), s || (s = { hasWheelEvent: "onwheel" in document, hasMouseWheelEvent: "onmousewheel" in document, hasTouch: "ontouchstart" in document, hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1, hasPointer: !!window.navigator.msPointerEnabled, hasKeyDown: "onkeydown" in document, isFirefox: navigator.userAgent.indexOf("Firefox") > -1 }), n(this, a)[a] = Object.assign({ mouseMultiplier: 1, touchMultiplier: 2, firefoxMultiplier: 15, keyStep: 120, preventTouch: !1, unpreventTouchClass: "vs-touchmove-allowed", useKeyboard: !0, useTouch: !0 }, t), n(this, h)[h] = new r, n(this, c)[c] = { y: 0, x: 0, deltaX: 0, deltaY: 0 }, n(this, u)[u] = { x: null, y: null }, n(this, d)[d] = null, void 0 !== n(this, a)[a].passive && (this.listenerOptions = { passive: n(this, a)[a].passive }) } var e = t.prototype; return e._notify = function (t) { var e = n(this, c)[c]; e.x += e.deltaX, e.y += e.deltaY, n(this, h)[h].emit(o, { x: e.x, y: e.y, deltaX: e.deltaX, deltaY: e.deltaY, originalEvent: t }) }, e._bind = function () { s.hasWheelEvent && n(this, l)[l].addEventListener("wheel", this._onWheel, this.listenerOptions), s.hasMouseWheelEvent && n(this, l)[l].addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions), s.hasTouch && n(this, a)[a].useTouch && (n(this, l)[l].addEventListener("touchstart", this._onTouchStart, this.listenerOptions), n(this, l)[l].addEventListener("touchmove", this._onTouchMove, this.listenerOptions)), s.hasPointer && s.hasTouchWin && (n(this, d)[d] = document.body.style.msTouchAction, document.body.style.msTouchAction = "none", n(this, l)[l].addEventListener("MSPointerDown", this._onTouchStart, !0), n(this, l)[l].addEventListener("MSPointerMove", this._onTouchMove, !0)), s.hasKeyDown && n(this, a)[a].useKeyboard && document.addEventListener("keydown", this._onKeyDown) }, e._unbind = function () { s.hasWheelEvent && n(this, l)[l].removeEventListener("wheel", this._onWheel), s.hasMouseWheelEvent && n(this, l)[l].removeEventListener("mousewheel", this._onMouseWheel), s.hasTouch && (n(this, l)[l].removeEventListener("touchstart", this._onTouchStart), n(this, l)[l].removeEventListener("touchmove", this._onTouchMove)), s.hasPointer && s.hasTouchWin && (document.body.style.msTouchAction = n(this, d)[d], n(this, l)[l].removeEventListener("MSPointerDown", this._onTouchStart, !0), n(this, l)[l].removeEventListener("MSPointerMove", this._onTouchMove, !0)), s.hasKeyDown && n(this, a)[a].useKeyboard && document.removeEventListener("keydown", this._onKeyDown) }, e.on = function (t, e) { n(this, h)[h].on(o, t, e); var i = n(this, h)[h].e; i && i[o] && 1 === i[o].length && this._bind() }, e.off = function (t, e) { n(this, h)[h].off(o, t, e); var i = n(this, h)[h].e; (!i[o] || i[o].length <= 0) && this._unbind() }, e.destroy = function () { n(this, h)[h].off(), this._unbind() }, t }() }() } }, __webpack_module_cache__ = {}, deferred; function __webpack_require__(t) { var e = __webpack_module_cache__[t]; if (void 0 !== e) return e.exports; var n = __webpack_module_cache__[t] = { exports: {} }; return __webpack_modules__[t].call(n.exports, n, n.exports, __webpack_require__), n.exports } __webpack_require__.m = __webpack_modules__, __webpack_require__.amdO = {}, deferred = [], __webpack_require__.O = function (t, e, n, i) { if (!e) { var r = 1 / 0; for (l = 0; l < deferred.length; l++) { e = deferred[l][0], n = deferred[l][1], i = deferred[l][2]; for (var s = !0, o = 0; o < e.length; o++)(!1 & i || r >= i) && Object.keys(__webpack_require__.O).every((function (t) { return __webpack_require__.O[t](e[o]) })) ? e.splice(o--, 1) : (s = !1, i < r && (r = i)); if (s) { deferred.splice(l--, 1); var a = n(); void 0 !== a && (t = a) } } return t } i = i || 0; for (var l = deferred.length; l > 0 && deferred[l - 1][2] > i; l--)deferred[l] = deferred[l - 1]; deferred[l] = [e, n, i] }, __webpack_require__.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return __webpack_require__.d(e, { a: e }), e }, __webpack_require__.d = function (t, e) { for (var n in e) __webpack_require__.o(e, n) && !__webpack_require__.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: e[n] }) }, __webpack_require__.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (t) { if ("object" == typeof window) return window } }(), __webpack_require__.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, __webpack_require__.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, function () { var t = { 155: 0, 805: 0, 938: 0 }; __webpack_require__.O.j = function (e) { return 0 === t[e] }; var e = function (e, n) { var i, r, s = n[0], o = n[1], a = n[2], l = 0; if (s.some((function (e) { return 0 !== t[e] }))) { for (i in o) __webpack_require__.o(o, i) && (__webpack_require__.m[i] = o[i]); if (a) var h = a(__webpack_require__) } for (e && e(n); l < s.length; l++)r = s[l], __webpack_require__.o(t, r) && t[r] && t[r][0](), t[r] = 0; return __webpack_require__.O(h) }, n = self.webpackChunkunseen = self.webpackChunkunseen || []; n.forEach(e.bind(null, 0)), n.push = e.bind(null, n.push.bind(n)) }(), __webpack_require__.O(void 0, [805, 938], (function () { return __webpack_require__(6077) })), __webpack_require__.O(void 0, [805, 938], (function () { return __webpack_require__(6587) })); var __webpack_exports__ = __webpack_require__.O(void 0, [805, 938], (function () { return __webpack_require__(2899) })); __webpack_exports__ = __webpack_require__.O(__webpack_exports__) })();